import { setFlag, getFlag } from "../binary/booleanByteWrapper"
import { BinaryReader, BinaryWriter } from "../interfaces"

import DofusMessage from "./dofusMessage"
import DofusType from "./dofusType"

export enum ItemTypeEnum {
	AMULET = 1,
	BOW = 2,
	WAND = 3,
	STAFF = 4,
	DAGGER = 5,
	SWORD = 6,
	HAMMER = 7,
	SHOVEL = 8,
	RING = 9,
	BELT = 10,
	BOOTS = 11,
	POTION = 12,
	EXPERIENCE_SCROLL = 13,
	ORDER_ABILITY_ITEM = 14,
	MISCELLANEOUS_RESOURCES = 15,
	HAT = 16,
	CLOAK = 17,
	PET = 18,
	AXE = 19,
	TOOL = 20,
	PICKAXE = 21,
	SCYTHE = 22,
	DOFUS = 23,
	MISCELLANEOUS = 24,
	DOCUMENT = 25,
	SMITHMAGIC_POTION = 26,
	MUTATION_ITEM = 27,
	BOOST_FOOD = 28,
	BLESSING = 29,
	CURSE = 30,
	ROLEPLAY_BUFF = 31,
	FOLLOWING_CHARACTER = 32,
	BREAD = 33,
	CEREAL = 34,
	FLOWER = 35,
	PLANT = 36,
	BEER = 37,
	WOOD = 38,
	ORE = 39,
	ALLOY = 40,
	FISH = 41,
	TREAT = 42,
	TELEPORTATION_POTION = 43,
	UNKNOWN_TEXT_ID_29778 = 44,
	UNKNOWN_TEXT_ID_29779 = 45,
	FRUIT = 46,
	BONE = 47,
	POWDER = 48,
	EDIBLE_FISH = 49,
	PRECIOUS_STONE = 50,
	STONE = 51,
	UNKNOWN_TEXT_ID_29731 = 52,
	FEATHER = 53,
	HAIR = 54,
	FABRIC = 55,
	LEATHER = 56,
	WOOL = 57,
	SEED = 58,
	SKIN = 59,
	OIL = 60,
	STUFFED_TOY = 61,
	UNKNOWN_TEXT_ID_29759 = 62,
	MEAT = 63,
	UNKNOWN_TEXT_ID_29767 = 64,
	TAIL = 65,
	METARIA = 66,
	VEGETABLE = 68,
	EDIBLE_MEAT = 69,
	DYE = 70,
	ALCHEMY_EQUIPMENT = 71,
	PET_EGG = 72,
	SKILL = 73,
	FAIRYWORK = 74,
	SPELL_LEARNING_SCROLL = 75,
	CHARACTERISTIC_SCROLL = 76,
	UNKNOWN_TEXT_ID_29679 = 77,
	SMITHMAGIC_RUNE = 78,
	DRINK = 79,
	MISSION_ITEM = 80,
	BACKPACK = 81,
	SHIELD = 82,
	SOUL_STONE = 83,
	KEY = 84,
	FULL_SOUL_STONE = 85,
	PERCEPTOR_DELEVELING_POTION = 86,
	SEEKER_SCROLL = 87,
	MAGIC_STONE = 88,
	GIFT = 89,
	UNKNOWN_TEXT_ID_29784 = 90,
	DRAGOTURKEY = 91,
	GOBBALL = 92,
	BREEDING_ITEM = 93,
	VARIOUS = 94,
	PLANK = 95,
	BARK = 96,
	DRAGOTURKEY_CERTIFICATE = 97,
	ROOT = 98,
	CAPTURING_NET = 99,
	BAG_OF_RESOURCES = 100,
	CROSSBOW = 102,
	LEG = 103,
	WING = 104,
	EGG = 105,
	EAR = 106,
	CARAPACE = 107,
	BUD = 108,
	EYE = 109,
	JELLY = 110,
	SHELL = 111,
	PRISM = 112,
	LIVING_OBJECT = 113,
	MAGIC_WEAPON = 114,
	FRAGMENT_OF_SHUSHU_SOUL = 115,
	PET_POTION = 116,
	EQUIPMENT = 118,
	MUSHROOM = 119,
	PETSMOUNT = 121,
	PETSMOUNT_POTION = 122,
	UNKNOWN_TEXT_ID_29669 = 123,
	UNKNOWN_TEXT_ID_29808 = 124,
	SOUVENIR = 125,
	MAIN_QUESTS = 126,
	TEMPLE_QUESTS = 127,
	WANTED_NOTICE = 128,
	ALIGNMENT = 129,
	UNKNOWN_TEXT_ID_29724 = 130,
	EVENT = 131,
	ARCHIPELAGO_OF_VULKANIA = 132,
	ASTRUB = 133,
	UNKNOWN_TEXT_ID_29793 = 134,
	BWORK_CAMP = 136,
	CANIA = 137,
	AMAKNA_CASTLE = 138,
	FRIGOST_ISLAND = 139,
	OTOMAI_ISLAND = 140,
	KWISMAS_ISLAND = 141,
	INCARNAM = 142,
	KOALAK_MOUNTAIN = 143,
	PANDALA = 144,
	MADRESTAM_HARBOUR = 145,
	PROVINCE_OF_AMAKNA = 146,
	KROSMOZ = 147,
	TOKEN = 148,
	MOON_ISLAND = 149,
	WABBIT_ISLANDS = 150,
	TROPHY = 151,
	PEBBLE = 152,
	KWISMAS = 153,
	WRAPPING_PAPER = 154,
	SUFOKIA = 155,
	ALMANAX = 156,
	FIGURINE = 157,
	UNKNOWN_TEXT_ID_297037 = 158,
	UNKNOWN_TEXT_ID_297033 = 159,
	UNKNOWN_TEXT_ID_297027 = 160,
	UNKNOWN_TEXT_ID_297028 = 161,
	UNKNOWN_TEXT_ID_297031 = 162,
	UNKNOWN_TEXT_ID_297032 = 163,
	GARMENT = 164,
	CONQUEST_POTION = 165,
	MIMISYMBIC = 166,
	DUNGEON_KEEPER_ESSENCE = 167,
	VIGILANTES = 168,
	SIDEKICK = 169,
	DIVINE_DIMENSIONS = 171,
	CHEST = 172,
	EMOTE_SCROLL = 173,
	MAP = 174,
	MAP_FRAGMENT = 175,
	BOX_OF_FRAGMENTS = 176,
	UNKNOWN_TEXT_ID_472462 = 177,
	IDOL = 178,
	PREPARATION = 179,
	UNKNOWN_TEXT_ID_544014 = 180,
	UNKNOWN_TEXT_ID_544017 = 181,
	UNKNOWN_TEXT_ID_544016 = 182,
	SUBSTRATE = 183,
	CONTAINER = 184,
	SAP = 185,
	UNKNOWN_TEXT_ID_561243 = 186,
	PRIMITIVE_MEAT = 187,
	SMILIES_SCROLL = 188,
	SMITHMAGIC_ORB = 189,
	DRAGOTURKEY_HARNESSES = 190,
	UNKNOWN_TEXT_ID_585144 = 191,
	UNKNOWN_TEXT_ID_585146 = 192,
	EXPLORATION_EQUIPMENT = 195,
	SEEMYOOL_CERTIFICATE = 196,
	RECEIPT = 197,
	OHWYMI = 198,
	COSTUME = 199,
	TITLE_SCROLL = 200,
	NIMALTOPIA = 201,
	SIDIMOTE = 202,
	INVISIBLE_OBJECT = 203,
	TOWERS_OF_THE_BROTHERHOOD_OF_THE_FORGOTTEN = 205,
	MOUNT_POTION = 206,
	RHINEETLE_CERTIFICATE = 207,
	PET_FOOD = 209,
	TRANSCENDENCE_RUNE = 211,
	UNKNOWN_TEXT_ID_777453 = 212,
	FLEASTER_ISLAND = 213,
	EMOTE_POTION = 214,
	ARCHIPELAGO_OF_SCALES = 215,
	PURSE_OF_KAMAS = 216,
	PRYSMARADITE = 217,
	HAVEN_BAG_POPOCKET = 218,
	DREAM_RESOURCES = 219,
	ELIOCALYPSE = 220,
	UNKNOWN_TEXT_ID_818310 = 221,
	ORNAMENTAL_SCROLL = 222,
	TEMPORIS_SCROLLS = 223,
	TEMPORIS = 225,
	ITEM_USABLE_IN_TEMPORIS = 226,
	LIQUID = 228,
	COMBAT_RESOURCE = 229,
	OBSOLETE = 230,
	RABMAJOKE = 231,
	HAIKU = 232,
	ASTRAL_RUNE = 233,
	RESSOURCES_EN_COURS_DINTÃ‰GRATION = 234,
	HAIKU_WORDS = 236,
	ECAFLIP_CARD_TEMPORIS = 238,
	KITTY_NEKO = 240,
	TEMPORIS_RESOURCES = 241,
	ATOLL_OF_THE_POSSESSED = 242,
	UNKNOWN_TEXT_ID_903536 = 243,
	UNKNOWN_TEXT_ID_905999 = 244,
	OBSOLETE_RESOURCES = 245,
	CEREMONIAL_HAT = 246,
	CEREMONIAL_CAPE = 247,
	CEREMONIAL_SHIELD = 248,
	CEREMONIAL_PET = 249,
	CEREMONIAL_PETSMOUNT = 250,
	CEREMONIAL_WEAPON = 251,
	MISCELLANEOUS_CEREMONIAL_ITEM = 252,
	DESTROYERS_NIGHTMARE = 253,
	BONTA_BRAKMAR = 254,
	SEEMYOOL_HARNESSES = 255,
	RHINEETLE_HARNESSES = 256,
}

export enum SubEntityBindingPointCategoryEnum {
	HOOK_POINT_CATEGORY_UNUSED = 0,
	HOOK_POINT_CATEGORY_PET = 1,
	HOOK_POINT_CATEGORY_MOUNT_DRIVER = 2,
	HOOK_POINT_CATEGORY_LIFTED_ENTITY = 3,
	HOOK_POINT_CATEGORY_BASE_BACKGROUND = 4,
	HOOK_POINT_CATEGORY_MERCHANT_BAG = 5,
	HOOK_POINT_CATEGORY_BASE_FOREGROUND = 6,
	HOOK_POINT_CATEGORY_PET_FOLLOWER = 7,
	HOOK_POINT_CATEGORY_UNDERWATER_BUBBLES = 8,
}

export enum MapScrollEnum {
	TOP,
	LEFT,
	BOTTOM,
	RIGHT,
	UNDEFINED,
}

export enum SkillTypeEnum {
	CHOP6 = 6,
	CHOP10 = 10,
	CREATE_JEWELLERY12 = 12,
	WORK_LEATHER13 = 13,
	CARVE15 = 15,
	FORGE20 = 20,
	PEEL22 = 22,
	PREPARE_A_POTION23 = 23,
	MINE24 = 24,
	MINE25 = 25,
	MINE26 = 26,
	BAKE27 = 27,
	MINE28 = 28,
	MINE29 = 29,
	MINE30 = 30,
	MINE31 = 31,
	MELT32 = 32,
	CHOP33 = 33,
	CHOP34 = 34,
	CHOP35 = 35,
	CHOP37 = 37,
	CHOP38 = 38,
	CHOP39 = 39,
	CHOP40 = 40,
	CHOP41 = 41,
	PICK_UP42 = 42,
	SAVE44 = 44,
	REAP45 = 45,
	REAP46 = 46,
	GRIND47 = 47,
	POLISH_A_STONE48 = 48,
	REAP50 = 50,
	REAP52 = 52,
	REAP53 = 53,
	REAP54 = 54,
	MINE55 = 55,
	MINE56 = 56,
	REAP57 = 57,
	REAP58 = 58,
	REGENERATE62 = 62,
	SEW63 = 63,
	GATHER68 = 68,
	GATHER69 = 69,
	GATHER71 = 71,
	GATHER72 = 72,
	GATHER73 = 73,
	GATHER74 = 74,
	LOCK81 = 81,
	ENTER84 = 84,
	BUY97 = 97,
	SELL98 = 98,
	UNLOCK100 = 100,
	SAW101 = 101,
	DRAW102 = 102,
	OPEN104 = 104,
	LOCK105 = 105,
	UNLOCK106 = 106,
	CHANGE_THE_PRICE108 = 108,
	MAKE_CANDIES109 = 109,
	USE_WORKBENCH110 = 110,
	REGENERATE111 = 111,
	SMITHMAGE113 = 113,
	USE114 = 114,
	SCULPTMAGE118 = 118,
	COMBINE_RESOURCES121 = 121,
	SHELL122 = 122,
	FISH124 = 124,
	FISH125 = 125,
	FISH126 = 126,
	FISH127 = 127,
	FISH128 = 128,
	FISH129 = 129,
	FISH130 = 130,
	FISH131 = 131,
	PREPARE_MEAT134 = 134,
	PREPARE_FISH135 = 135,
	FISH136 = 136,
	CHOP139 = 139,
	CHOP141 = 141,
	PLAY150 = 150,
	SUMMON_A_FAIRY151 = 151,
	FISH_FOR_QUAQUACKS152 = 152,
	SEARCH153 = 153,
	CHOP154 = 154,
	CHOP155 = 155,
	FORGE_A_SHIELD156 = 156,
	BE_TRANSPORTED157 = 157,
	CHOP158 = 158,
	REAP159 = 159,
	GATHER160 = 160,
	MINE161 = 161,
	MINE162 = 162,
	SHOEMAGE164 = 164,
	COSTUMAGE166 = 166,
	JEWELMAGE168 = 168,
	UNKNOWN_TEXT_ID_60209169 = 169,
	CONSULT170 = 170,
	CRAFT171 = 171,
	CHOP174 = 174,
	ACCESS175 = 175,
	BUY176 = 176,
	SELL177 = 177,
	CHANGE_THE_PRICE178 = 178,
	ACTIVATE179 = 179,
	SHATTER_ITEMS181 = 181,
	GO_TO_INCARNAM183 = 183,
	USE184 = 184,
	"@REF_COFFRE_MAISON185" = 185,
	"@REF_MAISON186" = 186,
	LEAVE187 = 187,
	GATHER188 = 188,
	FISH189 = 189,
	CHOP190 = 190,
	REAP191 = 191,
	MINE192 = 192,
	PICK_UP193 = 193,
	PICK_UP195 = 195,
	PICK_UP196 = 196,
	"@REF_MULTIENCLOS198" = 198,
	MAKE_A_SMALL_KEY199 = 199,
	GO_TO_THE_TEMPLE200 = 200,
	FORGE_A_TROPHY201 = 201,
	SEW_A_LINING202 = 202,
	PREPARE_A_SAUCE203 = 203,
	MAKE_A_BROOM204 = 204,
	SEW_FABRIC205 = 205,
	PREPARE_LIVER_OIL206 = 206,
	MAKE_A_TOY207 = 207,
	WRAP_A_GIFT209 = 209,
	OPEN_A_GIFT_PACKAGE210 = 210,
	REVIVE211 = 211,
	GO_TO_SUFOKIA212 = 212,
	GO_TO_AMAKNA213 = 213,
	PICK_UP_A_ROCK_CRYSTAL214 = 214,
	OPEN_A_SHELL215 = 215,
	MAKE_A_BOW_WOW_COLLAR217 = 217,
	PREPARE_A_HOT_MEAL218 = 218,
	PREPARE_A_FRIGOSTIAN_DELICACY219 = 219,
	MAKE_A_BOX_OF_MATERIALS220 = 220,
	MAKE_A_PAIR_OF_FRIGOSTIAN_CRAMPONS221 = 221,
	MAKE_A_WINDY_BATTLE_SWORD222 = 222,
	MAKE_A_FRIGOSTIAN_SHIELD223 = 223,
	MAKE_SQUEAKY_SMILERS224 = 224,
	MAKE_A_WHACK_SAW225 = 225,
	MAKE_A_CLANKEN_RACKET226 = 226,
	MAKE_A_MIDWINTER_SPADE227 = 227,
	PREPARE_ICEFISH_CHEESE228 = 228,
	MAKE_AN_AMMUNITION_BAG229 = 229,
	MAKE_A_CREEMATHA_CROP230 = 230,
	MAKE_A_WOODEN_SLIBOU_PIECE231 = 231,
	MAKE_A_FISHERMANS_GILET232 = 232,
	CUT_ICE233 = 233,
	WEAVE_A_VEIL234 = 234,
	MAKE_BRAKMARIAN_EXPLOSIVES235 = 235,
	GRILL_A_WABBIT_PAW236 = 236,
	PICK_UP_A_CAWWOT237 = 237,
	MAKE_WAX238 = 238,
	SALVAGE_A_BOTTLE239 = 239,
	TO_THE_SPLASH_ZONE240 = 240,
	TO_THE_UNDERTOW_ROOMS241 = 241,
	TO_THE_ABYSS_ROOMS242 = 242,
	TO_MERKATORS_AQUADOME243 = 243,
	USE_LEVER244 = 244,
	RECREATE_A_SCALE245 = 245,
	MAKE_SOLES246 = 246,
	PICK_UP_A_MUSHROOM247 = 247,
	HUNT_FOR_TREASURE_LEVEL_20248 = 248,
	HUNT_FOR_TREASURE_LEVEL_40249 = 249,
	HUNT_FOR_TREASURE_LEVEL_60250 = 250,
	HUNT_FOR_TREASURE_LEVEL_80251 = 251,
	HUNT_FOR_TREASURE_LEVEL_100252 = 252,
	HUNT_FOR_TREASURE_LEVEL_120253 = 253,
	HUNT_FOR_TREASURE_LEVEL_140254 = 254,
	HUNT_FOR_TREASURE_LEVEL_160255 = 255,
	HUNT_FOR_TREASURE_LEVEL_180256 = 256,
	HUNT_FOR_TREASURE_LEVEL_200257 = 257,
	LEAVE_THE_DIMENSION258 = 258,
	STAY_IN_THE_DIMENSION259 = 259,
	OPEN_A_CHEST260 = 260,
	PICK_UP_AN_ICE_CUBE261 = 261,
	ARENA_I262 = 262,
	ARENA_II263 = 263,
	ARENA_III264 = 264,
	ARENA_IV265 = 265,
	ARENA_V266 = 266,
	ARENA_VI267 = 267,
	ARENA_VII268 = 268,
	ARENA_VIII269 = 269,
	ARENA_IX270 = 270,
	ARENA_X271 = 271,
	ARENA_XI272 = 272,
	ARENA_XII273 = 273,
	ASSEMBLE_A_MAP275 = 275,
	PEEL_SWEET_POTATOES276 = 276,
	HUNT_FOR_LEGENDARY_TREASURE277 = 277,
	MAKE_A_WATCH278 = 278,
	MAKE_A_BATH_SOAP279 = 279,
	MAKE_PARADOXICAL_TEMPORAL_EXPLOSIVES280 = 280,
	PICK_UP_EGGS281 = 281,
	MAKE_ETERNAL_TEMPORAL_EXPLOSIVES282 = 282,
	MAKE_HISTORY_ALTERING_TEMPORAL_EXPLOSIVES283 = 283,
	MAKE_SINGULAR_TEMPORAL_EXPLOSIVES284 = 284,
	USE_A_PARADOXICAL_TEMPORAL_DETONATOR285 = 285,
	USE_A_SINGULAR_TEMPORAL_DETONATOR286 = 286,
	USE_A_HISTORY_ALTERING_TEMPORAL_DETONATOR287 = 287,
	USE_AN_ETERNAL_TEMPORAL_DETONATOR288 = 288,
	CHECK_THE_STATE_OF_THE_WORKSHOP289 = 289,
	CONCOCT_A_TRANSPARENCY_POTION290 = 290,
	INVASION_OF_THE_XELORIUM291 = 291,
	THE_LEGEND_OF_METHEA292 = 292,
	CONSULT293 = 293,
	GET_SCRAP295 = 295,
	REAP296 = 296,
	CREATE_AN_IDOL297 = 297,
	MINE298 = 298,
	CHOP299 = 299,
	GATHER300 = 300,
	FISH301 = 301,
	GO_TO_INCARNAM302 = 302,
	GATHER303 = 303,
	GATHER304 = 304,
	GATHER305 = 305,
	CHOP306 = 306,
	REAP307 = 307,
	REAP308 = 308,
	EXTRACT_A_STONE_BLOCK309 = 309,
	LOOK_TOWARDS_SIDIMOTE310 = 310,
	LOOK_TOWARDS_ASTRUB311 = 311,
	LOOK_TOWARDS_SUFOKIA312 = 312,
	LOOK_TOWARDS_FRIGOST313 = 313,
	LOOK_TOWARDS_NOLIFIS_ISLAND314 = 314,
	LOOK_TOWARDS_OHWYMI315 = 315,
	LOOK_TOWARDS_MOON_ISLAND316 = 316,
	FISH317 = 317,
	FISH318 = 318,
	FISH319 = 319,
	FISH320 = 320,
	FISH321 = 321,
	FISH322 = 322,
	FISH323 = 323,
	FISH324 = 324,
	FISH325 = 325,
	FISH326 = 326,
	FISH327 = 327,
	FISH328 = 328,
	FORGE_A_BACK_SCRATCHER_WITH_MULIC_BERE329 = 329,
	SCULPT_A_BACK_SCRATCHER_WITH_MULIC_BERE330 = 330,
	CRAFT_A_BACK_SCRATCHER_WITH_MULIC_BERE331 = 331,
	ASSEMBLE_A_BACK_SCRATCHER_WITH_MULIC_BERE332 = 332,
	USE_MAGUS_AXS_WORKSHOP333 = 333,
	FORGE_A_KNOUT_WITH_MULIC_BERE334 = 334,
	SCULPT_A_KNOUT_WITH_MULIC_BERE335 = 335,
	CRAFT_A_KNOUT_WITH_MULIC_BERE336 = 336,
	ASSEMBLE_A_KNOUT_WITH_MULIC_BERE337 = 337,
	GATHER_FOUR_LEAF_CLOVER338 = 338,
	POINT_OUT_AN_EXIT339 = 339,
	PICK_UP_CORAL340 = 340,
	REAP341 = 341,
	MINE342 = 342,
	CHOP343 = 343,
	GATHER344 = 344,
	PICK_UP_A_SHELL345 = 345,
	UNSPEAKABLE_WORKBENCH346 = 346,
	FISH347 = 347,
	WRITE_A_RECEIPT348 = 348,
	NATASHA_MANKAS_WORKSHOP349 = 349,
	FRESH_EGGS350 = 350,
	CRAFTMAGE351 = 351,
	FISH_FOR_A_MUSHROOM352 = 352,
	PICK_UP_A_SOMNITIA_SLEEP_KILLER353 = 353,
	PICK_UP_A_GRILLED_SOMNITIA_SLEEP_KILLER354 = 354,
	CONSULT355 = 355,
	MAKE_A_CANDLE_WICK356 = 356,
	OPEN_A_SURPRISE_GIFT357 = 357,
	MAKESHIFT_WORKSHOP358 = 358,
	PICK_UP359 = 359,
	PANNEAU_DIRECTIONNEL_TEXTE_LIBRE360 = 360,
	PANNEAU_DIRECTIONNEL_VIA_RÃ‰FÃ‰RENCE_HINT361 = 361,
	PANNEAU_DIRECTIONNEL_VIA_RÃ‰FÃ‰RENCE_SUBAREA362 = 362,
	REAP_SHREDS_OF_POSSIBILITY370 = 370,
	PICK_UP_A_PAPER_WRAPPER371 = 371,
	CRAFT_AN_UPGRADE372 = 372,
	MAKE_A_DOSE_OF_DOCILITY373 = 373,
	GO_BACK_INTO_THE_TEMPORAL_ANOMALY374 = 374,
	DIP_IN_SWEAT_AND_BLOOD375 = 375,
	MAKE_PAINT376 = 376,
	COOK377 = 377,
	MAKESHIFT_WORKSHOP378 = 378,
	FASHION_A_PRYSMARADITE380 = 380,
	RESTORE_A_BOOK381 = 381,
	PATCH_FABRIC382 = 382,
	CREATE_A_SPELL_SCROLL383 = 383,
	FORGE_A_KATANA384 = 384,
	PREPARE_A_FERMENTED_MIXTURE385 = 385,
	GATHER_FUJIBAKAMAS386 = 386,
	CARVE_A_SPIRIT_BAMBOO_STAFF387 = 387,
	COOK_WANCHIAOS388 = 388,
	FISH389 = 389,
	BREW_STRONG_BEER390 = 390,
	MINE391 = 391,
	MINE392 = 392,
	GATHER393 = 393,
	PREPARE_WINDALOO394 = 394,
	PLAY_FIVE_CAT_MONTE397 = 397,
	MODIFY_A_KITTY_NEKO398 = 398,
	CREATE_A_RUNE_OF_HARMONY399 = 399,
	UTILISER_AVEC_PORTÃ‰E400 = 400,
}

export enum StatedElementState {
	Active = 0,
	Unactive = 1,
	Used = 2,
}

export enum InteractiveTypeEnum {
	TYPE_ASH = 1,
	TYPE_SAW = 2,
	TYPE_OAK = 8,
	TYPE_CRAFTING_TABLE = 11,
	TYPE_BENCH = 13,
	TYPE_CAULDRON = 15,
	TYPE_ZAAP = 16,
	TYPE_IRON = 17,
	TYPE_OVEN = 22,
	TYPE_SILVER = 24,
	TYPE_GOLD = 25,
	TYPE_BAUXITE = 26,
	TYPE_MOULD = 27,
	TYPE_YEW = 28,
	TYPE_EBONY = 29,
	TYPE_ELM = 30,
	TYPE_MAPLE = 31,
	TYPE_HORNBEAM = 32,
	TYPE_CHESTNUT = 33,
	TYPE_WALNUT = 34,
	TYPE_CHERRY = 35,
	TYPE_COBALT = 37,
	TYPE_WHEAT = 38,
	TYPE_HOP = 39,
	TYPE_MILL = 40,
	TYPE_GRIND = 41,
	TYPE_FLAX = 42,
	TYPE_BARLEY = 43,
	TYPE_RYE = 44,
	TYPE_OATS = 45,
	TYPE_HEMP = 46,
	TYPE_MALT = 47,
	TYPE_POTATO_HEAP = 48,
	TYPE_POTATO_TABLE = 49,
	TYPE_CRUSHER = 50,
	TYPE_TIN = 52,
	TYPE_COPPER = 53,
	TYPE_MANGANESE = 54,
	TYPE_BRONZE = 55,
	TYPE_FOUNTAIN_OF_YOUTH = 56,
	TYPE_ANVIL = 57,
	TYPE_SEWING_MACHINE = 58,
	TYPE_POT = 60,
	TYPE_EDELWEISS = 61,
	TYPE_ALEMBIC = 62,
	TYPE_SPELT = 64,
	TYPE_SORGHUM = 65,
	TYPE_WILD_MINT = 66,
	TYPE_FIVE_LEAF_CLOVER = 67,
	TYPE_FREYESQUE_ORCHID = 68,
	TYPE_MORTAR_AND_PESTLE = 69,
	TYPE_DOOR = 70,
	TYPE_GRAWN = 71,
	TYPE_AGGRESSIVE_SALMOON = 72,
	TYPE_OCTOPWUS = 73,
	TYPE_TROUT = 74,
	TYPE_GUDGEON = 75,
	TYPE_KITTENFISH = 76,
	TYPE_CRAB = 77,
	TYPE_BREADED_FISH = 78,
	TYPE_EDIEM_CARP = 79,
	TYPE_SLUDGY_TROUT = 80,
	TYPE_SHINY_SARDINE = 81,
	TYPE_COTTON = 82,
	TYPE_SPINNER = 83,
	TYPE_WELL = 84,
	TYPE_SAFE = 85,
	TYPE_WOODEN_BENCH = 88,
  TYPE_BREWING_STAND = 90,
	TYPE_MAGIC_ANVIL = 92,
	TYPE_MUNSTER_CRUSHER = 93,
	TYPE_BOMBU = 98,
	TYPE_STRANGE_SHADOW = 99,
	TYPE_SNAPPER = 100,
	TYPE_OLIVIOLET = 101,
	TYPE_STRENGTH_MACHINE = 102,
	TYPE_PYROTECHNIC_WORKBENCH = 103,
	TYPE_QUAQUACK = 104,
	TYPE_TRASH = 105,
	TYPE_ZAAPI = 106,
	TYPE_SHIELD_ANVIL = 107,
	TYPE_BAMBOO = 108,
	TYPE_DARK_BAMBOO = 109,
	TYPE_HOLY_BAMBOO = 110,
	TYPE_RICE = 111,
	TYPE_PANDKIN = 112,
	TYPE_DOLOMITE = 113,
	TYPE_SILICATE = 114,
	TYPE_RESTLESS = 115,
	TYPE_MAGIC_SEWING_MACHINE = 116,
	TYPE_MAGIC_WORKSHOP = 117,
	TYPE_MAGIC_TABLE = 118,
	TYPE_LIST_OF_CRAFTSMEN = 119,
	TYPE_PADDOCK = 120,
	TYPE_KALIPTUS = 121,
	TYPE_WORKSHOP = 122,
	TYPE_SWITCH = 127,
	TYPE_CLASS_STATUE = 128,
	TYPE__NO_TRAD_ANY_IE = 129,
	TYPE_SNOWDROP = 131,
	TYPE_ICEFISH = 132,
	TYPE_ASPEN = 133,
	TYPE_FROSTEEZ = 134,
	TYPE_OBSIDIAN = 135,
	TYPE_SHELL = 136,
	TYPE_POSS_YBEL_S_SEWING_MACHINE = 137,
	TYPE_FACTORY = 138,
	TYPE_BAD_QUALITY_KITCHEN_TABLE = 139,
	TYPE_BAD_QUALITY_WORKSHOP = 140,
	TYPE_BAD_QUALITY_WORKBENCH = 141,
	TYPE_BAD_QUALITY_SEWING_MACHINE = 142,
	TYPE_TOY_MACHINE = 143,
	TYPE_FISH_PRESS = 144,
	TYPE_WRAPPING_STATION = 145,
	TYPE_GIFT_PACKAGE = 146,
	TYPE_GIFT_WRAPPING_STATION = 147,
	TYPE_ALCHEMISTS__WORKSHOP = 148,
	TYPE_JEWELLERS__WORKSHOP = 12,
	TYPE_BUTCHERS__WORKSHOP = 150,
	TYPE_BUTCHERS__AND_HUNTERS__WORKSHOP = 151,
	TYPE_SHIELD_SMITHS__WORKSHOP = 152,
	TYPE_BAKERS__WORKSHOP = 153,
	TYPE_HANDYMEN_S_WORKSHOP = 94,
	TYPE_LUMBERJACKS__WORKSHOP = 155,
	TYPE_HUNTERS__WORKSHOP = 97,
	TYPE_SHOEMAKERS__WORKSHOP = 157,
	TYPE_SMITHMAGI_S_WORKSHOP = 158,
	TYPE_SMITHS__WORKSHOP = 159,
	TYPE_MINERS__WORKSHOP = 160,
	TYPE_FARMERS__WORKSHOP = 161,
	TYPE_FISHMONGERS__WORKSHOP = 162,
	TYPE_FISHERMEN_AND_FISHMONGERS__WORKSHOP = 163,
	TYPE_FISHERMEN_S_WORKSHOP = 164,
	TYPE_CARVERS__WORKSHOP = 165,
	TYPE_TAILORS__WORKSHOP = 166,
	TYPE_ARENA = 167,
	TYPE_BANK = 168,
	TYPE_BAR_RACUDA = 169,
	TYPE_LIBRARY = 170,
	TYPE_KWISMAS_SHOPS = 171,
	TYPE_DOJO = 172,
	TYPE_CHURCH = 173,
	TYPE_GROCERY_STORE = 174,
	TYPE_SKI_MAKER = 175,
	TYPE_TOWN_HALL = 176,
	TYPE_PROFESSION_INFORMATION_CENTRE = 177,
	TYPE_KANOJEDO = 178,
	TYPE_KOLOSSIUM = 179,
	TYPE_MILITIA = 180,
	TYPE_FRIGOST_S_DOCTOR = 181,
	TYPE_INN = 182,
	TYPE_ATYU_SIRVIS_S_INN = 183,
	TYPE_ATOLMOND_S_INN = 184,
	TYPE_THE_SILVER_TAVERN = 185,
	TYPE_DJAUL_INN = 186,
	TYPE_BAGRUTTE_INN = 187,
	TYPE_WOODENGLASS_INN = 188,
	TYPE_MISERY_INN = 189,
	TYPE_KIKIM_INN = 190,
	TYPE_LISA_KAYA_S_TAVERN = 191,
	TYPE_SAKAI_TAVERN = 192,
	TYPE_BWORK_INN = 193,
	TYPE_BURNT_CAT_INN = 194,
	TYPE_LAST_CHANCE_SALOON = 195,
	TYPE_SWASHBUCKLER_INN = 196,
	TYPE_FEUBUK_INN = 197,
	TYPE_DRUNKEN_PANDAWA_INN = 198,
	TYPE_FRIGOSTIAN_PARADISE_TAVERN = 199,
	TYPE_PINCHAUT_INN = 200,
	TYPE_RIPATE_INN = 201,
	TYPE_GUILD_TEMPLE = 202,
	TYPE_TOWER_OF_BRAKMAR = 203,
	TYPE_TOWER_OF_ARCHIVES = 204,
	TYPE_TOWER_OF_ORDERS = 205,
	TYPE_FOGGERNAUT_SUBMARINE = 206,
	TYPE_ALTAR = 207,
	TYPE_KROSMASTER = 208,
	TYPE_GITH_SMOLD_S_WORKSHOP = 209,
	TYPE_AL_SHAB_S_WORKSHOP = 210,
	TYPE_FRIGOSTINE_S_WORKSHOP = 211,
	TYPE_FRANCKY_S_WORKSHOP = 212,
	TYPE_DUTCH_S_WORKSHOP = 213,
	TYPE_BROKKREITRI_S_WORKSHOP = 214,
	TYPE_INGRAM_PART_S_WORKSHOP = 215,
	TYPE_CLARISSE_TOCATE_S_WORKSHOP = 216,
	TYPE_BEA_FORTAX_S_WORKSHOP = 217,
	TYPE_CARLA_GARFIELD_S_WORKSHOP = 218,
	TYPE_WEAVER_OF_FORTUNES = 219,
	TYPE_BARREL_OF_EXPLOSIVES = 220,
	TYPE_SUTOL_FLOWER = 221,
	TYPE_BARBECUE = 222,
	TYPE_FRESH_CAWWOT = 223,
	TYPE_PROFESSION_INFORMATION_CENTRE_S_WEATHERED_ALEMBIC = 224,
	TYPE_BOTTLE_OF_RUM = 225,
	TYPE_LIFT = 226,
	TYPE_MUSHROOM = 227,
	TYPE_BOWISSE_S_TABLE = 228,
	TYPE_MERIANA_S_WORKSHOP = 229,
	TYPE_BWORK_PORTAL = 230,
	TYPE_AUTOMATED_TREASURE_MACHINE = 231,
	TYPE_PORTAL = 232,
	TYPE_GOLDEN_CHEST = 233,
	TYPE_ICE_CUBE = 234,
	TYPE_GO_TO = 235,
	TYPE_DESK = 236,
	TYPE_DRAFTING_TABLE = 237,
	TYPE_GO_TO_INSTANCE_A = 238,
	TYPE_GO_TO_INSTANCE_B = 239,
	TYPE_GO_TO_INSTANCE_C = 240,
	TYPE_OLD_CHEST_XXIII = 241,
	TYPE_CLOCKMAKER_S_WORKBENCH = 242,
	TYPE_CHEST_XI = 243,
	TYPE_CHEST_XXIII = 244,
	TYPE_CHEST_XXXI = 245,
	TYPE_CHEST_LIX = 246,
	TYPE_CLOCK_THAT_S_2_MINUTES_FAST = 247,
	TYPE_CLOCK_THAT_S_3_MINUTES_SLOW = 248,
	TYPE_CLOCK_THAT_S_7_MINUTES_FAST = 249,
	TYPE_CLOCK_THAT_S_8_MINUTES_SLOW = 250,
	TYPE_PAXTIM_EGGS = 251,
	TYPE_VOYAGERS__WORKSHOP = 252,
	TYPE_ELIOTROPE_PORTAL = 253,
	TYPE_NETTLE = 254,
	TYPE_SAGE = 255,
	TYPE_GINSENG = 256,
	TYPE_BELLADONNA = 257,
	TYPE_MANDRAKE = 258,
	TYPE_HAZEL = 259,
	TYPE_CORN = 260,
	TYPE_MILLET = 261,
	TYPE_STONE_BLOCK = 262,
	TYPE_PIKE = 263,
	TYPE_KRALOVE = 264,
	TYPE_EEL = 265,
	TYPE_GREY_SEA_BREAM = 266,
	TYPE_PERCH = 267,
	TYPE_RAY = 268,
	TYPE_MONKFISH = 269,
	TYPE_SICKLE_HAMMERHEAD_SHARK = 270,
	TYPE_LARD_BASS = 271,
	TYPE_COD = 272,
	TYPE_TENCH = 273,
	TYPE_SWORDFISH = 274,
	TYPE_MULIC_BERE_S_ANVIL = 275,
	TYPE_MULIC_BERE_S_WORKBENCH = 276,
	TYPE_MULIC_BERE_S_WORKSHOP = 277,
	TYPE_MULIC_BERE_S_ASSEMBLER = 278,
	TYPE_MAGUS_AX_S_WORKSHOP = 279,
	TYPE_HUPPERMAGE_PLATFORM = 280,
	TYPE_FOUR_LEAF_CLOVER = 281,
	TYPE_POINT_OUT_AN_EXIT = 282,
	TYPE_CATUNA = 283,
	TYPE_STAIRS = 284,
	TYPE_REINFORCED_DOOR = 285,
	TYPE_UNSPEAKABLE_WORKBENCH = 286,
	TYPE_MAHAQUANY = 287,
	TYPE_SALIKRONIA = 288,
	TYPE_QUISNOA = 289,
	TYPE_LIMPET = 290,
	TYPE_SEPIOLITE = 291,
	TYPE_NATASHA_MANKA_S_WORKSHOP = 298,
	TYPE_FRESH_EGGS = 299,
	TYPE_HOUSE = 300,
	TYPE_TOURNAMENT_ARENA = 301,
	TYPE_AQUATIC_MUSHROOM = 302,
	TYPE_SOMNITIA_SLEEP_KILLER = 303,
	TYPE_GRILLED_SOMNITIA_SLEEP_KILLER = 304,
	TYPE_MINIATURE_VILLAGE = 305,
	TYPE_ASTRUBIAN_SEWING_MACHINE = 306,
	TYPE_GALAETHIEL_S_PINGWIN = 307,
	TYPE_SURPRISE_GIFT = 308,
	TYPE_CREAKING_BOX = 309,
	TYPE_SURPRISE_POTION = 310,
	TYPE_MAKESHIFT_WORKSHOP = 311,
	TYPE_DOOR_TO_THE_REALM_OF_THE_GODS = 312,
	TYPE_RESOURCE_MARKETPLACE = 313,
	TYPE_EQUIPMENT_MARKETPLACE = 314,
	TYPE_CONSUMABLES_MARKETPLACE = 315,
	TYPE_PANNEAU_DIRECTIONNEL = 316,
	TYPE_CRYSTAL = 317,
	TYPE_RUNE_MARKETPLACE = 318,
	TYPE_CREATURE_MARKETPLACE = 319,
	TYPE_SOUL_MARKETPLACE = 320,
	TYPE_DUNG = 900,
}

export enum GenericActionEnum {
	None,
	Teleport,
	OpenBank,
	RemoveItem,
	LearnOrnament,
	LearnTitle,
	Collect,
	Bidshop,
	Zaap,
	Zaapi,
	CreateGuild,
	LearnSpell,
	AddKamas,
	Craft,
	AddItem,
	AddExperience,
	Notification,
	Fight,
	Smithmagic,
	RuneTrade,
	Unhandled,
}

export enum BuildTypeEnum {
	RELEASE = 0,
	BETA = 1,
	ALPHA = 2,
	TESTING = 3,
	INTERNAL = 4,
	DEBUG = 5,
	DRAFT = 6,
}

export enum ChatActivableChannelsEnum {
	CHANNEL_GLOBAL = 0,
	CHANNEL_TEAM = 1,
	CHANNEL_GUILD = 2,
	CHANNEL_ALLIANCE = 3,
	CHANNEL_PARTY = 4,
	CHANNEL_SALES = 5,
	CHANNEL_SEEK = 6,
	CHANNEL_NOOB = 7,
	CHANNEL_ADMIN = 8,
	PSEUDO_CHANNEL_PRIVATE = 9,
	PSEUDO_CHANNEL_INFO = 10,
	PSEUDO_CHANNEL_FIGHT_LOG = 11,
	CHANNEL_ADS = 12,
	CHANNEL_ARENA = 13,
	CHANNEL_COMMUNITY = 14,
}

export enum FightSpellCastCriticalEnum {
	NORMAL = 1,
	CRITICAL_HIT = 2,
	CRITICAL_FAIL = 3,
}

export enum PlayerLifeStatusEnum {
	STATUS_ALIVE_AND_KICKING = 0,
	STATUS_TOMBSTONE = 1,
	STATUS_PHANTOM = 2,
}

export enum PrismStateEnum {
	PRISM_STATE_INVULNERABLE = 0,
	PRISM_STATE_NORMAL = 1,
	PRISM_STATE_ATTACKED = 2,
	PRISM_STATE_FIGHTING = 3,
	PRISM_STATE_WEAKENED = 4,
	PRISM_STATE_VULNERABLE = 5,
	PRISM_STATE_DEFEATED = 6,
	PRISM_STATE_SABOTAGED = 7,
}

export enum MapObstacleStateEnum {
	OBSTACLE_OPENED = 1,
	OBSTACLE_CLOSED = 2,
}

export enum AggressableStatusEnum {
	NON_AGGRESSABLE = 0,
	PvP_ENABLED_AGGRESSABLE = 10,
	PvP_ENABLED_NON_AGGRESSABLE = 11,
	AvA_ENABLED_AGGRESSABLE = 20,
	AvA_ENABLED_NON_AGGRESSABLE = 21,
	AvA_DISQUALIFIED = 22,
	AvA_PREQUALIFIED_AGGRESSABLE = 23,
}

export enum TeamEnum {
	TEAM_CHALLENGER = 0,
	TEAM_DEFENDER = 1,
	TEAM_SPECTATOR = 2,
}

export enum GameActionFightInvisibilityStateEnum {
	INVISIBLE = 1,
	DETECTED = 2,
	VISIBLE = 3,
}

export enum DirectionsEnum {
	DIRECTION_EAST = 0,
	DIRECTION_SOUTH_EAST = 1,
	DIRECTION_SOUTH = 2,
	DIRECTION_SOUTH_WEST = 3,
	DIRECTION_WEST = 4,
	DIRECTION_NORTH_WEST = 5,
	DIRECTION_NORTH = 6,
	DIRECTION_NORTH_EAST = 7,
}

export enum CharacterInventoryPositionEnum {
	ACCESSORY_POSITION_AMULET = 0,
	ACCESSORY_POSITION_WEAPON = 1,
	INVENTORY_POSITION_RING_LEFT = 2,
	ACCESSORY_POSITION_BELT = 3,
	INVENTORY_POSITION_RING_RIGHT = 4,
	ACCESSORY_POSITION_BOOTS = 5,
	ACCESSORY_POSITION_HAT = 6,
	ACCESSORY_POSITION_CAPE = 7,
	ACCESSORY_POSITION_PETS = 8,
	INVENTORY_POSITION_DOFUS_1 = 9,
	INVENTORY_POSITION_DOFUS_2 = 10,
	INVENTORY_POSITION_DOFUS_3 = 11,
	INVENTORY_POSITION_DOFUS_4 = 12,
	INVENTORY_POSITION_DOFUS_5 = 13,
	INVENTORY_POSITION_DOFUS_6 = 14,
	ACCESSORY_POSITION_SHIELD = 15,
	INVENTORY_POSITION_MOUNT = 16,
	INVENTORY_POSITION_MUTATION = 20,
	INVENTORY_POSITION_BOOST_FOOD = 21,
	INVENTORY_POSITION_FIRST_BONUS = 22,
	INVENTORY_POSITION_SECOND_BONUS = 23,
	INVENTORY_POSITION_FIRST_MALUS = 24,
	INVENTORY_POSITION_SECOND_MALUS = 25,
	INVENTORY_POSITION_ROLEPLAY_BUFFER = 26,
	INVENTORY_POSITION_FOLLOWER = 27,
	INVENTORY_POSITION_ENTITY = 28,
	ACCESSORY_POSITION_RIDE_HARNESS = 29,
	INVENTORY_POSITION_COSTUME = 30,
	INVENTORY_POSITION_NOT_EQUIPED = 63,
}

export enum FightTypeEnum {
	FIGHT_TYPE_CHALLENGE = 0,
	FIGHT_TYPE_AGRESSION = 1,
	FIGHT_TYPE_PvMA = 2,
	FIGHT_TYPE_MXvM = 3,
	FIGHT_TYPE_PvM = 4,
	FIGHT_TYPE_PvT = 5,
	FIGHT_TYPE_PvMU = 6,
	FIGHT_TYPE_PVP_ARENA = 7,
	FIGHT_TYPE_Koh = 8,
	FIGHT_TYPE_PvPr = 9,
	FIGHT_TYPE_BREACH = 10,
}

export enum FightOutcomeEnum {
	RESULT_LOST = 0,
	RESULT_DRAW = 1,
	RESULT_VICTORY = 2,
	RESULT_TAX = 5,
	RESULT_DEFENDER_GROUP = 6,
}

export enum GameServerTypeEnum {
	SERVER_TYPE_UNDEFINED = -1,
	SERVER_TYPE_CLASSICAL = 0,
	SERVER_TYPE_HARDCORE = 1,
	SERVER_TYPE_KOLIZEUM = 2,
	SERVER_TYPE_TOURNAMENT = 3,
	SERVER_TYPE_EPIC = 4,
	SERVER_TYPE_TEMPORIS = 5,
}

export enum DebugLevelEnum {
	LEVEL_TRACE = 0,
	LEVEL_DEBUG = 1,
	LEVEL_INFO = 2,
	LEVEL_WARN = 3,
	LEVEL_ERROR = 4,
	LEVEL_FATAL = 5,
}

export enum CharacterSpellModificationTypeEnum {
	INVALID_MODIFICATION = 0,
	RANGEABLE = 1,
	DAMAGE = 2,
	BASE_DAMAGE = 3,
	HEAL_BONUS = 4,
	AP_COST = 5,
	CAST_INTERVAL = 6,
	CAST_INTERVAL_SET = 7,
	CRITICAL_HIT_BONUS = 8,
	CAST_LINE = 9,
	LOS = 10,
	MAX_CAST_PER_TURN = 11,
	MAX_CAST_PER_TARGET = 12,
	RANGE_MAX = 13,
	RANGE_MIN = 14,
}

export enum ShortcutBarEnum {
	GENERAL_SHORTCUT_BAR = 0,
	SPELL_SHORTCUT_BAR = 1,
}

export enum CharacterCreationResultEnum {
	OK = 0,
	ERR_NO_REASON = 1,
	ERR_INVALID_NAME = 2,
	ERR_NAME_ALREADY_EXISTS = 3,
	ERR_TOO_MANY_CHARACTERS = 4,
	ERR_NOT_ALLOWED = 5,
	ERR_NEW_PLAYER_NOT_ALLOWED = 6,
	ERR_RESTRICED_ZONE = 7,
	ERR_INCONSISTENT_COMMUNITY = 8,
}

export enum ExchangeErrorEnum {
	REQUEST_IMPOSSIBLE = 1,
	REQUEST_CHARACTER_OCCUPIED = 2,
	REQUEST_CHARACTER_JOB_NOT_EQUIPED = 3,
	REQUEST_CHARACTER_TOOL_TOO_FAR = 4,
	REQUEST_CHARACTER_OVERLOADED = 5,
	REQUEST_CHARACTER_NOT_SUSCRIBER = 6,
	REQUEST_CHARACTER_RESTRICTED = 7,
	REQUEST_CHARACTER_GUEST = 8,
	MOUNT_PADDOCK_ERROR = 10,
	BID_SEARCH_ERROR = 11,
	SELL_ERROR = 63,
	BUY_ERROR = 64,
}

export enum IdentificationFailureReasonEnum {
	BAD_VERSION = 1,
	WRONG_CREDENTIALS = 2,
	BANNED = 3,
	KICKED = 4,
	IN_MAINTENANCE = 5,
	TOO_MANY_ON_IP = 6,
	TIME_OUT = 7,
	BAD_IPRANGE = 8,
	CREDENTIALS_RESET = 9,
	EMAIL_UNVALIDATED = 10,
	OTP_TIMEOUT = 11,
	LOCKED = 12,
	SERVICE_UNAVAILABLE = 53,
	EXTERNAL_ACCOUNT_LINK_REFUSED = 61,
	EXTERNAL_ACCOUNT_ALREADY_LINKED = 62,
	UNKNOWN_AUTH_ERROR = 99,
	SPARE = 100,
}

export enum ServerCompletionEnum {
	COMPLETION_RECOMANDATED = 0,
	COMPLETION_AVERAGE = 1,
	COMPLETION_HIGH = 2,
	COMPLETION_COMING_SOON = 3,
	COMPLETION_FULL = 4,
}

export enum ServerStatusEnum {
	STATUS_UNKNOWN = 0,
	OFFLINE = 1,
	STARTING = 2,
	ONLINE = 3,
	NOJOIN = 4,
	SAVING = 5,
	STOPING = 6,
	FULL = 7,
}

export enum BoostableCharacteristicEnum {
	BOOSTABLE_CHARAC_STRENGTH = 10,
	BOOSTABLE_CHARAC_VITALITY = 11,
	BOOSTABLE_CHARAC_WISDOM = 12,
	BOOSTABLE_CHARAC_CHANCE = 13,
	BOOSTABLE_CHARAC_AGILITY = 14,
	BOOSTABLE_CHARAC_INTELLIGENCE = 15,
}

export enum CompassTypeEnum {
	COMPASS_TYPE_SIMPLE = 0,
	COMPASS_TYPE_SPOUSE = 1,
	COMPASS_TYPE_PARTY = 2,
	COMPASS_TYPE_PVP_SEEK = 3,
	COMPASS_TYPE_QUEST = 4,
}

export enum AlignmentSideEnum {
	ALIGNMENT_UNKNOWN = -2,
	ALIGNMENT_WITHOUT = -1,
	ALIGNMENT_NEUTRAL = 0,
	ALIGNMENT_ANGEL = 1,
	ALIGNMENT_EVIL = 2,
}

export enum MountCharacteristicEnum {
	ENERGY = 1,
	SERENITY = 2,
	STAMINA = 3,
	LOVE = 4,
	MATURITY = 5,
	TIREDNESS = 6,
	CARRIER = 7,
	FERTILE = 8,
	PREGNANT = 9,
}

export enum StatsBoostEnum {
	STRENGTH = 10,
	VITALITY,
	WISDOM,
	CHANCE,
	AGILITY,
	INTELLIGENCE,
}

export enum ExchangeTypeEnum {
	UNKNOWN_TRADE_TYPE = -1,
	NPC_SHOP = 0,
	PLAYER_TRADE = 1,
	NPC_TRADE = 2,
	CRAFT = 3,
	STORAGE = 4,
	SHOP_STOCK = 5,
	TAXCOLLECTOR = 6,
	NPC_MODIFY_TRADE = 7,
	BIDHOUSE_SELL = 8,
	BIDHOUSE_BUY = 9,
	MULTICRAFT_CRAFTER = 10,
	MULTICRAFT_CUSTOMER = 11,
	JOB_INDEX = 12,
	MOUNT = 13,
	MOUNT_STABLE = 14,
	NPC_RESURECT_PET = 15,
	NPC_TRADE_DRAGOTURKEY = 16,
	REALESTATE_HOUSE = 17,
	REALESTATE_FARM = 18,
	RUNES_TRADE = 19,
	RECYCLE_TRADE = 20,
	BANK = 21,
	TRASHBIN = 22,
	ALLIANCE_PRISM = 23,
	HAVENBAG = 24,
	NPC_TRADE_SEEMYOOL = 25,
	NPC_TRADE_RHINEETLE = 26,
	EVOLUTIVE_OBJECT_ELEMENTARY_RECYCLE = 27,
	NPC_RIDE_CAPABILITY_TRADE = 28,
	GUILD_CHEST = 29,
}

export enum GameContextEnum {
	ROLE_PLAY = 1,
	FIGHT = 2,
}

export enum SpellTargetType {
	NONE = 0,
	SELF_ONLY = 0x80000, // C
	SELF = 0x1, // c

	ALLY_MONSTER_SUMMON = 0x2, // s
	ALLY_SUMMON = 0x4, // j
	ALLY_NON_MONSTER_SUMMON = 0x8, // i
	ALLY_COMPANION = 0x10, // d
	ALLY_MONSTER = 0x20, // m
	ALLY_SUMMONER = 0x40, // h
	ALLY_PLAYER = 0x80, // l

	ALLY_ALL_EXCEPT_SELF = ALLY_MONSTER_SUMMON |
		ALLY_SUMMON |
		ALLY_NON_MONSTER_SUMMON |
		ALLY_COMPANION |
		ALLY_COMPANION |
		ALLY_MONSTER |
		ALLY_PLAYER, // g

	ALLY_ALL = SELF |
		ALLY_MONSTER_SUMMON |
		ALLY_SUMMON |
		ALLY_NON_MONSTER_SUMMON |
		ALLY_COMPANION |
		ALLY_COMPANION |
		ALLY_MONSTER |
		ALLY_PLAYER, // a

	ENEMY_MONSTER_SUMMON = 0x100, // S
	ENEMY_SUMMON = 0x200, // J
	ENEMY_NON_MONSTER_SUMMON = 0x400, // I
	ENEMY_COMPANION = 0x800, // D
	ENEMY_MONSTER = 0x1000, // M
	ENEMY_HUMAN = 0x2000, // H
	ENEMY_PLAYER = 0x4000, // L

	ENEMY_ALL = ENEMY_MONSTER_SUMMON |
		ENEMY_SUMMON |
		ENEMY_NON_MONSTER_SUMMON |
		ENEMY_COMPANION |
		ENEMY_COMPANION |
		ENEMY_MONSTER |
		ENEMY_HUMAN |
		ENEMY_PLAYER, // A
}

export enum TriggerTypeEnum {
	Instant, // I

	CasterInflictDamageMelee, // CDM
	CasterInflictDamageRange, // CDR
	CasterInflictDamageEnnemy, // CBDE On inflige des dÃ©gats a un enemi
	CasterHealed, // CH

	OnDamaged, // D
	OnDamagedAir, // DA
	OnDamagedEarth, // DE
	OnDamagedFire, // DF
	OnDamagedWater, // DW
	OnDamagedNeutral, // DN
	OnDamagedByAlly, // DBA
	OnDamagedByEnemy, // BDE
	OnDamagedBySummon, // DI
	// OnDamagedByWeapon, // DC
	OnDamagedBySpell, // DS
	//  OnDamagedByGlyph, // DG
	// OnDamagedByTrap, //DP
	OnDamagedMelee, //DM
	OnDamagedRange, //DR
	OnDamagedByPush, // PD
	OnDamagedByAllyPush, //PMD

	//OnDamageEnemyByPush, // MMD

	OnSummon, // CI

	OnTurnBegin, // TB
	OnTurnEnd, // TE

	AfterTurnBegin, // ATB

	OnMPLost, // m , MPA (effective loss? attempt? )
	OnAPLost, // A
	OnRangeLost, // R

	OnLifePointsPending,

	OnHealed, //H

	OnStateAdded, // EO
	OnStateRemoved, //Eo

	OnDispelled, //d

	OnCriticalHit, //CC
	OnDeath, //X

	OnPushed, //MP , P
	OnMoved, //M
	OnTackled, //tF
	OnTackle, //tS

	OnTeleportPortal,

	/*
	 * Custom
	 */
	Delayed,
	Unknown,

	/*
	 *A=lose AP (101)
	 *CC=on critical hit
	 *d=dispell
	 *D=damage
	 *DA=damage air
	 *DBA=damage on ally
	 *DBE=damage on enemy
	 *DC=damaged by weapon
	 *DE=damage earth
	 *DF=damage fire
	 *DG=damage from glyph
	 *DI=
	 *DM=distance between 0 and 1
	 *DN=damage neutral
	 *DP=damage from trap
	 *Dr=
	 *DR=distance > 1
	 *DS=not weapon
	 *DTB=
	 *DTE=
	 *DW=damage water
	 *EO=on add state
	 *EO#=on add state #
	 *Eo=on state removed
	 *Eo#=on state # removed
	 *H=on heal
	 *I=instant
	 *m=lose mp (127)
	 *M=OnMoved
	 *mA=
	 *MD=push damage
	 *MDM=receive push damages from enemy push
	 *MDP=inflict push damage to enemy
	 *ML=
	 *MP=Pushed
	 *MS=
	 *P=
	 *R=Lost Range
	 *TB=turn begin
	 *TE=turn end
	 *tF=Tackled
	 *tS=Tackle
	 *X= Death
	 *CT =tackle enemy?
	 *CI = Summoned
	 */
}

export enum ServerConstantTypeEnum {
	TIME_BEFORE_DISCONNECTION = 1,
	KOH_DURATION = 2,
	KOH_WINNING_SCORE = 3,
	MINIMAL_TIME_BEFORE_KOH = 4,
	TIME_BEFORE_WEIGH_IN_KOH = 5,
	UNKNOWN_6 = 6,
	UNKNOWN_7 = 7,
}

export enum EffectsEnum {
	/// <summary>
	/// TÃ©lÃ©porte sur la map ciblÃ©e
	/// </summary>
	Effect_2 = 2,
	/// <summary>
	/// Fixe le point de respawn
	/// </summary>
	Effect_3 = 3,
	/// <summary>
	/// TÃ©lÃ©porte sur la case ciblÃ©e
	/// </summary>
	Effect_Teleport = 4,
	/// <summary>
	/// Repousse de #1 case(s)
	/// </summary>
	Effect_PushBack = 5,
	/// <summary>
	/// Attire de #1 case(s)
	/// </summary>
	Effect_PullForward = 6,
	/// <summary>
	/// Divorcer le couple
	/// </summary>
	Effect_7 = 7,
	/// <summary>
	/// Ã‰change de positions
	/// </summary>
	Effect_SwitchPosition = 8,
	/// <summary>
	/// Esquive #1% des coups en reculant de #2 case(s)
	/// </summary>
	Effect_DodgeDamages = 9,
	/// <summary>
	/// Attitude #3
	/// </summary>
	Effect_LearnEmote = 10,
	/// <summary>
	///
	/// </summary>
	Effect_12 = 12,
	/// <summary>
	/// Change le temps de jeu d'un joueur
	/// </summary>
	Effect_13 = 13,
	/// <summary>
	/// (not found)
	/// </summary>
	Effect_30 = 30,
	/// <summary>
	/// (not found)
	/// </summary>
	Effect_31 = 31,
	/// <summary>
	/// (not found)
	/// </summary>
	Effect_32 = 32,
	/// <summary>
	/// DÃ©bute une quÃªte
	/// </summary>
	Effect_34 = 34,
	/// <summary>
	/// Reset d'une quÃªte
	/// </summary>
	Effect_36 = 36,
	/// <summary>
	/// DÃ©marre une quÃªte (force)
	/// </summary>
	Effect_37 = 37,
	/// <summary>
	/// Porte la cible
	/// </summary>
	Effect_Carry = 50,
	/// <summary>
	/// Lance une entitÃ©
	/// </summary>
	Effect_Throw = 51,
	/// <summary>
	/// Vole #1{~1~2 Ã  }#2 PM
	/// </summary>
	Effect_StealMP_77 = 77,
	/// <summary>
	/// Ajoute +#1{~1~2 Ã  }#2 PM
	/// </summary>
	Effect_AddMP = 78,
	/// <summary>
	/// #3% soignÃ© de x#2, sinon dÃ©gÃ¢ts subis x#1
	/// </summary>
	Effect_HealOrMultiply = 79,
	/// <summary>
	/// #1{~1~2 Ã  }#2 (PV rendus)
	/// </summary>
	Effect_HealHP_81 = 81,
	/// <summary>
	/// #1{~1~2 Ã  }#2 PV (vol Neutre fixe)
	/// </summary>
	Effect_StealHPFix = 82,
	/// <summary>
	/// Vole #1{~1~2 Ã  }#2 PA
	/// </summary>
	Effect_StealAP_84 = 84,
	/// <summary>
	/// #1{~1~2 Ã  }#2% des PV de l'attaquant (dommages Eau)
	/// </summary>
	Effect_DamagePercentWater = 85,
	/// <summary>
	/// #1{~1~2 Ã  }#2% des PV de l'attaquant (dommages Terre)
	/// </summary>
	Effect_DamagePercentEarth = 86,
	/// <summary>
	/// #1{~1~2 Ã  }#2% des PV de l'attaquant (dommages Air)
	/// </summary>
	Effect_DamagePercentAir = 87,
	/// <summary>
	/// #1{~1~2 Ã  }#2% des PV de l'attaquant (dommages Feu)
	/// </summary>
	Effect_DamagePercentFire = 88,
	/// <summary>
	/// #1{~1~2 Ã  }#2% des PV de l'attaquant (dommages Neutre)
	/// </summary>
	Effect_DamagePercentNeutral = 89,
	/// <summary>
	/// Donne #1{~1~2 Ã  }#2 % de sa vie
	/// </summary>
	Effect_GiveHPPercent = 90,
	/// <summary>
	/// #1{~1~2 Ã  }#2 (vol Eau)
	/// </summary>
	Effect_StealHPWater = 91,
	/// <summary>
	/// #1{~1~2 Ã  }#2 (vol Terre)
	/// </summary>
	Effect_StealHPEarth = 92,
	/// <summary>
	/// #1{~1~2 Ã  }#2 (vol Air)
	/// </summary>
	Effect_StealHPAir = 93,
	/// <summary>
	/// #1{~1~2 Ã  }#2 (vol Feu)
	/// </summary>
	Effect_StealHPFire = 94,
	/// <summary>
	/// #1{~1~2 Ã  }#2 (vol Neutre)
	/// </summary>
	Effect_StealHPNeutral = 95,
	/// <summary>
	/// #1{~1~2 Ã  }#2 (dommages Eau)
	/// </summary>
	Effect_DamageWater = 96,
	/// <summary>
	/// #1{~1~2 Ã  }#2 (dommages Terre)
	/// </summary>
	Effect_DamageEarth = 97,
	/// <summary>
	/// #1{~1~2 Ã  }#2 (dommages Air)
	/// </summary>
	Effect_DamageAir = 98,
	/// <summary>
	/// #1{~1~2 Ã  }#2 (dommages Feu)
	/// </summary>
	Effect_DamageFire = 99,
	/// <summary>
	/// #1{~1~2 Ã  }#2 (dommages Neutre)
	/// </summary>
	Effect_DamageNeutral = 100,
	/// <summary>
	/// -#1{~1~2 Ã  -}#2 PA
	/// </summary>
	Effect_LostAP = 101,

	Effect_RemoveAP = 104,
	/// <summary>
	/// Dommages rÃ©duits de #1{~1~2 Ã  }#2
	/// </summary>
	Effect_AddGlobalDamageReduction_105 = 105,
	/// <summary>
	/// Renvoie un sort de niveau #2 maximum
	/// </summary>
	Effect_ReflectSpell = 106,
	/// <summary>
	/// Dommages retournÃ©s : #1{~1~2 Ã  }#2
	/// </summary>
	Effect_ReflectDamage = 107,
	/// <summary>
	/// #1{~1~2 Ã  }#2 (PV rendus)
	/// </summary>
	Effect_HealHP_108 = 108,
	/// <summary>
	/// #1{~1~2 Ã  }#2 (dommages au lanceur)
	/// </summary>
	Effect_109 = 109,
	/// <summary>
	/// #1{~1~2 Ã  }#2 Vie
	/// </summary>
	Effect_AddHealth = 110,
	/// <summary>
	/// #1{~1~2 Ã  }#2 PA
	/// </summary>
	Effect_AddAP_111 = 111,
	/// <summary>
	/// #1{~1~2 Ã  }#2 Dommages
	/// </summary>
	Effect_AddDamageBonus = 112,
	/// <summary>
	/// Double les dommages ou rend  #1{~1~2 Ã  }#2 PDV
	/// </summary>
	Effect_113 = 113,
	/// <summary>
	/// Multiplie les dommages par #1
	/// </summary>
	Effect_AddDamageMultiplicator = 114,
	/// <summary>
	/// #1{~1~2 Ã  }#2% Critique
	/// </summary>
	Effect_AddCriticalHit = 115,
	/// <summary>
	/// -#1{~1~2 Ã  -}#2 PO
	/// </summary>
	Effect_SubRange = 116,
	/// <summary>
	/// #1{~1~2 Ã  }#2 PO
	/// </summary>
	Effect_AddRange = 117,
	/// <summary>
	/// #1{~1~2 Ã  }#2 Force
	/// </summary>
	Effect_AddStrength = 118,
	/// <summary>
	/// #1{~1~2 Ã  }#2 AgilitÃ©
	/// </summary>
	Effect_AddAgility = 119,
	/// <summary>
	/// Ajoute +#1{~1~2 Ã  }#2 PA
	/// </summary>
	Effect_RegainAP = 120,
	/// <summary>
	/// #1{~1~2 Ã  }#2 Dommages
	/// </summary>
	Effect_AddDamageBonus_121 = 121,
	/// <summary>
	/// #1{~1~2 Ã  }#2 Ã‰checs Critiques
	/// </summary>
	Effect_AddCriticalMiss = 122,
	/// <summary>
	/// #1{~1~2 Ã  }#2 Chance
	/// </summary>
	Effect_AddChance = 123,
	/// <summary>
	/// #1{~1~2 Ã  }#2 Sagesse
	/// </summary>
	Effect_AddWisdom = 124,
	/// <summary>
	/// #1{~1~2 Ã  }#2 VitalitÃ©
	/// </summary>
	Effect_AddVitality = 125,
	/// <summary>
	/// #1{~1~2 Ã  }#2 Intelligence
	/// </summary>
	Effect_AddIntelligence = 126,
	/// <summary>
	/// -#1{~1~2 Ã  -}#2 PM
	/// </summary>
	Effect_LostMP = 127,
	/// <summary>
	/// #1{~1~2 Ã  }#2 PM
	/// </summary>
	Effect_AddMP_128 = 128,
	/// <summary>
	/// Vole #1{~1~2 Ã  }#2 Kamas
	/// </summary>
	Effect_StealKamas = 130,
	/// <summary>
	/// #1 PA utilisÃ©s font perdre #2 PV
	/// </summary>
	Effect_LoseHPByUsingAP = 131,
	/// <summary>
	/// EnlÃ¨ve les envoÃ»tements
	/// </summary>
	Effect_DispelMagicEffects = 132,
	/// <summary>
	/// PA perdus pour le lanceur : #1{~1~2 Ã  }#2
	/// </summary>
	Effect_LosingAP = 133,
	/// <summary>
	/// PM perdus pour le lanceur : #1{~1~2 Ã  }#2
	/// </summary>
	Effect_LosingMP = 134,
	/// <summary>
	/// PortÃ©e du lanceur rÃ©duite de : #1{~1~2 Ã  }#2
	/// </summary>
	Effect_SubRange_135 = 135,
	/// <summary>
	/// PortÃ©e du lanceur augmentÃ©e de : #1{~1~2 Ã  }#2
	/// </summary>
	Effect_AddRange_136 = 136,
	/// <summary>
	/// Dommages physiques du lanceur augmentÃ©s de : #1{~1~2 Ã  }#2
	/// </summary>
	Effect_AddPhysicalDamage_137 = 137,
	/// <summary>
	/// #1{~1~2 Ã  }#2 Puissance
	/// </summary>
	Effect_IncreaseDamage_138 = 138,
	/// <summary>
	/// Rend #1{~1~2 Ã  }#2 points d'Ã©nergie
	/// </summary>
	Effect_RestoreEnergyPoints = 139,
	/// <summary>
	/// Tour annulÃ©
	/// </summary>
	Effect_SkipTurn = 140,
	/// <summary>
	/// Tue la cible
	/// </summary>
	Effect_Kill = 141,
	/// <summary>
	/// #1{~1~2 Ã  }#2 Dommages Physiques
	/// </summary>
	Effect_AddPhysicalDamage_142 = 142,
	/// <summary>
	/// #1{~1~2 Ã  }#2 (PV rendus)
	/// </summary>
	Effect_HealHP_143 = 143,
	/// <summary>
	/// #1{~1~2 Ã  }#2 (dommages Neutre fixe)
	/// </summary>
	Effect_DamageNeutralFix = 144,
	/// <summary>
	/// -#1{~1~2 Ã  }#2 Dommages
	/// </summary>
	Effect_SubDamageBonus = 145,
	/// <summary>
	/// Change les paroles
	/// </summary>
	Effect_146 = 146,
	/// <summary>
	/// Ressuscite un alliÃ©
	/// </summary>
	Effect_ReviveAlly = 147,
	/// <summary>
	/// Quelqu'un vous suit !
	/// </summary>
	Effect_Followed = 148,
	/// <summary>
	/// Change l'apparence
	/// </summary>
	Effect_ChangeAppearance = 149,
	/// <summary>
	/// Rend le personnage invisible
	/// </summary>
	Effect_Invisibility = 150,
	/// <summary>
	/// -#1{~1~2 Ã  -}#2 Chance
	/// </summary>
	Effect_SubChance = 152,
	/// <summary>
	/// -#1{~1~2 Ã  -}#2 VitalitÃ©
	/// </summary>
	Effect_SubVitality = 153,
	/// <summary>
	/// -#1{~1~2 Ã  -}#2 AgilitÃ©
	/// </summary>
	Effect_SubAgility = 154,
	/// <summary>
	/// -#1{~1~2 Ã  -}#2 Intelligence
	/// </summary>
	Effect_SubIntelligence = 155,
	/// <summary>
	/// -#1{~1~2 Ã  -}#2 Sagesse
	/// </summary>
	Effect_SubWisdom = 156,
	/// <summary>
	/// -#1{~1~2 Ã  -}#2 Force
	/// </summary>
	Effect_SubStrength = 157,
	/// <summary>
	/// #1{~1~2 Ã  }#2 Pods
	/// </summary>
	Effect_IncreaseWeight = 158,
	/// <summary>
	/// -#1{~1~2 Ã  }#2 Pods
	/// </summary>
	Effect_DecreaseWeight = 159,
	/// <summary>
	/// #1{~1~2 Ã  }#2 Esquive PA
	/// </summary>
	Effect_AddDodgeAPProbability = 160,
	/// <summary>
	/// #1{~1~2 Ã  }#2 Esquive PM
	/// </summary>
	Effect_AddDodgeMPProbability = 161,
	/// <summary>
	/// -#1{~1~2 Ã  }#2 Esquive PA
	/// </summary>
	Effect_SubDodgeAPProbability = 162,
	/// <summary>
	/// -#1{~1~2 Ã  }#2 Esquive PM
	/// </summary>
	Effect_SubDodgeMPProbability = 163,
	/// <summary>
	/// Dommages rÃ©duits de #1%
	/// </summary>
	Effect_AddGlobalDamageReduction = 164,
	/// <summary>
	/// #2% Dommages #1
	/// </summary>
	Effect_AddDamageBonusPercent = 165,
	/// <summary>
	/// PA retournÃ©s : #1{~1~2 Ã  }#2
	/// </summary>
	Effect_166 = 166,
	/// <summary>
	/// -#1{~1~2 Ã  -}#2 PA
	/// </summary>
	Effect_SubAP = 168,
	/// <summary>
	/// -#1{~1~2 Ã  -}#2 PM
	/// </summary>
	Effect_SubMP = 169,
	/// <summary>
	/// -#1{~1~2 Ã  }#2% Critique
	/// </summary>
	Effect_SubCriticalHit = 171,
	/// <summary>
	/// -#1{~1~2 Ã  }#2 RÃ©duction Magique
	/// </summary>
	Effect_SubMagicDamageReduction = 172,
	/// <summary>
	/// -#1{~1~2 Ã  }#2 RÃ©duction Physique
	/// </summary>
	Effect_SubPhysicalDamageReduction = 173,
	/// <summary>
	/// #1{~1~2 Ã  }#2 Initiative
	/// </summary>
	Effect_AddInitiative = 174,
	/// <summary>
	/// -#1{~1~2 Ã  }#2 Initiative
	/// </summary>
	Effect_SubInitiative = 175,
	/// <summary>
	/// #1{~1~2 Ã  }#2 Prospection
	/// </summary>
	Effect_AddProspecting = 176,
	/// <summary>
	/// -#1{~1~2 Ã  }#2 Prospection
	/// </summary>
	Effect_SubProspecting = 177,
	/// <summary>
	/// #1{~1~2 Ã  }#2 Soins
	/// </summary>
	Effect_AddHealBonus = 178,
	/// <summary>
	/// -#1{~1~2 Ã  }#2 Soins
	/// </summary>
	Effect_SubHealBonus = 179,
	/// <summary>
	/// CrÃ©e un double du lanceur de sort
	/// </summary>
	Effect_Double = 180,
	/// <summary>
	/// Invoque : #1
	/// </summary>
	Effect_Summon = 181,
	/// <summary>
	/// #1{~1~2 Ã  }#2 Invocations
	/// </summary>
	Effect_AddSummonLimit = 182,
	/// <summary>
	/// #1{~1~2 Ã  }#2 RÃ©duction Magique
	/// </summary>
	Effect_AddMagicDamageReduction = 183,
	/// <summary>
	/// #1{~1~2 Ã  }#2 RÃ©duction Physique
	/// </summary>
	Effect_AddPhysicalDamageReduction = 184,
	/// <summary>
	/// Invoque : #1 (statique)
	/// </summary>
	Effect_185 = 185,
	/// <summary>
	/// -#1{~1~2 Ã  }#2 Puissance
	/// </summary>
	Effect_SubDamageBonusPercent = 186,
	/// <summary>
	/// Changer l'alignement
	/// </summary>
	Effect_188 = 188,
	/// <summary>
	///
	/// </summary>
	Effect_192 = 192,
	/// <summary>
	/// (not found)
	/// </summary>
	Effect_193 = 193,
	/// <summary>
	/// Gagner #1{~1~2 Ã  }#2 Kamas
	/// </summary>
	Effect_GiveKamas = 194,
	/// <summary>
	/// Transforme en #1
	/// </summary>
	Effect_197 = 197,
	/// <summary>
	/// Pose un objet au sol
	/// </summary>
	Effect_201 = 201,
	/// <summary>
	/// DÃ©voile tous les objets invisibles
	/// </summary>
	Effect_RevealsInvisible = 202,
	/// <summary>
	/// Ressuscite la cible
	/// </summary>
	Effect_206 = 206,
	/// <summary>
	/// #1{~1~2 Ã  }#2% RÃ©sistance Terre
	/// </summary>
	Effect_AddEarthResistPercent = 210,
	/// <summary>
	/// #1{~1~2 Ã  }#2% RÃ©sistance Eau
	/// </summary>
	Effect_AddWaterResistPercent = 211,
	/// <summary>
	/// #1{~1~2 Ã  }#2% RÃ©sistance Air
	/// </summary>
	Effect_AddAirResistPercent = 212,
	/// <summary>
	/// #1{~1~2 Ã  }#2% RÃ©sistance Feu
	/// </summary>
	Effect_AddFireResistPercent = 213,
	/// <summary>
	/// #1{~1~2 Ã  }#2% RÃ©sistance Neutre
	/// </summary>
	Effect_AddNeutralResistPercent = 214,
	/// <summary>
	/// -#1{~1~2 Ã  }#2% RÃ©sistance Terre
	/// </summary>
	Effect_SubEarthResistPercent = 215,
	/// <summary>
	/// -#1{~1~2 Ã  }#2 % RÃ©sistance Eau
	/// </summary>
	Effect_SubWaterResistPercent = 216,
	/// <summary>
	/// -#1{~1~2 Ã  }#2% RÃ©sistance Air
	/// </summary>
	Effect_SubAirResistPercent = 217,
	/// <summary>
	/// -#1{~1~2 Ã  }#2% RÃ©sistance Feu
	/// </summary>
	Effect_SubFireResistPercent = 218,
	/// <summary>
	/// -#1{~1~2 Ã  }#2 % RÃ©sistance Neutre
	/// </summary>
	Effect_SubNeutralResistPercent = 219,
	/// <summary>
	/// Renvoie #1{~1~2 Ã  }#2 dommages
	/// </summary>
	Effect_AddDamageReflection_220 = 220,
	/// <summary>
	/// Qu'y a-t-il lÃ  dedans ?
	/// </summary>
	Effect_221 = 221,
	/// <summary>
	/// Qu'y a-t-il lÃ  dedans ?
	/// </summary>
	Effect_222 = 222,
	/// <summary>
	/// #1{~1~2 Ã  }#2 Dommages PiÃ¨ges
	/// </summary>
	Effect_AddTrapBonus = 225,
	/// <summary>
	/// #1{~1~2 Ã  }#2 Puissance (piÃ¨ges)
	/// </summary>
	Effect_AddTrapBonusPercent = 226,
	/// <summary>
	/// RÃ©cupÃ¨re une monture !
	/// </summary>
	Effect_229 = 229,
	/// <summary>
	/// #1 Ã‰nergie Perdue
	/// </summary>
	Effect_230 = 230,
	/// <summary>
	/// (not found)
	/// </summary>
	Effect_239 = 239,
	/// <summary>
	/// #1{~1~2 Ã  }#2 RÃ©sistance Terre
	/// </summary>
	Effect_AddEarthElementReduction = 240,
	/// <summary>
	/// #1{~1~2 Ã  }#2 RÃ©sistance Eau
	/// </summary>
	Effect_AddWaterElementReduction = 241,
	/// <summary>
	/// #1{~1~2 Ã  }#2 RÃ©sistance Air
	/// </summary>
	Effect_AddAirElementReduction = 242,
	/// <summary>
	/// #1{~1~2 Ã  }#2 RÃ©sistance Feu
	/// </summary>
	Effect_AddFireElementReduction = 243,
	/// <summary>
	/// #1{~1~2 Ã  }#2 RÃ©sistance Neutre
	/// </summary>
	Effect_AddNeutralElementReduction = 244,
	/// <summary>
	/// -#1{~1~2 Ã  }#2 RÃ©sistance Terre
	/// </summary>
	Effect_SubEarthElementReduction = 245,
	/// <summary>
	/// -#1{~1~2 Ã  }#2 RÃ©sistance Eau
	/// </summary>
	Effect_SubWaterElementReduction = 246,
	/// <summary>
	/// -#1{~1~2 Ã  }#2 RÃ©sistance Air
	/// </summary>
	Effect_SubAirElementReduction = 247,
	/// <summary>
	/// -#1{~1~2 Ã  }#2 RÃ©sistance Feu
	/// </summary>
	Effect_SubFireElementReduction = 248,
	/// <summary>
	/// -#1{~1~2 Ã  }#2 RÃ©sistance Neutre
	/// </summary>
	Effect_SubNeutralElementReduction = 249,
	/// <summary>
	/// #1{~1~2 Ã  }#2% RÃ©sistance Terre JCJ
	/// </summary>
	Effect_AddPvpEarthResistPercent = 250,
	/// <summary>
	/// #1{~1~2 Ã  }#2% RÃ©sistance Eau JCJ
	/// </summary>
	Effect_AddPvpWaterResistPercent = 251,
	/// <summary>
	/// #1{~1~2 Ã  }#2% RÃ©sistance Air JCJ
	/// </summary>
	Effect_AddPvpAirResistPercent = 252,
	/// <summary>
	/// #1{~1~2 Ã  }#2% RÃ©sistance Feu JCJ
	/// </summary>
	Effect_AddPvpFireResistPercent = 253,
	/// <summary>
	/// #1{~1~2 Ã  }#2% RÃ©sistance Neutre JCJ
	/// </summary>
	Effect_AddPvpNeutralResistPercent = 254,
	/// <summary>
	/// -#1{~1~2 Ã  }#2% RÃ©sistance Terre JCJ
	/// </summary>
	Effect_SubPvpEarthResistPercent = 255,
	/// <summary>
	/// -#1{~1~2 Ã  }#2% RÃ©sistance Eau JCJ
	/// </summary>
	Effect_SubPvpWaterResistPercent = 256,
	/// <summary>
	/// -#1{~1~2 Ã  }#2% RÃ©sistance Air JCJ
	/// </summary>
	Effect_SubPvpAirResistPercent = 257,
	/// <summary>
	/// -#1{~1~2 Ã  }#2% RÃ©sistance Feu JCJ
	/// </summary>
	Effect_SubPvpFireResistPercent = 258,
	/// <summary>
	/// -#1{~1~2 Ã  }#2% RÃ©sistance Neutre JCJ
	/// </summary>
	Effect_SubPvpNeutralResistPercent = 259,
	/// <summary>
	/// #1{~1~2 Ã  }#2 RÃ©sistance Terre JCJ
	/// </summary>
	Effect_AddPvpEarthElementReduction = 260,
	/// <summary>
	/// #1{~1~2 Ã  }#2 RÃ©sistance Eau JCJ
	/// </summary>
	Effect_AddPvpWaterElementReduction = 261,
	/// <summary>
	/// #1{~1~2 Ã  }#2 RÃ©sistance Air JCJ
	/// </summary>
	Effect_AddPvpAirElementReduction = 262,
	/// <summary>
	/// #1{~1~2 Ã  }#2 RÃ©sistance Feu JCJ
	/// </summary>
	Effect_AddPvpFireElementReduction = 263,
	/// <summary>
	/// #1{~1~2 Ã  }#2 RÃ©sistance Neutre JCJ
	/// </summary>
	Effect_AddPvpNeutralElementReduction = 264,
	/// <summary>
	/// Dommages rÃ©duits de #1{~1~2 Ã  }#2
	/// </summary>
	Effect_ArmorDamageReduction = 265,
	/// <summary>
	/// Vole #1{~1~2 Ã  -}#2 Chance
	/// </summary>
	Effect_StealChance = 266,
	/// <summary>
	/// Vole #1{~1~2 Ã  -}#2 VitalitÃ©
	/// </summary>
	Effect_StealVitality = 267,
	/// <summary>
	/// Vole #1{~1~2 Ã  -}#2 AgilitÃ©
	/// </summary>
	Effect_StealAgility = 268,
	/// <summary>
	/// Vole #1{~1~2 Ã  -}#2 Intelligence
	/// </summary>
	Effect_StealIntelligence = 269,
	/// <summary>
	/// Vole #1{~1~2 Ã  -}#2 Sagesse
	/// </summary>
	Effect_StealWisdom = 270,
	/// <summary>
	/// Vole #1{~1~2 Ã  -}#2 Force
	/// </summary>
	Effect_StealStrength = 271,
	/// <summary>
	/// #1{~1~2 Ã  }#2% des PV manquants de l'attaquant (dommages Eau)
	/// </summary>
	Effect_DamageWaterPerHPLost = 275,
	/// <summary>
	/// #1{~1~2 Ã  }#2% des PV manquants de l'attaquant (dommages Terre)
	/// </summary>
	Effect_DamageEarthPerHPLost = 276,
	/// <summary>
	/// #1{~1~2 Ã  }#2% des PV manquants de l'attaquant (dommages Air)
	/// </summary>
	Effect_DamageAirPerHPLost = 277,
	/// <summary>
	/// #1{~1~2 Ã  }#2% des PV manquants de l'attaquant (dommages Feu)
	/// </summary>
	Effect_DamageFirePerHPLost = 278,
	/// <summary>
	/// #1{~1~2 Ã  }#2% des PV manquants de l'attaquant (dommages Neutre)
	/// </summary>
	Effect_DamageNeutralPerHPLost = 279,
	/// <summary>
	/// Augmente la portÃ©e minimale du sort #1 de #3
	/// </summary>
	Effect_SpellBoostMinimalRange = 280,
	/// <summary>
	/// Augmente la PO du sort #1 de #3
	/// </summary>
	Effect_SpellBoostRange = 281,
	/// <summary>
	/// Rend la portÃ©e du sort #1 modifiable
	/// </summary>
	Effect_282 = 282,
	/// <summary>
	/// +#3 Dommages sur le sort #1
	/// </summary>
	Effect_IncreaseDamageOfTheSpell = 283,
	/// <summary>
	/// +#3 Soins sur le sort #1
	/// </summary>
	Effect_AddHealBonusOnSpell = 284,
	/// <summary>
	/// RÃ©duit de #3 le coÃ»t en PA du sort #1
	/// </summary>
	Effect_SpellReduceApCost = 285,
	/// <summary>
	/// RÃ©duit de #3 le dÃ©lai de relance du sort #1
	/// </summary>
	Effect_ReduceSpellCooldownDelay = 286,
	/// <summary>
	/// +#3% Critique sur le sort #1
	/// </summary>
	Effect_AddCriticalForSpell = 287,
	/// <summary>
	/// DÃ©sactive le lancer en ligne du sort #1
	/// </summary>
	Effect_288 = 288,
	/// <summary>
	/// DÃ©sactive la ligne de vue du sort #1
	/// </summary>
	Effect_DisableLOS = 289,
	/// <summary>
	/// Augmente de #3 le nombre de lancer maximal par tour du sort #1
	/// </summary>
	Effect_IncreaseMaxNumberOfCastPerTurn = 290,
	/// <summary>
	/// Augmente de #3 le nombre de lancer maximal par cible du sort #1
	/// </summary>
	Effect_IncreaseMaxNumberOfCastPerTarget = 291,
	/// <summary>
	/// Fixe Ã  #3 le dÃ©lai de relance du sort #1
	/// </summary>
	Effect_CooldownSet_292 = 292,
	/// <summary>
	/// Augmente les dÃ©gÃ¢ts de base du sort #1 de #3
	/// </summary>
	Effect_SpellBoostBaseDamage = 293,
	/// <summary>
	/// Diminue la portÃ©e maximale du sort #1 de #3
	/// </summary>
	Effect_ReduceSpellRange = 294,
	/// <summary>
	/// Diminue la portÃ©e minimale du sort #1 de #3
	/// </summary>
	Effect_ReduceSpellMinimalRange = 295,
	/// <summary>
	/// Augmente de #3 le coÃ»t en PA du sort #1
	/// </summary>
	Effect_IncreaseSpellAPCost = 296,
	/// <summary>
	/// (not found)
	/// </summary>
	Effect_310 = 310,
	/// <summary>
	/// Vole #1{~1~2 Ã  }#2 PO
	/// </summary>
	Effect_StealRange = 320,
	/// <summary>
	/// Change une couleur
	/// </summary>
	Effect_ChangeColor = 333,
	/// <summary>
	/// Change l'apparence
	/// </summary>
	Effect_ChangeAppearance_335 = 335,
	/// <summary>
	///
	/// </summary>
	Effect_350 = 350,
	/// <summary>
	///
	/// </summary>
	Effect_PowerSink = 351,
	/// <summary>
	/// Pose un piÃ¨ge de rang #2
	/// </summary>
	Effect_Trap = 400,
	/// <summary>
	/// Pose un glyphe de rang #2
	/// </summary>
	Effect_TurnBeginGlyph = 401,
	/// <summary>
	/// Pose un glyphe de rang #2
	/// </summary>
	Effect_TurnEndGlyph = 402,
	/// <summary>
	/// Tue la cible pour la remplacer par l'invocation : #1
	/// </summary>
	Effect_KillAndSummon = 405,
	/// <summary>
	/// EnlÃ¨ve les effets du sort #2
	/// </summary>
	Effect_RemoveSpellEffects = 406,
	/// <summary>
	/// #1{~1~2 Ã  }#2 (PV rendus)
	/// </summary>
	Effect_HealHP_407 = 407,
	/// <summary>
	/// #1{~1~2 Ã  }#2 Retrait PA
	/// </summary>
	Effect_AddAPAttack = 410,
	/// <summary>
	/// -#1{~1~2 Ã  }#2 Retrait PA
	/// </summary>
	Effect_SubAPAttack = 411,
	/// <summary>
	/// #1{~1~2 Ã  }#2 Retrait PM
	/// </summary>
	Effect_AddMPAttack = 412,
	/// <summary>
	/// -#1{~1~2 Ã  }#2 Retrait PM
	/// </summary>
	Effect_SubMPAttack = 413,
	/// <summary>
	/// #1{~1~2 Ã  }#2 Dommages PoussÃ©e
	/// </summary>
	Effect_AddPushDamageBonus = 414,
	/// <summary>
	/// -#1{~1~2 Ã  }#2 Dommages PoussÃ©e
	/// </summary>
	Effect_SubPushDamageBonus = 415,
	/// <summary>
	/// #1{~1~2 Ã  }#2 RÃ©sistance PoussÃ©e
	/// </summary>
	Effect_AddPushDamageReduction = 416,
	/// <summary>
	/// -#1{~1~2 Ã  }#2 RÃ©sistance PoussÃ©e
	/// </summary>
	Effect_SubPushDamageReduction = 417,
	/// <summary>
	/// #1{~1~2 Ã  }#2 Dommages Critiques
	/// </summary>
	Effect_AddCriticalDamageBonus = 418,
	/// <summary>
	/// -#1{~1~2 Ã  }#2 Dommages Critiques
	/// </summary>
	Effect_SubCriticalDamageBonus = 419,
	/// <summary>
	/// #1{~1~2 Ã  }#2 RÃ©sistance Critiques
	/// </summary>
	Effect_AddCriticalDamageReduction = 420,
	/// <summary>
	/// -#1{~1~2 Ã  }#2 RÃ©sistance Critiques
	/// </summary>
	Effect_SubCriticalDamageReduction = 421,
	/// <summary>
	/// #1{~1~2 Ã  }#2 Dommages Terre
	/// </summary>
	Effect_AddEarthDamageBonus = 422,
	/// <summary>
	/// -#1{~1~2 Ã  }#2 Dommages Terre
	/// </summary>
	Effect_SubEarthDamageBonus = 423,
	/// <summary>
	/// #1{~1~2 Ã  }#2 Dommages Feu
	/// </summary>
	Effect_AddFireDamageBonus = 424,
	/// <summary>
	/// -#1{~1~2 Ã  }#2 Dommages Feu
	/// </summary>
	Effect_SubFireDamageBonus = 425,
	/// <summary>
	/// #1{~1~2 Ã  }#2 Dommages Eau
	/// </summary>
	Effect_AddWaterDamageBonus = 426,
	/// <summary>
	/// -#1{~1~2 Ã  }#2 Dommages Eau
	/// </summary>
	Effect_SubWaterDamageBonus = 427,
	/// <summary>
	/// #1{~1~2 Ã  }#2 Dommages Air
	/// </summary>
	Effect_AddAirDamageBonus = 428,
	/// <summary>
	/// -#1{~1~2 Ã  }#2 Dommages Air
	/// </summary>
	Effect_SubAirDamageBonus = 429,
	/// <summary>
	/// #1{~1~2 Ã  }#2 Dommages Neutre
	/// </summary>
	Effect_AddNeutralDamageBonus = 430,
	/// <summary>
	/// -#1{~1~2 Ã  }#2 Dommages Neutre
	/// </summary>
	Effect_SubNeutralDamageBonus = 431,
	/// <summary>
	/// Vole #1{~1~2 Ã  }#2 PA
	/// </summary>
	Effect_StealAP_440 = 440,
	/// <summary>
	/// Vole #1{~1~2 Ã  }#2 PM
	/// </summary>
	Effect_StealMP_441 = 441,
	/// <summary>
	/// Positionne la boussole
	/// </summary>
	Effect_509 = 509,
	/// <summary>
	/// Pose un prisme
	/// </summary>
	Effect_513 = 513,
	/// <summary>
	/// Afficher les percepteurs les plus riches
	/// </summary>
	Effect_516 = 516,
	/// <summary>
	///
	/// </summary>
	Effect_517 = 517,
	/// <summary>
	/// TÃ©lÃ©porte au point de sauvegarde
	/// </summary>
	Effect_TeleportToSavePoint = 600,
	/// <summary>
	/// (not found)
	/// </summary>
	Effect_601 = 601,
	/// <summary>
	/// Enregistre sa position
	/// </summary>
	Effect_602 = 602,
	/// <summary>
	/// Apprend le mÃ©tier #3
	/// </summary>
	Effect_603 = 603,
	/// <summary>
	/// Apprend le sort #3
	/// </summary>
	Effect_LearnSpell = 604,
	/// <summary>
	/// +#1{~1~2 Ã  }#2 XP
	/// </summary>
	Effect_AddExp = 605,
	/// <summary>
	/// +#1{~1~2 Ã  }#2 Sagesse
	/// </summary>
	Effect_AddPermanentWisdom = 606,
	/// <summary>
	/// +#1{~1~2 Ã  }#2 Force
	/// </summary>
	Effect_AddPermanentStrength = 607,
	/// <summary>
	/// +#1{~1~2 Ã  }#2 Chance
	/// </summary>
	Effect_AddPermanentChance = 608,
	/// <summary>
	/// +#1{~1~2 Ã  }#2 AgilitÃ©
	/// </summary>
	Effect_AddPermanentAgility = 609,
	/// <summary>
	/// +#1{~1~2 Ã  }#2 VitalitÃ©
	/// </summary>
	Effect_AddPermanentVitality = 610,
	/// <summary>
	/// +#1{~1~2 Ã  }#2 Intelligence
	/// </summary>
	Effect_AddPermanentIntelligence = 611,
	/// <summary>
	/// +#1{~1~2 Ã  }#2 points de caractÃ©ristique
	/// </summary>
	Effect_612 = 612,
	/// <summary>
	/// +#1{~1~2 Ã  }#2 point(s) de sort
	/// </summary>
	Effect_AddSpellPoints = 613,
	/// <summary>
	/// + #1 XP #2
	/// </summary>
	Effect_614 = 614,
	/// <summary>
	/// Fait oublier le mÃ©tier de #3
	/// </summary>
	Effect_615 = 615,
	/// <summary>
	/// Fait oublier un niveau du sort #3
	/// </summary>
	Effect_616 = 616,
	/// <summary>
	/// Consulter #3
	/// </summary>
	Effect_ConsultDocument = 620,
	/// <summary>
	/// Invoque : #3 (grade #1)
	/// </summary>
	Effect_621 = 621,
	/// <summary>
	/// TÃ©lÃ©porte chez soi
	/// </summary>
	Effect_622 = 622,
	/// <summary>
	/// #3 (#2)
	/// </summary>
	Effect_SoulStoneSummon = 623,
	/// <summary>
	/// Fait oublier un niveau du sort #3
	/// </summary>
	Effect_ForgetSpell = 624,
	/// <summary>
	/// (not found)
	/// </summary>
	Effect_625 = 625,
	/// <summary>
	/// (not found)
	/// </summary>
	Effect_626 = 626,
	/// <summary>
	/// Reproduit la carte d'origine
	/// </summary>
	Effect_627 = 627,
	/// <summary>
	/// #3 (#2)
	/// </summary>
	Effect_628 = 628,
	/// <summary>
	///
	/// </summary>
	Effect_630 = 630,
	/// <summary>
	/// (not found)
	/// </summary>
	Effect_631 = 631,
	/// <summary>
	///
	/// </summary>
	Effect_632 = 632,
	/// <summary>
	/// Ajoute #3 points d'honneur
	/// </summary>
	Effect_640 = 640,
	/// <summary>
	/// Ajoute #3 points de dÃ©shonneur
	/// </summary>
	Effect_641 = 641,
	/// <summary>
	/// Retire #3 points d'honneur
	/// </summary>
	Effect_642 = 642,
	/// <summary>
	/// Retire #3 points de dÃ©shonneur
	/// </summary>
	Effect_643 = 643,
	/// <summary>
	/// Ressuscite les alliÃ©s prÃ©sents sur la carte
	/// </summary>
	Effect_645 = 645,
	/// <summary>
	/// #1{~1~2 Ã  }#2 (PV rendus)
	/// </summary>
	Effect_646 = 646,
	/// <summary>
	/// LibÃ¨re les Ã¢mes des ennemis
	/// </summary>
	Effect_647 = 647,
	/// <summary>
	/// LibÃ¨re une Ã¢me ennemie
	/// </summary>
	Effect_648 = 648,
	/// <summary>
	/// Faire semblant d'Ãªtre #3
	/// </summary>
	Effect_649 = 649,
	/// <summary>
	///
	/// </summary>
	Effect_652 = 652,
	/// <summary>
	/// (not found)
	/// </summary>
	Effect_654 = 654,
	/// <summary>
	/// Pas d'effet supplÃ©mentaire
	/// </summary>
	Effect_NoMoreEffects = 666,
	/// <summary>
	/// Combat annulÃ©
	/// </summary>
	Effects_CancelFight = 667,
	/// <summary>
	/// Incarnation Niveau #5
	/// </summary>
	Effect_669 = 669,
	/// <summary>
	/// #1{~1~2 Ã  }#2% de la vie de l'attaquant (dommages Neutre)
	/// </summary>
	Effect_670 = 670,
	/// <summary>
	/// #1{~1~2 Ã  }#2% de la vie de l'attaquant (dommages Neutre fixes)
	/// </summary>
	Effect_DamagePercentNeutral_671 = 671,
	/// <summary>
	/// #1{~1~2 Ã  }#2% de la vie de l'attaquant (dommages Neutre)
	/// </summary>
	Effect_Punishment_Damage = 672,
	/// <summary>
	/// Lier son mÃ©tier : #1
	/// </summary>
	Effect_699 = 699,
	/// <summary>
	/// Change l'Ã©lÃ©ment de frappe
	/// </summary>
	Effect_700 = 700,
	/// <summary>
	/// Puissance : #1{~1~2 Ã  }#2
	/// </summary>
	Effect_701 = 701,
	/// <summary>
	/// +#1{~1~2 Ã  }#2 Point(s) de durabilitÃ©
	/// </summary>
	Effect_702 = 702,
	/// <summary>
	/// #1% capture d'Ã¢me de puissance #3
	/// </summary>
	Effect_SoulStone = 705,
	/// <summary>
	/// #1% de proba de capturer une monture
	/// </summary>
	Effect_706 = 706,
	/// <summary>
	/// Utilise l'Ã©quipement rapide nÂ°#3
	/// </summary>
	Effect_707 = 707,
	/// <summary>
	/// CoÃ»t supplÃ©mentaire
	/// </summary>
	Effect_710 = 710,
	/// <summary>
	/// #1 : #3
	/// </summary>
	Effect_MonsterSuperRaceKilledCount = 715,
	/// <summary>
	/// #1 : #3
	/// </summary>
	Effect_MonsterRaceKilledCount = 716,
	/// <summary>
	/// #1 : #3
	/// </summary>
	Effect_MonsterKilledCount = 717,
	/// <summary>
	/// Nombre de victimes : #2
	/// </summary>
	Effect_720 = 720,
	/// <summary>
	/// Titre : #3
	/// </summary>
	Effect_AddTitle = 724,
	/// <summary>
	/// Renommer la guilde : #4
	/// </summary>
	Effect_725 = 725,
	/// <summary>
	/// Ornement : #3
	/// </summary>
	Effect_AddOrnament = 726,
	/// <summary>
	/// TÃ©lÃ©porte au prisme alliÃ© le plus proche
	/// </summary>
	Effect_730 = 730,
	/// <summary>
	/// Agresse les personnages d'alliances ennemies automatiquement
	/// </summary>
	Effect_731 = 731,
	/// <summary>
	/// RÃ©sistance Ã  l'agression automatique par les joueurs ennemis : #1{~1~2 Ã  }#2
	/// </summary>
	Effect_732 = 732,
	/// <summary>
	/// (not found)
	/// </summary>
	Effect_740 = 740,
	/// <summary>
	/// (not found)
	/// </summary>
	Effect_741 = 741,
	/// <summary>
	/// (not found)
	/// </summary>
	Effect_742 = 742,
	/// <summary>
	/// Bonus aux chances de capture : #1{~1~2 Ã  }#2%
	/// </summary>
	Effect_750 = 750,
	/// <summary>
	/// #1{~1~2 Ã  }#2% Bonus XP monture
	/// </summary>
	Effect_AddMountXpPercent = 751,
	/// <summary>
	/// #1{~1~2 Ã  }#2 Fuite
	/// </summary>
	Effect_AddEvade = 752,
	/// <summary>
	/// #1{~1~2 Ã  }#2 Tacle
	/// </summary>
	Effect_AddLock = 753,
	/// <summary>
	/// -#1{~1~2 Ã  }#2 Fuite
	/// </summary>
	Effect_SubEvade = 754,
	/// <summary>
	/// -#1{~1~2 Ã  }#2 Tacle
	/// </summary>
	Effect_SubLock = 755,
	/// <summary>
	/// DisparaÃ®t en se dÃ©plaÃ§ant
	/// </summary>
	Effect_760 = 760,
	/// <summary>
	/// Interception des dommages
	/// </summary>
	Effect_DamageIntercept = 765,
	/// <summary>
	/// Confusion horaire : #1{~1~2 Ã  }#2 degrÃ©s
	/// </summary>
	Effect_TimeConfusionDegrees = 770,
	/// <summary>
	/// Confusion horaire : #1{~1~2 Ã  }#2 Pi/2
	/// </summary>
	Effect_TimeConfusionPI2 = 771,
	/// <summary>
	/// Confusion horaire : #1{~1~2 Ã  }#2 Pi/4
	/// </summary>
	Effect_TimeConfusionPI4 = 772,
	/// <summary>
	/// Confusion contre horaire : #1{~1~2 Ã  }#2 degrÃ©s
	/// </summary>
	Effect_AgainstTimeConfusionDegrees = 773,
	/// <summary>
	/// Confusion contre horaire : #1{~1~2 Ã  }#2 Pi/2
	/// </summary>
	Effect_AgainstTimeConfusionDegreesPI2 = 774,
	/// <summary>
	/// Confusion contre horaire : #1{~1~2 Ã  }#2 Pi/4
	/// </summary>
	Effect_AgainstTimeConfusionDegreesPI4 = 775,
	/// <summary>
	/// #1{~1~2 Ã  }#2% Ã‰rosion
	/// </summary>
	Effect_AddErosion = 776,
	/// <summary>
	/// Fixe le point de respawn
	/// </summary>
	Effect_778 = 778,
	/// <summary>
	/// Invoque le dernier alliÃ© mort avec #1{~1~2 Ã  }#2 % de ses PDV
	/// </summary>
	Effect_ReviveAndGiveHPToLastDiedAlly = 780,
	/// <summary>
	/// Minimise les effets alÃ©atoires
	/// </summary>
	Effect_RandDownModifier = 781,
	/// <summary>
	/// Maximise les effets alÃ©atoires
	/// </summary>
	Effect_RandUpModifier = 782,
	/// <summary>
	/// Pousse jusqu'Ã  la case visÃ©e
	/// </summary>
	Effect_RepelsTo = 783,
	/// <summary>
	/// Retour Ã  la position de dÃ©part
	/// </summary>
	Effect_ReturnToOriginalPos = 784,
	/// <summary>
	/// (not found)
	/// </summary>
	Effect_785 = 785,
	/// <summary>
	/// Soigne l'attaquant de #1{~1~2 Ã  }#2% des dommages subis.
	/// </summary>
	Effect_GiveHpPercentWhenAttack = 786,
	/// <summary>
	/// #1
	/// </summary>
	Effect_787 = 787,
	/// <summary>
	/// ChÃ¢timent de #2 sur #3 tour(s)
	/// </summary>
	Effect_Punishment = 788,
	/// <summary>
	/// (not found)
	/// </summary>
	Effect_789 = 789,
	/// <summary>
	/// (not found)
	/// </summary>
	Effect_790 = 790,
	/// <summary>
	/// PrÃ©pare #1{~1~2 Ã  }#2 parchemins pour mercenaire [wait]
	/// </summary>
	Effect_791 = 791,
	/// <summary>
	/// #1
	/// </summary>
	Effect_CastSpell_792 = 792,
	/// <summary>
	/// #1
	/// </summary>
	Effect_CastSpell_793 = 793,
	/// <summary>
	/// Arme de chasse
	/// </summary>
	Effect_795 = 795,
	/// <summary>
	/// Restaurer le point de respawn
	/// </summary>
	Effect_796 = 796,
	/// <summary>
	/// Points de vie : #3
	/// </summary>
	Effect_LifePoints = 800,
	/// <summary>
	/// ReÃ§u le : #1
	/// </summary>
	Effect_805 = 805,
	/// <summary>
	/// Corpulence : #1
	/// </summary>
	Effect_Corpulence = 806,
	/// <summary>
	/// Dernier repas : #1
	/// </summary>
	Effect_LastMeal = 807,
	/// <summary>
	/// A mangÃ© le : #1
	/// </summary>
	Effect_LastMealDate = 808,
	/// <summary>
	/// Taille : #3 poces
	/// </summary>
	Effect_810 = 810,
	/// <summary>
	/// Combat(s) restant(s) : #3
	/// </summary>
	Effect_RemainingFights = 811,
	/// <summary>
	/// Utilisations : #2 / #3
	/// </summary>
	Effect_812 = 812,
	/// <summary>
	/// (not found)
	/// </summary>
	Effect_MealCount = 813,
	/// <summary>
	/// #1
	/// </summary>
	Effect_814 = 814,
	/// <summary>
	/// (not found)
	/// </summary>
	Effect_815 = 815,
	/// <summary>
	/// (not found)
	/// </summary>
	Effect_816 = 816,
	/// <summary>
	/// TÃ©lÃ©porte
	/// </summary>
	Effect_825 = 825,
	/// <summary>
	/// TÃ©lÃ©porte
	/// </summary>
	Effect_826 = 826,
	/// <summary>
	/// Oublier un sort
	/// </summary>
	Effect_831 = 831,
	/// <summary>
	/// Lance un combat contre #2
	/// </summary>
	Effect_905 = 905,
	/// <summary>
	///
	/// </summary>
	Effect_911 = 911,
	/// <summary>
	///
	/// </summary>
	Effect_916 = 916,
	/// <summary>
	///
	/// </summary>
	Effect_917 = 917,
	/// <summary>
	/// Augmente la sÃ©rÃ©nitÃ©, diminue l'agressivitÃ©
	/// </summary>
	Effect_930 = 930,
	/// <summary>
	/// Augmente l'agressivitÃ©, diminue la sÃ©rÃ©nitÃ©
	/// </summary>
	Effect_931 = 931,
	/// <summary>
	/// Augmente l'endurance
	/// </summary>
	Effect_932 = 932,
	/// <summary>
	/// Diminue l'endurance
	/// </summary>
	Effect_933 = 933,
	/// <summary>
	/// Augmente l'amour
	/// </summary>
	Effect_934 = 934,
	/// <summary>
	/// Diminue l'amour
	/// </summary>
	Effect_935 = 935,
	/// <summary>
	/// AccÃ©lÃ¨re la maturitÃ©
	/// </summary>
	Effect_936 = 936,
	/// <summary>
	/// Ralentit la maturitÃ©
	/// </summary>
	Effect_937 = 937,
	/// <summary>
	/// Augmente les capacitÃ©s d'un familier #3
	/// </summary>
	Effect_939 = 939,
	/// <summary>
	/// CapacitÃ©s accrues
	/// </summary>
	Effect_IncreasePetStats = 940,
	/// <summary>
	/// Retirer temporairement un objet d'Ã©levage
	/// </summary>
	Effect_946 = 946,
	/// <summary>
	/// RÃ©cupÃ©rer un objet d'enclos
	/// </summary>
	Effect_947 = 947,
	/// <summary>
	/// Objet pour enclos
	/// </summary>
	Effect_948 = 948,
	/// <summary>
	/// Monter/Descendre d'une monture
	/// </summary>
	Effect_949 = 949,
	/// <summary>
	/// Ã‰tat #3
	/// </summary>
	Effect_AddState = 950,
	/// <summary>
	/// EnlÃ¨ve l'Ã©tat #3
	/// </summary>
	Effect_DispelState = 951,
	/// <summary>
	/// DÃ©sactive l'Ã©tat '#3'
	/// </summary>
	Effect_DisableState = 952,
	/// <summary>
	/// Alignement : #3
	/// </summary>
	Effect_Alignment = 960,
	/// <summary>
	/// Grade : #3
	/// </summary>
	Effect_Grade = 961,
	/// <summary>
	/// Niveau : #3
	/// </summary>
	Effect_Level = 962,
	/// <summary>
	/// CrÃ©Ã© depuis : #3 jour(s)
	/// </summary>
	Effect_963 = 963,
	/// <summary>
	/// Nom : #4
	/// </summary>
	Effect_964 = 964,
	/// <summary>
	/// (not found)
	/// </summary>
	Effect_LivingObjectId = 970,
	/// <summary>
	/// (not found)
	/// </summary>
	Effect_LivingObjectMood = 971,
	/// <summary>
	/// (not found)
	/// </summary>
	Effect_LivingObjectSkin = 972,
	/// <summary>
	/// (not found)
	/// </summary>
	Effect_LivingObjectCategory = 973,
	/// <summary>
	/// (not found)
	/// </summary>
	Effect_LivingObjectLevel = 974,
	/// <summary>
	/// LiÃ© au personnage
	/// </summary>
	Effect_NonExchangeable_981 = 981,
	/// <summary>
	/// LiÃ© au compte
	/// </summary>
	Effect_NonExchangeable_982 = 982,
	/// <summary>
	/// Ã‰changeable : #1
	/// </summary>
	Effect_Exchangeable = 983,
	/// <summary>
	/// (not found)
	/// </summary>
	Effect_984 = 984,
	/// <summary>
	/// ModifiÃ© par : #4
	/// </summary>
	Effect_985 = 985,
	/// <summary>
	/// PrÃ©pare #1{~1~2 Ã  }#2 parchemins
	/// </summary>
	Effect_986 = 986,
	/// <summary>
	/// Appartient Ã  : #4
	/// </summary>
	Effect_BelongsTo = 987,
	/// <summary>
	/// FabriquÃ© par : #4
	/// </summary>
	Effect_988 = 988,
	/// <summary>
	/// Recherche : #4
	/// </summary>
	Effect_Seek = 989,
	/// <summary>
	/// #4
	/// </summary>
	Effect_990 = 990,
	/// <summary>
	/// !! Certificat invalide !!
	/// </summary>
	Effect_InvalidCertificate = 994,
	/// <summary>
	///
	/// </summary>
	Effect_ViewMountCharacteristics = 995,
	/// <summary>
	/// Appartient Ã  : #4
	/// </summary>
	Effect_996 = 996,
	/// <summary>
	/// Nom : #4
	/// </summary>
	Effect_Name = 997,
	/// <summary>
	/// ValiditÃ© : #1j #2h #3m
	/// </summary>
	Effect_Validity = 998,
	/// <summary>
	/// (not found)
	/// </summary>
	Effect_999 = 999,
	/// <summary>
	/// 2
	/// </summary>
	Effect_1002 = 1002,
	/// <summary>
	/// Diminue de #1{~1~2 Ã  }#2 le bonus maximum
	/// </summary>
	Effect_1003 = 1003,
	/// <summary>
	/// (not found)
	/// </summary>
	Effect_1004 = 1004,
	/// <summary>
	/// Diminue de #1{~1~2 Ã  }#2 le bonus maximum
	/// </summary>
	Effect_1005 = 1005,
	/// <summary>
	/// Diminue de #1{~1~2 Ã  }#2 le bonus minimum
	/// </summary>
	Effect_1006 = 1006,
	/// <summary>
	/// EfficacitÃ© : #1{~1~2 Ã  }#2
	/// </summary>
	Effect_1007 = 1007,
	/// <summary>
	/// Invoque : #1
	/// </summary>
	Effect_SummonsBomb = 1008,
	/// <summary>
	/// Active une bombe
	/// </summary>
	Effect_TriggerBomb = 1009,
	/// <summary>
	/// Pose un glyphe de rang #2
	/// </summary>
	Effect_1010 = 1010,
	/// <summary>
	/// Invoque : #1
	/// </summary>
	Effect_SummonSlave = 1011,
	/// <summary>
	/// #1{~1~2 Ã  }#2 (dommages Neutre)
	/// </summary>
	Effect_DamageNeutralRemainingMP = 1012,
	/// <summary>
	/// #1{~1~2 Ã  }#2 (dommages Air)
	/// </summary>
	Effect_DamageAirRemainingMP = 1013,
	/// <summary>
	/// #1{~1~2 Ã  }#2 (dommages Eau)
	/// </summary>
	Effect_DamageWaterRemainingMP = 1014,
	/// <summary>
	/// #1{~1~2 Ã  }#2 (dommages Feu)
	/// </summary>
	Effect_DamageFireRemainingMP = 1015,
	/// <summary>
	/// #1{~1~2 Ã  }#2 (dommages Terre)
	/// </summary>
	Effect_DamageEarthRemainingMP = 1016,
	/// <summary>
	/// #1
	/// </summary>
	Effect_CastSpell_1017 = 1017,
	/// <summary>
	/// #1
	/// </summary>
	Effect_CastSpell_1018 = 1018,
	/// <summary>
	/// #1
	/// </summary>
	Effect_CastSpell_1019 = 1019,

	Effect_AddShieldPercentLevel = 1020,

	/// <summary>
	/// Repousse de #1 case(s)
	/// </summary>
	Effect_PushBack_1021 = 1021,
	/// <summary>
	/// Attire de #1 case(s)
	/// </summary>
	Effect_PullForward_1022 = 1022,
	/// <summary>
	/// Ã‰change de positions
	/// </summary>
	Effect_SwitchPosition_1023 = 1023,
	/// <summary>
	/// CrÃ©e des illusions
	/// </summary>
	Effect_CreateIllusions = 1024,
	/// <summary>
	/// DÃ©clenche les piÃ¨ges
	/// </summary>
	Effect_TriggerTraps = 1025,
	/// <summary>
	/// DÃ©clenche les glyphes
	/// </summary>
	Effect_TriggerGlyphs = 1026,
	/// <summary>
	/// #1{~1~2 Ã  }#2% Dommages Combo
	/// </summary>
	Effect_AddComboBonus = 1027,
	/// <summary>
	/// DÃ©clenche les poudres
	/// </summary>
	Effect_1028 = 1028,
	/// <summary>
	/// (not found)
	/// </summary>
	Effect_Vanish = 1029,
	/// <summary>
	/// Pose de la poudre de rang #2
	/// </summary>
	Effect_1030 = 1030,
	/// <summary>
	/// Termine le tour
	/// </summary>
	Effect_SkipTurn_1031 = 1031,
	/// <summary>
	/// (not found)
	/// </summary>
	Effect_1032 = 1032,
	/// <summary>
	/// -#1{~1~2 Ã  -}#2% VitalitÃ©
	/// </summary>
	Effect_SubVitalityPercent = 1033,
	/// <summary>
	/// Invoque le dernier alliÃ© mort avec #1{~1~2 Ã  }#2 % de ses PDV
	/// </summary>
	Effect_ReviveAlly_1034 = 1034,
	/// <summary>
	/// #1 : +#3 tour(s) de relance
	/// </summary>
	Effect_1035 = 1035,
	/// <summary>
	/// #1 : -#3 tour(s) de relance
	/// </summary>
	Effect_ReduceSpellCooldown = 1036,
	/// <summary>
	/// [TEST] PDV rendus : #1{~1~2 Ã  }#2
	/// </summary>
	Effect_1037 = 1037,
	/// <summary>
	/// Aura : #1
	/// </summary>
	Effect_1038 = 1038,
	/// <summary>
	/// #1{~1~2 Ã  }#2% des PV en bouclier
	/// </summary>
	Effect_AddShieldPercent = 1039,
	/// <summary>
	/// #1{~1~2 Ã  }#2 Bouclier
	/// </summary>
	Effect_AddShield = 1040,
	/// <summary>
	/// Recule de #1 case(s)
	/// </summary>
	Effect_Retreat = 1041,
	/// <summary>
	/// Avance de #1 case(s)
	/// </summary>
	Effect_Advance = 1042,
	/// <summary>
	/// Attire jusqu'Ã  la case visÃ©e
	/// </summary>
	Effect_Attract = 1043,
	/// <summary>
	/// ImmunitÃ© : #1
	/// </summary>
	Effect_SpellImmunity = 1044,
	/// <summary>
	/// #1 : #3 tour(s) de relance
	/// </summary>
	Effect_CooldownSet = 1045,
	/// <summary>
	/// #1 PM utilisÃ©s font perdre #2 PV
	/// </summary>
	Effect_1046 = 1046,
	/// <summary>
	/// -#1{~1~2 Ã  }#2 PV
	/// </summary>
	Effect_SubVitality_1047 = 1047,
	/// <summary>
	/// -#1{~1~2 Ã  }#2% PV
	/// </summary>
	Effect_SubVitalityPercent_1048 = 1048,
	/// <summary>
	/// +#1{~1~2 Ã  }#2 niveau
	/// </summary>
	Effect_1049 = 1049,
	/// <summary>
	/// + #1 niveau dans le mÃ©tier #2
	/// </summary>
	Effect_1050 = 1050,
	/// <summary>
	/// (not found)
	/// </summary>
	Effect_1051 = 1051,
	/// <summary>
	/// (not found)
	/// </summary>
	Effect_1052 = 1052,
	/// <summary>
	/// (not found)
	/// </summary>
	Effect_1053 = 1053,
	/// <summary>
	/// #1{~1~2 Ã  }#2 Puissance (sorts)
	/// </summary>
	Effect_IncreaseDamage_1054 = 1054,
	/// <summary>
	/// (not found)
	/// </summary>
	Effect_1055 = 1055,
	/// <summary>
	/// (not found)
	/// </summary>
	Effect_1057 = 1057,
	/// <summary>
	/// (not found)
	/// </summary>
	Effect_1058 = 1058,
	/// <summary>
	/// (not found)
	/// </summary>
	Effect_1059 = 1059,
	/// <summary>
	/// Augmente la taille.
	/// </summary>
	Effect_IncreaseSize = 1060,
	/// <summary>
	/// Partage des dommages
	/// </summary>
	Effect_DamageSharing = 1061,
	/// <summary>
	/// (not found)
	/// </summary>
	Effect_1062 = 1062,
	/// <summary>
	/// #1{~1~2 Ã  }#2 (dommages Terre fixes)
	/// </summary>
	Effect_DamageEarthFix = 1063,
	/// <summary>
	/// #1{~1~2 Ã  }#2 (dommages Air fixes)
	/// </summary>
	Effect_DamageAirFix = 1064,
	/// <summary>
	/// #1{~1~2 Ã  }#2 (dommages Eau fixes)
	/// </summary>
	Effect_DamageWaterFix = 1065,
	/// <summary>
	/// #1{~1~2 Ã  }#2 (dommages Feu fixes)
	/// </summary>
	Effect_DamageFireFix = 1066,
	/// <summary>
	/// #1{~1~2 Ã  }#2% des PV de la cible (dommages Air)
	/// </summary>
	Effect_DamageAirPerHpPercent = 1067,
	/// <summary>
	/// #1{~1~2 Ã  }#2% des PV de la cible (dommages Eau)
	/// </summary>
	Effect_DamageWaterPerHpPercent = 1068,
	/// <summary>
	/// #1{~1~2 Ã  }#2% des PV de la cible (dommages Feu)
	/// </summary>
	Effect_DamageFirePerHpPercent = 1069,
	/// <summary>
	/// #1{~1~2 Ã  }#2% des PV de la cible (dommages Terre)
	/// </summary>
	Effect_DamageEarthPerHpPercent = 1070,
	/// <summary>
	/// #1{~1~2 Ã  }#2% des PV de la cible (dommages Neutre)
	/// </summary>
	Effect_DamageNeutralPerHpPercent = 1071,
	/// <summary>
	/// (not found)
	/// </summary>
	Effect_1072 = 1072,
	/// <summary>
	/// Change l'Ã©lÃ©ment de frappe
	/// </summary>
	Effect_1073 = 1073,
	/// <summary>
	/// (not found)
	/// </summary>
	Effect_1074 = 1074,
	/// <summary>
	/// -#1{~1~2 Ã  }#2 DurÃ©e des effets
	/// </summary>
	Effect_ReduceEffectsDuration = 1075,
	/// <summary>
	/// #1{~1~2 Ã  }#2% RÃ©sistance
	/// </summary>
	Effect_AddResistances = 1076,
	/// <summary>
	/// -#1{~1~2 Ã  -}#2% RÃ©sistance
	/// </summary>
	Effect_SubResistances = 1077,
	/// <summary>
	/// #1{~1~2 Ã  }#2% VitalitÃ©
	/// </summary>
	Effect_AddVitalityPercent = 1078,
	/// <summary>
	/// -#1{~1~2 Ã  -}#2 PA
	/// </summary>
	Effect_SubAP_Roll = 1079,
	/// <summary>
	/// -#1{~1~2 Ã  -}#2 PM
	/// </summary>
	Effect_SubMP_Roll = 1080,
	/// <summary>
	/// (not found)
	/// </summary>
	Effect_1081 = 1081,
	/// <summary>
	/// EmballÃ© par : #4
	/// </summary>
	Effect_1082 = 1082,
	/// <summary>
	/// (not found)
	/// </summary>
	Effect_1083 = 1083,
	/// <summary>
	/// #1
	/// </summary>
	Effect_1084 = 1084,
	/// <summary>
	/// QuantitÃ© : #1
	/// </summary>
	Effect_1085 = 1085,
	/// <summary>
	/// Pour : #4
	/// </summary>
	Effect_1086 = 1086,
	/// <summary>
	/// Ã‰crire un nom
	/// </summary>
	Effect_1087 = 1087,
	/// <summary>
	/// Pose un glyphe-aura de rang #2
	/// </summary>
	Effect_GlyphAura = 1091,
	/// <summary>
	/// #1{~1~2 Ã  }#2% des PV Ã©rodÃ©s de la cible (dommages Neutre)
	/// </summary>
	Effect_DamageNeutralPerHPEroded = 1092,
	/// <summary>
	/// #1{~1~2 Ã  }#2% des PV Ã©rodÃ©s de la cible (dommages Air)
	/// </summary>
	Effect_DamageAirPerHPEroded = 1093,
	/// <summary>
	/// #1{~1~2 Ã  }#2% des PV Ã©rodÃ©s de la cible (dommages Feu)
	/// </summary>
	Effect_DamageFirePerHPEroded = 1094,
	/// <summary>
	/// #1{~1~2 Ã  }#2% des PV Ã©rodÃ©s de la cible (dommages Eau)
	/// </summary>
	Effect_DamageWaterPerHPEroded = 1095,
	/// <summary>
	/// #1{~1~2 Ã  }#2% des PV Ã©rodÃ©s de la cible (dommages Terre)
	/// </summary>
	Effect_DamageEarthPerHPEroded = 1096,
	/// <summary>
	/// CrÃ©e des illusions
	/// </summary>
	Effect_Illusions = 1097,
	/// <summary>
	/// (not found)
	/// </summary>
	Effect_1098 = 1098,
	/// <summary>
	/// TÃ©lÃ©porte Ã  la position de dÃ©but de tour
	/// </summary>
	Effect_Rewind = 1099,
	/// <summary>
	/// TÃ©lÃ©porte Ã  la position prÃ©cÃ©dente
	/// </summary>
	Effect_ReturnToLastPos = 1100,
	/// <summary>
	///
	/// </summary>
	Effect_TeleportToRune = 1101,
	/// <summary>
	///
	/// </summary>
	Effect_1102 = 1102,
	/// <summary>
	/// Pousse de #1 case(s)
	/// </summary>
	Effect_PushBack_1103 = 1103,
	/// <summary>
	/// TÃ©lÃ©portation symÃ©trique par rapport Ã  la cible
	/// </summary>
	Effect_SymetricTargetTeleport = 1104,
	/// <summary>
	/// TÃ©lÃ©portation symÃ©trique par rapport au lanceur
	/// </summary>
	Effect_SymetricCasterTeleport = 1105,
	/// <summary>
	/// TÃ©lÃ©portation symÃ©trique
	/// </summary>
	Effect_SymetricPointTeleport = 1106,
	/// <summary>
	/// Renommer la guilde
	/// </summary>
	Effect_ChangeGuildName = 1107,
	/// <summary>
	/// Changer le blason de la guilde
	/// </summary>
	Effect_ChangeGuildBlazon = 1108,
	/// <summary>
	/// #1{~1~2 Ã  }#2% (PV rendus)
	/// </summary>
	Effect_RestoreHPPercent = 1109,
	/// <summary>
	/// #3 butins
	/// </summary>
	Effect_1111 = 1111,
	/// <summary>
	/// #1{~1~2 Ã  }#2% des PV Ã©rodÃ©s du lanceur (dommages Neutre)
	/// </summary>
	Effect_DamageNeutralPerCasterHPEroded = 1118,
	/// <summary>
	/// #1{~1~2 Ã  }#2% des PV Ã©rodÃ©s du lanceur (dommages Air)
	/// </summary>
	Effect_DamageAirPerCasterHPEroded = 1119,
	/// <summary>
	/// #1{~1~2 Ã  }#2% des PV Ã©rodÃ©s du lanceur (dommages Feu)
	/// </summary>
	Effect_DamageFirePerCasterHPEroded = 1120,
	/// <summary>
	/// #1{~1~2 Ã  }#2% des PV Ã©rodÃ©s du lanceur (dommages Eau)
	/// </summary>
	Effect_DamageWaterPerCasterHPEroded = 1121,
	/// <summary>
	/// #1{~1~2 Ã  }#2% des PV Ã©rodÃ©s du lanceur (dommages Terre)
	/// </summary>
	Effect_DamageEarthPerCasterHPEroded = 1122,
	/// <summary>
	/// RÃ©partit #1{~1~2 Ã  }#2% des dommages subis.
	/// </summary>
	Effect_DispatchDamages = 1123,
	/// <summary>
	///
	/// </summary>
	Effect_Unknown_1124 = 1124,
	/// <summary>
	///
	/// </summary>
	Effect_Unknown1125 = 1125,
	/// <summary>
	///
	/// </summary>
	Effect_Unknown_1126 = 1126,
	/// <summary>
	///
	/// </summary>
	Effect_Unknown_1127 = 1127,
	/// <summary>
	///
	/// </summary>
	Effect_Unknown_1128 = 1128,
	/// <summary>
	/// Envoyer vers Krosmaster
	/// </summary>
	Effect_1129 = 1129,
	/// <summary>
	/// #1 PA utilisÃ©s font perdre #2 PV (Air)
	/// </summary>
	Effect_DamageAirPerAP = 1131,
	/// <summary>
	/// #1 PA utilisÃ©s font perdre #2 PV (Eau)
	/// </summary>
	Effect_DamageWaterPerAP = 1132,
	/// <summary>
	/// #1 PA utilisÃ© fait perdre #2 PV (Feu)
	/// </summary>
	Effect_DamageFirePerAP = 1133,
	/// <summary>
	/// #1 PA utilisÃ©s font perdre #2 PV (Neutre)
	/// </summary>
	Effect_DamageNeutralPerAP = 1134,
	/// <summary>
	/// #1 PA utilisÃ©s font perdre #2 PV (Terre)
	/// </summary>
	Effect_DamageEarthPerAP = 1135,
	/// <summary>
	/// #1 PM utilisÃ©s font perdre #2 PV (Air)
	/// </summary>
	Effect_DamageAirPerMP = 1136,
	/// <summary>
	/// #1 PM utilisÃ©s font perdre #2 PV (Eau)
	/// </summary>
	Effect_DamageWaterPerMP = 1137,
	/// <summary>
	/// #1 PM utilisÃ©s font perdre #2 PV (Feu)
	/// </summary>
	Effect_DamageFirePerMP = 1138,
	/// <summary>
	/// #1 PM utilisÃ©s font perdre #2 PV (Neutre)
	/// </summary>
	Effect_DamageNeutralPerMP = 1139,
	/// <summary>
	/// #1 PM utilisÃ©s font perdre #2 PV (Terre)
	/// </summary>
	Effect_DamageEarthPerMP = 1140,
	/// <summary>
	///
	/// </summary>
	Effect_1141 = 1141,
	/// <summary>
	///
	/// </summary>
	Effect_1142 = 1142,
	/// <summary>
	/// #1{~1~2 Ã  }#2 Puissance (armes)
	/// </summary>
	Effect_AddWeaponDamageBonus = 1144,
	/// <summary>
	/// Changer le blason de l'alliance
	/// </summary>
	Effect_1145 = 1145,
	/// <summary>
	/// Renommer l'alliance
	/// </summary>
	Effect_1146 = 1146,
	/// <summary>
	///
	/// </summary>
	Effect_1149 = 1149,
	/// <summary>
	///
	/// </summary>
	Effect_1150 = 1150,
	/// <summary>
	/// Apparence : #1
	/// </summary>
	Effect_Appearance = 1151,
	/// <summary>
	///
	/// </summary>
	Effect_1152 = 1152,
	/// <summary>
	/// Invoque un percepteur
	/// </summary>
	Effect_SummonTaxcollector = 1153,
	/// <summary>
	///
	/// </summary>
	Effect_1154 = 1154,
	/// <summary>
	/// TÃ©lÃ©porte
	/// </summary>
	Effect_1155 = 1155,
	/// <summary>
	/// Soins reÃ§us x#1%
	/// </summary>
	Effect_HealBuff = 1159,
	/// <summary>
	/// #1
	/// </summary>
	Effect_CastSpell_1160 = 1160,
	/// <summary>
	/// #1
	/// </summary>
	Effect_1161 = 1161,
	/// <summary>
	/// Positionne la boussole
	/// </summary>
	Effect_1162 = 1162,
	/// <summary>
	/// Dommages subis x#1%
	/// </summary>
	Effect_DamageMultiplier = 1163,
	/// <summary>
	/// Les dommages reÃ§us soignent.
	/// </summary>
	Effect_HealWhenAttack = 1164,
	/// <summary>
	/// Pose un glyphe de rang #2
	/// </summary>
	Effect_Glyph_1165 = 1165,
	/// <summary>
	/// #1{~1~2 Ã  }#2 Puissance (glyphes)
	/// </summary>
	Effect_IncreaseGlyphDamages = 1166,
	/// <summary>
	/// #1{~1~2 Ã  }#2 Puissance (runes)
	/// </summary>
	Effect_1167 = 1167,
	/// <summary>
	///
	/// </summary>
	Effect_1168 = 1168,
	/// <summary>
	///
	/// </summary>
	Effect_1169 = 1169,
	/// <summary>
	///
	/// </summary>
	Effect_1170 = 1170,
	/// <summary>
	/// Augmente les dommages finaux occasionnÃ©s de #1%
	/// </summary>
	Effect_IncreaseFinalDamages = 1171,
	/// <summary>
	/// RÃ©duit les dommages finaux occasionnÃ©s de #1%
	/// </summary>
	Effect_ReduceFinalDamages = 1172,
	/// <summary>
	///
	/// </summary>
	Effect_1173 = 1173,
	/// <summary>
	/// Supprime les gains d'expÃ©rience
	/// </summary>
	Effect_1174 = 1174,
	/// <summary>
	/// #1
	/// </summary>
	Effect_CastSpell_1175 = 1175,
	/// <summary>
	/// Apparence : #1
	/// </summary>
	Effect_Apparence_Wrapper = 1176,
	/// <summary>
	///
	/// </summary>
	Effect_1177 = 1177,
	/// <summary>
	///
	/// </summary>
	Effect_1178 = 1178,
	/// <summary>
	/// Compatible avec : #1
	/// </summary>
	Effect_Compatible = 1179,
	/// <summary>
	/// Lire #3
	/// </summary>
	Effect_1180 = 1180,
	/// <summary>
	/// Pose un portail (+#3% dommages)
	/// </summary>
	Effect_SpawnPortal = 1181,
	/// <summary>
	/// TÃ©lÃ©portation portail
	/// </summary>
	Effect_TeleportPortal = 1182,
	/// <summary>
	/// DÃ©sactiver un portail
	/// </summary>
	Effect_DisablePortal = 1183,
	/// <summary>
	/// ExpÃ©rience du niveau : #3
	/// </summary>
	Effect_1184 = 1184,
	/// <summary>
	/// RÃ©initialise les effets d'un objet de niveau infÃ©rieur ou Ã©gal Ã  #1{~1~2 Ã  }#2
	/// </summary>
	Effect_1185 = 1185,
	/// <summary>
	/// Niveau : #1
	/// </summary>
	Effect_1186 = 1186,
	/// <summary>
	/// #1
	/// </summary>
	Effect_HarnessGID = 1187,
	/// <summary>
	/// CrÃ©e un double du lanceur de sort
	/// </summary>
	Effect_Double_1189 = 1189,
	/// <summary>
	/// RÃ©partit #1{~1~2 Ã  }#2% des dommages subis.
	/// </summary>
	Effect_DispatchDamage_1223 = 1223,
	/// <summary>
	/// RÃ©partit #1{~1~2 Ã  }#2% des dommages subis.
	/// </summary>
	Effect_Unknown_1225 = 1225,
	/// <summary>
	/// #1
	/// </summary>
	///
	Effect_CastSpell2017 = 2017,
	/// <summary>
	/// Something related to spells ?
	/// </summary>
	Effect_Unknown_2018 = 2018,
	/// <summary>
	///
	/// </summary>
	Effect_Unknown_2019 = 2019,
	/// <summary>
	/// Soigne #1{~1~2 Ã  }#2% des dommages subis.
	/// </summary>
	Effect_HealReceivedDamages = 2020,
	/// <summary>
	///
	/// </summary>
	Effect_2021 = 2021,
	/// <summary>
	/// Pose une rune de rang #2
	/// </summary>
	Effect_Rune = 2022,
	/// <summary>
	/// DÃ©clenche les runes
	/// </summary>
	Effect_TriggerRune = 2023,
	/// <summary>
	///
	/// </summary>
	Effect_Unknown_2024 = 2024,
	/// <summary>
	///
	/// </summary>
	Effect_2025 = 2025,
	/// <summary>
	///
	/// </summary>
	Effect_2026 = 2026,
	/// <summary>
	/// Prend le contrÃ´le de l'entitÃ© ciblÃ©e
	/// </summary>
	Effect_TakeControl = 2027,
	/// <summary>
	/// Transmet une partie de ses caractÃ©ristiques
	/// </summary>
	Effect_TransmitCharacteristic = 2028,
	/// <summary>
	/// Lance un coup fatal
	/// </summary>
	Effect_2029 = 2029,
	/// <summary>
	///
	/// </summary>
	Effect_LearnFinishMove = 2030,
	/// <summary>
	/// #1
	/// </summary>
	Effect_CastSpell_2160 = 2160,
	/// <summary>
	/// #1
	/// </summary>
	Effect_CastSpell_2792 = 2792,
	/// <summary>
	/// #1
	/// </summary>
	Effect_CastSpell_2793 = 2793,
	/// <summary>
	/// #1
	/// </summary>
	Effect_CastSpell_2794 = 2794,
	/// <summary>
	/// #1 (Couronnes d'Ã©pines)
	/// </summary>
	Effect_CastSpell_2795 = 2795,
	/// <summary>
	/// Tue la cible pour la remplacer par l'invocation : #1
	/// </summary>
	Effect_KillAndSummonSlave = 2796,
	/// <summary>
	///
	/// </summary>
	Effect_LearnSmileyPack = 2797,
	/// <summary>
	///
	/// </summary>
	Effect_2798 = 2798,

	/// <summary>
	/// Aumenta o dano corpo a corpo : #1{~1~2 a }#2% de danos no corpo a corpo
	/// </summary>
	Effect_MeleeDamageDonePercent = 2800,

	/// <summary>
	/// Diminui o dano corpo a corpo : #1{~1~2 a -}#2% de danos no corpo a corpo
	/// </summary>
	Effect_SubMeleeDamageDonePercent = 2801,

	/// <summary>
	/// Diminui a resistÃªncia corpo a corpo : -#1{~1~2 a -}#2% de resistÃªncia ao corpo a corpo
	/// </summary>
	Effect_SubMeleeResistance = 2802,

	/// <summary>
	/// Aumenta a resistÃªncia corpo a corpo : #1{~1~2 a }#2% de resistÃªncia ao corpo a corpo
	/// </summary>
	Effect_AddMeleeResistance = 2803,

	/// <summary>
	/// Aumenta os dano danos Ã  distÃ¢ncia : #1{~1~2 a }#2% de danos Ã  distÃ¢ncia
	/// </summary>
	Effect_RangedDamageDonePercent = 2804,

	/// <summary>
	/// Dimiui os dano danos Ã  distÃ¢ncia : -#1{~1~2 a -}#2% de danos Ã  distÃ¢ncia
	/// </summary>
	Effect_SubRangedDamageDonePercent = 2805,

	/// <summary>
	/// Dimiui a resistÃªncia Ã  distÃ¢ncia : -#1{~1~2 a -}#2% de resistÃªncia Ã  distÃ¢ncia
	/// </summary>
	Effect_SubRangedResistance = 2806,

	/// <summary>
	/// Aumenta a resistÃªncia Ã  distÃ¢ncia : #1{~1~2 a }#2% de resistÃªncia Ã  distÃ¢ncia
	/// </summary>
	Effect_AddRangedResistance = 2807,

	/// <summary>
	/// Aumenta os danos de armas : #1{~1~2 a }#2% de danos de armas
	/// </summary>
	Effect_WeaponDamageDonePercent = 2808,

	/// <summary>
	/// Diminui os danos de armas : -#1{~1~2 a -}#2% de danos de armas
	/// </summary>
	Effect_SubWeaponDamageDonePercent = 2809,

	/// <summary>
	/// Diminui a resistÃªncia Ã s armas : -#1{~1~2 a -}#2% de resistÃªncia Ã s armas
	/// </summary>
	Effect_SubWeaponResistance = 2810,

	/// <summary>
	/// Aumenta a resistÃªncia Ã s armas : #1{~1~2 a }#2% de resistÃªncia Ã s armas
	/// </summary>
	Effect_WeaponResistance = 2811,

	/// <summary>
	/// Aumenta o dano de spells : #1{~1~2 a }#2% de danos de feitiÃ§os
	/// </summary>
	Effect_SpellDamageDonePercent = 2812,

	/// <summary>
	/// Diminui o dano de spells : -#1{~1~2 a -}#2% de danos de feitiÃ§os
	/// </summary>
	Effect_SubSpellDamageDonePercent = 2813,

	/// <summary>
	/// Diminui a resistÃªncia aos feitiÃ§os : -#1{~1~2 a -}#2% de resistÃªncia aos feitiÃ§os
	/// </summary>
	Effect_SubSpellResistance = 2814,

	/// <summary>
	/// Aumenta a resistÃªncia aos feitiÃ§os : #1{~1~2 a }#2% de resistÃªncia aos feitiÃ§os
	/// </summary>
	Effect_AddSpellResistance = 2815,
	/// <summary>
	/// [UNKNOWN_TEXT_ID_735940]
	/// </summary>
	Effect_Unknown_2816 = 2816,
	/// <summary>
	///
	/// </summary>
	Effect_Unknown_2817 = 2817,
	/// <summary>
	/// Craft coopÃ©ratif impossible.
	/// </summary>
	Effect_CraftError = 2818,
	/// <summary>
	/// #1{~1~2 Ã  }#2 (dommages)
	/// </summary>
	Effect_DamageBestElement = 2822,
	/// <summary>
	/// #1{~1~2 Ã  }#2 (dommages)
	/// </summary>
	Effect_DamageBestElement_2828 = 2828,
	/// <summary>
	/// #1{~1~2 Ã  }#2 (dommages)
	/// </summary>
	Effect_DamageBestElement_2829 = 2829,
	/// <summary>
	/// #1{~1~2 Ã  }#2% Force
	/// </summary>
	Effect_AddStrengthPercent = 2834,
	/// <summary>
	/// -#1{~1~2 Ã  -}#2% Force
	/// </summary>
	Effect_SubStrengthPercent = 2835,
	/// <summary>
	/// #1{~1~2 Ã  }#2% AgilitÃ©
	/// </summary>
	Effect_AddAgilityPercent = 2836,
	/// <summary>
	/// -#1{~1~2 Ã  -}#2% AgilitÃ©
	/// </summary>
	Effect_SubAgilityPercent = 2837,
	/// <summary>
	/// #1{~1~2 Ã  }#2% Intelligence
	/// </summary>
	Effect_AddIntelligencePercent = 2838,
	/// <summary>
	/// -#1{~1~2 Ã  -}#2% Intelligence
	/// </summary>
	Effect_SubIntelligencePercent = 2839,
	/// <summary>
	/// #1{~1~2 Ã  }#2% Chance
	/// </summary>
	Effect_AddChancePercent = 2840,
	/// <summary>
	/// -#1{~1~2 Ã  -}#2% Chance
	/// </summary>
	Effect_SubChancePercent = 2841,
	/// <summary>
	/// #1{~1~2 Ã  }#2% Sagesse
	/// </summary>
	Effect_AddWisdomPercent = 2842,
	/// <summary>
	/// -#1{~1~2 Ã  -}#2% Sagesse
	/// </summary>
	Effect_SubWisdomPercent = 2843,
	/// <summary>
	/// #1{~1~2 Ã  }#2% VitalitÃ©
	/// </summary>
	Effect_AddVitalityPercent_2844 = 2844,
	/// <summary>
	/// -#1{~1~2 Ã  -}#2% VitalitÃ©
	/// </summary>
	Effect_SubVitalityPercent_2845 = 2845,
	/// <summary>
	/// #1{~1~2 Ã  }#2% PA
	/// </summary>
	Effect_AddAPPercent = 2846,
	/// <summary>
	/// -#1{~1~2 Ã  -}#2% PA
	/// </summary>
	Effect_SubAPPercent = 2847,
	/// <summary>
	/// #1{~1~2 Ã  }#2% PM
	/// </summary>
	Effect_AddMPPercent = 2848,
	/// <summary>
	/// -#1{~1~2 Ã  -}#2% PM
	/// </summary>
	Effect_SubMPPercent = 2849,
	/// <summary>
	/// #1{~1~2 Ã  }#2% Tacle
	/// </summary>
	Effect_AddTacklePercent = 2850,
	/// <summary>
	/// #1{~1~2 Ã  }#2% Fuite
	/// </summary>
	Effect_AddEvadePercent = 2852,
	/// <summary>
	/// #1{~1~2 Ã  }#2% Esquive PA
	/// </summary>
	Effect_AddDodgeAPPercent = 2854,
	/// <summary>
	/// #1{~1~2 Ã  }#2% Esquive PM
	/// </summary>
	Effect_AddDodgeMPPercent = 2856,
	/// <summary>
	/// -#1{~1~2 Ã  -}#2% Esquive PM
	/// </summary>
	Effect_SubDodgeMPPercent = 2857,
	/// <summary>
	/// #1{~1~2 Ã  }#2% Retrait PA
	/// </summary>
	Effect_AddAPAttackPercent = 2858,
	/// <summary>
	/// #1{~1~2 Ã  }#2% Retrait PM
	/// </summary>
	Effect_AddMPAttackPercent = 2860,
	/// <summary>
	/// Augmente la taille de #1{~1~2 Ã  }#2%
	/// </summary>
	Effect_IncreaseSize_2868 = 2868,
	/// <summary>
	/// Diminue la taille de #1{~1~2 Ã  }#2%
	/// </summary>
	Effect_ReduceSize = 2871,
	/// <summary>
	/// Seuil : #1 PV
	/// </summary>
	Effect_HealthThreshold = 2872,
	/// <summary>
	/// Apprend le sort #3
	/// </summary>
	Effect_LearnSpell_2875 = 2875,
	/// <summary>
	///
	/// </summary>
	Effect_Unknown_2876 = 2876,
	/// <summary>
	///
	/// </summary>
	Effect_Unknown_2877 = 2877,

	End = 2878,
}

export enum FighterRefusedReasonEnum {
	FIGHTER_REFUSED = -1,
	FIGHTER_ACCEPTED = 0,
	CHALLENGE_FULL = 1,
	TEAM_FULL = 2,
	WRONG_ALIGNMENT = 3,
	WRONG_GUILD = 4,
	TOO_LATE = 5,
	MUTANT_REFUSED = 6,
	WRONG_MAP = 7,
	JUST_RESPAWNED = 8,
	IM_OCCUPIED = 9,
	OPPONENT_OCCUPIED = 10,
	FIGHT_MYSELF = 11,
	INSUFFICIENT_RIGHTS = 12,
	MEMBER_ACCOUNT_NEEDED = 13,
	OPPONENT_NOT_MEMBER = 14,
	TEAM_LIMITED_BY_MAINCHARACTER = 15,
	MULTIACCOUNT_NOT_ALLOWED = 16,
	GHOST_REFUSED = 17,
	RESTRICTED_ACCOUNT = 19,
	WRONG_ALLIANCE = 20,
	AVA_ZONE = 21,
	ENTITY_REFUSED = 22,
	NOT_ENOUGH_ROOM = 23,
	GUEST_ACCOUNT = 24,
}

export enum CraftResultEnum {
	CRAFT_IMPOSSIBLE = 0,
	CRAFT_FAILED = 1,
	CRAFT_SUCCESS = 2,
	CRAFT_NEUTRAL = 3,
	CRAFT_FORBIDDEN = 4,
}

export enum JobTypeEnum {
	LUMBERJACK = 2,
	SMITH = 11,
	CARVER = 13,
	SHOEMAKER = 15,
	JEWELLER = 16,
	MINER = 24,
	ALCHEMIST = 26,
	TAILOR = 27,
	FARMER = 28,
	FISHERMAN = 36,
	HUNTER = 41,
	SMITHMAGUS = 44,
	CARVMAGUS = 48,
	ARTIFICER = 60,
	SHOEMAGUS = 62,
	JEWELMAGUS = 63,
	COSTUMAGUS = 64,
	HANDYMAN = 65,
	CRAFTMAGUS = 74,
	SCROLLMAGE = 75,
}

export enum DelayedActionTypeEnum {
	DELAYED_ACTION_DISCONNECT = 0,
	DELAYED_ACTION_OBJECT_USE = 1,
	DELAYED_ACTION_JOIN_CHARACTER = 2,
	DELAYED_ACTION_AGGRESSION_IMMUNE = 3,
}

export enum LockableResultEnum {
	LOCKABLE_UNLOCKED = 0,
	LOCKABLE_CODE_ERROR = 1,
	LOCKABLE_UNLOCK_FORBIDDEN = 2,
}

export enum ClientUITypeEnum {
	CLIENT_UI_UNDEFINED = 0,
	CLIENT_UI_TELEPORT_GUILD_HOUSE = 1,
	CLIENT_UI_TELEPORT_GUILD_PADDOCK = 2,
	CLIENT_UI_OBJECT_MIMICRY = 3,
	CLIENT_UI_LEGENDARY_TREASURE_QUEST = 4,
	CLIENT_UI_TELEPORT_HOUSE = 5,
}

export enum TeleporterTypeEnum {
	TELEPORTER_ZAAP = 0,
	TELEPORTER_SUBWAY = 1,
	TELEPORTER_PRISM = 2,
	TELEPORTER_HAVENBAG = 3,
	TELEPORTER_ANOMALY = 4,
}

export enum SocialNoticeErrorEnum {
	SOCIAL_NOTICE_UNKNOWN_ERROR = 0,
	SOCIAL_NOTICE_INVALID_RIGHTS = 1,
	SOCIAL_NOTICE_COOLDOWN = 2,
}

export enum TaxCollectorErrorReasonEnum {
	TAX_COLLECTOR_ERROR_UNKNOWN = 0,
	TAX_COLLECTOR_NOT_FOUND = 1,
	TAX_COLLECTOR_NOT_OWNED = 2,
	TAX_COLLECTOR_NO_RIGHTS = 3,
	TAX_COLLECTOR_MAX_REACHED = 4,
	TAX_COLLECTOR_ALREADY_ONE = 5,
	TAX_COLLECTOR_CANT_HIRE_YET = 6,
	TAX_COLLECTOR_CANT_HIRE_HERE = 7,
	TAX_COLLECTOR_NOT_ENOUGH_KAMAS = 8,
}

export enum GuildInformationsTypeEnum {
	INFO_GENERAL = 1,
	INFO_MEMBERS = 2,
	INFO_BOOSTS = 3,
	INFO_PADDOCKS = 4,
	INFO_HOUSES = 5,
	INFO_TAX_COLLECTOR_GUILD_ONLY = 6,
	INFO_TAX_COLLECTOR_ALLIANCE = 7,
	INFO_TAX_COLLECTOR_LEAVE = 8,
}

export enum SocialGroupInvitationStateEnum {
	SOCIAL_GROUP_INVITATION_FAILED = 0,
	SOCIAL_GROUP_INVITATION_SENT = 1,
	SOCIAL_GROUP_INVITATION_CANCELED = 2,
	SOCIAL_GROUP_INVITATION_OK = 3,
}

export enum ListAddFailureEnum {
	LIST_ADD_FAILURE_UNKNOWN = 0,
	LIST_ADD_FAILURE_OVER_QUOTA = 1,
	LIST_ADD_FAILURE_NOT_FOUND = 2,
	LIST_ADD_FAILURE_EGOCENTRIC = 3,
	LIST_ADD_FAILURE_IS_DOUBLE = 4,
	LIST_ADD_FAILURE_IS_CONFLICTING_DOUBLE = 5,
}

export enum TaxCollectorMovementTypeEnum {
	TAX_COLLECTOR_UNKNOWN_ACTION = 0,
	TAX_COLLECTOR_HIRED = 1,
	TAX_COLLECTOR_HARVESTED = 2,
	TAX_COLLECTOR_DEFEATED = 3,
	TAX_COLLECTOR_DESTROYED = 4,
}

export enum TaxCollectorStateEnum {
	STATE_COLLECTING = 0,
	STATE_WAITING_FOR_HELP = 1,
	STATE_FIGHTING = 2,
}

export enum SocialGroupCreationResultEnum {
	SOCIAL_GROUP_CREATE_OK = 1,
	SOCIAL_GROUP_CREATE_ERROR_NAME_INVALID = 2,
	SOCIAL_GROUP_CREATE_ERROR_ALREADY_IN_GROUP = 3,
	SOCIAL_GROUP_CREATE_ERROR_NAME_ALREADY_EXISTS = 4,
	SOCIAL_GROUP_CREATE_ERROR_EMBLEM_ALREADY_EXISTS = 5,
	SOCIAL_GROUP_CREATE_ERROR_LEAVE = 6,
	SOCIAL_GROUP_CREATE_ERROR_CANCEL = 7,
	SOCIAL_GROUP_CREATE_ERROR_REQUIREMENT_UNMET = 8,
	SOCIAL_GROUP_CREATE_ERROR_EMBLEM_INVALID = 9,
	SOCIAL_GROUP_CREATE_ERROR_TAG_INVALID = 10,
	SOCIAL_GROUP_CREATE_ERROR_TAG_ALREADY_EXISTS = 11,
	SOCIAL_GROUP_CREATE_ERROR_NEEDS_SUBGROUP = 12,
	SOCIAL_GROUP_CREATE_ERROR_UNKNOWN = 99,
}

export enum PlayerStateEnum {
	NOT_CONNECTED = 0,
	GAME_TYPE_ROLEPLAY = 1,
	GAME_TYPE_FIGHT = 2,
	UNKNOWN_STATE = 99,
}

export enum ObjectErrorEnum {
	INVENTORY_FULL = 1,
	CANNOT_EQUIP_TWICE = 2,
	NOT_TRADABLE = 3,
	CANNOT_DROP = 4,
	CANNOT_DROP_NO_PLACE = 5,
	CANNOT_DESTROY = 6,
	LEVEL_TOO_LOW = 7,
	LIVING_OBJECT_REFUSED_FOOD = 8,
	CANNOT_UNEQUIP = 9,
	CANNOT_EQUIP_HERE = 10,
	CRITERIONS = 11,
	SYMBIOTIC_OBJECT_ERROR = 12,
	EVOLUTIVE_OBJECT_REFUSED_FOOD = 13,
}

export enum GameHierarchyEnum {
	UNAVAILABLE = -1,
	PLAYER = 0,
	MODERATOR = 10,
	GAMEMASTER_PADAWAN = 20,
	GAMEMASTER = 30,
	ADMIN = 40,
	UNKNOWN_SPECIAL_USER = 50,
}

export enum TextInformationTypeEnum {
	TEXT_INFORMATION_MESSAGE = 0,
	TEXT_INFORMATION_ERROR = 1,
	TEXT_INFORMATION_PVP = 2,
	TEXT_INFORMATION_FIGHT_LOG = 3,
	TEXT_INFORMATION_POPUP = 4,
	TEXT_LIVING_OBJECT = 5,
	TEXT_ENTITY_TALK = 6,
	TEXT_INFORMATION_FIGHT = 7,
}

export enum ChatChannelsMultiEnum {
	CHANNEL_GLOBAL = 0,
	CHANNEL_TEAM = 1,
	CHANNEL_GUILD = 2,
	CHANNEL_ALLIANCE = 3,
	CHANNEL_PARTY = 4,
	CHANNEL_SALES = 5,
	CHANNEL_SEEK = 6,
	CHANNEL_NOOB = 7,
	CHANNEL_ADMIN = 8,
	CHANNEL_ADS = 12,
	CHANNEL_ARENA = 13,
	CHANNEL_COMMUNITY = 14,
}

export enum ChatErrorEnum {
	CHAT_ERROR_UNKNOWN = 0,
	CHAT_ERROR_RECEIVER_NOT_FOUND = 1,
	CHAT_ERROR_INTERIOR_MONOLOGUE = 2,
	CHAT_ERROR_NO_GUILD = 3,
	CHAT_ERROR_NO_PARTY = 4,
	CHAT_ERROR_ALLIANCE = 5,
	CHAT_ERROR_INVALID_MAP = 6,
	CHAT_ERROR_NO_PARTY_ARENA = 7,
	CHAT_ERROR_NO_TEAM = 8,
	CHAT_ERROR_MALFORMED_CONTENT = 9,
	CHAT_ERROR_NO_CHANNEL_COMMUNITY = 10,
}

export enum PartyJoinErrorEnum {
	PARTY_JOIN_ERROR_UNKNOWN = 0,
	PARTY_JOIN_ERROR_PLAYER_NOT_FOUND = 1,
	PARTY_JOIN_ERROR_PARTY_NOT_FOUND = 2,
	PARTY_JOIN_ERROR_PARTY_FULL = 3,
	PARTY_JOIN_ERROR_PLAYER_BUSY = 4,
	PARTY_JOIN_ERROR_PLAYER_ALREADY_INVITED = 6,
	PARTY_JOIN_ERROR_PLAYER_TOO_SOLLICITED = 7,
	PARTY_JOIN_ERROR_PLAYER_LOYAL = 8,
	PARTY_JOIN_ERROR_UNMODIFIABLE = 9,
	PARTY_JOIN_ERROR_UNMET_CRITERION = 10,
	PARTY_JOIN_ERROR_NOT_ENOUGH_ROOM = 11,
	PARTY_JOIN_ERROR_COMPOSITION_CHANGED = 12,
	PARTY_JOIN_ERROR_PLAYER_IN_TUTORIAL = 13,
}

export enum PartyTypeEnum {
	PARTY_TYPE_UNDEFINED = 0,
	PARTY_TYPE_CLASSICAL = 1,
	PARTY_TYPE_DUNGEON = 2,
	PARTY_TYPE_ARENA = 3,
}

export enum PvpArenaTypeEnum {
	ARENA_TYPE_1VS1 = 1,
	ARENA_TYPE_3VS3_SOLO = 2,
	ARENA_TYPE_3VS3_TEAM = 3,
}

export enum PvpArenaStepEnum {
	ARENA_STEP_REGISTRED = 0,
	ARENA_STEP_WAITING_FIGHT = 1,
	ARENA_STEP_STARTING_FIGHT = 2,
	ARENA_STEP_UNREGISTER = 3,
}

export enum PartyNameErrorEnum {
	PARTY_NAME_UNDEFINED_ERROR = 0,
	PARTY_NAME_INVALID = 1,
	PARTY_NAME_ALREADY_USED = 2,
	PARTY_NAME_UNALLOWED_RIGHTS = 3,
	PARTY_NAME_UNALLOWED_NOW = 4,
}

export enum PrismSetSabotagedRefusedReasonEnum {
	SABOTAGE_REFUSED = -1,
	SABOTAGE_INSUFFICIENT_RIGHTS = 0,
	SABOTAGE_MEMBER_ACCOUNT_NEEDED = 1,
	SABOTAGE_RESTRICTED_ACCOUNT = 2,
	SABOTAGE_WRONG_ALLIANCE = 3,
	SABOTAGE_NO_PRISM = 4,
	SABOTAGE_WRONG_STATE = 5,
}

export enum PrismListenEnum {
	PRISM_LISTEN_NONE = 0,
	PRISM_LISTEN_MINE = 1,
	PRISM_LISTEN_ALL = 2,
}

export enum FightDispellableEnum {
	DISPELLABLE = 1,
	DISPELLABLE_BY_DEATH = 2,
	DISPELLABLE_BY_STRONG_DISPEL = 3,
	REALLY_NOT_DISPELLABLE = 4,
}

export enum GameActionMarkCellsTypeEnum {
	CELLS_CIRCLE = 0,
	CELLS_CROSS = 1,
	CELLS_SQUARE = 2,
}

export enum TeamTypeEnum {
	TEAM_TYPE_PLAYER = 0,
	TEAM_TYPE_MONSTER = 1,
	TEAM_TYPE_MUTANT = 2,
	TEAM_TYPE_TAXCOLLECTOR = 3,
	TEAM_TYPE_BAD_PLAYER = 4,
	TEAM_TYPE_PRISM = 5,
}

export enum BreachRoomUnlockEnum {
	BREACH_UNLOCK_SUCCESS = 0,
	BREACH_UNLOCK_FAIL_NOT_ENOUGH_BUDGET = 1,
}

export enum HavenBagDailyLoteryErrorEnum {
	HAVENBAG_DAILY_LOTERY_OK = 0,
	HAVENBAG_DAILY_LOTERY_ALREADYUSED = 1,
	HAVENBAG_DAILY_LOTERY_ERROR = 2,
}

export enum FightOptionsEnum {
	FIGHT_OPTION_SET_SECRET = 0,
	FIGHT_OPTION_SET_TO_PARTY_ONLY = 1,
	FIGHT_OPTION_SET_CLOSED = 2,
	FIGHT_OPTION_ASK_FOR_HELP = 3,
}

export enum TreasureHuntFlagRequestEnum {
	TREASURE_HUNT_FLAG_ERROR_UNDEFINED = 0,
	TREASURE_HUNT_FLAG_OK = 1,
	TREASURE_HUNT_FLAG_WRONG = 2,
	TREASURE_HUNT_FLAG_TOO_MANY = 3,
	TREASURE_HUNT_FLAG_ERROR_IMPOSSIBLE = 4,
	TREASURE_HUNT_FLAG_WRONG_INDEX = 5,
	TREASURE_HUNT_FLAG_SAME_MAP = 6,
}

export enum TreasureHuntDigRequestEnum {
	TREASURE_HUNT_DIG_ERROR_UNDEFINED = 0,
	TREASURE_HUNT_DIG_NEW_HINT = 1,
	TREASURE_HUNT_DIG_FINISHED = 2,
	TREASURE_HUNT_DIG_WRONG = 3,
	TREASURE_HUNT_DIG_LOST = 4,
	TREASURE_HUNT_DIG_ERROR_IMPOSSIBLE = 5,
	TREASURE_HUNT_DIG_WRONG_AND_YOU_KNOW_IT = 6,
}

export enum TreasureHuntFlagStateEnum {
	TREASURE_HUNT_FLAG_STATE_UNKNOWN = 0,
	TREASURE_HUNT_FLAG_STATE_OK = 1,
	TREASURE_HUNT_FLAG_STATE_WRONG = 2,
}

export enum TreasureHuntRequestEnum {
	TREASURE_HUNT_ERROR_UNDEFINED = 0,
	TREASURE_HUNT_OK = 1,
	TREASURE_HUNT_ERROR_NO_QUEST_FOUND = 2,
	TREASURE_HUNT_ERROR_ALREADY_HAVE_QUEST = 3,
	TREASURE_HUNT_ERROR_NOT_AVAILABLE = 4,
	TREASURE_HUNT_ERROR_DAILY_LIMIT_EXCEEDED = 5,
}

export enum TreasureHuntTypeEnum {
	TREASURE_HUNT_CLASSIC = 0,
	TREASURE_HUNT_PORTAL = 1,
	TREASURE_HUNT_LEGENDARY = 2,
}

export enum CharacterDeletionErrorEnum {
	DEL_ERR_NO_REASON = 1,
	DEL_ERR_TOO_MANY_CHAR_DELETION = 2,
	DEL_ERR_BAD_SECRET_ANSWER = 3,
	DEL_ERR_RESTRICED_ZONE = 4,
}

export enum CharacterRemodelingEnum {
	CHARACTER_REMODELING_NOT_APPLICABLE = 0,
	CHARACTER_REMODELING_NAME = 1,
	CHARACTER_REMODELING_COLORS = 2,
	CHARACTER_REMODELING_COSMETIC = 4,
	CHARACTER_REMODELING_BREED = 8,
	CHARACTER_REMODELING_GENDER = 16,
	CHARACTER_OPT_REMODELING_NAME = 32,
	CHARACTER_OPT_REMODELING_ALL = 64,
}

export enum ServerConnectionErrorEnum {
	SERVER_CONNECTION_ERROR_DUE_TO_STATUS = 0,
	SERVER_CONNECTION_ERROR_NO_REASON = 1,
	SERVER_CONNECTION_ERROR_ACCOUNT_RESTRICTED = 2,
	SERVER_CONNECTION_ERROR_COMMUNITY_RESTRICTED = 3,
	SERVER_CONNECTION_ERROR_LOCATION_RESTRICTED = 4,
	SERVER_CONNECTION_ERROR_SUBSCRIBERS_ONLY = 5,
	SERVER_CONNECTION_ERROR_REGULAR_PLAYERS_ONLY = 6,
	SERVER_CONNECTION_ERROR_MONOACCOUNT_CANNOT_VERIFY = 7,
	SERVER_CONNECTION_ERROR_MONOACCOUNT_ONLY = 8,
	SERVER_CONNECTION_ERROR_SERVER_OVERLOAD = 9,
}

export enum HaapiAuthTypeEnum {
	HAAPI_API_KEY = 0,
	HAAPI_TOKEN = 1,
}

export enum HaapiSessionTypeEnum {
	HAAPI_ACCOUNT_SESSION = 0,
	HAAPI_GAME_SESSION = 1,
}

export enum ForgettableSpellListActionEnum {
	FORGETTABLE_SPELL_LIST_DISPATCH = 0,
	FORGETTABLE_SPELL_LIST_UPDATE = 1,
}

export enum StatsUpgradeResultEnum {
	NONE = -1,
	SUCCESS = 0,
	RESTRICTED = 1,
	GUEST = 2,
	IN_FIGHT = 3,
	NOT_ENOUGH_POINT = 4,
}

export enum AlignmentWarEffortDonationResultEnum {
	WAR_EFFORT_DONATION_SUCCESS = 0,
	WAR_EFFORT_DONATION_ERROR_NOT_ENOUGH_KAMAS = 1,
	WAR_EFFORT_DONATION_ERROR_INVALID_ALIGNMENT = 2,
	WAR_EFFORT_DONATION_ERROR_KAMAS_LIMIT_REACH = 3,
	WAR_EFFORT_DONATION_ERROR_UNKNOWN = 4,
}

export enum DialogTypeEnum {
	DIALOG_BOOK = 0,
	DIALOG_DIALOG = 1,
	DIALOG_LOCKABLE = 2,
	DIALOG_PURCHASABLE = 3,
	DIALOG_GUILD_INVITATION = 4,
	DIALOG_GUILD_CREATE = 5,
	DIALOG_GUILD_RENAME = 6,
	DIALOG_MARRIAGE = 7,
	DIALOG_DUNGEON_MEETING = 8,
	DIALOG_SPELL_FORGET = 9,
	DIALOG_TELEPORTER = 10,
	DIALOG_EXCHANGE = 11,
	DIALOG_ALLIANCE_INVITATION = 12,
	DIALOG_ALLIANCE_CREATE = 13,
	DIALOG_ALLIANCE_RENAME = 14,
	DIALOG_HAVENBAG_MEETING = 15,
}

export enum SocialContactCategoryEnum {
	SOCIAL_CONTACT_FRIEND = 0,
	SOCIAL_CONTACT_SPOUSE = 1,
	SOCIAL_CONTACT_PARTY = 2,
	SOCIAL_CONTACT_GUILD = 3,
	SOCIAL_CONTACT_ALLIANCE = 4,
	SOCIAL_CONTACT_CRAFTER = 5,
	SOCIAL_CONTACT_INTERLOCUTOR = 6,
	SOCIAL_CONTACT_FIGHT = 7,
}

export enum ExchangeReplayStopReasonEnum {
	STOPPED_REASON_OK = 1,
	STOPPED_REASON_USER = 2,
	STOPPED_REASON_MISSING_RESSOURCE = 3,
	STOPPED_REASON_IMPOSSIBLE_MODIFICATION = 4,
}

export enum MountEquipedErrorEnum {
	UNSET = 0,
	SET = 1,
	RIDING = 2,
}

export enum AllianceRightsBitEnum {
	ALLIANCE_RIGHT_NONE = 0,
	ALLIANCE_RIGHT_BOSS = 1,
	ALLIANCE_RIGHT_MANAGE_PRISMS = 2,
	ALLIANCE_RIGHT_TALK_IN_CHAN = 4,
	ALLIANCE_RIGHT_RECRUIT_GUILDS = 8,
	ALLIANCE_RIGHT_KICK_GUILDS = 16,
	ALLIANCE_RIGHT_MANAGE_RIGHTS = 32,
}

export enum CharacteristicEnum {
	LIFE_POINTS = 0,
	ACTION_POINTS = 1,
	STATS_POINTS = 3,
	SPELLS_POINTS = 4,
	LEVEL = 5,
	STRENGTH = 10,
	VITALITY = 11,
	WISDOM = 12,
	CHANCE = 13,
	AGILITY = 14,
	INTELLIGENCE = 15,
	ALL_DAMAGES_BONUS = 16,
	CRITICAL_HIT = 18,
	RANGE = 19,
	MAGICAL_REDUCTION = 20,
	PHYSICAL_REDUCTION = 21,
	EXPERIENCE_BOOST = 22,
	MOVEMENT_POINTS = 23,
	INVISIBILITY = 24,
	DAMAGES_BONUS_PERCENT = 25,
	SUMMONABLE_CREATURES_BOOST = 26,
	DODGE_PALOST_PROBABILITY = 27,
	DODGE_PMLOST_PROBABILITY = 28,
	ENERGY_POINTS = 29,
	ALIGNEMENT_VALUE = 30,
	WEAPON_DAMAGES_BONUS_PERCENT = 31,
	PHYSICAL_DAMAGES = 32,
	EARTH_ELEMENT_RESIST_PERCENT = 33,
	FIRE_ELEMENT_RESIST_PERCENT = 34,
	WATER_ELEMENT_RESIST_PERCENT = 35,
	AIR_ELEMENT_RESIST_PERCENT = 36,
	NEUTRAL_ELEMENT_RESIST_PERCENT = 37,
	CRITICAL_MISS = 39,
	WEIGHT = 40,
	NULL = 41,
	NULL42 = 42,
	ALIGNEMENT_SIDE = 43,
	INITIATIVE = 44,
	SHOP_PERCENT_REDUCTION = 45,
	ALIGNEMENT_RANK = 46,
	MAX_ENERGY_POINTS = 47,
	PROSPECTING = 48,
	HEAL_BONUS = 49,
	REFLECT = 50,
	ENERGY_LOOSE = 51,
	HONOUR_POINTS = 52,
	NULL53 = 53,
	EARTH_ELEMENT_REDUCTION = 54,
	FIRE_ELEMENT_REDUCTION = 55,
	WATER_ELEMENT_REDUCTION = 56,
	AIR_ELEMENT_REDUCTION = 57,
	NEUTRAL_ELEMENT_REDUCTION = 58,
	TRAP_BONUS_PERCENT = 69,
	TRAP_BONUS = 70,
	SOUL_CAPTURE_BONUS = 72,
	RIDE_XPBONUS = 73,
	CONFUSION = 74,
	PERMANENT_DAMAGE_PERCENT = 75,
	UNLUCKY = 76,
	MAXIMIZE_ROLL = 77,
	TACKLE_EVADE = 78,
	TACKLE_BLOCK = 79,
	ALLIANCE_AUTO_AGRESS_RANGE = 80,
	ALLIANCE_AUTO_AGRESS_RESIST = 81,
	PAATTACK = 82,
	PMATTACK = 83,
	PUSH_DAMAGE_BONUS = 84,
	PUSH_DAMAGE_REDUCTION = 85,
	CRITICAL_DAMAGE_BONUS = 86,
	CRITICAL_DAMAGE_REDUCTION = 87,
	EARTH_DAMAGE_BONUS = 88,
	FIRE_DAMAGE_BONUS = 89,
	WATER_DAMAGE_BONUS = 90,
	AIR_DAMAGE_BONUS = 91,
	NEUTRAL_DAMAGE_BONUS = 92,
	MAX_BOMB = 93,
	BOMB_COMBO = 94,
	MAX_LIFE_POINTS = 95,
	SHIELD = 96,
	CUR_LIFE = 97,
	SPELL_PERCENT_DAMAGES = 98,
	EXTRA_SCALE = 99,
	PASS_TURN = 100,
	PERCENT_RESIST = 101,
	WEAPON_POWER = 103,
	INCOMING_PERCENT_DAMAGE_MULTIPLICATOR = 104,
	INCOMING_PERCENT_HEAL_MULTIPLICATOR = 105,
	GLYPH_POWER = 106,
	DEALT_DAMAGES_MULTIPLICATOR = 107,
	STOP_XP = 108,
	HUNTER = 109,
	RUNE_POWER = 110,
	MELEE_DAMAGE_DONE_PERCENT = 112,
	RANGED_DAMAGE_DONE_PERCENT = 113,
	WEAPON_DAMAGE_DONE_PERCENT = 114,
	MELEE_DAMAGE_RECEIVED_PERCENT = 115,
	SPELL_DAMAGE_DONE_PERCENT = 116,
	RANGED_DAMAGE_RECEIVED_PERCENT = 117,
	WEAPON_DAMAGE_RECEIVED_PERCENT = 118,
	SPELL_DAMAGE_RECEIVED_PERCENT = 119,
	RANGED_DAMAGE_DONE_PERCENT120 = 120,
	RANGED_DAMAGE_RECEIVED_PERCENT121 = 121,
	WEAPON_DAMAGE_DONE_PERCENT122 = 122,
	SPELL_DAMAGE_DONE_PERCENT123 = 123,
	MELEE_DAMAGE_RECEIVED_PERCENT124 = 124,
	MELEE_DAMAGE_DONE_PERCENT125 = 125,
	AGILITY_INITIAL_PERCENT = 126,
	STRENGTH_INITIAL_PERCENT = 127,
	CHANCE_INITIAL_PERCENT = 128,
	INTELLIGENCE_INITIAL_PERCENT = 129,
	VITALITY_INITIAL_PERCENT = 130,
	WISDOM_INITIAL_PERCENT = 131,
	TACKLE_BLOCK_INITIAL_PERCENT = 132,
	TACKLE_EVADE_INITIAL_PERCENT = 133,
	ACTION_POINTS_INITIAL_PERCENT = 134,
	MOVEMENT_POINTS_INITIAL_PERCENT = 135,
	PAATTACK_INITIAL_PERCENT = 136,
	PMATTACK_INITIAL_PERCENT = 137,
	DODGE_PALOST_PROBABILITY_INITIAL_PERCENT = 138,
	DODGE_PMLOST_PROBABILITY_INITIAL_PERCENT = 139,
	EXTRA_SCALE_PERCENT = 140,
	SPELL_DAMAGE_RECEIVED_PERCENT141 = 141,
	WEAPON_DAMAGE_RECEIVED_PERCENT142 = 142,
	MAX_ACTION_POINTS = 144,
	MAX_MOVEMENT_POINTS = 145,
}

export enum AccessoryPreviewErrorEnum {
	PREVIEW_ERROR = 0,
	PREVIEW_COOLDOWN = 1,
	PREVIEW_BAD_ITEM = 2,
}

export enum PresetUseResultEnum {
	PRESET_USE_OK = 1,
	PRESET_USE_OK_PARTIAL = 2,
	PRESET_USE_ERR_STATS_FIGHT_PREPARATION = 3,
	PRESET_USE_ERR_COOLDOWN = 4,
	PRESET_USE_ERR_BAD_PRESET_ID = 5,
	PRESET_USE_ERR_INVALID_STATE = 6,
	PRESET_USE_ERR_STATS = 7,
	PRESET_USE_ERR_CRITERION = 8,
	PRESET_USE_ERR_UNKNOWN = 9,
	PRESET_USE_ERR_INVALID_DATA = 10,
}

export enum PresetDeleteResultEnum {
	PRESET_DEL_OK = 1,
	PRESET_DEL_ERR_UNKNOWN = 2,
	PRESET_DEL_ERR_BAD_PRESET_ID = 3,
	PRESET_DEL_ERR_SYSTEM_INACTIVE = 4,
}

export enum PresetSaveResultEnum {
	PRESET_SAVE_OK = 1,
	PRESET_SAVE_ERR_UNKNOWN = 2,
	PRESET_SAVE_ERR_TOO_MANY = 3,
	PRESET_SAVE_ERR_INVALID_PLAYER_STATE = 4,
	PRESET_SAVE_ERR_SYSTEM_INACTIVE = 5,
	PRESET_SAVE_ERR_INVALID_ID = 6,
}

export enum BreachRewardLockEnum {
	BREACH_REWARD_LOCK_OWNER = 0,
	BREACH_REWARD_LOCK_FIGHTER = 1,
	BREACH_REWARD_LOCK_RESOURCES = 2,
	BREACH_REWARD_LOCK_CRITERION = 3,
	BREACH_REWARD_LOCK_USELESS = 4,
	BREACH_REWARD_MAX_PURCHASE_REACHED = 5,
}

export enum BidCancellationEnum {
	UNKNOWN_TYPE = 0,
	CLASSIC = 1,
	FRAUD = 2,
}

export enum BidValidationEnum {
	GENERIC_ERROR = 0,
	BUFFER_OVERLOAD = 1,
	OFFER_DOESNT_EXIST = 2,
	OFFER_ALREADY_EXISTS = 3,
	NOT_ENOUGH_KAMAS = 4,
	NOT_ENOUGH_OGRINES = 5,
	SERVER_MAINTENANCE = 6,
	VALIDATION_SUCCESS = 100,
}

export enum BidActionEnum {
	INVALID_ACTION = 0,
	CONSUME_BUFF = 1,
	CANCEL = 2,
	CREATE_KAMA = 3,
	CREATE_OGRINE = 4,
	BUY_KAMA = 5,
	BUY_OGRINE = 6,
}

export enum PlayerStatusEnum {
	PLAYER_STATUS_OFFLINE = 0,
	PLAYER_STATUS_UNKNOWN = 1,
	PLAYER_STATUS_AVAILABLE = 10,
	PLAYER_STATUS_IDLE = 20,
	PLAYER_STATUS_AFK = 21,
	PLAYER_STATUS_PRIVATE = 30,
	PLAYER_STATUS_SOLO = 40,
}

export enum HavenBagShareBitEnum {
	HAVEN_BAG_NONE = 0,
	HAVEN_BAG_FRIENDS = 1,
	HAVEN_BAG_GUILD = 2,
}

export enum BreedEnum {
	INCARNATION = -11,
	PRISM = -10,
	MOUNT_OUTSIDE = -9,
	MUTANT_IN_DUNGEON = -8,
	MUTANT = -7,
	TAX_COLLECTOR = -6,
	HUMAN_VENDOR = -5,
	NPC = -4,
	MONSTER_GROUP = -3,
	MONSTER = -2,
	SUMMONED = -1,
	UNDEFINED = 0,
	Feca = 1,
	Osamodas = 2,
	Enutrof = 3,
	Sram = 4,
	Xelor = 5,
	Ecaflip = 6,
	Eniripsa = 7,
	Iop = 8,
	Cra = 9,
	Sadida = 10,
	Sacrieur = 11,
	Pandawa = 12,
	Roublard = 13,
	Zobal = 14,
	Steamer = 15,
	Eliotrope = 16,
	Huppermage = 17,
	Ouginak = 18,
}

export enum NicknameErrorEnum {
	ALREADY_USED = 1,
	SAME_AS_LOGIN = 2,
	TOO_SIMILAR_TO_LOGIN = 3,
	INVALID_NICK = 4,
	UNKNOWN_NICK_ERROR = 99,
}

export enum ForgettableSpellClientActionEnum {
	FORGETTABLE_SPELL_FORGET = 0,
	FORGETTABLE_SPELL_EQUIP = 1,
	FORGETTABLE_SPELL_UNEQUIP = 2,
}

export enum SavablePresetTypeEnum {
	CHARACTER_BUILD = 0,
	SPELL_PRESET = 1,
}

export enum ExchangeHandleMountStableTypeEnum {
	EXCHANGE_MOUNTSTABLES_PUT = 1,
	EXCHANGE_MOUNTSTABLES_GET = 2,
	EXCHANGE_MOUNTSTABLES_FREE = 3,
	EXCHANGE_MOUNTSTABLES_CERTIF = 4,
	EXCHANGE_MOUNTSTABLES_UNCERTIF = 5,
	EXCHANGE_MOUNTPADDOCK_PUT = 6,
	EXCHANGE_MOUNTPADDOCK_GET = 7,
	EXCHANGE_MOUNTPADDOCK_FREE = 8,
	EXCHANGE_EQUIPED_MOUNTPADDOCK_PUT = 9,
	EXCHANGE_EQUIPED_MOUNTPADDOCK_GET = 10,
	EXCHANGE_EQUIPED_FREE = 11,
	EXCHANGE_CERTIFICAT_FREE = 12,
	EXCHANGE_EQUIPED_CERTIF = 13,
	EXCHANGE_MOUNTPADDOCK_CERTIF = 14,
	EXCHANGE_UNCERTIF_TO_EQUIPED = 15,
	EXCHANGE_UNCERTIF_TO_PADDOCK = 16,
	EXCHANGE_MOUNTSTABLES_STERILIZE = 17,
	EXCHANGE_EQUIPED_STERILIZE = 18,
	EXCHANGE_MOUNTPADDOCK_STERILIZE = 19,
}

export enum AlliancePrismModuleTypeEnum {
	TELEPORTER = 0,
	RECYCLER = 1,
}

export enum PlayableBreedEnum {
	UNDEFINED = 0,
	Feca = 1,
	Osamodas = 2,
	Enutrof = 3,
	Sram = 4,
	Xelor = 5,
	Ecaflip = 6,
	Eniripsa = 7,
	Iop = 8,
	Cra = 9,
	Sadida = 10,
	Sacrieur = 11,
	Pandawa = 12,
	Roublard = 13,
	Zobal = 14,
	Steamer = 15,
	Eliotrope = 16,
	Huppermage = 17,
	Ouginak = 18,
}

export enum HavenBagRoomActionEnum {
	HAVEN_BAG_ROOM_DISPATCH = 0,
	HAVEN_BAG_ROOM_UPDATE = 1,
}

export enum SubscriptionRequiredEnum {
	LIMITED_TO_SUBSCRIBER = 0,
	LIMIT_ON_JOB_XP = 1,
	LIMIT_ON_JOB_USE = 2,
	LIMIT_ON_MAP = 3,
	LIMIT_ON_ITEM = 4,
	LIMIT_ON_VENDOR = 5,
	LIMIT_ON_HAVENBAG = 6,
}

export enum ConsoleMessageTypeEnum {
	CONSOLE_TEXT_MESSAGE = 0,
	CONSOLE_INFO_MESSAGE = 1,
	CONSOLE_ERR_MESSAGE = 2,
}

export enum GuildRightsBitEnum {
	GUILD_RIGHT_NONE = 0,
	GUILD_RIGHT_BOSS = 1,
	GUILD_RIGHT_MANAGE_GUILD_BOOSTS = 2,
	GUILD_RIGHT_MANAGE_RIGHTS = 4,
	GUILD_RIGHT_INVITE_NEW_MEMBERS = 8,
	GUILD_RIGHT_BAN_MEMBERS = 16,
	GUILD_RIGHT_MANAGE_XP_CONTRIBUTION = 32,
	GUILD_RIGHT_MANAGE_RANKS = 64,
	GUILD_RIGHT_HIRE_TAX_COLLECTOR = 128,
	GUILD_RIGHT_MANAGE_MY_XP_CONTRIBUTION = 256,
	GUILD_RIGHT_COLLECT = 512,
	GUILD_RIGHT_USE_PADDOCKS = 4096,
	GUILD_RIGHT_ORGANIZE_PADDOCKS = 8192,
	GUILD_RIGHT_TAKE_OTHERS_MOUNTS_IN_PADDOCKS = 16384,
	GUILD_RIGHT_DEFENSE_PRIORITY = 32768,
	GUILD_RIGHT_COLLECT_MY_TAX_COLLECTOR = 65536,
	GUILD_RIGHT_SET_ALLIANCE_PRISM = 131072,
	GUILD_RIGHT_TALK_IN_ALLIANCE_CHAN = 262144,
}

export interface RawGameContextActorPositionInformations {
	id: number
	contextualId: number
	disposition: EntityDispositionInformations
}

export class GameContextActorPositionInformations extends DofusType {
	public static id: number = 7500

	public contextualId: number | undefined = 0
	public disposition: EntityDispositionInformations | undefined

	public constructor(
		contextualId?: number | undefined,
		disposition?: EntityDispositionInformations | undefined
	) {
		super()
		this.contextualId = contextualId
		this.disposition = disposition
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeDouble(this.contextualId!)
		writer.writeShort(this.disposition!.id)
		this.disposition!.serialize(writer)
	}

	public deserialize(reader: BinaryReader): void {
		this.contextualId = reader.readDouble()
		const dispositionTypeId: number = reader.readShort()
		this.disposition = new types[
			dispositionTypeId
		]() as EntityDispositionInformations
		this.disposition!.deserialize(reader)
	}

	public hydrate(
		data: GameContextActorPositionInformations | Record<string, any>
	): GameContextActorPositionInformations {
		if (data instanceof GameContextActorPositionInformations) {
			return data
		}

		this.contextualId = data.contextualId
		this.disposition = (new types[
			data.disposition.id
		]() as EntityDispositionInformations).hydrate(data.disposition)
		return this
	}
}

export interface RawGameContextActorInformations
	extends RawGameContextActorPositionInformations {
	id: number
	look: EntityLook
}

export class GameContextActorInformations extends GameContextActorPositionInformations {
	public static id: number = 6639

	public look: EntityLook | undefined

	public constructor(
		contextualId?: number | undefined,
		disposition?: EntityDispositionInformations | undefined,
		look?: EntityLook | undefined
	) {
		super(contextualId, disposition)
		this.look = look
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		this.look!.serialize(writer)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.look = new EntityLook()
		this.look!.deserialize(reader)
	}

	public hydrate(
		data: GameContextActorInformations | Record<string, any>
	): GameContextActorInformations {
		if (data instanceof GameContextActorInformations) {
			return data
		}

		super.hydrate(data)

		this.look = new EntityLook().hydrate(data.look)

		return this
	}
}

export interface RawGameRolePlayActorInformations
	extends RawGameContextActorInformations {
	id: number
}

export class GameRolePlayActorInformations extends GameContextActorInformations {
	public static id: number = 9377

	public constructor(
		contextualId?: number | undefined,
		disposition?: EntityDispositionInformations | undefined,
		look?: EntityLook | undefined
	) {
		super(contextualId, disposition, look)
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
	}

	public hydrate(
		data: GameRolePlayActorInformations | Record<string, any>
	): GameRolePlayActorInformations {
		if (data instanceof GameRolePlayActorInformations) {
			return data
		}

		super.hydrate(data)

		return this
	}
}

export interface RawGameRolePlayGroupMonsterInformations
	extends RawGameRolePlayActorInformations {
	id: number
	keyRingBonus: boolean
	hasHardcoreDrop: boolean
	hasAVARewardToken: boolean
	staticInfos: GroupMonsterStaticInformations
	lootShare: number
	alignmentSide: number
}

export class GameRolePlayGroupMonsterInformations extends GameRolePlayActorInformations {
	public static id: number = 4648

	public keyRingBonus: boolean | undefined = false
	public hasHardcoreDrop: boolean | undefined = false
	public hasAVARewardToken: boolean | undefined = false
	public staticInfos: GroupMonsterStaticInformations | undefined
	public lootShare: number | undefined = 0
	public alignmentSide: number | undefined = 0

	public constructor(
		contextualId?: number | undefined,
		disposition?: EntityDispositionInformations | undefined,
		look?: EntityLook | undefined,
		keyRingBonus?: boolean | undefined,
		hasHardcoreDrop?: boolean | undefined,
		hasAVARewardToken?: boolean | undefined,
		staticInfos?: GroupMonsterStaticInformations | undefined,
		lootShare?: number | undefined,
		alignmentSide?: number | undefined
	) {
		super(contextualId, disposition, look)
		this.keyRingBonus = keyRingBonus
		this.hasHardcoreDrop = hasHardcoreDrop
		this.hasAVARewardToken = hasAVARewardToken
		this.staticInfos = staticInfos
		this.lootShare = lootShare
		this.alignmentSide = alignmentSide
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		let box0: number = 0
		box0 = setFlag(box0, 0, this.keyRingBonus!)
		box0 = setFlag(box0, 1, this.hasHardcoreDrop!)
		box0 = setFlag(box0, 2, this.hasAVARewardToken!)
		writer.writeByte(box0)
		writer.writeShort(this.staticInfos!.id)
		this.staticInfos!.serialize(writer)
		writer.writeByte(this.lootShare!)
		writer.writeByte(this.alignmentSide!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		const box0 = reader.readByte()
		this.keyRingBonus = getFlag(box0, 0)
		this.hasHardcoreDrop = getFlag(box0, 1)
		this.hasAVARewardToken = getFlag(box0, 2)
		const staticInfosTypeId: number = reader.readShort()
		this.staticInfos = new types[
			staticInfosTypeId
		]() as GroupMonsterStaticInformations
		this.staticInfos!.deserialize(reader)
		this.lootShare = reader.readByte()
		this.alignmentSide = reader.readByte()
	}

	public hydrate(
		data: GameRolePlayGroupMonsterInformations | Record<string, any>
	): GameRolePlayGroupMonsterInformations {
		if (data instanceof GameRolePlayGroupMonsterInformations) {
			return data
		}

		super.hydrate(data)

		this.keyRingBonus = data.keyRingBonus
		this.hasHardcoreDrop = data.hasHardcoreDrop
		this.hasAVARewardToken = data.hasAVARewardToken
		this.staticInfos = (new types[
			data.staticInfos.id
		]() as GroupMonsterStaticInformations).hydrate(data.staticInfos)
		this.lootShare = data.lootShare
		this.alignmentSide = data.alignmentSide

		return this
	}
}

export interface RawHavenBagRoomPreviewInformation {
	id: number
	roomId: number
	themeId: number
}

export class HavenBagRoomPreviewInformation extends DofusType {
	public static id: number = 3168

	public roomId: number | undefined = 0
	public themeId: number | undefined = 0

	public constructor(
		roomId?: number | undefined,
		themeId?: number | undefined
	) {
		super()
		this.roomId = roomId
		this.themeId = themeId
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeByte(this.roomId!)
		writer.writeByte(this.themeId!)
	}

	public deserialize(reader: BinaryReader): void {
		this.roomId = reader.readByte()
		this.themeId = reader.readByte()
	}

	public hydrate(
		data: HavenBagRoomPreviewInformation | Record<string, any>
	): HavenBagRoomPreviewInformation {
		if (data instanceof HavenBagRoomPreviewInformation) {
			return data
		}

		this.roomId = data.roomId
		this.themeId = data.themeId

		return this
	}
}

export interface RawInteractiveElement {
	id: number
	elementId: number
	elementTypeId: number
	enabledSkills: InteractiveElementSkill[]
	disabledSkills: InteractiveElementSkill[]
	onCurrentMap: boolean
}

export class InteractiveElement extends DofusType {
	public static id: number = 6168

	public elementId: number | undefined = 0
	public elementTypeId: number | undefined = 0
	public enabledSkills: InteractiveElementSkill[] | undefined
	public disabledSkills: InteractiveElementSkill[] | undefined
	public onCurrentMap: boolean | undefined = false

	public constructor(
		elementId?: number | undefined,
		elementTypeId?: number | undefined,
		enabledSkills?: InteractiveElementSkill[] | undefined,
		disabledSkills?: InteractiveElementSkill[] | undefined,
		onCurrentMap?: boolean | undefined
	) {
		super()
		this.elementId = elementId
		this.elementTypeId = elementTypeId
		this.enabledSkills = enabledSkills
		this.disabledSkills = disabledSkills
		this.onCurrentMap = onCurrentMap
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeInt(this.elementId!)
		writer.writeInt(this.elementTypeId!)
		writer.writeShort(this.enabledSkills!.length)
		this.enabledSkills!.forEach((current) => {
			writer.writeShort(current.id)
			current.serialize(writer)
		})
		writer.writeShort(this.disabledSkills!.length)
		this.disabledSkills!.forEach((current) => {
			writer.writeShort(current.id)
			current.serialize(writer)
		})
		writer.writeBoolean(this.onCurrentMap!)
	}

	public deserialize(reader: BinaryReader): void {
		this.elementId = reader.readInt()
		this.elementTypeId = reader.readInt()
		this.enabledSkills = []
		const countEnabledSkills = reader.readShort()
		for (let i: number = 0; i < countEnabledSkills; i++) {
			const enabledSkillsTypeId: number = reader.readShort()
			const type: InteractiveElementSkill = new types[
				enabledSkillsTypeId
			]() as InteractiveElementSkill
			type.deserialize(reader)
			this.enabledSkills.push(type)
		}
		this.disabledSkills = []
		const countDisabledSkills = reader.readShort()
		for (let i: number = 0; i < countDisabledSkills; i++) {
			const disabledSkillsTypeId: number = reader.readShort()
			const type: InteractiveElementSkill = new types[
				disabledSkillsTypeId
			]() as InteractiveElementSkill
			type.deserialize(reader)
			this.disabledSkills.push(type)
		}
		this.onCurrentMap = reader.readBoolean()
	}

	public hydrate(
		data: InteractiveElement | Record<string, any>
	): InteractiveElement {
		if (data instanceof InteractiveElement) {
			return data
		}

		this.elementId = data.elementId
		this.elementTypeId = data.elementTypeId
		this.enabledSkills = data.enabledSkills.map(
			(
				dataElement: InteractiveElementSkill | Record<string, any>
			): InteractiveElementSkill => {
				if (dataElement instanceof InteractiveElementSkill) {
					return dataElement
				} else {
					return (new types[
						dataElement.id
					]() as InteractiveElementSkill).hydrate(dataElement)
				}
			}
		)
		this.disabledSkills = data.disabledSkills.map(
			(
				dataElement: InteractiveElementSkill | Record<string, any>
			): InteractiveElementSkill => {
				if (dataElement instanceof InteractiveElementSkill) {
					return dataElement
				} else {
					return (new types[
						dataElement.id
					]() as InteractiveElementSkill).hydrate(dataElement)
				}
			}
		)
		this.onCurrentMap = data.onCurrentMap

		return this
	}
}

export interface RawGameFightFighterInformations
	extends RawGameContextActorInformations {
	id: number
	spawnInfo: GameContextBasicSpawnInformation
	wave: number
	stats: GameFightMinimalStats
	previousPositions: number[]
}

export class GameFightFighterInformations extends GameContextActorInformations {
	public static id: number = 8400

	public spawnInfo: GameContextBasicSpawnInformation | undefined
	public wave: number | undefined = 0
	public stats: GameFightMinimalStats | undefined
	public previousPositions: number[] | undefined

	public constructor(
		contextualId?: number | undefined,
		disposition?: EntityDispositionInformations | undefined,
		look?: EntityLook | undefined,
		spawnInfo?: GameContextBasicSpawnInformation | undefined,
		wave?: number | undefined,
		stats?: GameFightMinimalStats | undefined,
		previousPositions?: number[] | undefined
	) {
		super(contextualId, disposition, look)
		this.spawnInfo = spawnInfo
		this.wave = wave
		this.stats = stats
		this.previousPositions = previousPositions
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		this.spawnInfo!.serialize(writer)
		writer.writeByte(this.wave!)
		writer.writeShort(this.stats!.id)
		this.stats!.serialize(writer)
		writer.writeShort(this.previousPositions!.length)
		this.previousPositions!.forEach((current: number) =>
			writer.writeVarShort(current)
		)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.spawnInfo = new GameContextBasicSpawnInformation()
		this.spawnInfo!.deserialize(reader)
		this.wave = reader.readByte()
		const statsTypeId: number = reader.readShort()
		this.stats = new types[statsTypeId]() as GameFightMinimalStats
		this.stats!.deserialize(reader)
		this.previousPositions = []
		const countPreviousPositions = reader.readShort()
		for (let i: number = 0; i < countPreviousPositions; i++) {
			this.previousPositions.push(reader.readVarShort())
		}
	}

	public hydrate(
		data: GameFightFighterInformations | Record<string, any>
	): GameFightFighterInformations {
		if (data instanceof GameFightFighterInformations) {
			return data
		}

		super.hydrate(data)

		this.spawnInfo = new GameContextBasicSpawnInformation().hydrate(
			data.spawnInfo
		)
		this.wave = data.wave
		this.stats = (new types[data.stats.id]() as GameFightMinimalStats).hydrate(
			data.stats
		)
		this.previousPositions = data.previousPositions

		return this
	}
}

export interface RawGameFightEntityInformation
	extends RawGameFightFighterInformations {
	id: number
	entityModelId: number
	level: number
	masterId: number
}

export class GameFightEntityInformation extends GameFightFighterInformations {
	public static id: number = 9631

	public entityModelId: number | undefined = 0
	public level: number | undefined = 0
	public masterId: number | undefined = 0

	public constructor(
		contextualId?: number | undefined,
		disposition?: EntityDispositionInformations | undefined,
		look?: EntityLook | undefined,
		spawnInfo?: GameContextBasicSpawnInformation | undefined,
		wave?: number | undefined,
		stats?: GameFightMinimalStats | undefined,
		previousPositions?: number[] | undefined,
		entityModelId?: number | undefined,
		level?: number | undefined,
		masterId?: number | undefined
	) {
		super(
			contextualId,
			disposition,
			look,
			spawnInfo,
			wave,
			stats,
			previousPositions
		)
		this.entityModelId = entityModelId
		this.level = level
		this.masterId = masterId
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeByte(this.entityModelId!)
		writer.writeVarShort(this.level!)
		writer.writeDouble(this.masterId!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.entityModelId = reader.readByte()
		this.level = reader.readVarShort()
		this.masterId = reader.readDouble()
	}

	public hydrate(
		data: GameFightEntityInformation | Record<string, any>
	): GameFightEntityInformation {
		if (data instanceof GameFightEntityInformation) {
			return data
		}

		super.hydrate(data)

		this.entityModelId = data.entityModelId
		this.level = data.level
		this.masterId = data.masterId

		return this
	}
}

export interface RawGameRolePlayPrismInformations
	extends RawGameRolePlayActorInformations {
	id: number
	prism: PrismInformation
}

export class GameRolePlayPrismInformations extends GameRolePlayActorInformations {
	public static id: number = 7

	public prism: PrismInformation | undefined

	public constructor(
		contextualId?: number | undefined,
		disposition?: EntityDispositionInformations | undefined,
		look?: EntityLook | undefined,
		prism?: PrismInformation | undefined
	) {
		super(contextualId, disposition, look)
		this.prism = prism
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeShort(this.prism!.id)
		this.prism!.serialize(writer)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		const prismTypeId: number = reader.readShort()
		this.prism = new types[prismTypeId]() as PrismInformation
		this.prism!.deserialize(reader)
	}

	public hydrate(
		data: GameRolePlayPrismInformations | Record<string, any>
	): GameRolePlayPrismInformations {
		if (data instanceof GameRolePlayPrismInformations) {
			return data
		}

		super.hydrate(data)

		this.prism = (new types[data.prism.id]() as PrismInformation).hydrate(
			data.prism
		)
		return this
	}
}

export interface RawGameFightAIInformations
	extends RawGameFightFighterInformations {
	id: number
}

export class GameFightAIInformations extends GameFightFighterInformations {
	public static id: number = 950

	public constructor(
		contextualId?: number | undefined,
		disposition?: EntityDispositionInformations | undefined,
		look?: EntityLook | undefined,
		spawnInfo?: GameContextBasicSpawnInformation | undefined,
		wave?: number | undefined,
		stats?: GameFightMinimalStats | undefined,
		previousPositions?: number[] | undefined
	) {
		super(
			contextualId,
			disposition,
			look,
			spawnInfo,
			wave,
			stats,
			previousPositions
		)
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
	}

	public hydrate(
		data: GameFightAIInformations | Record<string, any>
	): GameFightAIInformations {
		if (data instanceof GameFightAIInformations) {
			return data
		}

		super.hydrate(data)

		return this
	}
}

export interface RawGameFightMonsterInformations
	extends RawGameFightAIInformations {
	id: number
	creatureGenericId: number
	creatureGrade: number
	creatureLevel: number
}

export class GameFightMonsterInformations extends GameFightAIInformations {
	public static id: number = 6096

	public creatureGenericId: number | undefined = 0
	public creatureGrade: number | undefined = 0
	public creatureLevel: number | undefined = 0

	public constructor(
		contextualId?: number | undefined,
		disposition?: EntityDispositionInformations | undefined,
		look?: EntityLook | undefined,
		spawnInfo?: GameContextBasicSpawnInformation | undefined,
		wave?: number | undefined,
		stats?: GameFightMinimalStats | undefined,
		previousPositions?: number[] | undefined,
		creatureGenericId?: number | undefined,
		creatureGrade?: number | undefined,
		creatureLevel?: number | undefined
	) {
		super(
			contextualId,
			disposition,
			look,
			spawnInfo,
			wave,
			stats,
			previousPositions
		)
		this.creatureGenericId = creatureGenericId
		this.creatureGrade = creatureGrade
		this.creatureLevel = creatureLevel
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeVarShort(this.creatureGenericId!)
		writer.writeByte(this.creatureGrade!)
		writer.writeShort(this.creatureLevel!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.creatureGenericId = reader.readVarShort()
		this.creatureGrade = reader.readByte()
		this.creatureLevel = reader.readShort()
	}

	public hydrate(
		data: GameFightMonsterInformations | Record<string, any>
	): GameFightMonsterInformations {
		if (data instanceof GameFightMonsterInformations) {
			return data
		}

		super.hydrate(data)

		this.creatureGenericId = data.creatureGenericId
		this.creatureGrade = data.creatureGrade
		this.creatureLevel = data.creatureLevel

		return this
	}
}

export interface RawGameRolePlayGroupMonsterWaveInformations
	extends RawGameRolePlayGroupMonsterInformations {
	id: number
	nbWaves: number
	alternatives: GroupMonsterStaticInformations[]
}

export class GameRolePlayGroupMonsterWaveInformations extends GameRolePlayGroupMonsterInformations {
	public static id: number = 7041

	public nbWaves: number | undefined = 0
	public alternatives: GroupMonsterStaticInformations[] | undefined

	public constructor(
		contextualId?: number | undefined,
		disposition?: EntityDispositionInformations | undefined,
		look?: EntityLook | undefined,
		keyRingBonus?: boolean | undefined,
		hasHardcoreDrop?: boolean | undefined,
		hasAVARewardToken?: boolean | undefined,
		staticInfos?: GroupMonsterStaticInformations | undefined,
		lootShare?: number | undefined,
		alignmentSide?: number | undefined,
		nbWaves?: number | undefined,
		alternatives?: GroupMonsterStaticInformations[] | undefined
	) {
		super(
			contextualId,
			disposition,
			look,
			keyRingBonus,
			hasHardcoreDrop,
			hasAVARewardToken,
			staticInfos,
			lootShare,
			alignmentSide
		)
		this.nbWaves = nbWaves
		this.alternatives = alternatives
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeByte(this.nbWaves!)
		writer.writeShort(this.alternatives!.length)
		this.alternatives!.forEach((current) => {
			writer.writeShort(current.id)
			current.serialize(writer)
		})
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.nbWaves = reader.readByte()
		this.alternatives = []
		const countAlternatives = reader.readShort()
		for (let i: number = 0; i < countAlternatives; i++) {
			const alternativesTypeId: number = reader.readShort()
			const type: GroupMonsterStaticInformations = new types[
				alternativesTypeId
			]() as GroupMonsterStaticInformations
			type.deserialize(reader)
			this.alternatives.push(type)
		}
	}

	public hydrate(
		data: GameRolePlayGroupMonsterWaveInformations | Record<string, any>
	): GameRolePlayGroupMonsterWaveInformations {
		if (data instanceof GameRolePlayGroupMonsterWaveInformations) {
			return data
		}

		super.hydrate(data)

		this.nbWaves = data.nbWaves
		this.alternatives = data.alternatives.map(
			(
				dataElement: GroupMonsterStaticInformations | Record<string, any>
			): GroupMonsterStaticInformations => {
				if (dataElement instanceof GroupMonsterStaticInformations) {
					return dataElement
				} else {
					return (new types[
						dataElement.id
					]() as GroupMonsterStaticInformations).hydrate(dataElement)
				}
			}
		)

		return this
	}
}

export interface RawGameRolePlayTaxCollectorInformations
	extends RawGameRolePlayActorInformations {
	id: number
	identification: TaxCollectorStaticInformations
	guildLevel: number
	taxCollectorAttack: number
}

export class GameRolePlayTaxCollectorInformations extends GameRolePlayActorInformations {
	public static id: number = 3424

	public identification: TaxCollectorStaticInformations | undefined
	public guildLevel: number | undefined = 0
	public taxCollectorAttack: number | undefined = 0

	public constructor(
		contextualId?: number | undefined,
		disposition?: EntityDispositionInformations | undefined,
		look?: EntityLook | undefined,
		identification?: TaxCollectorStaticInformations | undefined,
		guildLevel?: number | undefined,
		taxCollectorAttack?: number | undefined
	) {
		super(contextualId, disposition, look)
		this.identification = identification
		this.guildLevel = guildLevel
		this.taxCollectorAttack = taxCollectorAttack
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeShort(this.identification!.id)
		this.identification!.serialize(writer)
		writer.writeByte(this.guildLevel!)
		writer.writeInt(this.taxCollectorAttack!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		const identificationTypeId: number = reader.readShort()
		this.identification = new types[
			identificationTypeId
		]() as TaxCollectorStaticInformations
		this.identification!.deserialize(reader)
		this.guildLevel = reader.readByte()
		this.taxCollectorAttack = reader.readInt()
	}

	public hydrate(
		data: GameRolePlayTaxCollectorInformations | Record<string, any>
	): GameRolePlayTaxCollectorInformations {
		if (data instanceof GameRolePlayTaxCollectorInformations) {
			return data
		}

		super.hydrate(data)

		this.identification = (new types[
			data.identification.id
		]() as TaxCollectorStaticInformations).hydrate(data.identification)
		this.guildLevel = data.guildLevel
		this.taxCollectorAttack = data.taxCollectorAttack

		return this
	}
}

export interface RawGameRolePlayNamedActorInformations
	extends RawGameRolePlayActorInformations {
	id: number
	name: string
}

export class GameRolePlayNamedActorInformations extends GameRolePlayActorInformations {
	public static id: number = 9155

	public name: string | undefined

	public constructor(
		contextualId?: number | undefined,
		disposition?: EntityDispositionInformations | undefined,
		look?: EntityLook | undefined,
		name?: string | undefined
	) {
		super(contextualId, disposition, look)
		this.name = name
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeUTF(this.name!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.name = reader.readUTF()
	}

	public hydrate(
		data: GameRolePlayNamedActorInformations | Record<string, any>
	): GameRolePlayNamedActorInformations {
		if (data instanceof GameRolePlayNamedActorInformations) {
			return data
		}

		super.hydrate(data)

		this.name = data.name

		return this
	}
}

export interface RawGameRolePlayMountInformations
	extends RawGameRolePlayNamedActorInformations {
	id: number
	ownerName: string
	level: number
}

export class GameRolePlayMountInformations extends GameRolePlayNamedActorInformations {
	public static id: number = 4944

	public ownerName: string | undefined
	public level: number | undefined = 0

	public constructor(
		contextualId?: number | undefined,
		disposition?: EntityDispositionInformations | undefined,
		look?: EntityLook | undefined,
		name?: string | undefined,
		ownerName?: string | undefined,
		level?: number | undefined
	) {
		super(contextualId, disposition, look, name)
		this.ownerName = ownerName
		this.level = level
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeUTF(this.ownerName!)
		writer.writeByte(this.level!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.ownerName = reader.readUTF()
		this.level = reader.readByte()
	}

	public hydrate(
		data: GameRolePlayMountInformations | Record<string, any>
	): GameRolePlayMountInformations {
		if (data instanceof GameRolePlayMountInformations) {
			return data
		}

		super.hydrate(data)

		this.ownerName = data.ownerName
		this.level = data.level

		return this
	}
}

export interface RawGameRolePlayNpcInformations
	extends RawGameRolePlayActorInformations {
	id: number
	npcId: number
	sex: boolean
	specialArtworkId: number
}

export class GameRolePlayNpcInformations extends GameRolePlayActorInformations {
	public static id: number = 8307

	public npcId: number | undefined = 0
	public sex: boolean | undefined = false
	public specialArtworkId: number | undefined = 0

	public constructor(
		contextualId?: number | undefined,
		disposition?: EntityDispositionInformations | undefined,
		look?: EntityLook | undefined,
		npcId?: number | undefined,
		sex?: boolean | undefined,
		specialArtworkId?: number | undefined
	) {
		super(contextualId, disposition, look)
		this.npcId = npcId
		this.sex = sex
		this.specialArtworkId = specialArtworkId
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeVarShort(this.npcId!)
		writer.writeBoolean(this.sex!)
		writer.writeVarShort(this.specialArtworkId!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.npcId = reader.readVarShort()
		this.sex = reader.readBoolean()
		this.specialArtworkId = reader.readVarShort()
	}

	public hydrate(
		data: GameRolePlayNpcInformations | Record<string, any>
	): GameRolePlayNpcInformations {
		if (data instanceof GameRolePlayNpcInformations) {
			return data
		}

		super.hydrate(data)

		this.npcId = data.npcId
		this.sex = data.sex
		this.specialArtworkId = data.specialArtworkId

		return this
	}
}

export interface RawGameRolePlayNpcWithQuestInformations
	extends RawGameRolePlayNpcInformations {
	id: number
	questFlag: GameRolePlayNpcQuestFlag
}

export class GameRolePlayNpcWithQuestInformations extends GameRolePlayNpcInformations {
	public static id: number = 5968

	public questFlag: GameRolePlayNpcQuestFlag | undefined

	public constructor(
		contextualId?: number | undefined,
		disposition?: EntityDispositionInformations | undefined,
		look?: EntityLook | undefined,
		npcId?: number | undefined,
		sex?: boolean | undefined,
		specialArtworkId?: number | undefined,
		questFlag?: GameRolePlayNpcQuestFlag | undefined
	) {
		super(contextualId, disposition, look, npcId, sex, specialArtworkId)
		this.questFlag = questFlag
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		this.questFlag!.serialize(writer)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.questFlag = new GameRolePlayNpcQuestFlag()
		this.questFlag!.deserialize(reader)
	}

	public hydrate(
		data: GameRolePlayNpcWithQuestInformations | Record<string, any>
	): GameRolePlayNpcWithQuestInformations {
		if (data instanceof GameRolePlayNpcWithQuestInformations) {
			return data
		}

		super.hydrate(data)

		this.questFlag = new GameRolePlayNpcQuestFlag().hydrate(data.questFlag)

		return this
	}
}

export interface RawGameRolePlayMerchantInformations
	extends RawGameRolePlayNamedActorInformations {
	id: number
	sellType: number
	options: HumanOption[]
}

export class GameRolePlayMerchantInformations extends GameRolePlayNamedActorInformations {
	public static id: number = 1204

	public sellType: number | undefined = 0
	public options: HumanOption[] | undefined

	public constructor(
		contextualId?: number | undefined,
		disposition?: EntityDispositionInformations | undefined,
		look?: EntityLook | undefined,
		name?: string | undefined,
		sellType?: number | undefined,
		options?: HumanOption[] | undefined
	) {
		super(contextualId, disposition, look, name)
		this.sellType = sellType
		this.options = options
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeByte(this.sellType!)
		writer.writeShort(this.options!.length)
		this.options!.forEach((current) => {
			writer.writeShort(current.id)
			current.serialize(writer)
		})
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.sellType = reader.readByte()
		this.options = []
		const countOptions = reader.readShort()
		for (let i: number = 0; i < countOptions; i++) {
			const optionsTypeId: number = reader.readShort()
			const type: HumanOption = new types[optionsTypeId]() as HumanOption
			type.deserialize(reader)
			this.options.push(type)
		}
	}

	public hydrate(
		data: GameRolePlayMerchantInformations | Record<string, any>
	): GameRolePlayMerchantInformations {
		if (data instanceof GameRolePlayMerchantInformations) {
			return data
		}

		super.hydrate(data)

		this.sellType = data.sellType
		this.options = data.options.map(
			(dataElement: HumanOption | Record<string, any>): HumanOption => {
				if (dataElement instanceof HumanOption) {
					return dataElement
				} else {
					return (new types[dataElement.id]() as HumanOption).hydrate(
						dataElement
					)
				}
			}
		)

		return this
	}
}

export interface RawGameRolePlayHumanoidInformations
	extends RawGameRolePlayNamedActorInformations {
	id: number
	humanoidInfo: HumanInformations
	accountId: number
}

export class GameRolePlayHumanoidInformations extends GameRolePlayNamedActorInformations {
	public static id: number = 5061

	public humanoidInfo: HumanInformations | undefined
	public accountId: number | undefined = 0

	public constructor(
		contextualId?: number | undefined,
		disposition?: EntityDispositionInformations | undefined,
		look?: EntityLook | undefined,
		name?: string | undefined,
		humanoidInfo?: HumanInformations | undefined,
		accountId?: number | undefined
	) {
		super(contextualId, disposition, look, name)
		this.humanoidInfo = humanoidInfo
		this.accountId = accountId
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeShort(this.humanoidInfo!.id)
		this.humanoidInfo!.serialize(writer)
		writer.writeInt(this.accountId!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		const humanoidInfoTypeId: number = reader.readShort()
		this.humanoidInfo = new types[humanoidInfoTypeId]() as HumanInformations
		this.humanoidInfo!.deserialize(reader)
		this.accountId = reader.readInt()
	}

	public hydrate(
		data: GameRolePlayHumanoidInformations | Record<string, any>
	): GameRolePlayHumanoidInformations {
		if (data instanceof GameRolePlayHumanoidInformations) {
			return data
		}

		super.hydrate(data)

		this.humanoidInfo = (new types[
			data.humanoidInfo.id
		]() as HumanInformations).hydrate(data.humanoidInfo)
		this.accountId = data.accountId

		return this
	}
}

export interface RawGameRolePlayCharacterInformations
	extends RawGameRolePlayHumanoidInformations {
	id: number
	alignmentInfos: ActorAlignmentInformations
}

export class GameRolePlayCharacterInformations extends GameRolePlayHumanoidInformations {
	public static id: number = 1982

	public alignmentInfos: ActorAlignmentInformations | undefined

	public constructor(
		contextualId?: number | undefined,
		disposition?: EntityDispositionInformations | undefined,
		look?: EntityLook | undefined,
		name?: string | undefined,
		humanoidInfo?: HumanInformations | undefined,
		accountId?: number | undefined,
		alignmentInfos?: ActorAlignmentInformations | undefined
	) {
		super(contextualId, disposition, look, name, humanoidInfo, accountId)
		this.alignmentInfos = alignmentInfos
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		this.alignmentInfos!.serialize(writer)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.alignmentInfos = new ActorAlignmentInformations()
		this.alignmentInfos!.deserialize(reader)
	}

	public hydrate(
		data: GameRolePlayCharacterInformations | Record<string, any>
	): GameRolePlayCharacterInformations {
		if (data instanceof GameRolePlayCharacterInformations) {
			return data
		}

		super.hydrate(data)

		this.alignmentInfos = new ActorAlignmentInformations().hydrate(
			data.alignmentInfos
		)

		return this
	}
}
export interface RawGameRolePlayPortalInformations
	extends RawGameRolePlayActorInformations {
	id: number
	portal: PortalInformation
}

export class GameRolePlayPortalInformations extends GameRolePlayActorInformations {
	public static id: number = 6138

	public portal: PortalInformation | undefined

	public constructor(
		contextualId?: number | undefined,
		disposition?: EntityDispositionInformations | undefined,
		look?: EntityLook | undefined,
		portal?: PortalInformation | undefined
	) {
		super(contextualId, disposition, look)
		this.portal = portal
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeShort(this.portal!.id)
		this.portal!.serialize(writer)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		const portalTypeId: number = reader.readShort()
		this.portal = new types[portalTypeId]() as PortalInformation
		this.portal!.deserialize(reader)
	}

	public hydrate(
		data: GameRolePlayPortalInformations | Record<string, any>
	): GameRolePlayPortalInformations {
		if (data instanceof GameRolePlayPortalInformations) {
			return data
		}

		super.hydrate(data)

		this.portal = (new types[data.portal.id]() as PortalInformation).hydrate(
			data.portal
		)
		return this
	}
}

export interface RawGameRolePlayMutantInformations
	extends RawGameRolePlayHumanoidInformations {
	id: number
	monsterId: number
	powerLevel: number
}

export class GameRolePlayMutantInformations extends GameRolePlayHumanoidInformations {
	public static id: number = 8271

	public monsterId: number | undefined = 0
	public powerLevel: number | undefined = 0

	public constructor(
		contextualId?: number | undefined,
		disposition?: EntityDispositionInformations | undefined,
		look?: EntityLook | undefined,
		name?: string | undefined,
		humanoidInfo?: HumanInformations | undefined,
		accountId?: number | undefined,
		monsterId?: number | undefined,
		powerLevel?: number | undefined
	) {
		super(contextualId, disposition, look, name, humanoidInfo, accountId)
		this.monsterId = monsterId
		this.powerLevel = powerLevel
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeVarShort(this.monsterId!)
		writer.writeByte(this.powerLevel!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.monsterId = reader.readVarShort()
		this.powerLevel = reader.readByte()
	}

	public hydrate(
		data: GameRolePlayMutantInformations | Record<string, any>
	): GameRolePlayMutantInformations {
		if (data instanceof GameRolePlayMutantInformations) {
			return data
		}

		super.hydrate(data)

		this.monsterId = data.monsterId
		this.powerLevel = data.powerLevel

		return this
	}
}

export interface RawGameFightFighterNamedInformations
	extends RawGameFightFighterInformations {
	id: number
	name: string
	status: PlayerStatus
	leagueId: number
	ladderPosition: number
	hiddenInPrefight: boolean
}

export class GameFightFighterNamedInformations extends GameFightFighterInformations {
	public static id: number = 6665

	public name: string | undefined
	public status: PlayerStatus | undefined
	public leagueId: number | undefined = 0
	public ladderPosition: number | undefined = 0
	public hiddenInPrefight: boolean | undefined = false

	public constructor(
		contextualId?: number | undefined,
		disposition?: EntityDispositionInformations | undefined,
		look?: EntityLook | undefined,
		spawnInfo?: GameContextBasicSpawnInformation | undefined,
		wave?: number | undefined,
		stats?: GameFightMinimalStats | undefined,
		previousPositions?: number[] | undefined,
		name?: string | undefined,
		status?: PlayerStatus | undefined,
		leagueId?: number | undefined,
		ladderPosition?: number | undefined,
		hiddenInPrefight?: boolean | undefined
	) {
		super(
			contextualId,
			disposition,
			look,
			spawnInfo,
			wave,
			stats,
			previousPositions
		)
		this.name = name
		this.status = status
		this.leagueId = leagueId
		this.ladderPosition = ladderPosition
		this.hiddenInPrefight = hiddenInPrefight
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeUTF(this.name!)
		this.status!.serialize(writer)
		writer.writeVarShort(this.leagueId!)
		writer.writeInt(this.ladderPosition!)
		writer.writeBoolean(this.hiddenInPrefight!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.name = reader.readUTF()
		this.status = new PlayerStatus()
		this.status!.deserialize(reader)
		this.leagueId = reader.readVarShort()
		this.ladderPosition = reader.readInt()
		this.hiddenInPrefight = reader.readBoolean()
	}

	public hydrate(
		data: GameFightFighterNamedInformations | Record<string, any>
	): GameFightFighterNamedInformations {
		if (data instanceof GameFightFighterNamedInformations) {
			return data
		}

		super.hydrate(data)

		this.name = data.name
		this.status = new PlayerStatus().hydrate(data.status)
		this.leagueId = data.leagueId
		this.ladderPosition = data.ladderPosition
		this.hiddenInPrefight = data.hiddenInPrefight

		return this
	}
}

export interface RawGameFightCharacterInformations
	extends RawGameFightFighterNamedInformations {
	id: number
	level: number
	alignmentInfos: ActorAlignmentInformations
	breed: number
	sex: boolean
}

export class GameFightCharacterInformations extends GameFightFighterNamedInformations {
	public static id: number = 7807

	public level: number | undefined = 0
	public alignmentInfos: ActorAlignmentInformations | undefined
	public breed: number | undefined = 0
	public sex: boolean | undefined = false

	public constructor(
		contextualId?: number | undefined,
		disposition?: EntityDispositionInformations | undefined,
		look?: EntityLook | undefined,
		spawnInfo?: GameContextBasicSpawnInformation | undefined,
		wave?: number | undefined,
		stats?: GameFightMinimalStats | undefined,
		previousPositions?: number[] | undefined,
		name?: string | undefined,
		status?: PlayerStatus | undefined,
		leagueId?: number | undefined,
		ladderPosition?: number | undefined,
		hiddenInPrefight?: boolean | undefined,
		level?: number | undefined,
		alignmentInfos?: ActorAlignmentInformations | undefined,
		breed?: number | undefined,
		sex?: boolean | undefined
	) {
		super(
			contextualId,
			disposition,
			look,
			spawnInfo,
			wave,
			stats,
			previousPositions,
			name,
			status,
			leagueId,
			ladderPosition,
			hiddenInPrefight
		)
		this.level = level
		this.alignmentInfos = alignmentInfos
		this.breed = breed
		this.sex = sex
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeVarShort(this.level!)
		this.alignmentInfos!.serialize(writer)
		writer.writeByte(this.breed!)
		writer.writeBoolean(this.sex!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.level = reader.readVarShort()
		this.alignmentInfos = new ActorAlignmentInformations()
		this.alignmentInfos!.deserialize(reader)
		this.breed = reader.readByte()
		this.sex = reader.readBoolean()
	}

	public hydrate(
		data: GameFightCharacterInformations | Record<string, any>
	): GameFightCharacterInformations {
		if (data instanceof GameFightCharacterInformations) {
			return data
		}

		super.hydrate(data)

		this.level = data.level
		this.alignmentInfos = new ActorAlignmentInformations().hydrate(
			data.alignmentInfos
		)
		this.breed = data.breed
		this.sex = data.sex

		return this
	}
}

export interface RawGameFightTaxCollectorInformations
	extends RawGameFightAIInformations {
	id: number
	firstNameId: number
	lastNameId: number
	level: number
}

export class GameFightTaxCollectorInformations extends GameFightAIInformations {
	public static id: number = 6975

	public firstNameId: number | undefined = 0
	public lastNameId: number | undefined = 0
	public level: number | undefined = 0

	public constructor(
		contextualId?: number | undefined,
		disposition?: EntityDispositionInformations | undefined,
		look?: EntityLook | undefined,
		spawnInfo?: GameContextBasicSpawnInformation | undefined,
		wave?: number | undefined,
		stats?: GameFightMinimalStats | undefined,
		previousPositions?: number[] | undefined,
		firstNameId?: number | undefined,
		lastNameId?: number | undefined,
		level?: number | undefined
	) {
		super(
			contextualId,
			disposition,
			look,
			spawnInfo,
			wave,
			stats,
			previousPositions
		)
		this.firstNameId = firstNameId
		this.lastNameId = lastNameId
		this.level = level
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeVarShort(this.firstNameId!)
		writer.writeVarShort(this.lastNameId!)
		writer.writeByte(this.level!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.firstNameId = reader.readVarShort()
		this.lastNameId = reader.readVarShort()
		this.level = reader.readByte()
	}

	public hydrate(
		data: GameFightTaxCollectorInformations | Record<string, any>
	): GameFightTaxCollectorInformations {
		if (data instanceof GameFightTaxCollectorInformations) {
			return data
		}

		super.hydrate(data)

		this.firstNameId = data.firstNameId
		this.lastNameId = data.lastNameId
		this.level = data.level

		return this
	}
}

export interface RawEntityLook {
	id: number
	bonesId: number
	skins: number[]
	indexedColors: number[]
	scales: number[]
	subentities: SubEntity[]
}

export class EntityLook extends DofusType {
	public static id: number = 3340

	public bonesId: number | undefined = 0
	public skins: number[] | undefined
	public indexedColors: number[] | undefined
	public scales: number[] | undefined
	public subentities: SubEntity[] | undefined

	public constructor(
		bonesId?: number | undefined,
		skins?: number[] | undefined,
		indexedColors?: number[] | undefined,
		scales?: number[] | undefined,
		subentities?: SubEntity[] | undefined
	) {
		super()
		this.bonesId = bonesId
		this.skins = skins
		this.indexedColors = indexedColors
		this.scales = scales
		this.subentities = subentities
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarShort(this.bonesId!)
		writer.writeShort(this.skins!.length)
		this.skins!.forEach((current: number) => writer.writeVarShort(current))
		writer.writeShort(this.indexedColors!.length)
		this.indexedColors!.forEach((current: number) => writer.writeInt(current))
		writer.writeShort(this.scales!.length)
		this.scales!.forEach((current: number) => writer.writeVarShort(current))
		writer.writeShort(this.subentities!.length)
		this.subentities!.forEach((current) => {
			current.serialize(writer)
		})
	}

	public deserialize(reader: BinaryReader): void {
		this.bonesId = reader.readVarShort()
		this.skins = []
		const countSkins = reader.readShort()
		for (let i: number = 0; i < countSkins; i++) {
			this.skins.push(reader.readVarShort())
		}
		this.indexedColors = []
		const countIndexedColors = reader.readShort()
		for (let i: number = 0; i < countIndexedColors; i++) {
			this.indexedColors.push(reader.readInt())
		}
		this.scales = []
		const countScales = reader.readShort()
		for (let i: number = 0; i < countScales; i++) {
			this.scales.push(reader.readVarShort())
		}
		this.subentities = []
		const countSubentities = reader.readShort()
		for (let i: number = 0; i < countSubentities; i++) {
			const type: SubEntity = new SubEntity()
			type.deserialize(reader)
			this.subentities.push(type)
		}
	}

	public hydrate(data: EntityLook | Record<string, any>): EntityLook {
		if (data instanceof EntityLook) {
			return data
		}

		this.bonesId = data.bonesId
		this.skins = data.skins
		this.indexedColors = data.indexedColors
		this.scales = data.scales
		this.subentities = data.subentities.map(
			(dataElement: SubEntity | Record<string, any>): SubEntity => {
				if (dataElement instanceof SubEntity) {
					return dataElement
				} else {
					return new SubEntity().hydrate(dataElement)
				}
			}
		)

		return this
	}
}

export interface RawSubEntity {
	id: number
	bindingPointCategory: number
	bindingPointIndex: number
	subEntityLook: EntityLook
}

export class SubEntity extends DofusType {
	public static id: number = 7682

	public bindingPointCategory: number | undefined = 0
	public bindingPointIndex: number | undefined = 0
	public subEntityLook: EntityLook | undefined

	public constructor(
		bindingPointCategory?: number | undefined,
		bindingPointIndex?: number | undefined,
		subEntityLook?: EntityLook | undefined
	) {
		super()
		this.bindingPointCategory = bindingPointCategory
		this.bindingPointIndex = bindingPointIndex
		this.subEntityLook = subEntityLook
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeByte(this.bindingPointCategory!)
		writer.writeByte(this.bindingPointIndex!)
		this.subEntityLook!.serialize(writer)
	}

	public deserialize(reader: BinaryReader): void {
		this.bindingPointCategory = reader.readByte()
		this.bindingPointIndex = reader.readByte()
		this.subEntityLook = new EntityLook()
		this.subEntityLook!.deserialize(reader)
	}

	public hydrate(data: SubEntity | Record<string, any>): SubEntity {
		if (data instanceof SubEntity) {
			return data
		}

		this.bindingPointCategory = data.bindingPointCategory
		this.bindingPointIndex = data.bindingPointIndex
		this.subEntityLook = new EntityLook().hydrate(data.subEntityLook)

		return this
	}
}

export interface RawAbstractFightDispellableEffect {
	id: number
	uid: number
	targetId: number
	turnDuration: number
	dispelable: number
	spellId: number
	effectId: number
	parentBoostUid: number
}

export class AbstractFightDispellableEffect extends DofusType {
	public static id: number = 9836

	public uid: number | undefined = 0
	public targetId: number | undefined = 0
	public turnDuration: number | undefined = 0
	public dispelable: number | undefined = 1
	public spellId: number | undefined = 0
	public effectId: number | undefined = 0
	public parentBoostUid: number | undefined = 0

	public constructor(
		uid?: number | undefined,
		targetId?: number | undefined,
		turnDuration?: number | undefined,
		dispelable?: number | undefined,
		spellId?: number | undefined,
		effectId?: number | undefined,
		parentBoostUid?: number | undefined
	) {
		super()
		this.uid = uid
		this.targetId = targetId
		this.turnDuration = turnDuration
		this.dispelable = dispelable
		this.spellId = spellId
		this.effectId = effectId
		this.parentBoostUid = parentBoostUid
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarInt(this.uid!)
		writer.writeDouble(this.targetId!)
		writer.writeShort(this.turnDuration!)
		writer.writeByte(this.dispelable!)
		writer.writeVarShort(this.spellId!)
		writer.writeVarInt(this.effectId!)
		writer.writeVarInt(this.parentBoostUid!)
	}

	public deserialize(reader: BinaryReader): void {
		this.uid = reader.readVarInt()
		this.targetId = reader.readDouble()
		this.turnDuration = reader.readShort()
		this.dispelable = reader.readByte()
		this.spellId = reader.readVarShort()
		this.effectId = reader.readVarInt()
		this.parentBoostUid = reader.readVarInt()
	}

	public hydrate(
		data: AbstractFightDispellableEffect | Record<string, any>
	): AbstractFightDispellableEffect {
		if (data instanceof AbstractFightDispellableEffect) {
			return data
		}

		this.uid = data.uid
		this.targetId = data.targetId
		this.turnDuration = data.turnDuration
		this.dispelable = data.dispelable
		this.spellId = data.spellId
		this.effectId = data.effectId
		this.parentBoostUid = data.parentBoostUid

		return this
	}
}

export interface RawSpawnInformation {
	id: number
}

export class SpawnInformation extends DofusType {
	public static id: number = 2131

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public serialize(writer: BinaryWriter): void {}

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public deserialize(reader: BinaryReader): void {}

	public hydrate(
		data: SpawnInformation | Record<string, any>
	): SpawnInformation {
		if (data instanceof SpawnInformation) {
			return data
		}

		return this
	}
}

export interface RawSpawnCompanionInformation extends RawSpawnInformation {
	id: number
	modelId: number
	level: number
	summonerId: number
	ownerId: number
}

export class SpawnCompanionInformation extends SpawnInformation {
	public static id: number = 7811

	public modelId: number | undefined = 0
	public level: number | undefined = 0
	public summonerId: number | undefined = 0
	public ownerId: number | undefined = 0

	public constructor(
		modelId?: number | undefined,
		level?: number | undefined,
		summonerId?: number | undefined,
		ownerId?: number | undefined
	) {
		super()
		this.modelId = modelId
		this.level = level
		this.summonerId = summonerId
		this.ownerId = ownerId
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeByte(this.modelId!)
		writer.writeVarShort(this.level!)
		writer.writeDouble(this.summonerId!)
		writer.writeDouble(this.ownerId!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.modelId = reader.readByte()
		this.level = reader.readVarShort()
		this.summonerId = reader.readDouble()
		this.ownerId = reader.readDouble()
	}

	public hydrate(
		data: SpawnCompanionInformation | Record<string, any>
	): SpawnCompanionInformation {
		if (data instanceof SpawnCompanionInformation) {
			return data
		}

		this.modelId = data.modelId
		this.level = data.level
		this.summonerId = data.summonerId
		this.ownerId = data.ownerId

		return this
	}
}

export interface RawBaseSpawnMonsterInformation extends RawSpawnInformation {
	id: number
	creatureGenericId: number
}

export class BaseSpawnMonsterInformation extends SpawnInformation {
	public static id: number = 1071

	public creatureGenericId: number | undefined = 0

	public constructor(creatureGenericId?: number | undefined) {
		super()
		this.creatureGenericId = creatureGenericId
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeVarShort(this.creatureGenericId!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.creatureGenericId = reader.readVarShort()
	}

	public hydrate(
		data: BaseSpawnMonsterInformation | Record<string, any>
	): BaseSpawnMonsterInformation {
		if (data instanceof BaseSpawnMonsterInformation) {
			return data
		}

		this.creatureGenericId = data.creatureGenericId

		return this
	}
}

export interface RawSpawnScaledMonsterInformation
	extends RawBaseSpawnMonsterInformation {
	id: number
	creatureLevel: number
}

export class SpawnScaledMonsterInformation extends BaseSpawnMonsterInformation {
	public static id: number = 8617

	public creatureLevel: number | undefined = 0

	public constructor(
		creatureGenericId?: number | undefined,
		creatureLevel?: number | undefined
	) {
		super(creatureGenericId)
		this.creatureLevel = creatureLevel
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeShort(this.creatureLevel!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.creatureLevel = reader.readShort()
	}

	public hydrate(
		data: SpawnScaledMonsterInformation | Record<string, any>
	): SpawnScaledMonsterInformation {
		if (data instanceof SpawnScaledMonsterInformation) {
			return data
		}

		super.hydrate(data)

		this.creatureLevel = data.creatureLevel

		return this
	}
}

export interface RawGameContextBasicSpawnInformation {
	id: number
	teamId: number
	alive: boolean
	informations: GameContextActorPositionInformations
}

export class GameContextBasicSpawnInformation extends DofusType {
	public static id: number = 7069

	public teamId: number | undefined = 2
	public alive: boolean | undefined = false
	public informations: GameContextActorPositionInformations | undefined

	public constructor(
		teamId?: number | undefined,
		alive?: boolean | undefined,
		informations?: GameContextActorPositionInformations | undefined
	) {
		super()
		this.teamId = teamId
		this.alive = alive
		this.informations = informations
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeByte(this.teamId!)
		writer.writeBoolean(this.alive!)
		writer.writeShort(this.informations!.id)
		this.informations!.serialize(writer)
	}

	public deserialize(reader: BinaryReader): void {
		this.teamId = reader.readByte()
		this.alive = reader.readBoolean()
		const informationsTypeId: number = reader.readShort()
		this.informations = new types[
			informationsTypeId
		]() as GameContextActorPositionInformations
		this.informations!.deserialize(reader)
	}

	public hydrate(
		data: GameContextBasicSpawnInformation | Record<string, any>
	): GameContextBasicSpawnInformation {
		if (data instanceof GameContextBasicSpawnInformation) {
			return data
		}

		this.teamId = data.teamId
		this.alive = data.alive
		this.informations = (new types[
			data.informations.id
		]() as GameContextActorPositionInformations).hydrate(data.informations)
		return this
	}
}

export interface RawGameContextSummonsInformation {
	id: number
	spawnInformation: SpawnInformation
	wave: number
	look: EntityLook
	stats: GameFightMinimalStats
	summons: GameContextBasicSpawnInformation[]
}

export class GameContextSummonsInformation extends DofusType {
	public static id: number = 904

	public spawnInformation: SpawnInformation | undefined
	public wave: number | undefined = 0
	public look: EntityLook | undefined
	public stats: GameFightMinimalStats | undefined
	public summons: GameContextBasicSpawnInformation[] | undefined

	public constructor(
		spawnInformation?: SpawnInformation | undefined,
		wave?: number | undefined,
		look?: EntityLook | undefined,
		stats?: GameFightMinimalStats | undefined,
		summons?: GameContextBasicSpawnInformation[] | undefined
	) {
		super()
		this.spawnInformation = spawnInformation
		this.wave = wave
		this.look = look
		this.stats = stats
		this.summons = summons
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeShort(this.spawnInformation!.id)
		this.spawnInformation!.serialize(writer)
		writer.writeByte(this.wave!)
		this.look!.serialize(writer)
		writer.writeShort(this.stats!.id)
		this.stats!.serialize(writer)
		writer.writeShort(this.summons!.length)
		this.summons!.forEach((current) => {
			writer.writeShort(current.id)
			current.serialize(writer)
		})
	}

	public deserialize(reader: BinaryReader): void {
		const spawnInformationTypeId: number = reader.readShort()
		this.spawnInformation = new types[
			spawnInformationTypeId
		]() as SpawnInformation
		this.spawnInformation!.deserialize(reader)
		this.wave = reader.readByte()
		this.look = new EntityLook()
		this.look!.deserialize(reader)
		const statsTypeId: number = reader.readShort()
		this.stats = new types[statsTypeId]() as GameFightMinimalStats
		this.stats!.deserialize(reader)
		this.summons = []
		const countSummons = reader.readShort()
		for (let i: number = 0; i < countSummons; i++) {
			const summonsTypeId: number = reader.readShort()
			const type: GameContextBasicSpawnInformation = new types[
				summonsTypeId
			]() as GameContextBasicSpawnInformation
			type.deserialize(reader)
			this.summons.push(type)
		}
	}

	public hydrate(
		data: GameContextSummonsInformation | Record<string, any>
	): GameContextSummonsInformation {
		if (data instanceof GameContextSummonsInformation) {
			return data
		}

		this.spawnInformation = (new types[
			data.spawnInformation.id
		]() as SpawnInformation).hydrate(data.spawnInformation)
		this.wave = data.wave
		this.look = new EntityLook().hydrate(data.look)
		this.stats = (new types[data.stats.id]() as GameFightMinimalStats).hydrate(
			data.stats
		)
		this.summons = data.summons.map(
			(
				dataElement: GameContextBasicSpawnInformation | Record<string, any>
			): GameContextBasicSpawnInformation => {
				if (dataElement instanceof GameContextBasicSpawnInformation) {
					return dataElement
				} else {
					return (new types[
						dataElement.id
					]() as GameContextBasicSpawnInformation).hydrate(dataElement)
				}
			}
		)

		return this
	}
}

export interface RawGameFightSpellCooldown {
	id: number
	spellId: number
	cooldown: number
}

export class GameFightSpellCooldown extends DofusType {
	public static id: number = 9167

	public spellId: number | undefined = 0
	public cooldown: number | undefined = 0

	public constructor(
		spellId?: number | undefined,
		cooldown?: number | undefined
	) {
		super()
		this.spellId = spellId
		this.cooldown = cooldown
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeInt(this.spellId!)
		writer.writeByte(this.cooldown!)
	}

	public deserialize(reader: BinaryReader): void {
		this.spellId = reader.readInt()
		this.cooldown = reader.readByte()
	}

	public hydrate(
		data: GameFightSpellCooldown | Record<string, any>
	): GameFightSpellCooldown {
		if (data instanceof GameFightSpellCooldown) {
			return data
		}

		this.spellId = data.spellId
		this.cooldown = data.cooldown

		return this
	}
}

export interface RawFightTemporaryBoostEffect
	extends RawAbstractFightDispellableEffect {
	id: number
	delta: number
}

export class FightTemporaryBoostEffect extends AbstractFightDispellableEffect {
	public static id: number = 2668

	public delta: number | undefined = 0

	public constructor(
		uid?: number | undefined,
		targetId?: number | undefined,
		turnDuration?: number | undefined,
		dispelable?: number | undefined,
		spellId?: number | undefined,
		effectId?: number | undefined,
		parentBoostUid?: number | undefined,
		delta?: number | undefined
	) {
		super(
			uid,
			targetId,
			turnDuration,
			dispelable,
			spellId,
			effectId,
			parentBoostUid
		)
		this.delta = delta
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeInt(this.delta!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.delta = reader.readInt()
	}

	public hydrate(
		data: FightTemporaryBoostEffect | Record<string, any>
	): FightTemporaryBoostEffect {
		if (data instanceof FightTemporaryBoostEffect) {
			return data
		}

		super.hydrate(data)

		this.delta = data.delta

		return this
	}
}

export interface RawSpawnCharacterInformation extends RawSpawnInformation {
	id: number
	name: string
	level: number
}

export class SpawnCharacterInformation extends SpawnInformation {
	public static id: number = 1888

	public name: string | undefined
	public level: number | undefined = 0

	public constructor(name?: string | undefined, level?: number | undefined) {
		super()
		this.name = name
		this.level = level
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeUTF(this.name!)
		writer.writeVarShort(this.level!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.name = reader.readUTF()
		this.level = reader.readVarShort()
	}

	public hydrate(
		data: SpawnCharacterInformation | Record<string, any>
	): SpawnCharacterInformation {
		if (data instanceof SpawnCharacterInformation) {
			return data
		}

		this.name = data.name
		this.level = data.level

		return this
	}
}

export interface RawSpawnMonsterInformation
	extends RawBaseSpawnMonsterInformation {
	id: number
	creatureGrade: number
}

export class SpawnMonsterInformation extends BaseSpawnMonsterInformation {
	public static id: number = 3264

	public creatureGrade: number | undefined = 0

	public constructor(
		creatureGenericId?: number | undefined,
		creatureGrade?: number | undefined
	) {
		super(creatureGenericId)
		this.creatureGrade = creatureGrade
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeByte(this.creatureGrade!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.creatureGrade = reader.readByte()
	}

	public hydrate(
		data: SpawnMonsterInformation | Record<string, any>
	): SpawnMonsterInformation {
		if (data instanceof SpawnMonsterInformation) {
			return data
		}

		super.hydrate(data)

		this.creatureGrade = data.creatureGrade

		return this
	}
}

export interface RawEntityDispositionInformations {
	id: number
	cellId: number
	direction: number
}

export class EntityDispositionInformations extends DofusType {
	public static id: number = 9940

	public cellId: number | undefined = 0
	public direction: number | undefined = 1

	public constructor(
		cellId?: number | undefined,
		direction?: number | undefined
	) {
		super()
		this.cellId = cellId
		this.direction = direction
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeShort(this.cellId!)
		writer.writeByte(this.direction!)
	}

	public deserialize(reader: BinaryReader): void {
		this.cellId = reader.readShort()
		this.direction = reader.readByte()
	}

	public hydrate(
		data: EntityDispositionInformations | Record<string, any>
	): EntityDispositionInformations {
		if (data instanceof EntityDispositionInformations) {
			return data
		}

		this.cellId = data.cellId
		this.direction = data.direction

		return this
	}
}

export interface RawHumanOption {
	id: number
}

export class HumanOption extends DofusType {
	public static id: number = 2821

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public serialize(writer: BinaryWriter): void {}

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public deserialize(reader: BinaryReader): void {}

	public hydrate(data: HumanOption | Record<string, any>): HumanOption {
		if (data instanceof HumanOption) {
			return data
		}

		return this
	}
}

export interface RawHumanOptionAlliance extends RawHumanOption {
	id: number
	allianceInformations: AllianceInformations
	aggressable: number
}

export class HumanOptionAlliance extends HumanOption {
	public static id: number = 374

	public allianceInformations: AllianceInformations | undefined
	public aggressable: number | undefined = 0

	public constructor(
		allianceInformations?: AllianceInformations | undefined,
		aggressable?: number | undefined
	) {
		super()
		this.allianceInformations = allianceInformations
		this.aggressable = aggressable
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		this.allianceInformations!.serialize(writer)
		writer.writeByte(this.aggressable!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.allianceInformations = new AllianceInformations()
		this.allianceInformations!.deserialize(reader)
		this.aggressable = reader.readByte()
	}

	public hydrate(
		data: HumanOptionAlliance | Record<string, any>
	): HumanOptionAlliance {
		if (data instanceof HumanOptionAlliance) {
			return data
		}

		this.allianceInformations = new AllianceInformations().hydrate(
			data.allianceInformations
		)
		this.aggressable = data.aggressable

		return this
	}
}

export interface RawHumanOptionFollowers extends RawHumanOption {
	id: number
	followingCharactersLook: IndexedEntityLook[]
}

export class HumanOptionFollowers extends HumanOption {
	public static id: number = 8461

	public followingCharactersLook: IndexedEntityLook[] | undefined

	public constructor(
		followingCharactersLook?: IndexedEntityLook[] | undefined
	) {
		super()
		this.followingCharactersLook = followingCharactersLook
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeShort(this.followingCharactersLook!.length)
		this.followingCharactersLook!.forEach((current) => {
			current.serialize(writer)
		})
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.followingCharactersLook = []
		const countFollowingCharactersLook = reader.readShort()
		for (let i: number = 0; i < countFollowingCharactersLook; i++) {
			const type: IndexedEntityLook = new IndexedEntityLook()
			type.deserialize(reader)
			this.followingCharactersLook.push(type)
		}
	}

	public hydrate(
		data: HumanOptionFollowers | Record<string, any>
	): HumanOptionFollowers {
		if (data instanceof HumanOptionFollowers) {
			return data
		}

		this.followingCharactersLook = data.followingCharactersLook.map(
			(
				dataElement: IndexedEntityLook | Record<string, any>
			): IndexedEntityLook => {
				if (dataElement instanceof IndexedEntityLook) {
					return dataElement
				} else {
					return new IndexedEntityLook().hydrate(dataElement)
				}
			}
		)

		return this
	}
}

export interface RawActorOrientation {
	id: number
	id_: number
	direction: number
}

export class ActorOrientation extends DofusType {
	public static id: number = 366

	public id_: number | undefined = 0
	public direction: number | undefined = 1

	public constructor(id_?: number | undefined, direction?: number | undefined) {
		super()
		this.id_ = id_
		this.direction = direction
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeDouble(this.id_!)
		writer.writeByte(this.direction!)
	}

	public deserialize(reader: BinaryReader): void {
		this.id_ = reader.readDouble()
		this.direction = reader.readByte()
	}

	public hydrate(
		data: ActorOrientation | Record<string, any>
	): ActorOrientation {
		if (data instanceof ActorOrientation) {
			return data
		}

		this.id_ = data.id_
		this.direction = data.direction

		return this
	}
}

export interface RawGroupMonsterStaticInformations {
	id: number
	mainCreatureLightInfos: MonsterInGroupLightInformations
	underlings: MonsterInGroupInformations[]
}

export class GroupMonsterStaticInformations extends DofusType {
	public static id: number = 4311

	public mainCreatureLightInfos: MonsterInGroupLightInformations | undefined
	public underlings: MonsterInGroupInformations[] | undefined

	public constructor(
		mainCreatureLightInfos?: MonsterInGroupLightInformations | undefined,
		underlings?: MonsterInGroupInformations[] | undefined
	) {
		super()
		this.mainCreatureLightInfos = mainCreatureLightInfos
		this.underlings = underlings
	}

	public serialize(writer: BinaryWriter): void {
		this.mainCreatureLightInfos!.serialize(writer)
		writer.writeShort(this.underlings!.length)
		this.underlings!.forEach((current) => {
			current.serialize(writer)
		})
	}

	public deserialize(reader: BinaryReader): void {
		this.mainCreatureLightInfos = new MonsterInGroupLightInformations()
		this.mainCreatureLightInfos!.deserialize(reader)
		this.underlings = []
		const countUnderlings = reader.readShort()
		for (let i: number = 0; i < countUnderlings; i++) {
			const type: MonsterInGroupInformations = new MonsterInGroupInformations()
			type.deserialize(reader)
			this.underlings.push(type)
		}
	}

	public hydrate(
		data: GroupMonsterStaticInformations | Record<string, any>
	): GroupMonsterStaticInformations {
		if (data instanceof GroupMonsterStaticInformations) {
			return data
		}

		this.mainCreatureLightInfos = new MonsterInGroupLightInformations().hydrate(
			data.mainCreatureLightInfos
		)
		this.underlings = data.underlings.map(
			(
				dataElement: MonsterInGroupInformations | Record<string, any>
			): MonsterInGroupInformations => {
				if (dataElement instanceof MonsterInGroupInformations) {
					return dataElement
				} else {
					return new MonsterInGroupInformations().hydrate(dataElement)
				}
			}
		)

		return this
	}
}

export interface RawHumanInformations {
	id: number
	restrictions: ActorRestrictionsInformations
	sex: boolean
	options: HumanOption[]
}

export class HumanInformations extends DofusType {
	public static id: number = 9307

	public restrictions: ActorRestrictionsInformations | undefined
	public sex: boolean | undefined = false
	public options: HumanOption[] | undefined

	public constructor(
		restrictions?: ActorRestrictionsInformations | undefined,
		sex?: boolean | undefined,
		options?: HumanOption[] | undefined
	) {
		super()
		this.restrictions = restrictions
		this.sex = sex
		this.options = options
	}

	public serialize(writer: BinaryWriter): void {
		this.restrictions!.serialize(writer)
		writer.writeBoolean(this.sex!)
		writer.writeShort(this.options!.length)
		this.options!.forEach((current) => {
			writer.writeShort(current.id)
			current.serialize(writer)
		})
	}

	public deserialize(reader: BinaryReader): void {
		this.restrictions = new ActorRestrictionsInformations()
		this.restrictions!.deserialize(reader)
		this.sex = reader.readBoolean()
		this.options = []
		const countOptions = reader.readShort()
		for (let i: number = 0; i < countOptions; i++) {
			const optionsTypeId: number = reader.readShort()
			const type: HumanOption = new types[optionsTypeId]() as HumanOption
			type.deserialize(reader)
			this.options.push(type)
		}
	}

	public hydrate(
		data: HumanInformations | Record<string, any>
	): HumanInformations {
		if (data instanceof HumanInformations) {
			return data
		}

		this.restrictions = new ActorRestrictionsInformations().hydrate(
			data.restrictions
		)
		this.sex = data.sex
		this.options = data.options.map(
			(dataElement: HumanOption | Record<string, any>): HumanOption => {
				if (dataElement instanceof HumanOption) {
					return dataElement
				} else {
					return (new types[dataElement.id]() as HumanOption).hydrate(
						dataElement
					)
				}
			}
		)

		return this
	}
}

export interface RawFightTeamMemberInformations {
	id: number
	id_: number
}

export class FightTeamMemberInformations extends DofusType {
	public static id: number = 6629

	public id_: number | undefined = 0

	public constructor(id_?: number | undefined) {
		super()
		this.id_ = id_
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeDouble(this.id_!)
	}

	public deserialize(reader: BinaryReader): void {
		this.id_ = reader.readDouble()
	}

	public hydrate(
		data: FightTeamMemberInformations | Record<string, any>
	): FightTeamMemberInformations {
		if (data instanceof FightTeamMemberInformations) {
			return data
		}

		this.id_ = data.id_

		return this
	}
}

export interface RawHouseInformations {
	id: number
	houseId: number
	modelId: number
}

export class HouseInformations extends DofusType {
	public static id: number = 5066

	public houseId: number | undefined = 0
	public modelId: number | undefined = 0

	public constructor(
		houseId?: number | undefined,
		modelId?: number | undefined
	) {
		super()
		this.houseId = houseId
		this.modelId = modelId
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarInt(this.houseId!)
		writer.writeVarShort(this.modelId!)
	}

	public deserialize(reader: BinaryReader): void {
		this.houseId = reader.readVarInt()
		this.modelId = reader.readVarShort()
	}

	public hydrate(
		data: HouseInformations | Record<string, any>
	): HouseInformations {
		if (data instanceof HouseInformations) {
			return data
		}

		this.houseId = data.houseId
		this.modelId = data.modelId

		return this
	}
}

export interface RawHouseOnMapInformations extends RawHouseInformations {
	id: number
	doorsOnMap: number[]
	houseInstances: HouseInstanceInformations[]
}

export class HouseOnMapInformations extends HouseInformations {
	public static id: number = 8830

	public doorsOnMap: number[] | undefined
	public houseInstances: HouseInstanceInformations[] | undefined

	public constructor(
		houseId?: number | undefined,
		modelId?: number | undefined,
		doorsOnMap?: number[] | undefined,
		houseInstances?: HouseInstanceInformations[] | undefined
	) {
		super(houseId, modelId)
		this.doorsOnMap = doorsOnMap
		this.houseInstances = houseInstances
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeShort(this.doorsOnMap!.length)
		this.doorsOnMap!.forEach((current: number) => writer.writeInt(current))
		writer.writeShort(this.houseInstances!.length)
		this.houseInstances!.forEach((current) => {
			current.serialize(writer)
		})
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.doorsOnMap = []
		const countDoorsOnMap = reader.readShort()
		for (let i: number = 0; i < countDoorsOnMap; i++) {
			this.doorsOnMap.push(reader.readInt())
		}
		this.houseInstances = []
		const countHouseInstances = reader.readShort()
		for (let i: number = 0; i < countHouseInstances; i++) {
			const type: HouseInstanceInformations = new HouseInstanceInformations()
			type.deserialize(reader)
			this.houseInstances.push(type)
		}
	}

	public hydrate(
		data: HouseOnMapInformations | Record<string, any>
	): HouseOnMapInformations {
		if (data instanceof HouseOnMapInformations) {
			return data
		}

		super.hydrate(data)

		this.doorsOnMap = data.doorsOnMap
		this.houseInstances = data.houseInstances.map(
			(
				dataElement: HouseInstanceInformations | Record<string, any>
			): HouseInstanceInformations => {
				if (dataElement instanceof HouseInstanceInformations) {
					return dataElement
				} else {
					return new HouseInstanceInformations().hydrate(dataElement)
				}
			}
		)

		return this
	}
}

export interface RawHumanOptionObjectUse extends RawHumanOption {
	id: number
	delayTypeId: number
	delayEndTime: number
	objectGID: number
}

export class HumanOptionObjectUse extends HumanOption {
	public static id: number = 2440

	public delayTypeId: number | undefined = 0
	public delayEndTime: number | undefined = 0
	public objectGID: number | undefined = 0

	public constructor(
		delayTypeId?: number | undefined,
		delayEndTime?: number | undefined,
		objectGID?: number | undefined
	) {
		super()
		this.delayTypeId = delayTypeId
		this.delayEndTime = delayEndTime
		this.objectGID = objectGID
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeByte(this.delayTypeId!)
		writer.writeDouble(this.delayEndTime!)
		writer.writeVarShort(this.objectGID!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.delayTypeId = reader.readByte()
		this.delayEndTime = reader.readDouble()
		this.objectGID = reader.readVarShort()
	}

	public hydrate(
		data: HumanOptionObjectUse | Record<string, any>
	): HumanOptionObjectUse {
		if (data instanceof HumanOptionObjectUse) {
			return data
		}

		this.delayTypeId = data.delayTypeId
		this.delayEndTime = data.delayEndTime
		this.objectGID = data.objectGID

		return this
	}
}

export interface RawHouseInstanceInformations {
	id: number
	secondHand: boolean
	isLocked: boolean
	isSaleLocked: boolean
	instanceId: number
	ownerName: string
	price: number
}

export class HouseInstanceInformations extends DofusType {
	public static id: number = 9271

	public secondHand: boolean | undefined = false
	public isLocked: boolean | undefined = false
	public isSaleLocked: boolean | undefined = false
	public instanceId: number | undefined = 0
	public ownerName: string | undefined
	public price: number | undefined = 0

	public constructor(
		secondHand?: boolean | undefined,
		isLocked?: boolean | undefined,
		isSaleLocked?: boolean | undefined,
		instanceId?: number | undefined,
		ownerName?: string | undefined,
		price?: number | undefined
	) {
		super()
		this.secondHand = secondHand
		this.isLocked = isLocked
		this.isSaleLocked = isSaleLocked
		this.instanceId = instanceId
		this.ownerName = ownerName
		this.price = price
	}

	public serialize(writer: BinaryWriter): void {
		let box0: number = 0
		box0 = setFlag(box0, 0, this.secondHand!)
		box0 = setFlag(box0, 1, this.isLocked!)
		box0 = setFlag(box0, 2, this.isSaleLocked!)
		writer.writeByte(box0)
		writer.writeInt(this.instanceId!)
		writer.writeUTF(this.ownerName!)
		writer.writeVarLong(this.price!)
	}

	public deserialize(reader: BinaryReader): void {
		const box0 = reader.readByte()
		this.secondHand = getFlag(box0, 0)
		this.isLocked = getFlag(box0, 1)
		this.isSaleLocked = getFlag(box0, 2)
		this.instanceId = reader.readInt()
		this.ownerName = reader.readUTF()
		this.price = reader.readVarLong()
	}

	public hydrate(
		data: HouseInstanceInformations | Record<string, any>
	): HouseInstanceInformations {
		if (data instanceof HouseInstanceInformations) {
			return data
		}

		this.secondHand = data.secondHand
		this.isLocked = data.isLocked
		this.isSaleLocked = data.isSaleLocked
		this.instanceId = data.instanceId
		this.ownerName = data.ownerName
		this.price = data.price

		return this
	}
}

export interface RawHumanOptionEmote extends RawHumanOption {
	id: number
	emoteId: number
	emoteStartTime: number
}

export class HumanOptionEmote extends HumanOption {
	public static id: number = 7370

	public emoteId: number | undefined = 0
	public emoteStartTime: number | undefined = 0

	public constructor(
		emoteId?: number | undefined,
		emoteStartTime?: number | undefined
	) {
		super()
		this.emoteId = emoteId
		this.emoteStartTime = emoteStartTime
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeByte(this.emoteId!)
		writer.writeDouble(this.emoteStartTime!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.emoteId = reader.readByte()
		this.emoteStartTime = reader.readDouble()
	}

	public hydrate(
		data: HumanOptionEmote | Record<string, any>
	): HumanOptionEmote {
		if (data instanceof HumanOptionEmote) {
			return data
		}

		this.emoteId = data.emoteId
		this.emoteStartTime = data.emoteStartTime

		return this
	}
}

export interface RawObjectItemInRolePlay {
	id: number
	cellId: number
	objectGID: number
}

export class ObjectItemInRolePlay extends DofusType {
	public static id: number = 9311

	public cellId: number | undefined = 0
	public objectGID: number | undefined = 0

	public constructor(
		cellId?: number | undefined,
		objectGID?: number | undefined
	) {
		super()
		this.cellId = cellId
		this.objectGID = objectGID
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarShort(this.cellId!)
		writer.writeVarShort(this.objectGID!)
	}

	public deserialize(reader: BinaryReader): void {
		this.cellId = reader.readVarShort()
		this.objectGID = reader.readVarShort()
	}

	public hydrate(
		data: ObjectItemInRolePlay | Record<string, any>
	): ObjectItemInRolePlay {
		if (data instanceof ObjectItemInRolePlay) {
			return data
		}

		this.cellId = data.cellId
		this.objectGID = data.objectGID

		return this
	}
}

export interface RawPaddockItem extends RawObjectItemInRolePlay {
	id: number
	durability: ItemDurability
}

export class PaddockItem extends ObjectItemInRolePlay {
	public static id: number = 5602

	public durability: ItemDurability | undefined

	public constructor(
		cellId?: number | undefined,
		objectGID?: number | undefined,
		durability?: ItemDurability | undefined
	) {
		super(cellId, objectGID)
		this.durability = durability
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		this.durability!.serialize(writer)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.durability = new ItemDurability()
		this.durability!.deserialize(reader)
	}

	public hydrate(data: PaddockItem | Record<string, any>): PaddockItem {
		if (data instanceof PaddockItem) {
			return data
		}

		super.hydrate(data)

		this.durability = new ItemDurability().hydrate(data.durability)

		return this
	}
}

export interface RawAbstractFightTeamInformations {
	id: number
	teamId: number
	leaderId: number
	teamSide: number
	teamTypeId: number
	nbWaves: number
}

export class AbstractFightTeamInformations extends DofusType {
	public static id: number = 5839

	public teamId: number | undefined = 2
	public leaderId: number | undefined = 0
	public teamSide: number | undefined = 0
	public teamTypeId: number | undefined = 0
	public nbWaves: number | undefined = 0

	public constructor(
		teamId?: number | undefined,
		leaderId?: number | undefined,
		teamSide?: number | undefined,
		teamTypeId?: number | undefined,
		nbWaves?: number | undefined
	) {
		super()
		this.teamId = teamId
		this.leaderId = leaderId
		this.teamSide = teamSide
		this.teamTypeId = teamTypeId
		this.nbWaves = nbWaves
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeByte(this.teamId!)
		writer.writeDouble(this.leaderId!)
		writer.writeByte(this.teamSide!)
		writer.writeByte(this.teamTypeId!)
		writer.writeByte(this.nbWaves!)
	}

	public deserialize(reader: BinaryReader): void {
		this.teamId = reader.readByte()
		this.leaderId = reader.readDouble()
		this.teamSide = reader.readByte()
		this.teamTypeId = reader.readByte()
		this.nbWaves = reader.readByte()
	}

	public hydrate(
		data: AbstractFightTeamInformations | Record<string, any>
	): AbstractFightTeamInformations {
		if (data instanceof AbstractFightTeamInformations) {
			return data
		}

		this.teamId = data.teamId
		this.leaderId = data.leaderId
		this.teamSide = data.teamSide
		this.teamTypeId = data.teamTypeId
		this.nbWaves = data.nbWaves

		return this
	}
}

export interface RawFightTeamInformations
	extends RawAbstractFightTeamInformations {
	id: number
	teamMembers: FightTeamMemberInformations[]
}

export class FightTeamInformations extends AbstractFightTeamInformations {
	public static id: number = 563

	public teamMembers: FightTeamMemberInformations[] | undefined

	public constructor(
		teamId?: number | undefined,
		leaderId?: number | undefined,
		teamSide?: number | undefined,
		teamTypeId?: number | undefined,
		nbWaves?: number | undefined,
		teamMembers?: FightTeamMemberInformations[] | undefined
	) {
		super(teamId, leaderId, teamSide, teamTypeId, nbWaves)
		this.teamMembers = teamMembers
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeShort(this.teamMembers!.length)
		this.teamMembers!.forEach((current) => {
			writer.writeShort(current.id)
			current.serialize(writer)
		})
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.teamMembers = []
		const countTeamMembers = reader.readShort()
		for (let i: number = 0; i < countTeamMembers; i++) {
			const teamMembersTypeId: number = reader.readShort()
			const type: FightTeamMemberInformations = new types[
				teamMembersTypeId
			]() as FightTeamMemberInformations
			type.deserialize(reader)
			this.teamMembers.push(type)
		}
	}

	public hydrate(
		data: FightTeamInformations | Record<string, any>
	): FightTeamInformations {
		if (data instanceof FightTeamInformations) {
			return data
		}

		super.hydrate(data)

		this.teamMembers = data.teamMembers.map(
			(
				dataElement: FightTeamMemberInformations | Record<string, any>
			): FightTeamMemberInformations => {
				if (dataElement instanceof FightTeamMemberInformations) {
					return dataElement
				} else {
					return (new types[
						dataElement.id
					]() as FightTeamMemberInformations).hydrate(dataElement)
				}
			}
		)

		return this
	}
}

export interface RawIndexedEntityLook {
	id: number
	look: EntityLook
	index: number
}

export class IndexedEntityLook extends DofusType {
	public static id: number = 9720

	public look: EntityLook | undefined
	public index: number | undefined = 0

	public constructor(
		look?: EntityLook | undefined,
		index?: number | undefined
	) {
		super()
		this.look = look
		this.index = index
	}

	public serialize(writer: BinaryWriter): void {
		this.look!.serialize(writer)
		writer.writeByte(this.index!)
	}

	public deserialize(reader: BinaryReader): void {
		this.look = new EntityLook()
		this.look!.deserialize(reader)
		this.index = reader.readByte()
	}

	public hydrate(
		data: IndexedEntityLook | Record<string, any>
	): IndexedEntityLook {
		if (data instanceof IndexedEntityLook) {
			return data
		}

		this.look = new EntityLook().hydrate(data.look)
		this.index = data.index

		return this
	}
}

export interface RawHumanOptionSkillUse extends RawHumanOption {
	id: number
	elementId: number
	skillId: number
	skillEndTime: number
}

export class HumanOptionSkillUse extends HumanOption {
	public static id: number = 4888

	public elementId: number | undefined = 0
	public skillId: number | undefined = 0
	public skillEndTime: number | undefined = 0

	public constructor(
		elementId?: number | undefined,
		skillId?: number | undefined,
		skillEndTime?: number | undefined
	) {
		super()
		this.elementId = elementId
		this.skillId = skillId
		this.skillEndTime = skillEndTime
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeVarInt(this.elementId!)
		writer.writeVarShort(this.skillId!)
		writer.writeDouble(this.skillEndTime!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.elementId = reader.readVarInt()
		this.skillId = reader.readVarShort()
		this.skillEndTime = reader.readDouble()
	}

	public hydrate(
		data: HumanOptionSkillUse | Record<string, any>
	): HumanOptionSkillUse {
		if (data instanceof HumanOptionSkillUse) {
			return data
		}

		this.elementId = data.elementId
		this.skillId = data.skillId
		this.skillEndTime = data.skillEndTime

		return this
	}
}

export interface RawAlternativeMonstersInGroupLightInformations {
	id: number
	playerCount: number
	monsters: MonsterInGroupLightInformations[]
}

export class AlternativeMonstersInGroupLightInformations extends DofusType {
	public static id: number = 1267

	public playerCount: number | undefined = 0
	public monsters: MonsterInGroupLightInformations[] | undefined

	public constructor(
		playerCount?: number | undefined,
		monsters?: MonsterInGroupLightInformations[] | undefined
	) {
		super()
		this.playerCount = playerCount
		this.monsters = monsters
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeInt(this.playerCount!)
		writer.writeShort(this.monsters!.length)
		this.monsters!.forEach((current) => {
			current.serialize(writer)
		})
	}

	public deserialize(reader: BinaryReader): void {
		this.playerCount = reader.readInt()
		this.monsters = []
		const countMonsters = reader.readShort()
		for (let i: number = 0; i < countMonsters; i++) {
			const type: MonsterInGroupLightInformations = new MonsterInGroupLightInformations()
			type.deserialize(reader)
			this.monsters.push(type)
		}
	}

	public hydrate(
		data: AlternativeMonstersInGroupLightInformations | Record<string, any>
	): AlternativeMonstersInGroupLightInformations {
		if (data instanceof AlternativeMonstersInGroupLightInformations) {
			return data
		}

		this.playerCount = data.playerCount
		this.monsters = data.monsters.map(
			(
				dataElement: MonsterInGroupLightInformations | Record<string, any>
			): MonsterInGroupLightInformations => {
				if (dataElement instanceof MonsterInGroupLightInformations) {
					return dataElement
				} else {
					return new MonsterInGroupLightInformations().hydrate(dataElement)
				}
			}
		)

		return this
	}
}

export interface RawFightCommonInformations {
	id: number
	fightId: number
	fightType: number
	fightTeams: FightTeamInformations[]
	fightTeamsPositions: number[]
	fightTeamsOptions: FightOptionsInformations[]
}

export class FightCommonInformations extends DofusType {
	public static id: number = 2177

	public fightId: number | undefined = 0
	public fightType: number | undefined = 0
	public fightTeams: FightTeamInformations[] | undefined
	public fightTeamsPositions: number[] | undefined
	public fightTeamsOptions: FightOptionsInformations[] | undefined

	public constructor(
		fightId?: number | undefined,
		fightType?: number | undefined,
		fightTeams?: FightTeamInformations[] | undefined,
		fightTeamsPositions?: number[] | undefined,
		fightTeamsOptions?: FightOptionsInformations[] | undefined
	) {
		super()
		this.fightId = fightId
		this.fightType = fightType
		this.fightTeams = fightTeams
		this.fightTeamsPositions = fightTeamsPositions
		this.fightTeamsOptions = fightTeamsOptions
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarShort(this.fightId!)
		writer.writeByte(this.fightType!)
		writer.writeShort(this.fightTeams!.length)
		this.fightTeams!.forEach((current) => {
			writer.writeShort(current.id)
			current.serialize(writer)
		})
		writer.writeShort(this.fightTeamsPositions!.length)
		this.fightTeamsPositions!.forEach((current: number) =>
			writer.writeVarShort(current)
		)
		writer.writeShort(this.fightTeamsOptions!.length)
		this.fightTeamsOptions!.forEach((current) => {
			current.serialize(writer)
		})
	}

	public deserialize(reader: BinaryReader): void {
		this.fightId = reader.readVarShort()
		this.fightType = reader.readByte()
		this.fightTeams = []
		const countFightTeams = reader.readShort()
		for (let i: number = 0; i < countFightTeams; i++) {
			const fightTeamsTypeId: number = reader.readShort()
			const type: FightTeamInformations = new types[
				fightTeamsTypeId
			]() as FightTeamInformations
			type.deserialize(reader)
			this.fightTeams.push(type)
		}
		this.fightTeamsPositions = []
		const countFightTeamsPositions = reader.readShort()
		for (let i: number = 0; i < countFightTeamsPositions; i++) {
			this.fightTeamsPositions.push(reader.readVarShort())
		}
		this.fightTeamsOptions = []
		const countFightTeamsOptions = reader.readShort()
		for (let i: number = 0; i < countFightTeamsOptions; i++) {
			const type: FightOptionsInformations = new FightOptionsInformations()
			type.deserialize(reader)
			this.fightTeamsOptions.push(type)
		}
	}

	public hydrate(
		data: FightCommonInformations | Record<string, any>
	): FightCommonInformations {
		if (data instanceof FightCommonInformations) {
			return data
		}

		this.fightId = data.fightId
		this.fightType = data.fightType
		this.fightTeams = data.fightTeams.map(
			(
				dataElement: FightTeamInformations | Record<string, any>
			): FightTeamInformations => {
				if (dataElement instanceof FightTeamInformations) {
					return dataElement
				} else {
					return (new types[dataElement.id]() as FightTeamInformations).hydrate(
						dataElement
					)
				}
			}
		)
		this.fightTeamsPositions = data.fightTeamsPositions
		this.fightTeamsOptions = data.fightTeamsOptions.map(
			(
				dataElement: FightOptionsInformations | Record<string, any>
			): FightOptionsInformations => {
				if (dataElement instanceof FightOptionsInformations) {
					return dataElement
				} else {
					return new FightOptionsInformations().hydrate(dataElement)
				}
			}
		)

		return this
	}
}

export interface RawMonsterInGroupLightInformations {
	id: number
	genericId: number
	grade: number
	level: number
}

export class MonsterInGroupLightInformations extends DofusType {
	public static id: number = 7146

	public genericId: number | undefined = 0
	public grade: number | undefined = 0
	public level: number | undefined = 0

	public constructor(
		genericId?: number | undefined,
		grade?: number | undefined,
		level?: number | undefined
	) {
		super()
		this.genericId = genericId
		this.grade = grade
		this.level = level
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeInt(this.genericId!)
		writer.writeByte(this.grade!)
		writer.writeShort(this.level!)
	}

	public deserialize(reader: BinaryReader): void {
		this.genericId = reader.readInt()
		this.grade = reader.readByte()
		this.level = reader.readShort()
	}

	public hydrate(
		data: MonsterInGroupLightInformations | Record<string, any>
	): MonsterInGroupLightInformations {
		if (data instanceof MonsterInGroupLightInformations) {
			return data
		}

		this.genericId = data.genericId
		this.grade = data.grade
		this.level = data.level

		return this
	}
}

export interface RawMonsterInGroupInformations
	extends RawMonsterInGroupLightInformations {
	id: number
	look: EntityLook
}

export class MonsterInGroupInformations extends MonsterInGroupLightInformations {
	public static id: number = 3232

	public look: EntityLook | undefined

	public constructor(
		genericId?: number | undefined,
		grade?: number | undefined,
		level?: number | undefined,
		look?: EntityLook | undefined
	) {
		super(genericId, grade, level)
		this.look = look
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		this.look!.serialize(writer)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.look = new EntityLook()
		this.look!.deserialize(reader)
	}

	public hydrate(
		data: MonsterInGroupInformations | Record<string, any>
	): MonsterInGroupInformations {
		if (data instanceof MonsterInGroupInformations) {
			return data
		}

		super.hydrate(data)

		this.look = new EntityLook().hydrate(data.look)

		return this
	}
}

export interface RawMapObstacle {
	id: number
	obstacleCellId: number
	state: number
}

export class MapObstacle extends DofusType {
	public static id: number = 7674

	public obstacleCellId: number | undefined = 0
	public state: number | undefined = 0

	public constructor(
		obstacleCellId?: number | undefined,
		state?: number | undefined
	) {
		super()
		this.obstacleCellId = obstacleCellId
		this.state = state
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarShort(this.obstacleCellId!)
		writer.writeByte(this.state!)
	}

	public deserialize(reader: BinaryReader): void {
		this.obstacleCellId = reader.readVarShort()
		this.state = reader.readByte()
	}

	public hydrate(data: MapObstacle | Record<string, any>): MapObstacle {
		if (data instanceof MapObstacle) {
			return data
		}

		this.obstacleCellId = data.obstacleCellId
		this.state = data.state

		return this
	}
}

export interface RawGroupMonsterStaticInformationsWithAlternatives
	extends RawGroupMonsterStaticInformations {
	id: number
	alternatives: AlternativeMonstersInGroupLightInformations[]
}

export class GroupMonsterStaticInformationsWithAlternatives extends GroupMonsterStaticInformations {
	public static id: number = 8629

	public alternatives: AlternativeMonstersInGroupLightInformations[] | undefined

	public constructor(
		mainCreatureLightInfos?: MonsterInGroupLightInformations | undefined,
		underlings?: MonsterInGroupInformations[] | undefined,
		alternatives?: AlternativeMonstersInGroupLightInformations[] | undefined
	) {
		super(mainCreatureLightInfos, underlings)
		this.alternatives = alternatives
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeShort(this.alternatives!.length)
		this.alternatives!.forEach((current) => {
			current.serialize(writer)
		})
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.alternatives = []
		const countAlternatives = reader.readShort()
		for (let i: number = 0; i < countAlternatives; i++) {
			const type: AlternativeMonstersInGroupLightInformations = new AlternativeMonstersInGroupLightInformations()
			type.deserialize(reader)
			this.alternatives.push(type)
		}
	}

	public hydrate(
		data: GroupMonsterStaticInformationsWithAlternatives | Record<string, any>
	): GroupMonsterStaticInformationsWithAlternatives {
		if (data instanceof GroupMonsterStaticInformationsWithAlternatives) {
			return data
		}

		super.hydrate(data)

		this.alternatives = data.alternatives.map(
			(
				dataElement:
					| AlternativeMonstersInGroupLightInformations
					| Record<string, any>
			): AlternativeMonstersInGroupLightInformations => {
				if (
					dataElement instanceof AlternativeMonstersInGroupLightInformations
				) {
					return dataElement
				} else {
					return new AlternativeMonstersInGroupLightInformations().hydrate(
						dataElement
					)
				}
			}
		)

		return this
	}
}

export interface RawFightEntityDispositionInformations
	extends RawEntityDispositionInformations {
	id: number
	carryingCharacterId: number
}

export class FightEntityDispositionInformations extends EntityDispositionInformations {
	public static id: number = 4954

	public carryingCharacterId: number | undefined = 0

	public constructor(
		cellId?: number | undefined,
		direction?: number | undefined,
		carryingCharacterId?: number | undefined
	) {
		super(cellId, direction)
		this.carryingCharacterId = carryingCharacterId
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeDouble(this.carryingCharacterId!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.carryingCharacterId = reader.readDouble()
	}

	public hydrate(
		data: FightEntityDispositionInformations | Record<string, any>
	): FightEntityDispositionInformations {
		if (data instanceof FightEntityDispositionInformations) {
			return data
		}

		super.hydrate(data)

		this.carryingCharacterId = data.carryingCharacterId

		return this
	}
}

export interface RawBreachBranch {
	id: number
	room: number
	element: number
	bosses: MonsterInGroupLightInformations[]
	map: number
	score: number
	relativeScore: number
	monsters: MonsterInGroupLightInformations[]
}

export class BreachBranch extends DofusType {
	public static id: number = 4379

	public room: number | undefined = 0
	public element: number | undefined = 0
	public bosses: MonsterInGroupLightInformations[] | undefined
	public map: number | undefined = 0
	public score: number | undefined = 0
	public relativeScore: number | undefined = 0
	public monsters: MonsterInGroupLightInformations[] | undefined

	public constructor(
		room?: number | undefined,
		element?: number | undefined,
		bosses?: MonsterInGroupLightInformations[] | undefined,
		map?: number | undefined,
		score?: number | undefined,
		relativeScore?: number | undefined,
		monsters?: MonsterInGroupLightInformations[] | undefined
	) {
		super()
		this.room = room
		this.element = element
		this.bosses = bosses
		this.map = map
		this.score = score
		this.relativeScore = relativeScore
		this.monsters = monsters
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeByte(this.room!)
		writer.writeInt(this.element!)
		writer.writeShort(this.bosses!.length)
		this.bosses!.forEach((current) => {
			current.serialize(writer)
		})
		writer.writeDouble(this.map!)
		writer.writeShort(this.score!)
		writer.writeShort(this.relativeScore!)
		writer.writeShort(this.monsters!.length)
		this.monsters!.forEach((current) => {
			current.serialize(writer)
		})
	}

	public deserialize(reader: BinaryReader): void {
		this.room = reader.readByte()
		this.element = reader.readInt()
		this.bosses = []
		const countBosses = reader.readShort()
		for (let i: number = 0; i < countBosses; i++) {
			const type: MonsterInGroupLightInformations = new MonsterInGroupLightInformations()
			type.deserialize(reader)
			this.bosses.push(type)
		}
		this.map = reader.readDouble()
		this.score = reader.readShort()
		this.relativeScore = reader.readShort()
		this.monsters = []
		const countMonsters = reader.readShort()
		for (let i: number = 0; i < countMonsters; i++) {
			const type: MonsterInGroupLightInformations = new MonsterInGroupLightInformations()
			type.deserialize(reader)
			this.monsters.push(type)
		}
	}

	public hydrate(data: BreachBranch | Record<string, any>): BreachBranch {
		if (data instanceof BreachBranch) {
			return data
		}

		this.room = data.room
		this.element = data.element
		this.bosses = data.bosses.map(
			(
				dataElement: MonsterInGroupLightInformations | Record<string, any>
			): MonsterInGroupLightInformations => {
				if (dataElement instanceof MonsterInGroupLightInformations) {
					return dataElement
				} else {
					return new MonsterInGroupLightInformations().hydrate(dataElement)
				}
			}
		)
		this.map = data.map
		this.score = data.score
		this.relativeScore = data.relativeScore
		this.monsters = data.monsters.map(
			(
				dataElement: MonsterInGroupLightInformations | Record<string, any>
			): MonsterInGroupLightInformations => {
				if (dataElement instanceof MonsterInGroupLightInformations) {
					return dataElement
				} else {
					return new MonsterInGroupLightInformations().hydrate(dataElement)
				}
			}
		)

		return this
	}
}

export interface RawGameFightMinimalStats {
	id: number
	lifePoints: number
	maxLifePoints: number
	baseMaxLifePoints: number
	permanentDamagePercent: number
	shieldPoints: number
	actionPoints: number
	maxActionPoints: number
	movementPoints: number
	maxMovementPoints: number
	summoner: number
	summoned: boolean
	neutralElementResistPercent: number
	earthElementResistPercent: number
	waterElementResistPercent: number
	airElementResistPercent: number
	fireElementResistPercent: number
	neutralElementReduction: number
	earthElementReduction: number
	waterElementReduction: number
	airElementReduction: number
	fireElementReduction: number
	criticalDamageFixedResist: number
	pushDamageFixedResist: number
	pvpNeutralElementResistPercent: number
	pvpEarthElementResistPercent: number
	pvpWaterElementResistPercent: number
	pvpAirElementResistPercent: number
	pvpFireElementResistPercent: number
	pvpNeutralElementReduction: number
	pvpEarthElementReduction: number
	pvpWaterElementReduction: number
	pvpAirElementReduction: number
	pvpFireElementReduction: number
	dodgePALostProbability: number
	dodgePMLostProbability: number
	tackleBlock: number
	tackleEvade: number
	fixedDamageReflection: number
	invisibilityState: number
	meleeDamageReceivedPercent: number
	rangedDamageReceivedPercent: number
	weaponDamageReceivedPercent: number
	spellDamageReceivedPercent: number
}

export class GameFightMinimalStats extends DofusType {
	public static id: number = 8253

	public lifePoints: number | undefined = 0
	public maxLifePoints: number | undefined = 0
	public baseMaxLifePoints: number | undefined = 0
	public permanentDamagePercent: number | undefined = 0
	public shieldPoints: number | undefined = 0
	public actionPoints: number | undefined = 0
	public maxActionPoints: number | undefined = 0
	public movementPoints: number | undefined = 0
	public maxMovementPoints: number | undefined = 0
	public summoner: number | undefined = 0
	public summoned: boolean | undefined = false
	public neutralElementResistPercent: number | undefined = 0
	public earthElementResistPercent: number | undefined = 0
	public waterElementResistPercent: number | undefined = 0
	public airElementResistPercent: number | undefined = 0
	public fireElementResistPercent: number | undefined = 0
	public neutralElementReduction: number | undefined = 0
	public earthElementReduction: number | undefined = 0
	public waterElementReduction: number | undefined = 0
	public airElementReduction: number | undefined = 0
	public fireElementReduction: number | undefined = 0
	public criticalDamageFixedResist: number | undefined = 0
	public pushDamageFixedResist: number | undefined = 0
	public pvpNeutralElementResistPercent: number | undefined = 0
	public pvpEarthElementResistPercent: number | undefined = 0
	public pvpWaterElementResistPercent: number | undefined = 0
	public pvpAirElementResistPercent: number | undefined = 0
	public pvpFireElementResistPercent: number | undefined = 0
	public pvpNeutralElementReduction: number | undefined = 0
	public pvpEarthElementReduction: number | undefined = 0
	public pvpWaterElementReduction: number | undefined = 0
	public pvpAirElementReduction: number | undefined = 0
	public pvpFireElementReduction: number | undefined = 0
	public dodgePALostProbability: number | undefined = 0
	public dodgePMLostProbability: number | undefined = 0
	public tackleBlock: number | undefined = 0
	public tackleEvade: number | undefined = 0
	public fixedDamageReflection: number | undefined = 0
	public invisibilityState: number | undefined = 0
	public meleeDamageReceivedPercent: number | undefined = 0
	public rangedDamageReceivedPercent: number | undefined = 0
	public weaponDamageReceivedPercent: number | undefined = 0
	public spellDamageReceivedPercent: number | undefined = 0

	public constructor(
		lifePoints?: number | undefined,
		maxLifePoints?: number | undefined,
		baseMaxLifePoints?: number | undefined,
		permanentDamagePercent?: number | undefined,
		shieldPoints?: number | undefined,
		actionPoints?: number | undefined,
		maxActionPoints?: number | undefined,
		movementPoints?: number | undefined,
		maxMovementPoints?: number | undefined,
		summoner?: number | undefined,
		summoned?: boolean | undefined,
		neutralElementResistPercent?: number | undefined,
		earthElementResistPercent?: number | undefined,
		waterElementResistPercent?: number | undefined,
		airElementResistPercent?: number | undefined,
		fireElementResistPercent?: number | undefined,
		neutralElementReduction?: number | undefined,
		earthElementReduction?: number | undefined,
		waterElementReduction?: number | undefined,
		airElementReduction?: number | undefined,
		fireElementReduction?: number | undefined,
		criticalDamageFixedResist?: number | undefined,
		pushDamageFixedResist?: number | undefined,
		pvpNeutralElementResistPercent?: number | undefined,
		pvpEarthElementResistPercent?: number | undefined,
		pvpWaterElementResistPercent?: number | undefined,
		pvpAirElementResistPercent?: number | undefined,
		pvpFireElementResistPercent?: number | undefined,
		pvpNeutralElementReduction?: number | undefined,
		pvpEarthElementReduction?: number | undefined,
		pvpWaterElementReduction?: number | undefined,
		pvpAirElementReduction?: number | undefined,
		pvpFireElementReduction?: number | undefined,
		dodgePALostProbability?: number | undefined,
		dodgePMLostProbability?: number | undefined,
		tackleBlock?: number | undefined,
		tackleEvade?: number | undefined,
		fixedDamageReflection?: number | undefined,
		invisibilityState?: number | undefined,
		meleeDamageReceivedPercent?: number | undefined,
		rangedDamageReceivedPercent?: number | undefined,
		weaponDamageReceivedPercent?: number | undefined,
		spellDamageReceivedPercent?: number | undefined
	) {
		super()
		this.lifePoints = lifePoints
		this.maxLifePoints = maxLifePoints
		this.baseMaxLifePoints = baseMaxLifePoints
		this.permanentDamagePercent = permanentDamagePercent
		this.shieldPoints = shieldPoints
		this.actionPoints = actionPoints
		this.maxActionPoints = maxActionPoints
		this.movementPoints = movementPoints
		this.maxMovementPoints = maxMovementPoints
		this.summoner = summoner
		this.summoned = summoned
		this.neutralElementResistPercent = neutralElementResistPercent
		this.earthElementResistPercent = earthElementResistPercent
		this.waterElementResistPercent = waterElementResistPercent
		this.airElementResistPercent = airElementResistPercent
		this.fireElementResistPercent = fireElementResistPercent
		this.neutralElementReduction = neutralElementReduction
		this.earthElementReduction = earthElementReduction
		this.waterElementReduction = waterElementReduction
		this.airElementReduction = airElementReduction
		this.fireElementReduction = fireElementReduction
		this.criticalDamageFixedResist = criticalDamageFixedResist
		this.pushDamageFixedResist = pushDamageFixedResist
		this.pvpNeutralElementResistPercent = pvpNeutralElementResistPercent
		this.pvpEarthElementResistPercent = pvpEarthElementResistPercent
		this.pvpWaterElementResistPercent = pvpWaterElementResistPercent
		this.pvpAirElementResistPercent = pvpAirElementResistPercent
		this.pvpFireElementResistPercent = pvpFireElementResistPercent
		this.pvpNeutralElementReduction = pvpNeutralElementReduction
		this.pvpEarthElementReduction = pvpEarthElementReduction
		this.pvpWaterElementReduction = pvpWaterElementReduction
		this.pvpAirElementReduction = pvpAirElementReduction
		this.pvpFireElementReduction = pvpFireElementReduction
		this.dodgePALostProbability = dodgePALostProbability
		this.dodgePMLostProbability = dodgePMLostProbability
		this.tackleBlock = tackleBlock
		this.tackleEvade = tackleEvade
		this.fixedDamageReflection = fixedDamageReflection
		this.invisibilityState = invisibilityState
		this.meleeDamageReceivedPercent = meleeDamageReceivedPercent
		this.rangedDamageReceivedPercent = rangedDamageReceivedPercent
		this.weaponDamageReceivedPercent = weaponDamageReceivedPercent
		this.spellDamageReceivedPercent = spellDamageReceivedPercent
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarInt(this.lifePoints!)
		writer.writeVarInt(this.maxLifePoints!)
		writer.writeVarInt(this.baseMaxLifePoints!)
		writer.writeVarInt(this.permanentDamagePercent!)
		writer.writeVarInt(this.shieldPoints!)
		writer.writeVarShort(this.actionPoints!)
		writer.writeVarShort(this.maxActionPoints!)
		writer.writeVarShort(this.movementPoints!)
		writer.writeVarShort(this.maxMovementPoints!)
		writer.writeDouble(this.summoner!)
		writer.writeBoolean(this.summoned!)
		writer.writeVarShort(this.neutralElementResistPercent!)
		writer.writeVarShort(this.earthElementResistPercent!)
		writer.writeVarShort(this.waterElementResistPercent!)
		writer.writeVarShort(this.airElementResistPercent!)
		writer.writeVarShort(this.fireElementResistPercent!)
		writer.writeVarShort(this.neutralElementReduction!)
		writer.writeVarShort(this.earthElementReduction!)
		writer.writeVarShort(this.waterElementReduction!)
		writer.writeVarShort(this.airElementReduction!)
		writer.writeVarShort(this.fireElementReduction!)
		writer.writeVarShort(this.criticalDamageFixedResist!)
		writer.writeVarShort(this.pushDamageFixedResist!)
		writer.writeVarShort(this.pvpNeutralElementResistPercent!)
		writer.writeVarShort(this.pvpEarthElementResistPercent!)
		writer.writeVarShort(this.pvpWaterElementResistPercent!)
		writer.writeVarShort(this.pvpAirElementResistPercent!)
		writer.writeVarShort(this.pvpFireElementResistPercent!)
		writer.writeVarShort(this.pvpNeutralElementReduction!)
		writer.writeVarShort(this.pvpEarthElementReduction!)
		writer.writeVarShort(this.pvpWaterElementReduction!)
		writer.writeVarShort(this.pvpAirElementReduction!)
		writer.writeVarShort(this.pvpFireElementReduction!)
		writer.writeVarShort(this.dodgePALostProbability!)
		writer.writeVarShort(this.dodgePMLostProbability!)
		writer.writeVarShort(this.tackleBlock!)
		writer.writeVarShort(this.tackleEvade!)
		writer.writeVarShort(this.fixedDamageReflection!)
		writer.writeByte(this.invisibilityState!)
		writer.writeVarShort(this.meleeDamageReceivedPercent!)
		writer.writeVarShort(this.rangedDamageReceivedPercent!)
		writer.writeVarShort(this.weaponDamageReceivedPercent!)
		writer.writeVarShort(this.spellDamageReceivedPercent!)
	}

	public deserialize(reader: BinaryReader): void {
		this.lifePoints = reader.readVarInt()
		this.maxLifePoints = reader.readVarInt()
		this.baseMaxLifePoints = reader.readVarInt()
		this.permanentDamagePercent = reader.readVarInt()
		this.shieldPoints = reader.readVarInt()
		this.actionPoints = reader.readVarShort()
		this.maxActionPoints = reader.readVarShort()
		this.movementPoints = reader.readVarShort()
		this.maxMovementPoints = reader.readVarShort()
		this.summoner = reader.readDouble()
		this.summoned = reader.readBoolean()
		this.neutralElementResistPercent = reader.readVarShort()
		this.earthElementResistPercent = reader.readVarShort()
		this.waterElementResistPercent = reader.readVarShort()
		this.airElementResistPercent = reader.readVarShort()
		this.fireElementResistPercent = reader.readVarShort()
		this.neutralElementReduction = reader.readVarShort()
		this.earthElementReduction = reader.readVarShort()
		this.waterElementReduction = reader.readVarShort()
		this.airElementReduction = reader.readVarShort()
		this.fireElementReduction = reader.readVarShort()
		this.criticalDamageFixedResist = reader.readVarShort()
		this.pushDamageFixedResist = reader.readVarShort()
		this.pvpNeutralElementResistPercent = reader.readVarShort()
		this.pvpEarthElementResistPercent = reader.readVarShort()
		this.pvpWaterElementResistPercent = reader.readVarShort()
		this.pvpAirElementResistPercent = reader.readVarShort()
		this.pvpFireElementResistPercent = reader.readVarShort()
		this.pvpNeutralElementReduction = reader.readVarShort()
		this.pvpEarthElementReduction = reader.readVarShort()
		this.pvpWaterElementReduction = reader.readVarShort()
		this.pvpAirElementReduction = reader.readVarShort()
		this.pvpFireElementReduction = reader.readVarShort()
		this.dodgePALostProbability = reader.readVarShort()
		this.dodgePMLostProbability = reader.readVarShort()
		this.tackleBlock = reader.readVarShort()
		this.tackleEvade = reader.readVarShort()
		this.fixedDamageReflection = reader.readVarShort()
		this.invisibilityState = reader.readByte()
		this.meleeDamageReceivedPercent = reader.readVarShort()
		this.rangedDamageReceivedPercent = reader.readVarShort()
		this.weaponDamageReceivedPercent = reader.readVarShort()
		this.spellDamageReceivedPercent = reader.readVarShort()
	}

	public hydrate(
		data: GameFightMinimalStats | Record<string, any>
	): GameFightMinimalStats {
		if (data instanceof GameFightMinimalStats) {
			return data
		}

		this.lifePoints = data.lifePoints
		this.maxLifePoints = data.maxLifePoints
		this.baseMaxLifePoints = data.baseMaxLifePoints
		this.permanentDamagePercent = data.permanentDamagePercent
		this.shieldPoints = data.shieldPoints
		this.actionPoints = data.actionPoints
		this.maxActionPoints = data.maxActionPoints
		this.movementPoints = data.movementPoints
		this.maxMovementPoints = data.maxMovementPoints
		this.summoner = data.summoner
		this.summoned = data.summoned
		this.neutralElementResistPercent = data.neutralElementResistPercent
		this.earthElementResistPercent = data.earthElementResistPercent
		this.waterElementResistPercent = data.waterElementResistPercent
		this.airElementResistPercent = data.airElementResistPercent
		this.fireElementResistPercent = data.fireElementResistPercent
		this.neutralElementReduction = data.neutralElementReduction
		this.earthElementReduction = data.earthElementReduction
		this.waterElementReduction = data.waterElementReduction
		this.airElementReduction = data.airElementReduction
		this.fireElementReduction = data.fireElementReduction
		this.criticalDamageFixedResist = data.criticalDamageFixedResist
		this.pushDamageFixedResist = data.pushDamageFixedResist
		this.pvpNeutralElementResistPercent = data.pvpNeutralElementResistPercent
		this.pvpEarthElementResistPercent = data.pvpEarthElementResistPercent
		this.pvpWaterElementResistPercent = data.pvpWaterElementResistPercent
		this.pvpAirElementResistPercent = data.pvpAirElementResistPercent
		this.pvpFireElementResistPercent = data.pvpFireElementResistPercent
		this.pvpNeutralElementReduction = data.pvpNeutralElementReduction
		this.pvpEarthElementReduction = data.pvpEarthElementReduction
		this.pvpWaterElementReduction = data.pvpWaterElementReduction
		this.pvpAirElementReduction = data.pvpAirElementReduction
		this.pvpFireElementReduction = data.pvpFireElementReduction
		this.dodgePALostProbability = data.dodgePALostProbability
		this.dodgePMLostProbability = data.dodgePMLostProbability
		this.tackleBlock = data.tackleBlock
		this.tackleEvade = data.tackleEvade
		this.fixedDamageReflection = data.fixedDamageReflection
		this.invisibilityState = data.invisibilityState
		this.meleeDamageReceivedPercent = data.meleeDamageReceivedPercent
		this.rangedDamageReceivedPercent = data.rangedDamageReceivedPercent
		this.weaponDamageReceivedPercent = data.weaponDamageReceivedPercent
		this.spellDamageReceivedPercent = data.spellDamageReceivedPercent

		return this
	}
}

export interface RawGameFightMinimalStatsPreparation
	extends RawGameFightMinimalStats {
	id: number
	initiative: number
}

export class GameFightMinimalStatsPreparation extends GameFightMinimalStats {
	public static id: number = 9464

	public initiative: number | undefined = 0

	public constructor(
		lifePoints?: number | undefined,
		maxLifePoints?: number | undefined,
		baseMaxLifePoints?: number | undefined,
		permanentDamagePercent?: number | undefined,
		shieldPoints?: number | undefined,
		actionPoints?: number | undefined,
		maxActionPoints?: number | undefined,
		movementPoints?: number | undefined,
		maxMovementPoints?: number | undefined,
		summoner?: number | undefined,
		summoned?: boolean | undefined,
		neutralElementResistPercent?: number | undefined,
		earthElementResistPercent?: number | undefined,
		waterElementResistPercent?: number | undefined,
		airElementResistPercent?: number | undefined,
		fireElementResistPercent?: number | undefined,
		neutralElementReduction?: number | undefined,
		earthElementReduction?: number | undefined,
		waterElementReduction?: number | undefined,
		airElementReduction?: number | undefined,
		fireElementReduction?: number | undefined,
		criticalDamageFixedResist?: number | undefined,
		pushDamageFixedResist?: number | undefined,
		pvpNeutralElementResistPercent?: number | undefined,
		pvpEarthElementResistPercent?: number | undefined,
		pvpWaterElementResistPercent?: number | undefined,
		pvpAirElementResistPercent?: number | undefined,
		pvpFireElementResistPercent?: number | undefined,
		pvpNeutralElementReduction?: number | undefined,
		pvpEarthElementReduction?: number | undefined,
		pvpWaterElementReduction?: number | undefined,
		pvpAirElementReduction?: number | undefined,
		pvpFireElementReduction?: number | undefined,
		dodgePALostProbability?: number | undefined,
		dodgePMLostProbability?: number | undefined,
		tackleBlock?: number | undefined,
		tackleEvade?: number | undefined,
		fixedDamageReflection?: number | undefined,
		invisibilityState?: number | undefined,
		meleeDamageReceivedPercent?: number | undefined,
		rangedDamageReceivedPercent?: number | undefined,
		weaponDamageReceivedPercent?: number | undefined,
		spellDamageReceivedPercent?: number | undefined,
		initiative?: number | undefined
	) {
		super(
			lifePoints,
			maxLifePoints,
			baseMaxLifePoints,
			permanentDamagePercent,
			shieldPoints,
			actionPoints,
			maxActionPoints,
			movementPoints,
			maxMovementPoints,
			summoner,
			summoned,
			neutralElementResistPercent,
			earthElementResistPercent,
			waterElementResistPercent,
			airElementResistPercent,
			fireElementResistPercent,
			neutralElementReduction,
			earthElementReduction,
			waterElementReduction,
			airElementReduction,
			fireElementReduction,
			criticalDamageFixedResist,
			pushDamageFixedResist,
			pvpNeutralElementResistPercent,
			pvpEarthElementResistPercent,
			pvpWaterElementResistPercent,
			pvpAirElementResistPercent,
			pvpFireElementResistPercent,
			pvpNeutralElementReduction,
			pvpEarthElementReduction,
			pvpWaterElementReduction,
			pvpAirElementReduction,
			pvpFireElementReduction,
			dodgePALostProbability,
			dodgePMLostProbability,
			tackleBlock,
			tackleEvade,
			fixedDamageReflection,
			invisibilityState,
			meleeDamageReceivedPercent,
			rangedDamageReceivedPercent,
			weaponDamageReceivedPercent,
			spellDamageReceivedPercent
		)
		this.initiative = initiative
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeVarInt(this.initiative!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.initiative = reader.readVarInt()
	}

	public hydrate(
		data: GameFightMinimalStatsPreparation | Record<string, any>
	): GameFightMinimalStatsPreparation {
		if (data instanceof GameFightMinimalStatsPreparation) {
			return data
		}

		super.hydrate(data)

		this.initiative = data.initiative

		return this
	}
}

export interface RawIdentifiedEntityDispositionInformations
	extends RawEntityDispositionInformations {
	id: number
	id_: number
}

export class IdentifiedEntityDispositionInformations extends EntityDispositionInformations {
	public static id: number = 4029

	public id_: number | undefined = 0

	public constructor(
		cellId?: number | undefined,
		direction?: number | undefined,
		id_?: number | undefined
	) {
		super(cellId, direction)
		this.id_ = id_
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeDouble(this.id_!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.id_ = reader.readDouble()
	}

	public hydrate(
		data: IdentifiedEntityDispositionInformations | Record<string, any>
	): IdentifiedEntityDispositionInformations {
		if (data instanceof IdentifiedEntityDispositionInformations) {
			return data
		}

		super.hydrate(data)

		this.id_ = data.id_

		return this
	}
}

export interface RawStatedElement {
	id: number
	elementId: number
	elementCellId: number
	elementState: number
	onCurrentMap: boolean
}

export class StatedElement extends DofusType {
	public static id: number = 335

	public elementId: number | undefined = 0
	public elementCellId: number | undefined = 0
	public elementState: number | undefined = 0
	public onCurrentMap: boolean | undefined = false

	public constructor(
		elementId?: number | undefined,
		elementCellId?: number | undefined,
		elementState?: number | undefined,
		onCurrentMap?: boolean | undefined
	) {
		super()
		this.elementId = elementId
		this.elementCellId = elementCellId
		this.elementState = elementState
		this.onCurrentMap = onCurrentMap
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeInt(this.elementId!)
		writer.writeVarShort(this.elementCellId!)
		writer.writeVarInt(this.elementState!)
		writer.writeBoolean(this.onCurrentMap!)
	}

	public deserialize(reader: BinaryReader): void {
		this.elementId = reader.readInt()
		this.elementCellId = reader.readVarShort()
		this.elementState = reader.readVarInt()
		this.onCurrentMap = reader.readBoolean()
	}

	public hydrate(data: StatedElement | Record<string, any>): StatedElement {
		if (data instanceof StatedElement) {
			return data
		}

		this.elementId = data.elementId
		this.elementCellId = data.elementCellId
		this.elementState = data.elementState
		this.onCurrentMap = data.onCurrentMap

		return this
	}
}

export interface RawActorRestrictionsInformations {
	id: number
	cantBeAggressed: boolean
	cantBeChallenged: boolean
	cantTrade: boolean
	cantBeAttackedByMutant: boolean
	cantRun: boolean
	forceSlowWalk: boolean
	cantMinimize: boolean
	cantMove: boolean
	cantAggress: boolean
	cantChallenge: boolean
	cantExchange: boolean
	cantAttack: boolean
	cantChat: boolean
	cantBeMerchant: boolean
	cantUseObject: boolean
	cantUseTaxCollector: boolean
	cantUseInteractive: boolean
	cantSpeakToNPC: boolean
	cantChangeZone: boolean
	cantAttackMonster: boolean
	cantWalk8Directions: boolean
}

export class ActorRestrictionsInformations extends DofusType {
	public static id: number = 2284

	public cantBeAggressed: boolean | undefined = false
	public cantBeChallenged: boolean | undefined = false
	public cantTrade: boolean | undefined = false
	public cantBeAttackedByMutant: boolean | undefined = false
	public cantRun: boolean | undefined = false
	public forceSlowWalk: boolean | undefined = false
	public cantMinimize: boolean | undefined = false
	public cantMove: boolean | undefined = false
	public cantAggress: boolean | undefined = false
	public cantChallenge: boolean | undefined = false
	public cantExchange: boolean | undefined = false
	public cantAttack: boolean | undefined = false
	public cantChat: boolean | undefined = false
	public cantBeMerchant: boolean | undefined = false
	public cantUseObject: boolean | undefined = false
	public cantUseTaxCollector: boolean | undefined = false
	public cantUseInteractive: boolean | undefined = false
	public cantSpeakToNPC: boolean | undefined = false
	public cantChangeZone: boolean | undefined = false
	public cantAttackMonster: boolean | undefined = false
	public cantWalk8Directions: boolean | undefined = false

	public constructor(
		cantBeAggressed?: boolean | undefined,
		cantBeChallenged?: boolean | undefined,
		cantTrade?: boolean | undefined,
		cantBeAttackedByMutant?: boolean | undefined,
		cantRun?: boolean | undefined,
		forceSlowWalk?: boolean | undefined,
		cantMinimize?: boolean | undefined,
		cantMove?: boolean | undefined,
		cantAggress?: boolean | undefined,
		cantChallenge?: boolean | undefined,
		cantExchange?: boolean | undefined,
		cantAttack?: boolean | undefined,
		cantChat?: boolean | undefined,
		cantBeMerchant?: boolean | undefined,
		cantUseObject?: boolean | undefined,
		cantUseTaxCollector?: boolean | undefined,
		cantUseInteractive?: boolean | undefined,
		cantSpeakToNPC?: boolean | undefined,
		cantChangeZone?: boolean | undefined,
		cantAttackMonster?: boolean | undefined,
		cantWalk8Directions?: boolean | undefined
	) {
		super()
		this.cantBeAggressed = cantBeAggressed
		this.cantBeChallenged = cantBeChallenged
		this.cantTrade = cantTrade
		this.cantBeAttackedByMutant = cantBeAttackedByMutant
		this.cantRun = cantRun
		this.forceSlowWalk = forceSlowWalk
		this.cantMinimize = cantMinimize
		this.cantMove = cantMove
		this.cantAggress = cantAggress
		this.cantChallenge = cantChallenge
		this.cantExchange = cantExchange
		this.cantAttack = cantAttack
		this.cantChat = cantChat
		this.cantBeMerchant = cantBeMerchant
		this.cantUseObject = cantUseObject
		this.cantUseTaxCollector = cantUseTaxCollector
		this.cantUseInteractive = cantUseInteractive
		this.cantSpeakToNPC = cantSpeakToNPC
		this.cantChangeZone = cantChangeZone
		this.cantAttackMonster = cantAttackMonster
		this.cantWalk8Directions = cantWalk8Directions
	}

	public serialize(writer: BinaryWriter): void {
		let box0: number = 0
		box0 = setFlag(box0, 0, this.cantBeAggressed!)
		box0 = setFlag(box0, 1, this.cantBeChallenged!)
		box0 = setFlag(box0, 2, this.cantTrade!)
		box0 = setFlag(box0, 3, this.cantBeAttackedByMutant!)
		box0 = setFlag(box0, 4, this.cantRun!)
		box0 = setFlag(box0, 5, this.forceSlowWalk!)
		box0 = setFlag(box0, 6, this.cantMinimize!)
		box0 = setFlag(box0, 7, this.cantMove!)
		writer.writeByte(box0)
		let box1: number = 0
		box1 = setFlag(box1, 0, this.cantAggress!)
		box1 = setFlag(box1, 1, this.cantChallenge!)
		box1 = setFlag(box1, 2, this.cantExchange!)
		box1 = setFlag(box1, 3, this.cantAttack!)
		box1 = setFlag(box1, 4, this.cantChat!)
		box1 = setFlag(box1, 5, this.cantBeMerchant!)
		box1 = setFlag(box1, 6, this.cantUseObject!)
		box1 = setFlag(box1, 7, this.cantUseTaxCollector!)
		writer.writeByte(box1)
		let box2: number = 0
		box2 = setFlag(box2, 0, this.cantUseInteractive!)
		box2 = setFlag(box2, 1, this.cantSpeakToNPC!)
		box2 = setFlag(box2, 2, this.cantChangeZone!)
		box2 = setFlag(box2, 3, this.cantAttackMonster!)
		box2 = setFlag(box2, 4, this.cantWalk8Directions!)
		writer.writeByte(box2)
	}

	public deserialize(reader: BinaryReader): void {
		const box0 = reader.readByte()
		this.cantBeAggressed = getFlag(box0, 0)
		this.cantBeChallenged = getFlag(box0, 1)
		this.cantTrade = getFlag(box0, 2)
		this.cantBeAttackedByMutant = getFlag(box0, 3)
		this.cantRun = getFlag(box0, 4)
		this.forceSlowWalk = getFlag(box0, 5)
		this.cantMinimize = getFlag(box0, 6)
		this.cantMove = getFlag(box0, 7)
		const box1 = reader.readByte()
		this.cantAggress = getFlag(box1, 0)
		this.cantChallenge = getFlag(box1, 1)
		this.cantExchange = getFlag(box1, 2)
		this.cantAttack = getFlag(box1, 3)
		this.cantChat = getFlag(box1, 4)
		this.cantBeMerchant = getFlag(box1, 5)
		this.cantUseObject = getFlag(box1, 6)
		this.cantUseTaxCollector = getFlag(box1, 7)
		const box2 = reader.readByte()
		this.cantUseInteractive = getFlag(box2, 0)
		this.cantSpeakToNPC = getFlag(box2, 1)
		this.cantChangeZone = getFlag(box2, 2)
		this.cantAttackMonster = getFlag(box2, 3)
		this.cantWalk8Directions = getFlag(box2, 4)
	}

	public hydrate(
		data: ActorRestrictionsInformations | Record<string, any>
	): ActorRestrictionsInformations {
		if (data instanceof ActorRestrictionsInformations) {
			return data
		}

		this.cantBeAggressed = data.cantBeAggressed
		this.cantBeChallenged = data.cantBeChallenged
		this.cantTrade = data.cantTrade
		this.cantBeAttackedByMutant = data.cantBeAttackedByMutant
		this.cantRun = data.cantRun
		this.forceSlowWalk = data.forceSlowWalk
		this.cantMinimize = data.cantMinimize
		this.cantMove = data.cantMove
		this.cantAggress = data.cantAggress
		this.cantChallenge = data.cantChallenge
		this.cantExchange = data.cantExchange
		this.cantAttack = data.cantAttack
		this.cantChat = data.cantChat
		this.cantBeMerchant = data.cantBeMerchant
		this.cantUseObject = data.cantUseObject
		this.cantUseTaxCollector = data.cantUseTaxCollector
		this.cantUseInteractive = data.cantUseInteractive
		this.cantSpeakToNPC = data.cantSpeakToNPC
		this.cantChangeZone = data.cantChangeZone
		this.cantAttackMonster = data.cantAttackMonster
		this.cantWalk8Directions = data.cantWalk8Directions

		return this
	}
}

export class SpellModifierMessage extends DofusType {
	public static id: number = 1094

	public spellId: number | undefined = 0
	public actionType: number | undefined = 0
	public modifierType: number | undefined = 0
	public context: number | undefined = 0
	public equipment: number | undefined = 0

	public constructor(
		spellId?: number | undefined,
		actionType?: number | undefined,
		modifierType?: number | undefined,
		context?: number | undefined,
		equipment?: number | undefined
	) {
		super()
		this.spellId = spellId
		this.actionType = actionType
		this.modifierType = modifierType
		this.context = context
		this.equipment = equipment
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarShort(this.spellId!)
		writer.writeByte(this.actionType!)
		writer.writeByte(this.modifierType!)
		writer.writeInt(this.context!)
		writer.writeInt(this.equipment!)
	}

	public deserialize(reader: BinaryReader): void {
		this.spellId = reader.readVarUShort()
		this.actionType = reader.readByte()
		this.modifierType = reader.readByte()
		this.context = reader.readInt()
		this.equipment = reader.readInt()
	}
}

export class CharacterCharacteristic extends DofusType {
	public static id: number = 9225

	public characteristicId: number | undefined = 0

	constructor(characteristicId?: number | undefined) {
		super()
		this.characteristicId = characteristicId
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeShort(this.characteristicId!)
	}

	public deserialize(reader: BinaryReader): void {
		this.characteristicId = reader.readShort()
	}
}

export class CharacterCharacteristicValue extends CharacterCharacteristic {
	public static id: number = 9830

	public total: number | undefined = 0

	constructor(
		characteristicId?: number | undefined,
		total?: number | undefined
	) {
		super(characteristicId)
		this.total = total
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeInt(this.total!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.total = reader.readInt()
	}
}

export class CharacterCharacteristicDetailed extends CharacterCharacteristic {
	public static id: number = 446

	public base: number | undefined = 0
	public additional: number | undefined = 0
	public objectsAndMountBonus: number | undefined = 0
	public alignGiftBonus: number | undefined = 0
	public contextModif: number | undefined = 0

	constructor(
		characteristicId?: number,
		base?: number,
		additional?: number,
		objectsAndMountBonus?: number,
		alignGiftBonus?: number,
		contextModif?: number
	) {
		super(characteristicId)
		this.base = base
		this.additional = additional
		this.objectsAndMountBonus = objectsAndMountBonus
		this.alignGiftBonus = alignGiftBonus
		this.contextModif = contextModif
	}

	public serialize(writer: BinaryWriter) {
		super.serialize(writer)
		writer.writeVarInt(this.base!)
		writer.writeVarInt(this.additional!)
		writer.writeVarInt(this.objectsAndMountBonus!)
		writer.writeVarInt(this.alignGiftBonus!)
		writer.writeVarInt(this.contextModif!)
	}
	public deserialize(reader: BinaryReader) {
		super.deserialize(reader)
		this.base = reader.readVarInt()
		this.additional = reader.readVarInt()
		this.objectsAndMountBonus = reader.readVarInt()
		this.alignGiftBonus = reader.readVarInt()
		this.contextModif = reader.readVarInt()
	}
}

export interface RawCharacterCharacteristicsInformations {
	id: number
	experience: number
	experienceLevelFloor: number
	experienceNextLevelFloor: number
	experienceBonusLimit: number
	kamas: number
	statsPoints: number
	additionnalPoints: number
	spellsPoints: number
	alignmentInfos: ActorExtendedAlignmentInformations
	lifePoints: number
	maxLifePoints: number
	energyPoints: number
	maxEnergyPoints: number
	actionPointsCurrent: number
	movementPointsCurrent: number
	initiative: CharacterBaseCharacteristic
	prospecting: CharacterBaseCharacteristic
	actionPoints: CharacterBaseCharacteristic
	movementPoints: CharacterBaseCharacteristic
	strength: CharacterBaseCharacteristic
	vitality: CharacterBaseCharacteristic
	wisdom: CharacterBaseCharacteristic
	chance: CharacterBaseCharacteristic
	agility: CharacterBaseCharacteristic
	intelligence: CharacterBaseCharacteristic
	range: CharacterBaseCharacteristic
	summonableCreaturesBoost: CharacterBaseCharacteristic
	reflect: CharacterBaseCharacteristic
	criticalHit: CharacterBaseCharacteristic
	criticalHitWeapon: number
	criticalMiss: CharacterBaseCharacteristic
	healBonus: CharacterBaseCharacteristic
	allDamagesBonus: CharacterBaseCharacteristic
	weaponDamagesBonusPercent: CharacterBaseCharacteristic
	damagesBonusPercent: CharacterBaseCharacteristic
	trapBonus: CharacterBaseCharacteristic
	trapBonusPercent: CharacterBaseCharacteristic
	glyphBonusPercent: CharacterBaseCharacteristic
	runeBonusPercent: CharacterBaseCharacteristic
	permanentDamagePercent: CharacterBaseCharacteristic
	tackleBlock: CharacterBaseCharacteristic
	tackleEvade: CharacterBaseCharacteristic
	PAAttack: CharacterBaseCharacteristic
	PMAttack: CharacterBaseCharacteristic
	pushDamageBonus: CharacterBaseCharacteristic
	criticalDamageBonus: CharacterBaseCharacteristic
	neutralDamageBonus: CharacterBaseCharacteristic
	earthDamageBonus: CharacterBaseCharacteristic
	waterDamageBonus: CharacterBaseCharacteristic
	airDamageBonus: CharacterBaseCharacteristic
	fireDamageBonus: CharacterBaseCharacteristic
	dodgePALostProbability: CharacterBaseCharacteristic
	dodgePMLostProbability: CharacterBaseCharacteristic
	neutralElementResistPercent: CharacterBaseCharacteristic
	earthElementResistPercent: CharacterBaseCharacteristic
	waterElementResistPercent: CharacterBaseCharacteristic
	airElementResistPercent: CharacterBaseCharacteristic
	fireElementResistPercent: CharacterBaseCharacteristic
	neutralElementReduction: CharacterBaseCharacteristic
	earthElementReduction: CharacterBaseCharacteristic
	waterElementReduction: CharacterBaseCharacteristic
	airElementReduction: CharacterBaseCharacteristic
	fireElementReduction: CharacterBaseCharacteristic
	pushDamageReduction: CharacterBaseCharacteristic
	criticalDamageReduction: CharacterBaseCharacteristic
	pvpNeutralElementResistPercent: CharacterBaseCharacteristic
	pvpEarthElementResistPercent: CharacterBaseCharacteristic
	pvpWaterElementResistPercent: CharacterBaseCharacteristic
	pvpAirElementResistPercent: CharacterBaseCharacteristic
	pvpFireElementResistPercent: CharacterBaseCharacteristic
	pvpNeutralElementReduction: CharacterBaseCharacteristic
	pvpEarthElementReduction: CharacterBaseCharacteristic
	pvpWaterElementReduction: CharacterBaseCharacteristic
	pvpAirElementReduction: CharacterBaseCharacteristic
	pvpFireElementReduction: CharacterBaseCharacteristic
	meleeDamageDonePercent: CharacterBaseCharacteristic
	meleeDamageReceivedPercent: CharacterBaseCharacteristic
	rangedDamageDonePercent: CharacterBaseCharacteristic
	rangedDamageReceivedPercent: CharacterBaseCharacteristic
	weaponDamageDonePercent: CharacterBaseCharacteristic
	weaponDamageReceivedPercent: CharacterBaseCharacteristic
	spellDamageDonePercent: CharacterBaseCharacteristic
	spellDamageReceivedPercent: CharacterBaseCharacteristic
	spellModifications: CharacterSpellModification[]
	probationTime: number
}
export class CharacterCharacteristicsInformations extends DofusType {
	public static id: number = 4995

	public experience: number | undefined = 0
	public experienceLevelFloor: number | undefined = 0
	public experienceNextLevelFloor: number | undefined = 0
	public experienceBonusLimit: number | undefined = 0
	public kamas: number | undefined = 0
	public alignmentInfos: ActorExtendedAlignmentInformations | undefined
	public characteristics: CharacterCharacteristic[] | undefined = []
	public criticalHitWeapon: number | undefined = 0
	public spellModifiers: SpellModifierMessage[] | undefined
	public probationTime: number | undefined = 0

	public constructor(
		experience?: number | undefined,
		experienceLevelFloor?: number | undefined,
		experienceNextLevelFloor?: number | undefined,
		experienceBonusLimit?: number | undefined,
		kamas?: number | undefined,
		alignmentInfos?: ActorExtendedAlignmentInformations | undefined,
		characteristics?: CharacterCharacteristic[] | undefined,
		criticalHitWeapon?: number | undefined,
		spellModifiers?: SpellModifierMessage[] | undefined,
		probationTime?: number | undefined
	) {
		super()
		this.experience = experience
		this.experienceLevelFloor = experienceLevelFloor
		this.experienceNextLevelFloor = experienceNextLevelFloor
		this.experienceBonusLimit = experienceBonusLimit
		this.kamas = kamas
		this.alignmentInfos = alignmentInfos
		this.characteristics = characteristics
		this.criticalHitWeapon = criticalHitWeapon
		this.spellModifiers = spellModifiers
		this.probationTime = probationTime
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarLong(this.experience!)
		writer.writeVarLong(this.experienceLevelFloor!)
		writer.writeVarLong(this.experienceNextLevelFloor!)
		writer.writeVarLong(this.experienceBonusLimit!)
		writer.writeVarLong(this.kamas!)
		this.alignmentInfos!.serialize(writer)
		writer.writeVarShort(this.criticalHitWeapon!)
		writer.writeShort(this.characteristics!.length)
		this.characteristics!.forEach((current) => {
			writer.writeShort(current.id)
			current.serialize(writer)
		})
		writer.writeShort(this.spellModifiers!.length)
		this.spellModifiers!.forEach((current) => {
			current.serialize(writer)
		})
		writer.writeDouble(this.probationTime!)
	}

	public deserialize(reader: BinaryReader): void {
		let id1 = 0
		this.experience = reader.readVarLong()
		this.experienceLevelFloor = reader.readVarLong()
		this.experienceNextLevelFloor = reader.readVarLong()
		this.experienceBonusLimit = reader.readVarLong()
		this.kamas = reader.readVarLong()
		this.alignmentInfos = new ActorExtendedAlignmentInformations()
		this.alignmentInfos!.deserialize(reader)
		this.criticalHitWeapon = reader.readVarShort()
		this.characteristics = []
		const countCharacteristics = reader.readUShort()
		for (let i: number = 0; i < countCharacteristics; i++) {
			id1 = reader.readUShort()
			const type: CharacterCharacteristic = new CharacterCharacteristic()
			type.deserialize(reader)
			this.characteristics.push(type)
		}
		this.spellModifiers = []
		const countSpellModifications = reader.readUShort()
		for (let i: number = 0; i < countSpellModifications; i++) {
			const type: SpellModifierMessage = new SpellModifierMessage()
			type.deserialize(reader)
			this.spellModifiers.push(type)
		}
		this.probationTime = reader.readDouble()
	}
}

export interface RawAbstractCharacterInformation {
	id: number
	id_: number
}

export class AbstractCharacterInformation extends DofusType {
	public static id: number = 2111

	public id_: number | undefined = 0

	public constructor(id_?: number | undefined) {
		super()
		this.id_ = id_
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarLong(this.id_!)
	}

	public deserialize(reader: BinaryReader): void {
		this.id_ = reader.readVarLong()
	}

	public hydrate(
		data: AbstractCharacterInformation | Record<string, any>
	): AbstractCharacterInformation {
		if (data instanceof AbstractCharacterInformation) {
			return data
		}

		this.id_ = data.id_

		return this
	}
}

export interface RawCharacterBasicMinimalInformations
	extends RawAbstractCharacterInformation {
	id: number
	name: string
}

export class CharacterBasicMinimalInformations extends AbstractCharacterInformation {
	public static id: number = 4297

	public name: string | undefined

	public constructor(id_?: number | undefined, name?: string | undefined) {
		super(id_)
		this.name = name
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeUTF(this.name!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.name = reader.readUTF()
	}

	public hydrate(
		data: CharacterBasicMinimalInformations | Record<string, any>
	): CharacterBasicMinimalInformations {
		if (data instanceof CharacterBasicMinimalInformations) {
			return data
		}

		super.hydrate(data)

		this.name = data.name

		return this
	}
}

export interface RawCharacterMinimalInformations
	extends RawCharacterBasicMinimalInformations {
	id: number
	level: number
}

export class CharacterMinimalInformations extends CharacterBasicMinimalInformations {
	public static id: number = 1869

	public level: number | undefined = 0

	public constructor(
		id_?: number | undefined,
		name?: string | undefined,
		level?: number | undefined
	) {
		super(id_, name)
		this.level = level
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeVarShort(this.level!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.level = reader.readVarShort()
	}

	public hydrate(
		data: CharacterMinimalInformations | Record<string, any>
	): CharacterMinimalInformations {
		if (data instanceof CharacterMinimalInformations) {
			return data
		}

		super.hydrate(data)

		this.level = data.level

		return this
	}
}

export interface RawCharacterMinimalPlusLookInformations
	extends RawCharacterMinimalInformations {
	id: number
	entityLook: EntityLook
	breed: number
}

export class CharacterMinimalPlusLookInformations extends CharacterMinimalInformations {
	public static id: number = 9181

	public entityLook: EntityLook | undefined
	public breed: number | undefined = 0

	public constructor(
		id_?: number | undefined,
		name?: string | undefined,
		level?: number | undefined,
		entityLook?: EntityLook | undefined,
		breed?: number | undefined
	) {
		super(id_, name, level)
		this.entityLook = entityLook
		this.breed = breed
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		this.entityLook!.serialize(writer)
		writer.writeByte(this.breed!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.entityLook = new EntityLook()
		this.entityLook!.deserialize(reader)
		this.breed = reader.readByte()
	}

	public hydrate(
		data: CharacterMinimalPlusLookInformations | Record<string, any>
	): CharacterMinimalPlusLookInformations {
		if (data instanceof CharacterMinimalPlusLookInformations) {
			return data
		}

		super.hydrate(data)

		this.entityLook = new EntityLook().hydrate(data.entityLook)
		this.breed = data.breed

		return this
	}
}

export interface RawCharacterBaseInformations
	extends RawCharacterMinimalPlusLookInformations {
	id: number
	sex: boolean
}

export class CharacterBaseInformations extends CharacterMinimalPlusLookInformations {
	public static id: number = 7798

	public sex: boolean | undefined = false

	public constructor(
		id_?: number | undefined,
		name?: string | undefined,
		level?: number | undefined,
		entityLook?: EntityLook | undefined,
		breed?: number | undefined,
		sex?: boolean | undefined
	) {
		super(id_, name, level, entityLook, breed)
		this.sex = sex
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeBoolean(this.sex!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.sex = reader.readBoolean()
	}

	public hydrate(
		data: CharacterBaseInformations | Record<string, any>
	): CharacterBaseInformations {
		if (data instanceof CharacterBaseInformations) {
			return data
		}

		super.hydrate(data)

		this.sex = data.sex

		return this
	}
}

export interface RawFightDispellableEffectExtendedInformations {
	id: number
	actionId: number
	sourceId: number
	effect: AbstractFightDispellableEffect
}

export class FightDispellableEffectExtendedInformations extends DofusType {
	public static id: number = 2740

	public actionId: number | undefined = 0
	public sourceId: number | undefined = 0
	public effect: AbstractFightDispellableEffect | undefined

	public constructor(
		actionId?: number | undefined,
		sourceId?: number | undefined,
		effect?: AbstractFightDispellableEffect | undefined
	) {
		super()
		this.actionId = actionId
		this.sourceId = sourceId
		this.effect = effect
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarShort(this.actionId!)
		writer.writeDouble(this.sourceId!)
		writer.writeShort(this.effect!.id)
		this.effect!.serialize(writer)
	}

	public deserialize(reader: BinaryReader): void {
		this.actionId = reader.readVarShort()
		this.sourceId = reader.readDouble()
		const effectTypeId: number = reader.readShort()
		this.effect = new types[effectTypeId]() as AbstractFightDispellableEffect
		this.effect!.deserialize(reader)
	}

	public hydrate(
		data: FightDispellableEffectExtendedInformations | Record<string, any>
	): FightDispellableEffectExtendedInformations {
		if (data instanceof FightDispellableEffectExtendedInformations) {
			return data
		}

		this.actionId = data.actionId
		this.sourceId = data.sourceId
		this.effect = (new types[
			data.effect.id
		]() as AbstractFightDispellableEffect).hydrate(data.effect)
		return this
	}
}

export interface RawGameActionMarkedCell {
	id: number
	cellId: number
	zoneSize: number
	cellColor: number
	cellsType: number
}

export class GameActionMarkedCell extends DofusType {
	public static id: number = 7802

	public cellId: number | undefined = 0
	public zoneSize: number | undefined = 0
	public cellColor: number | undefined = 0
	public cellsType: number | undefined = 0

	public constructor(
		cellId?: number | undefined,
		zoneSize?: number | undefined,
		cellColor?: number | undefined,
		cellsType?: number | undefined
	) {
		super()
		this.cellId = cellId
		this.zoneSize = zoneSize
		this.cellColor = cellColor
		this.cellsType = cellsType
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarShort(this.cellId!)
		writer.writeByte(this.zoneSize!)
		writer.writeInt(this.cellColor!)
		writer.writeByte(this.cellsType!)
	}

	public deserialize(reader: BinaryReader): void {
		this.cellId = reader.readVarShort()
		this.zoneSize = reader.readByte()
		this.cellColor = reader.readInt()
		this.cellsType = reader.readByte()
	}

	public hydrate(
		data: GameActionMarkedCell | Record<string, any>
	): GameActionMarkedCell {
		if (data instanceof GameActionMarkedCell) {
			return data
		}

		this.cellId = data.cellId
		this.zoneSize = data.zoneSize
		this.cellColor = data.cellColor
		this.cellsType = data.cellsType

		return this
	}
}

export interface RawFightResultListEntry {
	id: number
	outcome: number
	wave: number
	rewards: FightLoot
}

export class FightResultListEntry extends DofusType {
	public static id: number = 5766

	public outcome: number | undefined = 0
	public wave: number | undefined = 0
	public rewards: FightLoot | undefined

	public constructor(
		outcome?: number | undefined,
		wave?: number | undefined,
		rewards?: FightLoot | undefined
	) {
		super()
		this.outcome = outcome
		this.wave = wave
		this.rewards = rewards
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarShort(this.outcome!)
		writer.writeByte(this.wave!)
		this.rewards!.serialize(writer)
	}

	public deserialize(reader: BinaryReader): void {
		this.outcome = reader.readVarShort()
		this.wave = reader.readByte()
		this.rewards = new FightLoot()
		this.rewards!.deserialize(reader)
	}

	public hydrate(
		data: FightResultListEntry | Record<string, any>
	): FightResultListEntry {
		if (data instanceof FightResultListEntry) {
			return data
		}

		this.outcome = data.outcome
		this.wave = data.wave
		this.rewards = new FightLoot().hydrate(data.rewards)

		return this
	}
}

export interface RawFightResultFighterListEntry
	extends RawFightResultListEntry {
	id: number
	id_: number
	alive: boolean
}

export class FightResultFighterListEntry extends FightResultListEntry {
	public static id: number = 7733

	public id_: number | undefined = 0
	public alive: boolean | undefined = false

	public constructor(
		outcome?: number | undefined,
		wave?: number | undefined,
		rewards?: FightLoot | undefined,
		id_?: number | undefined,
		alive?: boolean | undefined
	) {
		super(outcome, wave, rewards)
		this.id_ = id_
		this.alive = alive
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeDouble(this.id_!)
		writer.writeBoolean(this.alive!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.id_ = reader.readDouble()
		this.alive = reader.readBoolean()
	}

	public hydrate(
		data: FightResultFighterListEntry | Record<string, any>
	): FightResultFighterListEntry {
		if (data instanceof FightResultFighterListEntry) {
			return data
		}

		super.hydrate(data)

		this.id_ = data.id_
		this.alive = data.alive

		return this
	}
}

export interface RawGameFightResumeSlaveInfo {
	id: number
	slaveId: number
	spellCooldowns: GameFightSpellCooldown[]
	summonCount: number
	bombCount: number
}

export class GameFightResumeSlaveInfo extends DofusType {
	public static id: number = 8499

	public slaveId: number | undefined = 0
	public spellCooldowns: GameFightSpellCooldown[] | undefined
	public summonCount: number | undefined = 0
	public bombCount: number | undefined = 0

	public constructor(
		slaveId?: number | undefined,
		spellCooldowns?: GameFightSpellCooldown[] | undefined,
		summonCount?: number | undefined,
		bombCount?: number | undefined
	) {
		super()
		this.slaveId = slaveId
		this.spellCooldowns = spellCooldowns
		this.summonCount = summonCount
		this.bombCount = bombCount
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeDouble(this.slaveId!)
		writer.writeShort(this.spellCooldowns!.length)
		this.spellCooldowns!.forEach((current) => {
			current.serialize(writer)
		})
		writer.writeByte(this.summonCount!)
		writer.writeByte(this.bombCount!)
	}

	public deserialize(reader: BinaryReader): void {
		this.slaveId = reader.readDouble()
		this.spellCooldowns = []
		const countSpellCooldowns = reader.readShort()
		for (let i: number = 0; i < countSpellCooldowns; i++) {
			const type: GameFightSpellCooldown = new GameFightSpellCooldown()
			type.deserialize(reader)
			this.spellCooldowns.push(type)
		}
		this.summonCount = reader.readByte()
		this.bombCount = reader.readByte()
	}

	public hydrate(
		data: GameFightResumeSlaveInfo | Record<string, any>
	): GameFightResumeSlaveInfo {
		if (data instanceof GameFightResumeSlaveInfo) {
			return data
		}

		this.slaveId = data.slaveId
		this.spellCooldowns = data.spellCooldowns.map(
			(
				dataElement: GameFightSpellCooldown | Record<string, any>
			): GameFightSpellCooldown => {
				if (dataElement instanceof GameFightSpellCooldown) {
					return dataElement
				} else {
					return new GameFightSpellCooldown().hydrate(dataElement)
				}
			}
		)
		this.summonCount = data.summonCount
		this.bombCount = data.bombCount

		return this
	}
}

export interface RawNamedPartyTeamWithOutcome {
	id: number
	team: NamedPartyTeam
	outcome: number
}

export class NamedPartyTeamWithOutcome extends DofusType {
	public static id: number = 8513

	public team: NamedPartyTeam | undefined
	public outcome: number | undefined = 0

	public constructor(
		team?: NamedPartyTeam | undefined,
		outcome?: number | undefined
	) {
		super()
		this.team = team
		this.outcome = outcome
	}

	public serialize(writer: BinaryWriter): void {
		this.team!.serialize(writer)
		writer.writeVarShort(this.outcome!)
	}

	public deserialize(reader: BinaryReader): void {
		this.team = new NamedPartyTeam()
		this.team!.deserialize(reader)
		this.outcome = reader.readVarShort()
	}

	public hydrate(
		data: NamedPartyTeamWithOutcome | Record<string, any>
	): NamedPartyTeamWithOutcome {
		if (data instanceof NamedPartyTeamWithOutcome) {
			return data
		}

		this.team = new NamedPartyTeam().hydrate(data.team)
		this.outcome = data.outcome

		return this
	}
}

export interface RawGameActionMark {
	id: number
	markAuthorId: number
	markTeamId: number
	markSpellId: number
	markSpellLevel: number
	markId: number
	markType: number
	markimpactCell: number
	cells: GameActionMarkedCell[]
	active: boolean
}

export class GameActionMark extends DofusType {
	public static id: number = 8797

	public markAuthorId: number | undefined = 0
	public markTeamId: number | undefined = 2
	public markSpellId: number | undefined = 0
	public markSpellLevel: number | undefined = 0
	public markId: number | undefined = 0
	public markType: number | undefined = 0
	public markimpactCell: number | undefined = 0
	public cells: GameActionMarkedCell[] | undefined
	public active: boolean | undefined = false

	public constructor(
		markAuthorId?: number | undefined,
		markTeamId?: number | undefined,
		markSpellId?: number | undefined,
		markSpellLevel?: number | undefined,
		markId?: number | undefined,
		markType?: number | undefined,
		markimpactCell?: number | undefined,
		cells?: GameActionMarkedCell[] | undefined,
		active?: boolean | undefined
	) {
		super()
		this.markAuthorId = markAuthorId
		this.markTeamId = markTeamId
		this.markSpellId = markSpellId
		this.markSpellLevel = markSpellLevel
		this.markId = markId
		this.markType = markType
		this.markimpactCell = markimpactCell
		this.cells = cells
		this.active = active
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeDouble(this.markAuthorId!)
		writer.writeByte(this.markTeamId!)
		writer.writeInt(this.markSpellId!)
		writer.writeShort(this.markSpellLevel!)
		writer.writeShort(this.markId!)
		writer.writeByte(this.markType!)
		writer.writeShort(this.markimpactCell!)
		writer.writeShort(this.cells!.length)
		this.cells!.forEach((current) => {
			current.serialize(writer)
		})
		writer.writeBoolean(this.active!)
	}

	public deserialize(reader: BinaryReader): void {
		this.markAuthorId = reader.readDouble()
		this.markTeamId = reader.readByte()
		this.markSpellId = reader.readInt()
		this.markSpellLevel = reader.readShort()
		this.markId = reader.readShort()
		this.markType = reader.readByte()
		this.markimpactCell = reader.readShort()
		this.cells = []
		const countCells = reader.readShort()
		for (let i: number = 0; i < countCells; i++) {
			const type: GameActionMarkedCell = new GameActionMarkedCell()
			type.deserialize(reader)
			this.cells.push(type)
		}
		this.active = reader.readBoolean()
	}

	public hydrate(data: GameActionMark | Record<string, any>): GameActionMark {
		if (data instanceof GameActionMark) {
			return data
		}

		this.markAuthorId = data.markAuthorId
		this.markTeamId = data.markTeamId
		this.markSpellId = data.markSpellId
		this.markSpellLevel = data.markSpellLevel
		this.markId = data.markId
		this.markType = data.markType
		this.markimpactCell = data.markimpactCell
		this.cells = data.cells.map(
			(
				dataElement: GameActionMarkedCell | Record<string, any>
			): GameActionMarkedCell => {
				if (dataElement instanceof GameActionMarkedCell) {
					return dataElement
				} else {
					return new GameActionMarkedCell().hydrate(dataElement)
				}
			}
		)
		this.active = data.active

		return this
	}
}

export interface RawNamedPartyTeam {
	id: number
	teamId: number
	partyName: string
}

export class NamedPartyTeam extends DofusType {
	public static id: number = 644

	public teamId: number | undefined = 2
	public partyName: string | undefined

	public constructor(
		teamId?: number | undefined,
		partyName?: string | undefined
	) {
		super()
		this.teamId = teamId
		this.partyName = partyName
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeByte(this.teamId!)
		writer.writeUTF(this.partyName!)
	}

	public deserialize(reader: BinaryReader): void {
		this.teamId = reader.readByte()
		this.partyName = reader.readUTF()
	}

	public hydrate(data: NamedPartyTeam | Record<string, any>): NamedPartyTeam {
		if (data instanceof NamedPartyTeam) {
			return data
		}

		this.teamId = data.teamId
		this.partyName = data.partyName

		return this
	}
}

export interface RawIdol {
	id: number
	id_: number
	xpBonusPercent: number
	dropBonusPercent: number
}

export class Idol extends DofusType {
	public static id: number = 5752

	public id_: number | undefined = 0
	public xpBonusPercent: number | undefined = 0
	public dropBonusPercent: number | undefined = 0

	public constructor(
		id_?: number | undefined,
		xpBonusPercent?: number | undefined,
		dropBonusPercent?: number | undefined
	) {
		super()
		this.id_ = id_
		this.xpBonusPercent = xpBonusPercent
		this.dropBonusPercent = dropBonusPercent
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarShort(this.id_!)
		writer.writeVarShort(this.xpBonusPercent!)
		writer.writeVarShort(this.dropBonusPercent!)
	}

	public deserialize(reader: BinaryReader): void {
		this.id_ = reader.readVarShort()
		this.xpBonusPercent = reader.readVarShort()
		this.dropBonusPercent = reader.readVarShort()
	}

	public hydrate(data: Idol | Record<string, any>): Idol {
		if (data instanceof Idol) {
			return data
		}

		this.id_ = data.id_
		this.xpBonusPercent = data.xpBonusPercent
		this.dropBonusPercent = data.dropBonusPercent

		return this
	}
}

export interface RawGameFightMutantInformations
	extends RawGameFightFighterNamedInformations {
	id: number
	powerLevel: number
}

export class GameFightMutantInformations extends GameFightFighterNamedInformations {
	public static id: number = 4633

	public powerLevel: number | undefined = 0

	public constructor(
		contextualId?: number | undefined,
		disposition?: EntityDispositionInformations | undefined,
		look?: EntityLook | undefined,
		spawnInfo?: GameContextBasicSpawnInformation | undefined,
		wave?: number | undefined,
		stats?: GameFightMinimalStats | undefined,
		previousPositions?: number[] | undefined,
		name?: string | undefined,
		status?: PlayerStatus | undefined,
		leagueId?: number | undefined,
		ladderPosition?: number | undefined,
		hiddenInPrefight?: boolean | undefined,
		powerLevel?: number | undefined
	) {
		super(
			contextualId,
			disposition,
			look,
			spawnInfo,
			wave,
			stats,
			previousPositions,
			name,
			status,
			leagueId,
			ladderPosition,
			hiddenInPrefight
		)
		this.powerLevel = powerLevel
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeByte(this.powerLevel!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.powerLevel = reader.readByte()
	}

	public hydrate(
		data: GameFightMutantInformations | Record<string, any>
	): GameFightMutantInformations {
		if (data instanceof GameFightMutantInformations) {
			return data
		}

		super.hydrate(data)

		this.powerLevel = data.powerLevel

		return this
	}
}

export interface RawFightResultPlayerListEntry
	extends RawFightResultFighterListEntry {
	id: number
	level: number
	additional: FightResultAdditionalData[]
}

export class FightResultPlayerListEntry extends FightResultFighterListEntry {
	public static id: number = 6765

	public level: number | undefined = 0
	public additional: FightResultAdditionalData[] | undefined

	public constructor(
		outcome?: number | undefined,
		wave?: number | undefined,
		rewards?: FightLoot | undefined,
		id_?: number | undefined,
		alive?: boolean | undefined,
		level?: number | undefined,
		additional?: FightResultAdditionalData[] | undefined
	) {
		super(outcome, wave, rewards, id_, alive)
		this.level = level
		this.additional = additional
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeVarShort(this.level!)
		writer.writeShort(this.additional!.length)
		this.additional!.forEach((current) => {
			writer.writeShort(current.id)
			current.serialize(writer)
		})
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.level = reader.readVarShort()
		this.additional = []
		const countAdditional = reader.readShort()
		for (let i: number = 0; i < countAdditional; i++) {
			const additionalTypeId: number = reader.readShort()
			const type: FightResultAdditionalData = new types[
				additionalTypeId
			]() as FightResultAdditionalData
			type.deserialize(reader)
			this.additional.push(type)
		}
	}

	public hydrate(
		data: FightResultPlayerListEntry | Record<string, any>
	): FightResultPlayerListEntry {
		if (data instanceof FightResultPlayerListEntry) {
			return data
		}

		super.hydrate(data)

		this.level = data.level
		this.additional = data.additional.map(
			(
				dataElement: FightResultAdditionalData | Record<string, any>
			): FightResultAdditionalData => {
				if (dataElement instanceof FightResultAdditionalData) {
					return dataElement
				} else {
					return (new types[
						dataElement.id
					]() as FightResultAdditionalData).hydrate(dataElement)
				}
			}
		)

		return this
	}
}

export interface RawFightResultTaxCollectorListEntry
	extends RawFightResultFighterListEntry {
	id: number
	level: number
	guildInfo: BasicGuildInformations
	experienceForGuild: number
}

export class FightResultTaxCollectorListEntry extends FightResultFighterListEntry {
	public static id: number = 6240

	public level: number | undefined = 0
	public guildInfo: BasicGuildInformations | undefined
	public experienceForGuild: number | undefined = 0

	public constructor(
		outcome?: number | undefined,
		wave?: number | undefined,
		rewards?: FightLoot | undefined,
		id_?: number | undefined,
		alive?: boolean | undefined,
		level?: number | undefined,
		guildInfo?: BasicGuildInformations | undefined,
		experienceForGuild?: number | undefined
	) {
		super(outcome, wave, rewards, id_, alive)
		this.level = level
		this.guildInfo = guildInfo
		this.experienceForGuild = experienceForGuild
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeByte(this.level!)
		this.guildInfo!.serialize(writer)
		writer.writeInt(this.experienceForGuild!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.level = reader.readByte()
		this.guildInfo = new BasicGuildInformations()
		this.guildInfo!.deserialize(reader)
		this.experienceForGuild = reader.readInt()
	}

	public hydrate(
		data: FightResultTaxCollectorListEntry | Record<string, any>
	): FightResultTaxCollectorListEntry {
		if (data instanceof FightResultTaxCollectorListEntry) {
			return data
		}

		super.hydrate(data)

		this.level = data.level
		this.guildInfo = new BasicGuildInformations().hydrate(data.guildInfo)
		this.experienceForGuild = data.experienceForGuild

		return this
	}
}

export interface RawTrustCertificate {
	id: number
	id_: number
	hash: string
}

export class TrustCertificate extends DofusType {
	public static id: number = 327

	public id_: number | undefined = 0
	public hash: string | undefined

	public constructor(id_?: number | undefined, hash?: string | undefined) {
		super()
		this.id_ = id_
		this.hash = hash
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeInt(this.id_!)
		writer.writeUTF(this.hash!)
	}

	public deserialize(reader: BinaryReader): void {
		this.id_ = reader.readInt()
		this.hash = reader.readUTF()
	}

	public hydrate(
		data: TrustCertificate | Record<string, any>
	): TrustCertificate {
		if (data instanceof TrustCertificate) {
			return data
		}

		this.id_ = data.id_
		this.hash = data.hash

		return this
	}
}

export interface RawGameFightEffectTriggerCount {
	id: number
	effectId: number
	targetId: number
	count: number
}

export class GameFightEffectTriggerCount extends DofusType {
	public static id: number = 7452

	public effectId: number | undefined = 0
	public targetId: number | undefined = 0
	public count: number | undefined = 0

	public constructor(
		effectId?: number | undefined,
		targetId?: number | undefined,
		count?: number | undefined
	) {
		super()
		this.effectId = effectId
		this.targetId = targetId
		this.count = count
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarInt(this.effectId!)
		writer.writeDouble(this.targetId!)
		writer.writeByte(this.count!)
	}

	public deserialize(reader: BinaryReader): void {
		this.effectId = reader.readVarInt()
		this.targetId = reader.readDouble()
		this.count = reader.readByte()
	}

	public hydrate(
		data: GameFightEffectTriggerCount | Record<string, any>
	): GameFightEffectTriggerCount {
		if (data instanceof GameFightEffectTriggerCount) {
			return data
		}

		this.effectId = data.effectId
		this.targetId = data.targetId
		this.count = data.count

		return this
	}
}

export interface RawAchievementAchieved {
	id: number
	id_: number
	achievedBy: number
}

export class AchievementAchieved extends DofusType {
	public static id: number = 5822

	public id_: number | undefined = 0
	public achievedBy: number | undefined = 0

	public constructor(
		id_?: number | undefined,
		achievedBy?: number | undefined
	) {
		super()
		this.id_ = id_
		this.achievedBy = achievedBy
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarShort(this.id_!)
		writer.writeVarLong(this.achievedBy!)
	}

	public deserialize(reader: BinaryReader): void {
		this.id_ = reader.readVarShort()
		this.achievedBy = reader.readVarLong()
	}

	public hydrate(
		data: AchievementAchieved | Record<string, any>
	): AchievementAchieved {
		if (data instanceof AchievementAchieved) {
			return data
		}

		this.id_ = data.id_
		this.achievedBy = data.achievedBy

		return this
	}
}

export interface RawItem {
	id: number
}

export class Item extends DofusType {
	public static id: number = 5596

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public serialize(writer: BinaryWriter): void {}

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public deserialize(reader: BinaryReader): void {}

	public hydrate(data: Item | Record<string, any>): Item {
		if (data instanceof Item) {
			return data
		}

		return this
	}
}

export interface RawObjectItem extends RawItem {
	id: number
	position: number
	objectGID: number
	effects: ObjectEffect[]
	objectUID: number
	quantity: number
}

export class ObjectItem extends Item {
	public static id: number = 9326

	public position: number | undefined = 63
	public objectGID: number | undefined = 0
	public effects: ObjectEffect[] | undefined
	public objectUID: number | undefined = 0
	public quantity: number | undefined = 0

	public constructor(
		position?: number | undefined,
		objectGID?: number | undefined,
		effects?: ObjectEffect[] | undefined,
		objectUID?: number | undefined,
		quantity?: number | undefined
	) {
		super()
		this.position = position
		this.objectGID = objectGID
		this.effects = effects
		this.objectUID = objectUID
		this.quantity = quantity
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeShort(this.position!)
		writer.writeVarShort(this.objectGID!)
		writer.writeShort(this.effects!.length)
		this.effects!.forEach((current) => {
			writer.writeShort(current.id)
			current.serialize(writer)
		})
		writer.writeVarInt(this.objectUID!)
		writer.writeVarInt(this.quantity!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.position = reader.readShort()
		this.objectGID = reader.readVarShort()
		this.effects = []
		const countEffects = reader.readShort()
		for (let i: number = 0; i < countEffects; i++) {
			const effectsTypeId: number = reader.readShort()
			const type: ObjectEffect = new types[effectsTypeId]() as ObjectEffect
			type.deserialize(reader)
			this.effects.push(type)
		}
		this.objectUID = reader.readVarInt()
		this.quantity = reader.readVarInt()
	}

	public hydrate(data: ObjectItem | Record<string, any>): ObjectItem {
		if (data instanceof ObjectItem) {
			return data
		}

		this.position = data.position
		this.objectGID = data.objectGID
		this.effects = data.effects.map(
			(dataElement: ObjectEffect | Record<string, any>): ObjectEffect => {
				if (dataElement instanceof ObjectEffect) {
					return dataElement
				} else {
					return (new types[dataElement.id]() as ObjectEffect).hydrate(
						dataElement
					)
				}
			}
		)
		this.objectUID = data.objectUID
		this.quantity = data.quantity

		return this
	}
}

export interface RawObjectEffect {
	id: number
	actionId: number
}

export class ObjectEffect extends DofusType {
	public static id: number = 4941

	public actionId: number | undefined = 0

	public constructor(actionId?: number | undefined) {
		super()
		this.actionId = actionId
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarShort(this.actionId!)
	}

	public deserialize(reader: BinaryReader): void {
		this.actionId = reader.readVarShort()
	}

	public hydrate(data: ObjectEffect | Record<string, any>): ObjectEffect {
		if (data instanceof ObjectEffect) {
			return data
		}

		this.actionId = data.actionId

		return this
	}
}

export interface RawObjectEffectInteger extends RawObjectEffect {
	id: number
	value: number
}

export class ObjectEffectInteger extends ObjectEffect {
	public static id: number = 7541

	public value: number | undefined = 0

	public constructor(
		actionId?: number | undefined,
		value?: number | undefined
	) {
		super(actionId)
		this.value = value
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeVarInt(this.value!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.value = reader.readVarInt()
	}

	public hydrate(
		data: ObjectEffectInteger | Record<string, any>
	): ObjectEffectInteger {
		if (data instanceof ObjectEffectInteger) {
			return data
		}

		super.hydrate(data)

		this.value = data.value

		return this
	}
}

export interface RawCharacterSpellModification {
	id: number
	modificationType: number
	spellId: number
	value: CharacterBaseCharacteristic
}

export class CharacterSpellModification extends DofusType {
	public static id: number = 9332

	public modificationType: number | undefined = 0
	public spellId: number | undefined = 0
	public value: CharacterBaseCharacteristic | undefined

	public constructor(
		modificationType?: number | undefined,
		spellId?: number | undefined,
		value?: CharacterBaseCharacteristic | undefined
	) {
		super()
		this.modificationType = modificationType
		this.spellId = spellId
		this.value = value
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeByte(this.modificationType!)
		writer.writeVarShort(this.spellId!)
		this.value!.serialize(writer)
	}

	public deserialize(reader: BinaryReader): void {
		this.modificationType = reader.readByte()
		this.spellId = reader.readVarShort()
		this.value = new CharacterBaseCharacteristic()
		this.value!.deserialize(reader)
	}

	public hydrate(
		data: CharacterSpellModification | Record<string, any>
	): CharacterSpellModification {
		if (data instanceof CharacterSpellModification) {
			return data
		}

		this.modificationType = data.modificationType
		this.spellId = data.spellId
		this.value = new CharacterBaseCharacteristic().hydrate(data.value)

		return this
	}
}

export interface RawCharacterBaseCharacteristic {
	id: number
	base: number
	additionnal: number
	objectsAndMountBonus: number
	alignGiftBonus: number
	contextModif: number
}

export class CharacterBaseCharacteristic extends DofusType {
	public static id: number = 1767

	public base: number | undefined = 0
	public additionnal: number | undefined = 0
	public objectsAndMountBonus: number | undefined = 0
	public alignGiftBonus: number | undefined = 0
	public contextModif: number | undefined = 0

	public constructor(
		base?: number | undefined,
		additionnal?: number | undefined,
		objectsAndMountBonus?: number | undefined,
		alignGiftBonus?: number | undefined,
		contextModif?: number | undefined
	) {
		super()
		this.base = base
		this.additionnal = additionnal
		this.objectsAndMountBonus = objectsAndMountBonus
		this.alignGiftBonus = alignGiftBonus
		this.contextModif = contextModif
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarShort(this.base!)
		writer.writeVarShort(this.additionnal!)
		writer.writeVarShort(this.objectsAndMountBonus!)
		writer.writeVarShort(this.alignGiftBonus!)
		writer.writeVarShort(this.contextModif!)
	}

	public deserialize(reader: BinaryReader): void {
		this.base = reader.readVarShort()
		this.additionnal = reader.readVarShort()
		this.objectsAndMountBonus = reader.readVarShort()
		this.alignGiftBonus = reader.readVarShort()
		this.contextModif = reader.readVarShort()
	}

	public hydrate(
		data: CharacterBaseCharacteristic | Record<string, any>
	): CharacterBaseCharacteristic {
		if (data instanceof CharacterBaseCharacteristic) {
			return data
		}

		this.base = data.base
		this.additionnal = data.additionnal
		this.objectsAndMountBonus = data.objectsAndMountBonus
		this.alignGiftBonus = data.alignGiftBonus
		this.contextModif = data.contextModif

		return this
	}
}

export interface RawInteractiveElementSkill {
	id: number
	skillId: number
	skillInstanceUid: number
}

export class InteractiveElementSkill extends DofusType {
	public static id: number = 6762

	public skillId: number | undefined = 0
	public skillInstanceUid: number | undefined = 0

	public constructor(
		skillId?: number | undefined,
		skillInstanceUid?: number | undefined
	) {
		super()
		this.skillId = skillId
		this.skillInstanceUid = skillInstanceUid
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarInt(this.skillId!)
		writer.writeInt(this.skillInstanceUid!)
	}

	public deserialize(reader: BinaryReader): void {
		this.skillId = reader.readVarInt()
		this.skillInstanceUid = reader.readInt()
	}

	public hydrate(
		data: InteractiveElementSkill | Record<string, any>
	): InteractiveElementSkill {
		if (data instanceof InteractiveElementSkill) {
			return data
		}

		this.skillId = data.skillId
		this.skillInstanceUid = data.skillInstanceUid

		return this
	}
}

export interface RawQuestActiveInformations {
	id: number
	questId: number
}

export class QuestActiveInformations extends DofusType {
	public static id: number = 6433

	public questId: number | undefined = 0

	public constructor(questId?: number | undefined) {
		super()
		this.questId = questId
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarShort(this.questId!)
	}

	public deserialize(reader: BinaryReader): void {
		this.questId = reader.readVarShort()
	}

	public hydrate(
		data: QuestActiveInformations | Record<string, any>
	): QuestActiveInformations {
		if (data instanceof QuestActiveInformations) {
			return data
		}

		this.questId = data.questId

		return this
	}
}

export interface RawPrismInformation {
	id: number
	typeId: number
	state: number
	nextVulnerabilityDate: number
	placementDate: number
	rewardTokenCount: number
}

export class PrismInformation extends DofusType {
	public static id: number = 5963

	public typeId: number | undefined = 0
	public state: number | undefined = 1
	public nextVulnerabilityDate: number | undefined = 0
	public placementDate: number | undefined = 0
	public rewardTokenCount: number | undefined = 0

	public constructor(
		typeId?: number | undefined,
		state?: number | undefined,
		nextVulnerabilityDate?: number | undefined,
		placementDate?: number | undefined,
		rewardTokenCount?: number | undefined
	) {
		super()
		this.typeId = typeId
		this.state = state
		this.nextVulnerabilityDate = nextVulnerabilityDate
		this.placementDate = placementDate
		this.rewardTokenCount = rewardTokenCount
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeByte(this.typeId!)
		writer.writeByte(this.state!)
		writer.writeInt(this.nextVulnerabilityDate!)
		writer.writeInt(this.placementDate!)
		writer.writeVarInt(this.rewardTokenCount!)
	}

	public deserialize(reader: BinaryReader): void {
		this.typeId = reader.readByte()
		this.state = reader.readByte()
		this.nextVulnerabilityDate = reader.readInt()
		this.placementDate = reader.readInt()
		this.rewardTokenCount = reader.readVarInt()
	}

	public hydrate(
		data: PrismInformation | Record<string, any>
	): PrismInformation {
		if (data instanceof PrismInformation) {
			return data
		}

		this.typeId = data.typeId
		this.state = data.state
		this.nextVulnerabilityDate = data.nextVulnerabilityDate
		this.placementDate = data.placementDate
		this.rewardTokenCount = data.rewardTokenCount

		return this
	}
}

export interface RawTaxCollectorStaticInformations {
	id: number
	firstNameId: number
	lastNameId: number
	guildIdentity: GuildInformations
	callerId: number
}

export class TaxCollectorStaticInformations extends DofusType {
	public static id: number = 2842

	public firstNameId: number | undefined = 0
	public lastNameId: number | undefined = 0
	public guildIdentity: GuildInformations | undefined
	public callerId: number | undefined = 0

	public constructor(
		firstNameId?: number | undefined,
		lastNameId?: number | undefined,
		guildIdentity?: GuildInformations | undefined,
		callerId?: number | undefined
	) {
		super()
		this.firstNameId = firstNameId
		this.lastNameId = lastNameId
		this.guildIdentity = guildIdentity
		this.callerId = callerId
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarShort(this.firstNameId!)
		writer.writeVarShort(this.lastNameId!)
		this.guildIdentity!.serialize(writer)
		writer.writeVarLong(this.callerId!)
	}

	public deserialize(reader: BinaryReader): void {
		this.firstNameId = reader.readVarShort()
		this.lastNameId = reader.readVarShort()
		this.guildIdentity = new GuildInformations()
		this.guildIdentity!.deserialize(reader)
		this.callerId = reader.readVarLong()
	}

	public hydrate(
		data: TaxCollectorStaticInformations | Record<string, any>
	): TaxCollectorStaticInformations {
		if (data instanceof TaxCollectorStaticInformations) {
			return data
		}

		this.firstNameId = data.firstNameId
		this.lastNameId = data.lastNameId
		this.guildIdentity = new GuildInformations().hydrate(data.guildIdentity)
		this.callerId = data.callerId

		return this
	}
}

export interface RawSkillActionDescription {
	id: number
	skillId: number
}

export class SkillActionDescription extends DofusType {
	public static id: number = 7615

	public skillId: number | undefined = 0

	public constructor(skillId?: number | undefined) {
		super()
		this.skillId = skillId
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarShort(this.skillId!)
	}

	public deserialize(reader: BinaryReader): void {
		this.skillId = reader.readVarShort()
	}

	public hydrate(
		data: SkillActionDescription | Record<string, any>
	): SkillActionDescription {
		if (data instanceof SkillActionDescription) {
			return data
		}

		this.skillId = data.skillId

		return this
	}
}

export interface RawSkillActionDescriptionCraft
	extends RawSkillActionDescription {
	id: number
	probability: number
}

export class SkillActionDescriptionCraft extends SkillActionDescription {
	public static id: number = 8967

	public probability: number | undefined = 0

	public constructor(
		skillId?: number | undefined,
		probability?: number | undefined
	) {
		super(skillId)
		this.probability = probability
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeByte(this.probability!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.probability = reader.readByte()
	}

	public hydrate(
		data: SkillActionDescriptionCraft | Record<string, any>
	): SkillActionDescriptionCraft {
		if (data instanceof SkillActionDescriptionCraft) {
			return data
		}

		super.hydrate(data)

		this.probability = data.probability

		return this
	}
}

export interface RawJobDescription {
	id: number
	jobId: number
	skills: SkillActionDescription[]
}

export class JobDescription extends DofusType {
	public static id: number = 4248

	public jobId: number | undefined = 0
	public skills: SkillActionDescription[] | undefined

	public constructor(
		jobId?: number | undefined,
		skills?: SkillActionDescription[] | undefined
	) {
		super()
		this.jobId = jobId
		this.skills = skills
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeByte(this.jobId!)
		writer.writeShort(this.skills!.length)
		this.skills!.forEach((current) => {
			writer.writeShort(current.id)
			current.serialize(writer)
		})
	}

	public deserialize(reader: BinaryReader): void {
		this.jobId = reader.readByte()
		this.skills = []
		const countSkills = reader.readShort()
		for (let i: number = 0; i < countSkills; i++) {
			const skillsTypeId: number = reader.readShort()
			const type: SkillActionDescription = new types[
				skillsTypeId
			]() as SkillActionDescription
			type.deserialize(reader)
			this.skills.push(type)
		}
	}

	public hydrate(data: JobDescription | Record<string, any>): JobDescription {
		if (data instanceof JobDescription) {
			return data
		}

		this.jobId = data.jobId
		this.skills = data.skills.map(
			(
				dataElement: SkillActionDescription | Record<string, any>
			): SkillActionDescription => {
				if (dataElement instanceof SkillActionDescription) {
					return dataElement
				} else {
					return (new types[
						dataElement.id
					]() as SkillActionDescription).hydrate(dataElement)
				}
			}
		)

		return this
	}
}

export interface RawSkillActionDescriptionTimed
	extends RawSkillActionDescription {
	id: number
	time: number
}

export class SkillActionDescriptionTimed extends SkillActionDescription {
	public static id: number = 263

	public time: number | undefined = 0

	public constructor(skillId?: number | undefined, time?: number | undefined) {
		super(skillId)
		this.time = time
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeByte(this.time!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.time = reader.readByte()
	}

	public hydrate(
		data: SkillActionDescriptionTimed | Record<string, any>
	): SkillActionDescriptionTimed {
		if (data instanceof SkillActionDescriptionTimed) {
			return data
		}

		super.hydrate(data)

		this.time = data.time

		return this
	}
}

export interface RawSkillActionDescriptionCollect
	extends RawSkillActionDescriptionTimed {
	id: number
	min: number
	max: number
}

export class SkillActionDescriptionCollect extends SkillActionDescriptionTimed {
	public static id: number = 6581

	public min: number | undefined = 0
	public max: number | undefined = 0

	public constructor(
		skillId?: number | undefined,
		time?: number | undefined,
		min?: number | undefined,
		max?: number | undefined
	) {
		super(skillId, time)
		this.min = min
		this.max = max
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeVarShort(this.min!)
		writer.writeVarShort(this.max!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.min = reader.readVarShort()
		this.max = reader.readVarShort()
	}

	public hydrate(
		data: SkillActionDescriptionCollect | Record<string, any>
	): SkillActionDescriptionCollect {
		if (data instanceof SkillActionDescriptionCollect) {
			return data
		}

		super.hydrate(data)

		this.min = data.min
		this.max = data.max

		return this
	}
}

export interface RawGameServerInformations {
	id: number
	isMonoAccount: boolean
	isSelectable: boolean
	id_: number
	type: number
	status: number
	completion: number
	charactersCount: number
	charactersSlots: number
	date: number
}

export class GameServerInformations extends DofusType {
	public static id: number = 8807

	public isMonoAccount: boolean | undefined = false
	public isSelectable: boolean | undefined = false
	public id_: number | undefined = 0
	public type: number | undefined = -1
	public status: number | undefined = 1
	public completion: number | undefined = 0
	public charactersCount: number | undefined = 0
	public charactersSlots: number | undefined = 0
	public date: number | undefined = 0

	public constructor(
		isMonoAccount?: boolean | undefined,
		isSelectable?: boolean | undefined,
		id_?: number | undefined,
		type?: number | undefined,
		status?: number | undefined,
		completion?: number | undefined,
		charactersCount?: number | undefined,
		charactersSlots?: number | undefined,
		date?: number | undefined
	) {
		super()
		this.isMonoAccount = isMonoAccount
		this.isSelectable = isSelectable
		this.id_ = id_
		this.type = type
		this.status = status
		this.completion = completion
		this.charactersCount = charactersCount
		this.charactersSlots = charactersSlots
		this.date = date
	}

	public serialize(writer: BinaryWriter): void {
		let box0: number = 0
		box0 = setFlag(box0, 0, this.isMonoAccount!)
		box0 = setFlag(box0, 1, this.isSelectable!)
		writer.writeByte(box0)
		writer.writeVarShort(this.id_!)
		writer.writeByte(this.type!)
		writer.writeByte(this.status!)
		writer.writeByte(this.completion!)
		writer.writeByte(this.charactersCount!)
		writer.writeByte(this.charactersSlots!)
		writer.writeDouble(this.date!)
	}

	public deserialize(reader: BinaryReader): void {
		const box0 = reader.readByte()
		this.isMonoAccount = getFlag(box0, 0)
		this.isSelectable = getFlag(box0, 1)
		this.id_ = reader.readVarShort()
		this.type = reader.readByte()
		this.status = reader.readByte()
		this.completion = reader.readByte()
		this.charactersCount = reader.readByte()
		this.charactersSlots = reader.readByte()
		this.date = reader.readDouble()
	}

	public hydrate(
		data: GameServerInformations | Record<string, any>
	): GameServerInformations {
		if (data instanceof GameServerInformations) {
			return data
		}

		this.isMonoAccount = data.isMonoAccount
		this.isSelectable = data.isSelectable
		this.id_ = data.id_
		this.type = data.type
		this.status = data.status
		this.completion = data.completion
		this.charactersCount = data.charactersCount
		this.charactersSlots = data.charactersSlots
		this.date = data.date

		return this
	}
}

export interface RawPaddockInformations {
	id: number
	maxOutdoorMount: number
	maxItems: number
}

export class PaddockInformations extends DofusType {
	public static id: number = 1824

	public maxOutdoorMount: number | undefined = 0
	public maxItems: number | undefined = 0

	public constructor(
		maxOutdoorMount?: number | undefined,
		maxItems?: number | undefined
	) {
		super()
		this.maxOutdoorMount = maxOutdoorMount
		this.maxItems = maxItems
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarShort(this.maxOutdoorMount!)
		writer.writeVarShort(this.maxItems!)
	}

	public deserialize(reader: BinaryReader): void {
		this.maxOutdoorMount = reader.readVarShort()
		this.maxItems = reader.readVarShort()
	}

	public hydrate(
		data: PaddockInformations | Record<string, any>
	): PaddockInformations {
		if (data instanceof PaddockInformations) {
			return data
		}

		this.maxOutdoorMount = data.maxOutdoorMount
		this.maxItems = data.maxItems

		return this
	}
}

export interface RawPaddockInstancesInformations
	extends RawPaddockInformations {
	id: number
	paddocks: PaddockBuyableInformations[]
}

export class PaddockInstancesInformations extends PaddockInformations {
	public static id: number = 4322

	public paddocks: PaddockBuyableInformations[] | undefined

	public constructor(
		maxOutdoorMount?: number | undefined,
		maxItems?: number | undefined,
		paddocks?: PaddockBuyableInformations[] | undefined
	) {
		super(maxOutdoorMount, maxItems)
		this.paddocks = paddocks
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeShort(this.paddocks!.length)
		this.paddocks!.forEach((current) => {
			writer.writeShort(current.id)
			current.serialize(writer)
		})
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.paddocks = []
		const countPaddocks = reader.readShort()
		for (let i: number = 0; i < countPaddocks; i++) {
			const paddocksTypeId: number = reader.readShort()
			const type: PaddockBuyableInformations = new types[
				paddocksTypeId
			]() as PaddockBuyableInformations
			type.deserialize(reader)
			this.paddocks.push(type)
		}
	}

	public hydrate(
		data: PaddockInstancesInformations | Record<string, any>
	): PaddockInstancesInformations {
		if (data instanceof PaddockInstancesInformations) {
			return data
		}

		super.hydrate(data)

		this.paddocks = data.paddocks.map(
			(
				dataElement: PaddockBuyableInformations | Record<string, any>
			): PaddockBuyableInformations => {
				if (dataElement instanceof PaddockBuyableInformations) {
					return dataElement
				} else {
					return (new types[
						dataElement.id
					]() as PaddockBuyableInformations).hydrate(dataElement)
				}
			}
		)

		return this
	}
}

export interface RawPaddockBuyableInformations {
	id: number
	price: number
	locked: boolean
}

export class PaddockBuyableInformations extends DofusType {
	public static id: number = 4662

	public price: number | undefined = 0
	public locked: boolean | undefined = false

	public constructor(price?: number | undefined, locked?: boolean | undefined) {
		super()
		this.price = price
		this.locked = locked
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarLong(this.price!)
		writer.writeBoolean(this.locked!)
	}

	public deserialize(reader: BinaryReader): void {
		this.price = reader.readVarLong()
		this.locked = reader.readBoolean()
	}

	public hydrate(
		data: PaddockBuyableInformations | Record<string, any>
	): PaddockBuyableInformations {
		if (data instanceof PaddockBuyableInformations) {
			return data
		}

		this.price = data.price
		this.locked = data.locked

		return this
	}
}

export interface RawGameRolePlayNpcQuestFlag {
	id: number
	questsToValidId: number[]
	questsToStartId: number[]
}

export class GameRolePlayNpcQuestFlag extends DofusType {
	public static id: number = 9023

	public questsToValidId: number[] | undefined
	public questsToStartId: number[] | undefined

	public constructor(
		questsToValidId?: number[] | undefined,
		questsToStartId?: number[] | undefined
	) {
		super()
		this.questsToValidId = questsToValidId
		this.questsToStartId = questsToStartId
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeShort(this.questsToValidId!.length)
		this.questsToValidId!.forEach((current: number) =>
			writer.writeVarShort(current)
		)
		writer.writeShort(this.questsToStartId!.length)
		this.questsToStartId!.forEach((current: number) =>
			writer.writeVarShort(current)
		)
	}

	public deserialize(reader: BinaryReader): void {
		this.questsToValidId = []
		const countQuestsToValidId = reader.readShort()
		for (let i: number = 0; i < countQuestsToValidId; i++) {
			this.questsToValidId.push(reader.readVarShort())
		}
		this.questsToStartId = []
		const countQuestsToStartId = reader.readShort()
		for (let i: number = 0; i < countQuestsToStartId; i++) {
			this.questsToStartId.push(reader.readVarShort())
		}
	}

	public hydrate(
		data: GameRolePlayNpcQuestFlag | Record<string, any>
	): GameRolePlayNpcQuestFlag {
		if (data instanceof GameRolePlayNpcQuestFlag) {
			return data
		}

		this.questsToValidId = data.questsToValidId
		this.questsToStartId = data.questsToStartId

		return this
	}
}

export interface RawItemDurability {
	id: number
	durability: number
	durabilityMax: number
}

export class ItemDurability extends DofusType {
	public static id: number = 5623

	public durability: number | undefined = 0
	public durabilityMax: number | undefined = 0

	public constructor(
		durability?: number | undefined,
		durabilityMax?: number | undefined
	) {
		super()
		this.durability = durability
		this.durabilityMax = durabilityMax
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeShort(this.durability!)
		writer.writeShort(this.durabilityMax!)
	}

	public deserialize(reader: BinaryReader): void {
		this.durability = reader.readShort()
		this.durabilityMax = reader.readShort()
	}

	public hydrate(data: ItemDurability | Record<string, any>): ItemDurability {
		if (data instanceof ItemDurability) {
			return data
		}

		this.durability = data.durability
		this.durabilityMax = data.durabilityMax

		return this
	}
}

export interface RawAchievementAchievedRewardable
	extends RawAchievementAchieved {
	id: number
	finishedlevel: number
}

export class AchievementAchievedRewardable extends AchievementAchieved {
	public static id: number = 7985

	public finishedlevel: number | undefined = 0

	public constructor(
		id_?: number | undefined,
		achievedBy?: number | undefined,
		finishedlevel?: number | undefined
	) {
		super(id_, achievedBy)
		this.finishedlevel = finishedlevel
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeVarShort(this.finishedlevel!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.finishedlevel = reader.readVarShort()
	}

	public hydrate(
		data: AchievementAchievedRewardable | Record<string, any>
	): AchievementAchievedRewardable {
		if (data instanceof AchievementAchievedRewardable) {
			return data
		}

		super.hydrate(data)

		this.finishedlevel = data.finishedlevel

		return this
	}
}

export interface RawHumanOptionOrnament extends RawHumanOption {
	id: number
	ornamentId: number
	level: number
	leagueId: number
	ladderPosition: number
}

export class HumanOptionOrnament extends HumanOption {
	public static id: number = 1102

	public ornamentId: number | undefined = 0
	public level: number | undefined = 0
	public leagueId: number | undefined = 0
	public ladderPosition: number | undefined = 0

	public constructor(
		ornamentId?: number | undefined,
		level?: number | undefined,
		leagueId?: number | undefined,
		ladderPosition?: number | undefined
	) {
		super()
		this.ornamentId = ornamentId
		this.level = level
		this.leagueId = leagueId
		this.ladderPosition = ladderPosition
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeVarShort(this.ornamentId!)
		writer.writeVarShort(this.level!)
		writer.writeVarShort(this.leagueId!)
		writer.writeInt(this.ladderPosition!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.ornamentId = reader.readVarShort()
		this.level = reader.readVarShort()
		this.leagueId = reader.readVarShort()
		this.ladderPosition = reader.readInt()
	}

	public hydrate(
		data: HumanOptionOrnament | Record<string, any>
	): HumanOptionOrnament {
		if (data instanceof HumanOptionOrnament) {
			return data
		}

		this.ornamentId = data.ornamentId
		this.level = data.level
		this.leagueId = data.leagueId
		this.ladderPosition = data.ladderPosition

		return this
	}
}

export interface RawHumanOptionTitle extends RawHumanOption {
	id: number
	titleId: number
	titleParam: string
}

export class HumanOptionTitle extends HumanOption {
	public static id: number = 8924

	public titleId: number | undefined = 0
	public titleParam: string | undefined

	public constructor(
		titleId?: number | undefined,
		titleParam?: string | undefined
	) {
		super()
		this.titleId = titleId
		this.titleParam = titleParam
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeVarShort(this.titleId!)
		writer.writeUTF(this.titleParam!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.titleId = reader.readVarShort()
		this.titleParam = reader.readUTF()
	}

	public hydrate(
		data: HumanOptionTitle | Record<string, any>
	): HumanOptionTitle {
		if (data instanceof HumanOptionTitle) {
			return data
		}

		this.titleId = data.titleId
		this.titleParam = data.titleParam

		return this
	}
}

export interface RawAccountHouseInformations extends RawHouseInformations {
	id: number
	houseInfos: HouseInstanceInformations
	worldX: number
	worldY: number
	mapId: number
	subAreaId: number
}

export class AccountHouseInformations extends HouseInformations {
	public static id: number = 8916

	public houseInfos: HouseInstanceInformations | undefined
	public worldX: number | undefined = 0
	public worldY: number | undefined = 0
	public mapId: number | undefined = 0
	public subAreaId: number | undefined = 0

	public constructor(
		houseId?: number | undefined,
		modelId?: number | undefined,
		houseInfos?: HouseInstanceInformations | undefined,
		worldX?: number | undefined,
		worldY?: number | undefined,
		mapId?: number | undefined,
		subAreaId?: number | undefined
	) {
		super(houseId, modelId)
		this.houseInfos = houseInfos
		this.worldX = worldX
		this.worldY = worldY
		this.mapId = mapId
		this.subAreaId = subAreaId
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeShort(this.houseInfos!.id)
		this.houseInfos!.serialize(writer)
		writer.writeShort(this.worldX!)
		writer.writeShort(this.worldY!)
		writer.writeDouble(this.mapId!)
		writer.writeVarShort(this.subAreaId!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		const houseInfosTypeId: number = reader.readShort()
		this.houseInfos = new types[houseInfosTypeId]() as HouseInstanceInformations
		this.houseInfos!.deserialize(reader)
		this.worldX = reader.readShort()
		this.worldY = reader.readShort()
		this.mapId = reader.readDouble()
		this.subAreaId = reader.readVarShort()
	}

	public hydrate(
		data: AccountHouseInformations | Record<string, any>
	): AccountHouseInformations {
		if (data instanceof AccountHouseInformations) {
			return data
		}

		super.hydrate(data)

		this.houseInfos = (new types[
			data.houseInfos.id
		]() as HouseInstanceInformations).hydrate(data.houseInfos)
		this.worldX = data.worldX
		this.worldY = data.worldY
		this.mapId = data.mapId
		this.subAreaId = data.subAreaId

		return this
	}
}

export interface RawHouseInformationsInside extends RawHouseInformations {
	id: number
	houseInfos: HouseInstanceInformations
	worldX: number
	worldY: number
}

export class HouseInformationsInside extends HouseInformations {
	public static id: number = 2751

	public houseInfos: HouseInstanceInformations | undefined
	public worldX: number | undefined = 0
	public worldY: number | undefined = 0

	public constructor(
		houseId?: number | undefined,
		modelId?: number | undefined,
		houseInfos?: HouseInstanceInformations | undefined,
		worldX?: number | undefined,
		worldY?: number | undefined
	) {
		super(houseId, modelId)
		this.houseInfos = houseInfos
		this.worldX = worldX
		this.worldY = worldY
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeShort(this.houseInfos!.id)
		this.houseInfos!.serialize(writer)
		writer.writeShort(this.worldX!)
		writer.writeShort(this.worldY!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		const houseInfosTypeId: number = reader.readShort()
		this.houseInfos = new types[houseInfosTypeId]() as HouseInstanceInformations
		this.houseInfos!.deserialize(reader)
		this.worldX = reader.readShort()
		this.worldY = reader.readShort()
	}

	public hydrate(
		data: HouseInformationsInside | Record<string, any>
	): HouseInformationsInside {
		if (data instanceof HouseInformationsInside) {
			return data
		}

		super.hydrate(data)

		this.houseInfos = (new types[
			data.houseInfos.id
		]() as HouseInstanceInformations).hydrate(data.houseInfos)
		this.worldX = data.worldX
		this.worldY = data.worldY

		return this
	}
}

export interface RawActorAlignmentInformations {
	id: number
	alignmentSide: number
	alignmentValue: number
	alignmentGrade: number
	characterPower: number
}

export class ActorAlignmentInformations extends DofusType {
	public static id: number = 6198

	public alignmentSide: number | undefined = 0
	public alignmentValue: number | undefined = 0
	public alignmentGrade: number | undefined = 0
	public characterPower: number | undefined = 0

	public constructor(
		alignmentSide?: number | undefined,
		alignmentValue?: number | undefined,
		alignmentGrade?: number | undefined,
		characterPower?: number | undefined
	) {
		super()
		this.alignmentSide = alignmentSide
		this.alignmentValue = alignmentValue
		this.alignmentGrade = alignmentGrade
		this.characterPower = characterPower
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeByte(this.alignmentSide!)
		writer.writeByte(this.alignmentValue!)
		writer.writeByte(this.alignmentGrade!)
		writer.writeDouble(this.characterPower!)
	}

	public deserialize(reader: BinaryReader): void {
		this.alignmentSide = reader.readByte()
		this.alignmentValue = reader.readByte()
		this.alignmentGrade = reader.readByte()
		this.characterPower = reader.readDouble()
	}

	public hydrate(
		data: ActorAlignmentInformations | Record<string, any>
	): ActorAlignmentInformations {
		if (data instanceof ActorAlignmentInformations) {
			return data
		}

		this.alignmentSide = data.alignmentSide
		this.alignmentValue = data.alignmentValue
		this.alignmentGrade = data.alignmentGrade
		this.characterPower = data.characterPower

		return this
	}
}

export interface RawPortalInformation {
	id: number
	portalId: number
	areaId: number
}

export class PortalInformation extends DofusType {
	public static id: number = 1367

	public portalId: number | undefined = 0
	public areaId: number | undefined = 0

	public constructor(
		portalId?: number | undefined,
		areaId?: number | undefined
	) {
		super()
		this.portalId = portalId
		this.areaId = areaId
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeInt(this.portalId!)
		writer.writeShort(this.areaId!)
	}

	public deserialize(reader: BinaryReader): void {
		this.portalId = reader.readInt()
		this.areaId = reader.readShort()
	}

	public hydrate(
		data: PortalInformation | Record<string, any>
	): PortalInformation {
		if (data instanceof PortalInformation) {
			return data
		}

		this.portalId = data.portalId
		this.areaId = data.areaId

		return this
	}
}

export interface RawAlliancePrismInformation extends RawPrismInformation {
	id: number
	alliance: AllianceInformations
}

export class AlliancePrismInformation extends PrismInformation {
	public static id: number = 5996

	public alliance: AllianceInformations | undefined

	public constructor(
		typeId?: number | undefined,
		state?: number | undefined,
		nextVulnerabilityDate?: number | undefined,
		placementDate?: number | undefined,
		rewardTokenCount?: number | undefined,
		alliance?: AllianceInformations | undefined
	) {
		super(typeId, state, nextVulnerabilityDate, placementDate, rewardTokenCount)
		this.alliance = alliance
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		this.alliance!.serialize(writer)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.alliance = new AllianceInformations()
		this.alliance!.deserialize(reader)
	}

	public hydrate(
		data: AlliancePrismInformation | Record<string, any>
	): AlliancePrismInformation {
		if (data instanceof AlliancePrismInformation) {
			return data
		}

		super.hydrate(data)

		this.alliance = new AllianceInformations().hydrate(data.alliance)

		return this
	}
}

export interface RawAllianceInsiderPrismInformation
	extends RawPrismInformation {
	id: number
	lastTimeSlotModificationDate: number
	lastTimeSlotModificationAuthorGuildId: number
	lastTimeSlotModificationAuthorId: number
	lastTimeSlotModificationAuthorName: string
	modulesObjects: ObjectItem[]
}

export class AllianceInsiderPrismInformation extends PrismInformation {
	public static id: number = 6982

	public lastTimeSlotModificationDate: number | undefined = 0
	public lastTimeSlotModificationAuthorGuildId: number | undefined = 0
	public lastTimeSlotModificationAuthorId: number | undefined = 0
	public lastTimeSlotModificationAuthorName: string | undefined
	public modulesObjects: ObjectItem[] | undefined

	public constructor(
		typeId?: number | undefined,
		state?: number | undefined,
		nextVulnerabilityDate?: number | undefined,
		placementDate?: number | undefined,
		rewardTokenCount?: number | undefined,
		lastTimeSlotModificationDate?: number | undefined,
		lastTimeSlotModificationAuthorGuildId?: number | undefined,
		lastTimeSlotModificationAuthorId?: number | undefined,
		lastTimeSlotModificationAuthorName?: string | undefined,
		modulesObjects?: ObjectItem[] | undefined
	) {
		super(typeId, state, nextVulnerabilityDate, placementDate, rewardTokenCount)
		this.lastTimeSlotModificationDate = lastTimeSlotModificationDate
		this.lastTimeSlotModificationAuthorGuildId = lastTimeSlotModificationAuthorGuildId
		this.lastTimeSlotModificationAuthorId = lastTimeSlotModificationAuthorId
		this.lastTimeSlotModificationAuthorName = lastTimeSlotModificationAuthorName
		this.modulesObjects = modulesObjects
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeInt(this.lastTimeSlotModificationDate!)
		writer.writeVarInt(this.lastTimeSlotModificationAuthorGuildId!)
		writer.writeVarLong(this.lastTimeSlotModificationAuthorId!)
		writer.writeUTF(this.lastTimeSlotModificationAuthorName!)
		writer.writeShort(this.modulesObjects!.length)
		this.modulesObjects!.forEach((current) => {
			current.serialize(writer)
		})
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.lastTimeSlotModificationDate = reader.readInt()
		this.lastTimeSlotModificationAuthorGuildId = reader.readVarInt()
		this.lastTimeSlotModificationAuthorId = reader.readVarLong()
		this.lastTimeSlotModificationAuthorName = reader.readUTF()
		this.modulesObjects = []
		const countModulesObjects = reader.readShort()
		for (let i: number = 0; i < countModulesObjects; i++) {
			const type: ObjectItem = new ObjectItem()
			type.deserialize(reader)
			this.modulesObjects.push(type)
		}
	}

	public hydrate(
		data: AllianceInsiderPrismInformation | Record<string, any>
	): AllianceInsiderPrismInformation {
		if (data instanceof AllianceInsiderPrismInformation) {
			return data
		}

		super.hydrate(data)

		this.lastTimeSlotModificationDate = data.lastTimeSlotModificationDate
		this.lastTimeSlotModificationAuthorGuildId =
			data.lastTimeSlotModificationAuthorGuildId
		this.lastTimeSlotModificationAuthorId =
			data.lastTimeSlotModificationAuthorId
		this.lastTimeSlotModificationAuthorName =
			data.lastTimeSlotModificationAuthorName
		this.modulesObjects = data.modulesObjects.map(
			(dataElement: ObjectItem | Record<string, any>): ObjectItem => {
				if (dataElement instanceof ObjectItem) {
					return dataElement
				} else {
					return new ObjectItem().hydrate(dataElement)
				}
			}
		)

		return this
	}
}

export interface RawGuildMember extends RawCharacterMinimalInformations {
	id: number
	sex: boolean
	havenBagShared: boolean
	breed: number
	rank: number
	givenExperience: number
	experienceGivenPercent: number
	rights: number
	connected: number
	alignmentSide: number
	hoursSinceLastConnection: number
	moodSmileyId: number
	accountId: number
	achievementPoints: number
	status: PlayerStatus
}

export class GuildMember extends CharacterMinimalInformations {
	public static id: number = 8512

	public sex: boolean | undefined = false
	public havenBagShared: boolean | undefined = false
	public breed: number | undefined = 0
	public rank: number | undefined = 0
	public givenExperience: number | undefined = 0
	public experienceGivenPercent: number | undefined = 0
	public rights: number | undefined = 0
	public connected: number | undefined = 99
	public alignmentSide: number | undefined = 0
	public hoursSinceLastConnection: number | undefined = 0
	public moodSmileyId: number | undefined = 0
	public accountId: number | undefined = 0
	public achievementPoints: number | undefined = 0
	public status: PlayerStatus | undefined

	public constructor(
		id_?: number | undefined,
		name?: string | undefined,
		level?: number | undefined,
		sex?: boolean | undefined,
		havenBagShared?: boolean | undefined,
		breed?: number | undefined,
		rank?: number | undefined,
		givenExperience?: number | undefined,
		experienceGivenPercent?: number | undefined,
		rights?: number | undefined,
		connected?: number | undefined,
		alignmentSide?: number | undefined,
		hoursSinceLastConnection?: number | undefined,
		moodSmileyId?: number | undefined,
		accountId?: number | undefined,
		achievementPoints?: number | undefined,
		status?: PlayerStatus | undefined
	) {
		super(id_, name, level)
		this.sex = sex
		this.havenBagShared = havenBagShared
		this.breed = breed
		this.rank = rank
		this.givenExperience = givenExperience
		this.experienceGivenPercent = experienceGivenPercent
		this.rights = rights
		this.connected = connected
		this.alignmentSide = alignmentSide
		this.hoursSinceLastConnection = hoursSinceLastConnection
		this.moodSmileyId = moodSmileyId
		this.accountId = accountId
		this.achievementPoints = achievementPoints
		this.status = status
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		let box0: number = 0
		box0 = setFlag(box0, 0, this.sex!)
		box0 = setFlag(box0, 1, this.havenBagShared!)
		writer.writeByte(box0)
		writer.writeByte(this.breed!)
		writer.writeVarShort(this.rank!)
		writer.writeVarLong(this.givenExperience!)
		writer.writeByte(this.experienceGivenPercent!)
		writer.writeVarInt(this.rights!)
		writer.writeByte(this.connected!)
		writer.writeByte(this.alignmentSide!)
		writer.writeShort(this.hoursSinceLastConnection!)
		writer.writeVarShort(this.moodSmileyId!)
		writer.writeInt(this.accountId!)
		writer.writeInt(this.achievementPoints!)
		writer.writeShort(this.status!.id)
		this.status!.serialize(writer)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		const box0 = reader.readByte()
		this.sex = getFlag(box0, 0)
		this.havenBagShared = getFlag(box0, 1)
		this.breed = reader.readByte()
		this.rank = reader.readVarShort()
		this.givenExperience = reader.readVarLong()
		this.experienceGivenPercent = reader.readByte()
		this.rights = reader.readVarInt()
		this.connected = reader.readByte()
		this.alignmentSide = reader.readByte()
		this.hoursSinceLastConnection = reader.readShort()
		this.moodSmileyId = reader.readVarShort()
		this.accountId = reader.readInt()
		this.achievementPoints = reader.readInt()
		const statusTypeId: number = reader.readShort()
		this.status = new types[statusTypeId]() as PlayerStatus
		this.status!.deserialize(reader)
	}

	public hydrate(data: GuildMember | Record<string, any>): GuildMember {
		if (data instanceof GuildMember) {
			return data
		}

		super.hydrate(data)

		this.sex = data.sex
		this.havenBagShared = data.havenBagShared
		this.breed = data.breed
		this.rank = data.rank
		this.givenExperience = data.givenExperience
		this.experienceGivenPercent = data.experienceGivenPercent
		this.rights = data.rights
		this.connected = data.connected
		this.alignmentSide = data.alignmentSide
		this.hoursSinceLastConnection = data.hoursSinceLastConnection
		this.moodSmileyId = data.moodSmileyId
		this.accountId = data.accountId
		this.achievementPoints = data.achievementPoints
		this.status = (new types[data.status.id]() as PlayerStatus).hydrate(
			data.status
		)
		return this
	}
}

export interface RawSpellItem extends RawItem {
	id: number
	spellId: number
	spellLevel: number
}

export class SpellItem extends Item {
	public static id: number = 7403

	public spellId: number | undefined = 0
	public spellLevel: number | undefined = 0

	public constructor(
		spellId?: number | undefined,
		spellLevel?: number | undefined
	) {
		super()
		this.spellId = spellId
		this.spellLevel = spellLevel
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeInt(this.spellId!)
		writer.writeShort(this.spellLevel!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.spellId = reader.readInt()
		this.spellLevel = reader.readShort()
	}

	public hydrate(data: SpellItem | Record<string, any>): SpellItem {
		if (data instanceof SpellItem) {
			return data
		}

		this.spellId = data.spellId
		this.spellLevel = data.spellLevel

		return this
	}
}

export interface RawForgettableSpellItem extends RawSpellItem {
	id: number
	available: boolean
}

export class ForgettableSpellItem extends SpellItem {
	public static id: number = 6454

	public available: boolean | undefined = false

	public constructor(
		spellId?: number | undefined,
		spellLevel?: number | undefined,
		available?: boolean | undefined
	) {
		super(spellId, spellLevel)
		this.available = available
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeBoolean(this.available!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.available = reader.readBoolean()
	}

	public hydrate(
		data: ForgettableSpellItem | Record<string, any>
	): ForgettableSpellItem {
		if (data instanceof ForgettableSpellItem) {
			return data
		}

		super.hydrate(data)

		this.available = data.available

		return this
	}
}

export interface RawPlayerStatus {
	id: number
	statusId: number
}

export class PlayerStatus extends DofusType {
	public static id: number = 1443

	public statusId: number | undefined = 1

	public constructor(statusId?: number | undefined) {
		super()
		this.statusId = statusId
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeByte(this.statusId!)
	}

	public deserialize(reader: BinaryReader): void {
		this.statusId = reader.readByte()
	}

	public hydrate(data: PlayerStatus | Record<string, any>): PlayerStatus {
		if (data instanceof PlayerStatus) {
			return data
		}

		this.statusId = data.statusId

		return this
	}
}

export interface RawHumanOptionGuild extends RawHumanOption {
	id: number
	guildInformations: GuildInformations
}

export class HumanOptionGuild extends HumanOption {
	public static id: number = 7229

	public guildInformations: GuildInformations | undefined

	public constructor(guildInformations?: GuildInformations | undefined) {
		super()
		this.guildInformations = guildInformations
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		this.guildInformations!.serialize(writer)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.guildInformations = new GuildInformations()
		this.guildInformations!.deserialize(reader)
	}

	public hydrate(
		data: HumanOptionGuild | Record<string, any>
	): HumanOptionGuild {
		if (data instanceof HumanOptionGuild) {
			return data
		}

		this.guildInformations = new GuildInformations().hydrate(
			data.guildInformations
		)

		return this
	}
}

export interface RawTaxCollectorMovement {
	id: number
	movementType: number
	basicInfos: TaxCollectorBasicInformations
	playerId: number
	playerName: string
}

export class TaxCollectorMovement extends DofusType {
	public static id: number = 9466

	public movementType: number | undefined = 0
	public basicInfos: TaxCollectorBasicInformations | undefined
	public playerId: number | undefined = 0
	public playerName: string | undefined

	public constructor(
		movementType?: number | undefined,
		basicInfos?: TaxCollectorBasicInformations | undefined,
		playerId?: number | undefined,
		playerName?: string | undefined
	) {
		super()
		this.movementType = movementType
		this.basicInfos = basicInfos
		this.playerId = playerId
		this.playerName = playerName
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeByte(this.movementType!)
		this.basicInfos!.serialize(writer)
		writer.writeVarLong(this.playerId!)
		writer.writeUTF(this.playerName!)
	}

	public deserialize(reader: BinaryReader): void {
		this.movementType = reader.readByte()
		this.basicInfos = new TaxCollectorBasicInformations()
		this.basicInfos!.deserialize(reader)
		this.playerId = reader.readVarLong()
		this.playerName = reader.readUTF()
	}

	public hydrate(
		data: TaxCollectorMovement | Record<string, any>
	): TaxCollectorMovement {
		if (data instanceof TaxCollectorMovement) {
			return data
		}

		this.movementType = data.movementType
		this.basicInfos = new TaxCollectorBasicInformations().hydrate(
			data.basicInfos
		)
		this.playerId = data.playerId
		this.playerName = data.playerName

		return this
	}
}

export interface RawHouseInformationsForGuild extends RawHouseInformations {
	id: number
	instanceId: number
	secondHand: boolean
	ownerName: string
	worldX: number
	worldY: number
	mapId: number
	subAreaId: number
	skillListIds: number[]
	guildshareParams: number
}

export class HouseInformationsForGuild extends HouseInformations {
	public static id: number = 6667

	public instanceId: number | undefined = 0
	public secondHand: boolean | undefined = false
	public ownerName: string | undefined
	public worldX: number | undefined = 0
	public worldY: number | undefined = 0
	public mapId: number | undefined = 0
	public subAreaId: number | undefined = 0
	public skillListIds: number[] | undefined
	public guildshareParams: number | undefined = 0

	public constructor(
		houseId?: number | undefined,
		modelId?: number | undefined,
		instanceId?: number | undefined,
		secondHand?: boolean | undefined,
		ownerName?: string | undefined,
		worldX?: number | undefined,
		worldY?: number | undefined,
		mapId?: number | undefined,
		subAreaId?: number | undefined,
		skillListIds?: number[] | undefined,
		guildshareParams?: number | undefined
	) {
		super(houseId, modelId)
		this.instanceId = instanceId
		this.secondHand = secondHand
		this.ownerName = ownerName
		this.worldX = worldX
		this.worldY = worldY
		this.mapId = mapId
		this.subAreaId = subAreaId
		this.skillListIds = skillListIds
		this.guildshareParams = guildshareParams
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeInt(this.instanceId!)
		writer.writeBoolean(this.secondHand!)
		writer.writeUTF(this.ownerName!)
		writer.writeShort(this.worldX!)
		writer.writeShort(this.worldY!)
		writer.writeDouble(this.mapId!)
		writer.writeVarShort(this.subAreaId!)
		writer.writeShort(this.skillListIds!.length)
		this.skillListIds!.forEach((current: number) => writer.writeInt(current))
		writer.writeVarInt(this.guildshareParams!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.instanceId = reader.readInt()
		this.secondHand = reader.readBoolean()
		this.ownerName = reader.readUTF()
		this.worldX = reader.readShort()
		this.worldY = reader.readShort()
		this.mapId = reader.readDouble()
		this.subAreaId = reader.readVarShort()
		this.skillListIds = []
		const countSkillListIds = reader.readShort()
		for (let i: number = 0; i < countSkillListIds; i++) {
			this.skillListIds.push(reader.readInt())
		}
		this.guildshareParams = reader.readVarInt()
	}

	public hydrate(
		data: HouseInformationsForGuild | Record<string, any>
	): HouseInformationsForGuild {
		if (data instanceof HouseInformationsForGuild) {
			return data
		}

		super.hydrate(data)

		this.instanceId = data.instanceId
		this.secondHand = data.secondHand
		this.ownerName = data.ownerName
		this.worldX = data.worldX
		this.worldY = data.worldY
		this.mapId = data.mapId
		this.subAreaId = data.subAreaId
		this.skillListIds = data.skillListIds
		this.guildshareParams = data.guildshareParams

		return this
	}
}

export interface RawAbstractContactInformations {
	id: number
	accountId: number
	accountName: string
}

export class AbstractContactInformations extends DofusType {
	public static id: number = 5170

	public accountId: number | undefined = 0
	public accountName: string | undefined

	public constructor(
		accountId?: number | undefined,
		accountName?: string | undefined
	) {
		super()
		this.accountId = accountId
		this.accountName = accountName
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeInt(this.accountId!)
		writer.writeUTF(this.accountName!)
	}

	public deserialize(reader: BinaryReader): void {
		this.accountId = reader.readInt()
		this.accountName = reader.readUTF()
	}

	public hydrate(
		data: AbstractContactInformations | Record<string, any>
	): AbstractContactInformations {
		if (data instanceof AbstractContactInformations) {
			return data
		}

		this.accountId = data.accountId
		this.accountName = data.accountName

		return this
	}
}

export interface RawFriendInformations extends RawAbstractContactInformations {
	id: number
	playerState: number
	lastConnection: number
	achievementPoints: number
	leagueId: number
	ladderPosition: number
}

export class FriendInformations extends AbstractContactInformations {
	public static id: number = 9286

	public playerState: number | undefined = 99
	public lastConnection: number | undefined = 0
	public achievementPoints: number | undefined = 0
	public leagueId: number | undefined = 0
	public ladderPosition: number | undefined = 0

	public constructor(
		accountId?: number | undefined,
		accountName?: string | undefined,
		playerState?: number | undefined,
		lastConnection?: number | undefined,
		achievementPoints?: number | undefined,
		leagueId?: number | undefined,
		ladderPosition?: number | undefined
	) {
		super(accountId, accountName)
		this.playerState = playerState
		this.lastConnection = lastConnection
		this.achievementPoints = achievementPoints
		this.leagueId = leagueId
		this.ladderPosition = ladderPosition
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeByte(this.playerState!)
		writer.writeVarShort(this.lastConnection!)
		writer.writeInt(this.achievementPoints!)
		writer.writeVarShort(this.leagueId!)
		writer.writeInt(this.ladderPosition!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.playerState = reader.readByte()
		this.lastConnection = reader.readVarShort()
		this.achievementPoints = reader.readInt()
		this.leagueId = reader.readVarShort()
		this.ladderPosition = reader.readInt()
	}

	public hydrate(
		data: FriendInformations | Record<string, any>
	): FriendInformations {
		if (data instanceof FriendInformations) {
			return data
		}

		super.hydrate(data)

		this.playerState = data.playerState
		this.lastConnection = data.lastConnection
		this.achievementPoints = data.achievementPoints
		this.leagueId = data.leagueId
		this.ladderPosition = data.ladderPosition

		return this
	}
}

export interface RawFriendOnlineInformations extends RawFriendInformations {
	id: number
	sex: boolean
	havenBagShared: boolean
	playerId: number
	playerName: string
	level: number
	alignmentSide: number
	breed: number
	guildInfo: GuildInformations
	moodSmileyId: number
	status: PlayerStatus
}

export class FriendOnlineInformations extends FriendInformations {
	public static id: number = 450

	public sex: boolean | undefined = false
	public havenBagShared: boolean | undefined = false
	public playerId: number | undefined = 0
	public playerName: string | undefined
	public level: number | undefined = 0
	public alignmentSide: number | undefined = 0
	public breed: number | undefined = 0
	public guildInfo: GuildInformations | undefined
	public moodSmileyId: number | undefined = 0
	public status: PlayerStatus | undefined

	public constructor(
		accountId?: number | undefined,
		accountName?: string | undefined,
		playerState?: number | undefined,
		lastConnection?: number | undefined,
		achievementPoints?: number | undefined,
		leagueId?: number | undefined,
		ladderPosition?: number | undefined,
		sex?: boolean | undefined,
		havenBagShared?: boolean | undefined,
		playerId?: number | undefined,
		playerName?: string | undefined,
		level?: number | undefined,
		alignmentSide?: number | undefined,
		breed?: number | undefined,
		guildInfo?: GuildInformations | undefined,
		moodSmileyId?: number | undefined,
		status?: PlayerStatus | undefined
	) {
		super(
			accountId,
			accountName,
			playerState,
			lastConnection,
			achievementPoints,
			leagueId,
			ladderPosition
		)
		this.sex = sex
		this.havenBagShared = havenBagShared
		this.playerId = playerId
		this.playerName = playerName
		this.level = level
		this.alignmentSide = alignmentSide
		this.breed = breed
		this.guildInfo = guildInfo
		this.moodSmileyId = moodSmileyId
		this.status = status
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		let box0: number = 0
		box0 = setFlag(box0, 0, this.sex!)
		box0 = setFlag(box0, 1, this.havenBagShared!)
		writer.writeByte(box0)
		writer.writeVarLong(this.playerId!)
		writer.writeUTF(this.playerName!)
		writer.writeVarShort(this.level!)
		writer.writeByte(this.alignmentSide!)
		writer.writeByte(this.breed!)
		this.guildInfo!.serialize(writer)
		writer.writeVarShort(this.moodSmileyId!)
		writer.writeShort(this.status!.id)
		this.status!.serialize(writer)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		const box0 = reader.readByte()
		this.sex = getFlag(box0, 0)
		this.havenBagShared = getFlag(box0, 1)
		this.playerId = reader.readVarLong()
		this.playerName = reader.readUTF()
		this.level = reader.readVarShort()
		this.alignmentSide = reader.readByte()
		this.breed = reader.readByte()
		this.guildInfo = new GuildInformations()
		this.guildInfo!.deserialize(reader)
		this.moodSmileyId = reader.readVarShort()
		const statusTypeId: number = reader.readShort()
		this.status = new types[statusTypeId]() as PlayerStatus
		this.status!.deserialize(reader)
	}

	public hydrate(
		data: FriendOnlineInformations | Record<string, any>
	): FriendOnlineInformations {
		if (data instanceof FriendOnlineInformations) {
			return data
		}

		super.hydrate(data)

		this.sex = data.sex
		this.havenBagShared = data.havenBagShared
		this.playerId = data.playerId
		this.playerName = data.playerName
		this.level = data.level
		this.alignmentSide = data.alignmentSide
		this.breed = data.breed
		this.guildInfo = new GuildInformations().hydrate(data.guildInfo)
		this.moodSmileyId = data.moodSmileyId
		this.status = (new types[data.status.id]() as PlayerStatus).hydrate(
			data.status
		)
		return this
	}
}

export interface RawPlayerStatusExtended extends RawPlayerStatus {
	id: number
	message: string
}

export class PlayerStatusExtended extends PlayerStatus {
	public static id: number = 2943

	public message: string | undefined

	public constructor(
		statusId?: number | undefined,
		message?: string | undefined
	) {
		super(statusId)
		this.message = message
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeUTF(this.message!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.message = reader.readUTF()
	}

	public hydrate(
		data: PlayerStatusExtended | Record<string, any>
	): PlayerStatusExtended {
		if (data instanceof PlayerStatusExtended) {
			return data
		}

		super.hydrate(data)

		this.message = data.message

		return this
	}
}

export interface RawAcquaintanceInformation
	extends RawAbstractContactInformations {
	id: number
	playerState: number
}

export class AcquaintanceInformation extends AbstractContactInformations {
	public static id: number = 4492

	public playerState: number | undefined = 99

	public constructor(
		accountId?: number | undefined,
		accountName?: string | undefined,
		playerState?: number | undefined
	) {
		super(accountId, accountName)
		this.playerState = playerState
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeByte(this.playerState!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.playerState = reader.readByte()
	}

	public hydrate(
		data: AcquaintanceInformation | Record<string, any>
	): AcquaintanceInformation {
		if (data instanceof AcquaintanceInformation) {
			return data
		}

		super.hydrate(data)

		this.playerState = data.playerState

		return this
	}
}

export interface RawAcquaintanceOnlineInformation
	extends RawAcquaintanceInformation {
	id: number
	playerId: number
	playerName: string
	moodSmileyId: number
	status: PlayerStatus
}

export class AcquaintanceOnlineInformation extends AcquaintanceInformation {
	public static id: number = 5184

	public playerId: number | undefined = 0
	public playerName: string | undefined
	public moodSmileyId: number | undefined = 0
	public status: PlayerStatus | undefined

	public constructor(
		accountId?: number | undefined,
		accountName?: string | undefined,
		playerState?: number | undefined,
		playerId?: number | undefined,
		playerName?: string | undefined,
		moodSmileyId?: number | undefined,
		status?: PlayerStatus | undefined
	) {
		super(accountId, accountName, playerState)
		this.playerId = playerId
		this.playerName = playerName
		this.moodSmileyId = moodSmileyId
		this.status = status
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeVarLong(this.playerId!)
		writer.writeUTF(this.playerName!)
		writer.writeVarShort(this.moodSmileyId!)
		writer.writeShort(this.status!.id)
		this.status!.serialize(writer)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.playerId = reader.readVarLong()
		this.playerName = reader.readUTF()
		this.moodSmileyId = reader.readVarShort()
		const statusTypeId: number = reader.readShort()
		this.status = new types[statusTypeId]() as PlayerStatus
		this.status!.deserialize(reader)
	}

	public hydrate(
		data: AcquaintanceOnlineInformation | Record<string, any>
	): AcquaintanceOnlineInformation {
		if (data instanceof AcquaintanceOnlineInformation) {
			return data
		}

		super.hydrate(data)

		this.playerId = data.playerId
		this.playerName = data.playerName
		this.moodSmileyId = data.moodSmileyId
		this.status = (new types[data.status.id]() as PlayerStatus).hydrate(
			data.status
		)
		return this
	}
}

export interface RawObjectItemGenericQuantity extends RawItem {
	id: number
	objectGID: number
	quantity: number
}

export class ObjectItemGenericQuantity extends Item {
	public static id: number = 9440

	public objectGID: number | undefined = 0
	public quantity: number | undefined = 0

	public constructor(
		objectGID?: number | undefined,
		quantity?: number | undefined
	) {
		super()
		this.objectGID = objectGID
		this.quantity = quantity
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeVarShort(this.objectGID!)
		writer.writeVarInt(this.quantity!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.objectGID = reader.readVarShort()
		this.quantity = reader.readVarInt()
	}

	public hydrate(
		data: ObjectItemGenericQuantity | Record<string, any>
	): ObjectItemGenericQuantity {
		if (data instanceof ObjectItemGenericQuantity) {
			return data
		}

		this.objectGID = data.objectGID
		this.quantity = data.quantity

		return this
	}
}

export interface RawPaddockContentInformations extends RawPaddockInformations {
	id: number
	paddockId: number
	worldX: number
	worldY: number
	mapId: number
	subAreaId: number
	abandonned: boolean
	mountsInformations: MountInformationsForPaddock[]
}

export class PaddockContentInformations extends PaddockInformations {
	public static id: number = 4735

	public paddockId: number | undefined = 0
	public worldX: number | undefined = 0
	public worldY: number | undefined = 0
	public mapId: number | undefined = 0
	public subAreaId: number | undefined = 0
	public abandonned: boolean | undefined = false
	public mountsInformations: MountInformationsForPaddock[] | undefined

	public constructor(
		maxOutdoorMount?: number | undefined,
		maxItems?: number | undefined,
		paddockId?: number | undefined,
		worldX?: number | undefined,
		worldY?: number | undefined,
		mapId?: number | undefined,
		subAreaId?: number | undefined,
		abandonned?: boolean | undefined,
		mountsInformations?: MountInformationsForPaddock[] | undefined
	) {
		super(maxOutdoorMount, maxItems)
		this.paddockId = paddockId
		this.worldX = worldX
		this.worldY = worldY
		this.mapId = mapId
		this.subAreaId = subAreaId
		this.abandonned = abandonned
		this.mountsInformations = mountsInformations
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeDouble(this.paddockId!)
		writer.writeShort(this.worldX!)
		writer.writeShort(this.worldY!)
		writer.writeDouble(this.mapId!)
		writer.writeVarShort(this.subAreaId!)
		writer.writeBoolean(this.abandonned!)
		writer.writeShort(this.mountsInformations!.length)
		this.mountsInformations!.forEach((current) => {
			current.serialize(writer)
		})
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.paddockId = reader.readDouble()
		this.worldX = reader.readShort()
		this.worldY = reader.readShort()
		this.mapId = reader.readDouble()
		this.subAreaId = reader.readVarShort()
		this.abandonned = reader.readBoolean()
		this.mountsInformations = []
		const countMountsInformations = reader.readShort()
		for (let i: number = 0; i < countMountsInformations; i++) {
			const type: MountInformationsForPaddock = new MountInformationsForPaddock()
			type.deserialize(reader)
			this.mountsInformations.push(type)
		}
	}

	public hydrate(
		data: PaddockContentInformations | Record<string, any>
	): PaddockContentInformations {
		if (data instanceof PaddockContentInformations) {
			return data
		}

		super.hydrate(data)

		this.paddockId = data.paddockId
		this.worldX = data.worldX
		this.worldY = data.worldY
		this.mapId = data.mapId
		this.subAreaId = data.subAreaId
		this.abandonned = data.abandonned
		this.mountsInformations = data.mountsInformations.map(
			(
				dataElement: MountInformationsForPaddock | Record<string, any>
			): MountInformationsForPaddock => {
				if (dataElement instanceof MountInformationsForPaddock) {
					return dataElement
				} else {
					return new MountInformationsForPaddock().hydrate(dataElement)
				}
			}
		)

		return this
	}
}

export interface RawIgnoredInformations extends RawAbstractContactInformations {
	id: number
}

export class IgnoredInformations extends AbstractContactInformations {
	public static id: number = 4160

	public constructor(
		accountId?: number | undefined,
		accountName?: string | undefined
	) {
		super(accountId, accountName)
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
	}

	public hydrate(
		data: IgnoredInformations | Record<string, any>
	): IgnoredInformations {
		if (data instanceof IgnoredInformations) {
			return data
		}

		super.hydrate(data)

		return this
	}
}

export interface RawIgnoredOnlineInformations extends RawIgnoredInformations {
	id: number
	playerId: number
	playerName: string
	breed: number
	sex: boolean
}

export class IgnoredOnlineInformations extends IgnoredInformations {
	public static id: number = 5101

	public playerId: number | undefined = 0
	public playerName: string | undefined
	public breed: number | undefined = 0
	public sex: boolean | undefined = false

	public constructor(
		accountId?: number | undefined,
		accountName?: string | undefined,
		playerId?: number | undefined,
		playerName?: string | undefined,
		breed?: number | undefined,
		sex?: boolean | undefined
	) {
		super(accountId, accountName)
		this.playerId = playerId
		this.playerName = playerName
		this.breed = breed
		this.sex = sex
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeVarLong(this.playerId!)
		writer.writeUTF(this.playerName!)
		writer.writeByte(this.breed!)
		writer.writeBoolean(this.sex!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.playerId = reader.readVarLong()
		this.playerName = reader.readUTF()
		this.breed = reader.readByte()
		this.sex = reader.readBoolean()
	}

	public hydrate(
		data: IgnoredOnlineInformations | Record<string, any>
	): IgnoredOnlineInformations {
		if (data instanceof IgnoredOnlineInformations) {
			return data
		}

		super.hydrate(data)

		this.playerId = data.playerId
		this.playerName = data.playerName
		this.breed = data.breed
		this.sex = data.sex

		return this
	}
}

export interface RawTaxCollectorInformations {
	id: number
	uniqueId: number
	firtNameId: number
	lastNameId: number
	additionalInfos: AdditionalTaxCollectorInformations
	worldX: number
	worldY: number
	subAreaId: number
	state: number
	look: EntityLook
	complements: TaxCollectorComplementaryInformations[]
}

export class TaxCollectorInformations extends DofusType {
	public static id: number = 5151

	public uniqueId: number | undefined = 0
	public firtNameId: number | undefined = 0
	public lastNameId: number | undefined = 0
	public additionalInfos: AdditionalTaxCollectorInformations | undefined
	public worldX: number | undefined = 0
	public worldY: number | undefined = 0
	public subAreaId: number | undefined = 0
	public state: number | undefined = 0
	public look: EntityLook | undefined
	public complements: TaxCollectorComplementaryInformations[] | undefined

	public constructor(
		uniqueId?: number | undefined,
		firtNameId?: number | undefined,
		lastNameId?: number | undefined,
		additionalInfos?: AdditionalTaxCollectorInformations | undefined,
		worldX?: number | undefined,
		worldY?: number | undefined,
		subAreaId?: number | undefined,
		state?: number | undefined,
		look?: EntityLook | undefined,
		complements?: TaxCollectorComplementaryInformations[] | undefined
	) {
		super()
		this.uniqueId = uniqueId
		this.firtNameId = firtNameId
		this.lastNameId = lastNameId
		this.additionalInfos = additionalInfos
		this.worldX = worldX
		this.worldY = worldY
		this.subAreaId = subAreaId
		this.state = state
		this.look = look
		this.complements = complements
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeDouble(this.uniqueId!)
		writer.writeVarShort(this.firtNameId!)
		writer.writeVarShort(this.lastNameId!)
		this.additionalInfos!.serialize(writer)
		writer.writeShort(this.worldX!)
		writer.writeShort(this.worldY!)
		writer.writeVarShort(this.subAreaId!)
		writer.writeByte(this.state!)
		this.look!.serialize(writer)
		writer.writeShort(this.complements!.length)
		this.complements!.forEach((current) => {
			writer.writeShort(current.id)
			current.serialize(writer)
		})
	}

	public deserialize(reader: BinaryReader): void {
		this.uniqueId = reader.readDouble()
		this.firtNameId = reader.readVarShort()
		this.lastNameId = reader.readVarShort()
		this.additionalInfos = new AdditionalTaxCollectorInformations()
		this.additionalInfos!.deserialize(reader)
		this.worldX = reader.readShort()
		this.worldY = reader.readShort()
		this.subAreaId = reader.readVarShort()
		this.state = reader.readByte()
		this.look = new EntityLook()
		this.look!.deserialize(reader)
		this.complements = []
		const countComplements = reader.readShort()
		for (let i: number = 0; i < countComplements; i++) {
			const complementsTypeId: number = reader.readShort()
			const type: TaxCollectorComplementaryInformations = new types[
				complementsTypeId
			]() as TaxCollectorComplementaryInformations
			type.deserialize(reader)
			this.complements.push(type)
		}
	}

	public hydrate(
		data: TaxCollectorInformations | Record<string, any>
	): TaxCollectorInformations {
		if (data instanceof TaxCollectorInformations) {
			return data
		}

		this.uniqueId = data.uniqueId
		this.firtNameId = data.firtNameId
		this.lastNameId = data.lastNameId
		this.additionalInfos = new AdditionalTaxCollectorInformations().hydrate(
			data.additionalInfos
		)
		this.worldX = data.worldX
		this.worldY = data.worldY
		this.subAreaId = data.subAreaId
		this.state = data.state
		this.look = new EntityLook().hydrate(data.look)
		this.complements = data.complements.map(
			(
				dataElement: TaxCollectorComplementaryInformations | Record<string, any>
			): TaxCollectorComplementaryInformations => {
				if (dataElement instanceof TaxCollectorComplementaryInformations) {
					return dataElement
				} else {
					return (new types[
						dataElement.id
					]() as TaxCollectorComplementaryInformations).hydrate(dataElement)
				}
			}
		)

		return this
	}
}

export interface RawAbstractSocialGroupInfos {
	id: number
}

export class AbstractSocialGroupInfos extends DofusType {
	public static id: number = 781

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public serialize(writer: BinaryWriter): void {}

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public deserialize(reader: BinaryReader): void {}

	public hydrate(
		data: AbstractSocialGroupInfos | Record<string, any>
	): AbstractSocialGroupInfos {
		if (data instanceof AbstractSocialGroupInfos) {
			return data
		}

		return this
	}
}

export interface RawBasicGuildInformations extends RawAbstractSocialGroupInfos {
	id: number
	guildId: number
	guildName: string
	guildLevel: number
}

export class BasicGuildInformations extends AbstractSocialGroupInfos {
	public static id: number = 492

	public guildId: number | undefined = 0
	public guildName: string | undefined
	public guildLevel: number | undefined = 0

	public constructor(
		guildId?: number | undefined,
		guildName?: string | undefined,
		guildLevel?: number | undefined
	) {
		super()
		this.guildId = guildId
		this.guildName = guildName
		this.guildLevel = guildLevel
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeVarInt(this.guildId!)
		writer.writeUTF(this.guildName!)
		writer.writeByte(this.guildLevel!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.guildId = reader.readVarInt()
		this.guildName = reader.readUTF()
		this.guildLevel = reader.readByte()
	}

	public hydrate(
		data: BasicGuildInformations | Record<string, any>
	): BasicGuildInformations {
		if (data instanceof BasicGuildInformations) {
			return data
		}

		this.guildId = data.guildId
		this.guildName = data.guildName
		this.guildLevel = data.guildLevel

		return this
	}
}

export interface RawBasicAllianceInformations
	extends RawAbstractSocialGroupInfos {
	id: number
	allianceId: number
	allianceTag: string
}

export class BasicAllianceInformations extends AbstractSocialGroupInfos {
	public static id: number = 3988

	public allianceId: number | undefined = 0
	public allianceTag: string | undefined

	public constructor(
		allianceId?: number | undefined,
		allianceTag?: string | undefined
	) {
		super()
		this.allianceId = allianceId
		this.allianceTag = allianceTag
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeVarInt(this.allianceId!)
		writer.writeUTF(this.allianceTag!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.allianceId = reader.readVarInt()
		this.allianceTag = reader.readUTF()
	}

	public hydrate(
		data: BasicAllianceInformations | Record<string, any>
	): BasicAllianceInformations {
		if (data instanceof BasicAllianceInformations) {
			return data
		}

		this.allianceId = data.allianceId
		this.allianceTag = data.allianceTag

		return this
	}
}

export interface RawObjectItemQuantityPriceDateEffects
	extends RawObjectItemGenericQuantity {
	id: number
	price: number
	effects: ObjectEffects
	date: number
}

export class ObjectItemQuantityPriceDateEffects extends ObjectItemGenericQuantity {
	public static id: number = 6659

	public price: number | undefined = 0
	public effects: ObjectEffects | undefined
	public date: number | undefined = 0

	public constructor(
		objectGID?: number | undefined,
		quantity?: number | undefined,
		price?: number | undefined,
		effects?: ObjectEffects | undefined,
		date?: number | undefined
	) {
		super(objectGID, quantity)
		this.price = price
		this.effects = effects
		this.date = date
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeVarLong(this.price!)
		this.effects!.serialize(writer)
		writer.writeInt(this.date!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.price = reader.readVarLong()
		this.effects = new ObjectEffects()
		this.effects!.deserialize(reader)
		this.date = reader.readInt()
	}

	public hydrate(
		data: ObjectItemQuantityPriceDateEffects | Record<string, any>
	): ObjectItemQuantityPriceDateEffects {
		if (data instanceof ObjectItemQuantityPriceDateEffects) {
			return data
		}

		super.hydrate(data)

		this.price = data.price
		this.effects = new ObjectEffects().hydrate(data.effects)
		this.date = data.date

		return this
	}
}

export interface RawDungeonPartyFinderPlayer {
	id: number
	playerId: number
	playerName: string
	breed: number
	sex: boolean
	level: number
}

export class DungeonPartyFinderPlayer extends DofusType {
	public static id: number = 8707

	public playerId: number | undefined = 0
	public playerName: string | undefined
	public breed: number | undefined = 0
	public sex: boolean | undefined = false
	public level: number | undefined = 0

	public constructor(
		playerId?: number | undefined,
		playerName?: string | undefined,
		breed?: number | undefined,
		sex?: boolean | undefined,
		level?: number | undefined
	) {
		super()
		this.playerId = playerId
		this.playerName = playerName
		this.breed = breed
		this.sex = sex
		this.level = level
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarLong(this.playerId!)
		writer.writeUTF(this.playerName!)
		writer.writeByte(this.breed!)
		writer.writeBoolean(this.sex!)
		writer.writeVarShort(this.level!)
	}

	public deserialize(reader: BinaryReader): void {
		this.playerId = reader.readVarLong()
		this.playerName = reader.readUTF()
		this.breed = reader.readByte()
		this.sex = reader.readBoolean()
		this.level = reader.readVarShort()
	}

	public hydrate(
		data: DungeonPartyFinderPlayer | Record<string, any>
	): DungeonPartyFinderPlayer {
		if (data instanceof DungeonPartyFinderPlayer) {
			return data
		}

		this.playerId = data.playerId
		this.playerName = data.playerName
		this.breed = data.breed
		this.sex = data.sex
		this.level = data.level

		return this
	}
}

export interface RawPartyMemberInformations
	extends RawCharacterBaseInformations {
	id: number
	lifePoints: number
	maxLifePoints: number
	prospecting: number
	regenRate: number
	initiative: number
	alignmentSide: number
	worldX: number
	worldY: number
	mapId: number
	subAreaId: number
	status: PlayerStatus
	entities: PartyEntityBaseInformation[]
}

export class PartyMemberInformations extends CharacterBaseInformations {
	public static id: number = 8246

	public lifePoints: number | undefined = 0
	public maxLifePoints: number | undefined = 0
	public prospecting: number | undefined = 0
	public regenRate: number | undefined = 0
	public initiative: number | undefined = 0
	public alignmentSide: number | undefined = 0
	public worldX: number | undefined = 0
	public worldY: number | undefined = 0
	public mapId: number | undefined = 0
	public subAreaId: number | undefined = 0
	public status: PlayerStatus | undefined
	public entities: PartyEntityBaseInformation[] | undefined

	public constructor(
		id_?: number | undefined,
		name?: string | undefined,
		level?: number | undefined,
		entityLook?: EntityLook | undefined,
		breed?: number | undefined,
		sex?: boolean | undefined,
		lifePoints?: number | undefined,
		maxLifePoints?: number | undefined,
		prospecting?: number | undefined,
		regenRate?: number | undefined,
		initiative?: number | undefined,
		alignmentSide?: number | undefined,
		worldX?: number | undefined,
		worldY?: number | undefined,
		mapId?: number | undefined,
		subAreaId?: number | undefined,
		status?: PlayerStatus | undefined,
		entities?: PartyEntityBaseInformation[] | undefined
	) {
		super(id_, name, level, entityLook, breed, sex)
		this.lifePoints = lifePoints
		this.maxLifePoints = maxLifePoints
		this.prospecting = prospecting
		this.regenRate = regenRate
		this.initiative = initiative
		this.alignmentSide = alignmentSide
		this.worldX = worldX
		this.worldY = worldY
		this.mapId = mapId
		this.subAreaId = subAreaId
		this.status = status
		this.entities = entities
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeVarInt(this.lifePoints!)
		writer.writeVarInt(this.maxLifePoints!)
		writer.writeVarShort(this.prospecting!)
		writer.writeByte(this.regenRate!)
		writer.writeVarShort(this.initiative!)
		writer.writeByte(this.alignmentSide!)
		writer.writeShort(this.worldX!)
		writer.writeShort(this.worldY!)
		writer.writeDouble(this.mapId!)
		writer.writeVarShort(this.subAreaId!)
		writer.writeShort(this.status!.id)
		this.status!.serialize(writer)
		writer.writeShort(this.entities!.length)
		this.entities!.forEach((current) => {
			writer.writeShort(current.id)
			current.serialize(writer)
		})
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.lifePoints = reader.readVarInt()
		this.maxLifePoints = reader.readVarInt()
		this.prospecting = reader.readVarShort()
		this.regenRate = reader.readByte()
		this.initiative = reader.readVarShort()
		this.alignmentSide = reader.readByte()
		this.worldX = reader.readShort()
		this.worldY = reader.readShort()
		this.mapId = reader.readDouble()
		this.subAreaId = reader.readVarShort()
		const statusTypeId: number = reader.readShort()
		this.status = new types[statusTypeId]() as PlayerStatus
		this.status!.deserialize(reader)
		this.entities = []
		const countEntities = reader.readShort()
		for (let i: number = 0; i < countEntities; i++) {
			const entitiesTypeId: number = reader.readShort()
			const type: PartyEntityBaseInformation = new types[
				entitiesTypeId
			]() as PartyEntityBaseInformation
			type.deserialize(reader)
			this.entities.push(type)
		}
	}

	public hydrate(
		data: PartyMemberInformations | Record<string, any>
	): PartyMemberInformations {
		if (data instanceof PartyMemberInformations) {
			return data
		}

		super.hydrate(data)

		this.lifePoints = data.lifePoints
		this.maxLifePoints = data.maxLifePoints
		this.prospecting = data.prospecting
		this.regenRate = data.regenRate
		this.initiative = data.initiative
		this.alignmentSide = data.alignmentSide
		this.worldX = data.worldX
		this.worldY = data.worldY
		this.mapId = data.mapId
		this.subAreaId = data.subAreaId
		this.status = (new types[data.status.id]() as PlayerStatus).hydrate(
			data.status
		)
		this.entities = data.entities.map(
			(
				dataElement: PartyEntityBaseInformation | Record<string, any>
			): PartyEntityBaseInformation => {
				if (dataElement instanceof PartyEntityBaseInformation) {
					return dataElement
				} else {
					return (new types[
						dataElement.id
					]() as PartyEntityBaseInformation).hydrate(dataElement)
				}
			}
		)

		return this
	}
}

export interface RawPartyMemberArenaInformations
	extends RawPartyMemberInformations {
	id: number
	rank: number
}

export class PartyMemberArenaInformations extends PartyMemberInformations {
	public static id: number = 1101

	public rank: number | undefined = 0

	public constructor(
		id_?: number | undefined,
		name?: string | undefined,
		level?: number | undefined,
		entityLook?: EntityLook | undefined,
		breed?: number | undefined,
		sex?: boolean | undefined,
		lifePoints?: number | undefined,
		maxLifePoints?: number | undefined,
		prospecting?: number | undefined,
		regenRate?: number | undefined,
		initiative?: number | undefined,
		alignmentSide?: number | undefined,
		worldX?: number | undefined,
		worldY?: number | undefined,
		mapId?: number | undefined,
		subAreaId?: number | undefined,
		status?: PlayerStatus | undefined,
		entities?: PartyEntityBaseInformation[] | undefined,
		rank?: number | undefined
	) {
		super(
			id_,
			name,
			level,
			entityLook,
			breed,
			sex,
			lifePoints,
			maxLifePoints,
			prospecting,
			regenRate,
			initiative,
			alignmentSide,
			worldX,
			worldY,
			mapId,
			subAreaId,
			status,
			entities
		)
		this.rank = rank
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeVarShort(this.rank!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.rank = reader.readVarShort()
	}

	public hydrate(
		data: PartyMemberArenaInformations | Record<string, any>
	): PartyMemberArenaInformations {
		if (data instanceof PartyMemberArenaInformations) {
			return data
		}

		super.hydrate(data)

		this.rank = data.rank

		return this
	}
}

export interface RawPartyEntityBaseInformation {
	id: number
	indexId: number
	entityModelId: number
	entityLook: EntityLook
}

export class PartyEntityBaseInformation extends DofusType {
	public static id: number = 4252

	public indexId: number | undefined = 0
	public entityModelId: number | undefined = 0
	public entityLook: EntityLook | undefined

	public constructor(
		indexId?: number | undefined,
		entityModelId?: number | undefined,
		entityLook?: EntityLook | undefined
	) {
		super()
		this.indexId = indexId
		this.entityModelId = entityModelId
		this.entityLook = entityLook
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeByte(this.indexId!)
		writer.writeByte(this.entityModelId!)
		this.entityLook!.serialize(writer)
	}

	public deserialize(reader: BinaryReader): void {
		this.indexId = reader.readByte()
		this.entityModelId = reader.readByte()
		this.entityLook = new EntityLook()
		this.entityLook!.deserialize(reader)
	}

	public hydrate(
		data: PartyEntityBaseInformation | Record<string, any>
	): PartyEntityBaseInformation {
		if (data instanceof PartyEntityBaseInformation) {
			return data
		}

		this.indexId = data.indexId
		this.entityModelId = data.entityModelId
		this.entityLook = new EntityLook().hydrate(data.entityLook)

		return this
	}
}

export interface RawPartyInvitationMemberInformations
	extends RawCharacterBaseInformations {
	id: number
	worldX: number
	worldY: number
	mapId: number
	subAreaId: number
	entities: PartyEntityBaseInformation[]
}

export class PartyInvitationMemberInformations extends CharacterBaseInformations {
	public static id: number = 7145

	public worldX: number | undefined = 0
	public worldY: number | undefined = 0
	public mapId: number | undefined = 0
	public subAreaId: number | undefined = 0
	public entities: PartyEntityBaseInformation[] | undefined

	public constructor(
		id_?: number | undefined,
		name?: string | undefined,
		level?: number | undefined,
		entityLook?: EntityLook | undefined,
		breed?: number | undefined,
		sex?: boolean | undefined,
		worldX?: number | undefined,
		worldY?: number | undefined,
		mapId?: number | undefined,
		subAreaId?: number | undefined,
		entities?: PartyEntityBaseInformation[] | undefined
	) {
		super(id_, name, level, entityLook, breed, sex)
		this.worldX = worldX
		this.worldY = worldY
		this.mapId = mapId
		this.subAreaId = subAreaId
		this.entities = entities
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeShort(this.worldX!)
		writer.writeShort(this.worldY!)
		writer.writeDouble(this.mapId!)
		writer.writeVarShort(this.subAreaId!)
		writer.writeShort(this.entities!.length)
		this.entities!.forEach((current) => {
			current.serialize(writer)
		})
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.worldX = reader.readShort()
		this.worldY = reader.readShort()
		this.mapId = reader.readDouble()
		this.subAreaId = reader.readVarShort()
		this.entities = []
		const countEntities = reader.readShort()
		for (let i: number = 0; i < countEntities; i++) {
			const type: PartyEntityBaseInformation = new PartyEntityBaseInformation()
			type.deserialize(reader)
			this.entities.push(type)
		}
	}

	public hydrate(
		data: PartyInvitationMemberInformations | Record<string, any>
	): PartyInvitationMemberInformations {
		if (data instanceof PartyInvitationMemberInformations) {
			return data
		}

		super.hydrate(data)

		this.worldX = data.worldX
		this.worldY = data.worldY
		this.mapId = data.mapId
		this.subAreaId = data.subAreaId
		this.entities = data.entities.map(
			(
				dataElement: PartyEntityBaseInformation | Record<string, any>
			): PartyEntityBaseInformation => {
				if (dataElement instanceof PartyEntityBaseInformation) {
					return dataElement
				} else {
					return new PartyEntityBaseInformation().hydrate(dataElement)
				}
			}
		)

		return this
	}
}

export interface RawPartyGuestInformations {
	id: number
	guestId: number
	hostId: number
	name: string
	guestLook: EntityLook
	breed: number
	sex: boolean
	status: PlayerStatus
	entities: PartyEntityBaseInformation[]
}

export class PartyGuestInformations extends DofusType {
	public static id: number = 9468

	public guestId: number | undefined = 0
	public hostId: number | undefined = 0
	public name: string | undefined
	public guestLook: EntityLook | undefined
	public breed: number | undefined = 0
	public sex: boolean | undefined = false
	public status: PlayerStatus | undefined
	public entities: PartyEntityBaseInformation[] | undefined

	public constructor(
		guestId?: number | undefined,
		hostId?: number | undefined,
		name?: string | undefined,
		guestLook?: EntityLook | undefined,
		breed?: number | undefined,
		sex?: boolean | undefined,
		status?: PlayerStatus | undefined,
		entities?: PartyEntityBaseInformation[] | undefined
	) {
		super()
		this.guestId = guestId
		this.hostId = hostId
		this.name = name
		this.guestLook = guestLook
		this.breed = breed
		this.sex = sex
		this.status = status
		this.entities = entities
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarLong(this.guestId!)
		writer.writeVarLong(this.hostId!)
		writer.writeUTF(this.name!)
		this.guestLook!.serialize(writer)
		writer.writeByte(this.breed!)
		writer.writeBoolean(this.sex!)
		writer.writeShort(this.status!.id)
		this.status!.serialize(writer)
		writer.writeShort(this.entities!.length)
		this.entities!.forEach((current) => {
			current.serialize(writer)
		})
	}

	public deserialize(reader: BinaryReader): void {
		this.guestId = reader.readVarLong()
		this.hostId = reader.readVarLong()
		this.name = reader.readUTF()
		this.guestLook = new EntityLook()
		this.guestLook!.deserialize(reader)
		this.breed = reader.readByte()
		this.sex = reader.readBoolean()
		const statusTypeId: number = reader.readShort()
		this.status = new types[statusTypeId]() as PlayerStatus
		this.status!.deserialize(reader)
		this.entities = []
		const countEntities = reader.readShort()
		for (let i: number = 0; i < countEntities; i++) {
			const type: PartyEntityBaseInformation = new PartyEntityBaseInformation()
			type.deserialize(reader)
			this.entities.push(type)
		}
	}

	public hydrate(
		data: PartyGuestInformations | Record<string, any>
	): PartyGuestInformations {
		if (data instanceof PartyGuestInformations) {
			return data
		}

		this.guestId = data.guestId
		this.hostId = data.hostId
		this.name = data.name
		this.guestLook = new EntityLook().hydrate(data.guestLook)
		this.breed = data.breed
		this.sex = data.sex
		this.status = (new types[data.status.id]() as PlayerStatus).hydrate(
			data.status
		)
		this.entities = data.entities.map(
			(
				dataElement: PartyEntityBaseInformation | Record<string, any>
			): PartyEntityBaseInformation => {
				if (dataElement instanceof PartyEntityBaseInformation) {
					return dataElement
				} else {
					return new PartyEntityBaseInformation().hydrate(dataElement)
				}
			}
		)

		return this
	}
}

export interface RawPartyEntityMemberInformation
	extends RawPartyEntityBaseInformation {
	id: number
	initiative: number
	lifePoints: number
	maxLifePoints: number
	prospecting: number
	regenRate: number
}

export class PartyEntityMemberInformation extends PartyEntityBaseInformation {
	public static id: number = 4347

	public initiative: number | undefined = 0
	public lifePoints: number | undefined = 0
	public maxLifePoints: number | undefined = 0
	public prospecting: number | undefined = 0
	public regenRate: number | undefined = 0

	public constructor(
		indexId?: number | undefined,
		entityModelId?: number | undefined,
		entityLook?: EntityLook | undefined,
		initiative?: number | undefined,
		lifePoints?: number | undefined,
		maxLifePoints?: number | undefined,
		prospecting?: number | undefined,
		regenRate?: number | undefined
	) {
		super(indexId, entityModelId, entityLook)
		this.initiative = initiative
		this.lifePoints = lifePoints
		this.maxLifePoints = maxLifePoints
		this.prospecting = prospecting
		this.regenRate = regenRate
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeVarShort(this.initiative!)
		writer.writeVarInt(this.lifePoints!)
		writer.writeVarInt(this.maxLifePoints!)
		writer.writeVarShort(this.prospecting!)
		writer.writeByte(this.regenRate!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.initiative = reader.readVarShort()
		this.lifePoints = reader.readVarInt()
		this.maxLifePoints = reader.readVarInt()
		this.prospecting = reader.readVarShort()
		this.regenRate = reader.readByte()
	}

	public hydrate(
		data: PartyEntityMemberInformation | Record<string, any>
	): PartyEntityMemberInformation {
		if (data instanceof PartyEntityMemberInformation) {
			return data
		}

		super.hydrate(data)

		this.initiative = data.initiative
		this.lifePoints = data.lifePoints
		this.maxLifePoints = data.maxLifePoints
		this.prospecting = data.prospecting
		this.regenRate = data.regenRate

		return this
	}
}

export interface RawGuildInformations extends RawBasicGuildInformations {
	id: number
	guildEmblem: GuildEmblem
}

export class GuildInformations extends BasicGuildInformations {
	public static id: number = 6928

	public guildEmblem: GuildEmblem | undefined

	public constructor(
		guildId?: number | undefined,
		guildName?: string | undefined,
		guildLevel?: number | undefined,
		guildEmblem?: GuildEmblem | undefined
	) {
		super(guildId, guildName, guildLevel)
		this.guildEmblem = guildEmblem
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		this.guildEmblem!.serialize(writer)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.guildEmblem = new GuildEmblem()
		this.guildEmblem!.deserialize(reader)
	}

	public hydrate(
		data: GuildInformations | Record<string, any>
	): GuildInformations {
		if (data instanceof GuildInformations) {
			return data
		}

		super.hydrate(data)

		this.guildEmblem = new GuildEmblem().hydrate(data.guildEmblem)

		return this
	}
}

export interface RawGuildInAllianceInformations extends RawGuildInformations {
	id: number
	nbMembers: number
	joinDate: number
}

export class GuildInAllianceInformations extends GuildInformations {
	public static id: number = 8268

	public nbMembers: number | undefined = 0
	public joinDate: number | undefined = 0

	public constructor(
		guildId?: number | undefined,
		guildName?: string | undefined,
		guildLevel?: number | undefined,
		guildEmblem?: GuildEmblem | undefined,
		nbMembers?: number | undefined,
		joinDate?: number | undefined
	) {
		super(guildId, guildName, guildLevel, guildEmblem)
		this.nbMembers = nbMembers
		this.joinDate = joinDate
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeByte(this.nbMembers!)
		writer.writeInt(this.joinDate!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.nbMembers = reader.readByte()
		this.joinDate = reader.readInt()
	}

	public hydrate(
		data: GuildInAllianceInformations | Record<string, any>
	): GuildInAllianceInformations {
		if (data instanceof GuildInAllianceInformations) {
			return data
		}

		super.hydrate(data)

		this.nbMembers = data.nbMembers
		this.joinDate = data.joinDate

		return this
	}
}

export interface RawPrismSubareaEmptyInfo {
	id: number
	subAreaId: number
	allianceId: number
}

export class PrismSubareaEmptyInfo extends DofusType {
	public static id: number = 9305

	public subAreaId: number | undefined = 0
	public allianceId: number | undefined = 0

	public constructor(
		subAreaId?: number | undefined,
		allianceId?: number | undefined
	) {
		super()
		this.subAreaId = subAreaId
		this.allianceId = allianceId
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarShort(this.subAreaId!)
		writer.writeVarInt(this.allianceId!)
	}

	public deserialize(reader: BinaryReader): void {
		this.subAreaId = reader.readVarShort()
		this.allianceId = reader.readVarInt()
	}

	public hydrate(
		data: PrismSubareaEmptyInfo | Record<string, any>
	): PrismSubareaEmptyInfo {
		if (data instanceof PrismSubareaEmptyInfo) {
			return data
		}

		this.subAreaId = data.subAreaId
		this.allianceId = data.allianceId

		return this
	}
}

export interface RawPrismGeolocalizedInformation
	extends RawPrismSubareaEmptyInfo {
	id: number
	worldX: number
	worldY: number
	mapId: number
	prism: PrismInformation
}

export class PrismGeolocalizedInformation extends PrismSubareaEmptyInfo {
	public static id: number = 8192

	public worldX: number | undefined = 0
	public worldY: number | undefined = 0
	public mapId: number | undefined = 0
	public prism: PrismInformation | undefined

	public constructor(
		subAreaId?: number | undefined,
		allianceId?: number | undefined,
		worldX?: number | undefined,
		worldY?: number | undefined,
		mapId?: number | undefined,
		prism?: PrismInformation | undefined
	) {
		super(subAreaId, allianceId)
		this.worldX = worldX
		this.worldY = worldY
		this.mapId = mapId
		this.prism = prism
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeShort(this.worldX!)
		writer.writeShort(this.worldY!)
		writer.writeDouble(this.mapId!)
		writer.writeShort(this.prism!.id)
		this.prism!.serialize(writer)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.worldX = reader.readShort()
		this.worldY = reader.readShort()
		this.mapId = reader.readDouble()
		const prismTypeId: number = reader.readShort()
		this.prism = new types[prismTypeId]() as PrismInformation
		this.prism!.deserialize(reader)
	}

	public hydrate(
		data: PrismGeolocalizedInformation | Record<string, any>
	): PrismGeolocalizedInformation {
		if (data instanceof PrismGeolocalizedInformation) {
			return data
		}

		super.hydrate(data)

		this.worldX = data.worldX
		this.worldY = data.worldY
		this.mapId = data.mapId
		this.prism = (new types[data.prism.id]() as PrismInformation).hydrate(
			data.prism
		)
		return this
	}
}

export interface RawGuildFactSheetInformations extends RawGuildInformations {
	id: number
	leaderId: number
	nbMembers: number
}

export class GuildFactSheetInformations extends GuildInformations {
	public static id: number = 5100

	public leaderId: number | undefined = 0
	public nbMembers: number | undefined = 0

	public constructor(
		guildId?: number | undefined,
		guildName?: string | undefined,
		guildLevel?: number | undefined,
		guildEmblem?: GuildEmblem | undefined,
		leaderId?: number | undefined,
		nbMembers?: number | undefined
	) {
		super(guildId, guildName, guildLevel, guildEmblem)
		this.leaderId = leaderId
		this.nbMembers = nbMembers
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeVarLong(this.leaderId!)
		writer.writeVarShort(this.nbMembers!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.leaderId = reader.readVarLong()
		this.nbMembers = reader.readVarShort()
	}

	public hydrate(
		data: GuildFactSheetInformations | Record<string, any>
	): GuildFactSheetInformations {
		if (data instanceof GuildFactSheetInformations) {
			return data
		}

		super.hydrate(data)

		this.leaderId = data.leaderId
		this.nbMembers = data.nbMembers

		return this
	}
}

export interface RawGuildInsiderFactSheetInformations
	extends RawGuildFactSheetInformations {
	id: number
	leaderName: string
	nbConnectedMembers: number
	nbTaxCollectors: number
	lastActivity: number
}

export class GuildInsiderFactSheetInformations extends GuildFactSheetInformations {
	public static id: number = 6301

	public leaderName: string | undefined
	public nbConnectedMembers: number | undefined = 0
	public nbTaxCollectors: number | undefined = 0
	public lastActivity: number | undefined = 0

	public constructor(
		guildId?: number | undefined,
		guildName?: string | undefined,
		guildLevel?: number | undefined,
		guildEmblem?: GuildEmblem | undefined,
		leaderId?: number | undefined,
		nbMembers?: number | undefined,
		leaderName?: string | undefined,
		nbConnectedMembers?: number | undefined,
		nbTaxCollectors?: number | undefined,
		lastActivity?: number | undefined
	) {
		super(guildId, guildName, guildLevel, guildEmblem, leaderId, nbMembers)
		this.leaderName = leaderName
		this.nbConnectedMembers = nbConnectedMembers
		this.nbTaxCollectors = nbTaxCollectors
		this.lastActivity = lastActivity
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeUTF(this.leaderName!)
		writer.writeVarShort(this.nbConnectedMembers!)
		writer.writeByte(this.nbTaxCollectors!)
		writer.writeInt(this.lastActivity!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.leaderName = reader.readUTF()
		this.nbConnectedMembers = reader.readVarShort()
		this.nbTaxCollectors = reader.readByte()
		this.lastActivity = reader.readInt()
	}

	public hydrate(
		data: GuildInsiderFactSheetInformations | Record<string, any>
	): GuildInsiderFactSheetInformations {
		if (data instanceof GuildInsiderFactSheetInformations) {
			return data
		}

		super.hydrate(data)

		this.leaderName = data.leaderName
		this.nbConnectedMembers = data.nbConnectedMembers
		this.nbTaxCollectors = data.nbTaxCollectors
		this.lastActivity = data.lastActivity

		return this
	}
}

export interface RawActorExtendedAlignmentInformations
	extends RawActorAlignmentInformations {
	id: number
	honor: number
	honorGradeFloor: number
	honorNextGradeFloor: number
	aggressable: number
}

export class ActorExtendedAlignmentInformations extends ActorAlignmentInformations {
	public static id: number = 8515

	public honor: number | undefined = 0
	public honorGradeFloor: number | undefined = 0
	public honorNextGradeFloor: number | undefined = 0
	public aggressable: number | undefined = 0

	public constructor(
		alignmentSide?: number | undefined,
		alignmentValue?: number | undefined,
		alignmentGrade?: number | undefined,
		characterPower?: number | undefined,
		honor?: number | undefined,
		honorGradeFloor?: number | undefined,
		honorNextGradeFloor?: number | undefined,
		aggressable?: number | undefined
	) {
		super(alignmentSide, alignmentValue, alignmentGrade, characterPower)
		this.honor = honor
		this.honorGradeFloor = honorGradeFloor
		this.honorNextGradeFloor = honorNextGradeFloor
		this.aggressable = aggressable
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeVarShort(this.honor!)
		writer.writeVarShort(this.honorGradeFloor!)
		writer.writeVarShort(this.honorNextGradeFloor!)
		writer.writeByte(this.aggressable!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.honor = reader.readVarShort()
		this.honorGradeFloor = reader.readVarShort()
		this.honorNextGradeFloor = reader.readVarShort()
		this.aggressable = reader.readByte()
	}

	public hydrate(
		data: ActorExtendedAlignmentInformations | Record<string, any>
	): ActorExtendedAlignmentInformations {
		if (data instanceof ActorExtendedAlignmentInformations) {
			return data
		}

		super.hydrate(data)

		this.honor = data.honor
		this.honorGradeFloor = data.honorGradeFloor
		this.honorNextGradeFloor = data.honorNextGradeFloor
		this.aggressable = data.aggressable

		return this
	}
}

export interface RawFightTriggeredEffect
	extends RawAbstractFightDispellableEffect {
	id: number
	param1: number
	param2: number
	param3: number
	delay: number
}

export class FightTriggeredEffect extends AbstractFightDispellableEffect {
	public static id: number = 3040

	public param1: number | undefined = 0
	public param2: number | undefined = 0
	public param3: number | undefined = 0
	public delay: number | undefined = 0

	public constructor(
		uid?: number | undefined,
		targetId?: number | undefined,
		turnDuration?: number | undefined,
		dispelable?: number | undefined,
		spellId?: number | undefined,
		effectId?: number | undefined,
		parentBoostUid?: number | undefined,
		param1?: number | undefined,
		param2?: number | undefined,
		param3?: number | undefined,
		delay?: number | undefined
	) {
		super(
			uid,
			targetId,
			turnDuration,
			dispelable,
			spellId,
			effectId,
			parentBoostUid
		)
		this.param1 = param1
		this.param2 = param2
		this.param3 = param3
		this.delay = delay
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeInt(this.param1!)
		writer.writeInt(this.param2!)
		writer.writeInt(this.param3!)
		writer.writeShort(this.delay!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.param1 = reader.readInt()
		this.param2 = reader.readInt()
		this.param3 = reader.readInt()
		this.delay = reader.readShort()
	}

	public hydrate(
		data: FightTriggeredEffect | Record<string, any>
	): FightTriggeredEffect {
		if (data instanceof FightTriggeredEffect) {
			return data
		}

		super.hydrate(data)

		this.param1 = data.param1
		this.param2 = data.param2
		this.param3 = data.param3
		this.delay = data.delay

		return this
	}
}

export interface RawFightTemporarySpellImmunityEffect
	extends RawAbstractFightDispellableEffect {
	id: number
	immuneSpellId: number
}

export class FightTemporarySpellImmunityEffect extends AbstractFightDispellableEffect {
	public static id: number = 8464

	public immuneSpellId: number | undefined = 0

	public constructor(
		uid?: number | undefined,
		targetId?: number | undefined,
		turnDuration?: number | undefined,
		dispelable?: number | undefined,
		spellId?: number | undefined,
		effectId?: number | undefined,
		parentBoostUid?: number | undefined,
		immuneSpellId?: number | undefined
	) {
		super(
			uid,
			targetId,
			turnDuration,
			dispelable,
			spellId,
			effectId,
			parentBoostUid
		)
		this.immuneSpellId = immuneSpellId
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeInt(this.immuneSpellId!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.immuneSpellId = reader.readInt()
	}

	public hydrate(
		data: FightTemporarySpellImmunityEffect | Record<string, any>
	): FightTemporarySpellImmunityEffect {
		if (data instanceof FightTemporarySpellImmunityEffect) {
			return data
		}

		super.hydrate(data)

		this.immuneSpellId = data.immuneSpellId

		return this
	}
}

export interface RawFightTemporaryBoostWeaponDamagesEffect
	extends RawFightTemporaryBoostEffect {
	id: number
	weaponTypeId: number
}

export class FightTemporaryBoostWeaponDamagesEffect extends FightTemporaryBoostEffect {
	public static id: number = 4451

	public weaponTypeId: number | undefined = 0

	public constructor(
		uid?: number | undefined,
		targetId?: number | undefined,
		turnDuration?: number | undefined,
		dispelable?: number | undefined,
		spellId?: number | undefined,
		effectId?: number | undefined,
		parentBoostUid?: number | undefined,
		delta?: number | undefined,
		weaponTypeId?: number | undefined
	) {
		super(
			uid,
			targetId,
			turnDuration,
			dispelable,
			spellId,
			effectId,
			parentBoostUid,
			delta
		)
		this.weaponTypeId = weaponTypeId
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeShort(this.weaponTypeId!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.weaponTypeId = reader.readShort()
	}

	public hydrate(
		data: FightTemporaryBoostWeaponDamagesEffect | Record<string, any>
	): FightTemporaryBoostWeaponDamagesEffect {
		if (data instanceof FightTemporaryBoostWeaponDamagesEffect) {
			return data
		}

		super.hydrate(data)

		this.weaponTypeId = data.weaponTypeId

		return this
	}
}

export interface RawFightTemporaryBoostStateEffect
	extends RawFightTemporaryBoostEffect {
	id: number
	stateId: number
}

export class FightTemporaryBoostStateEffect extends FightTemporaryBoostEffect {
	public static id: number = 7115

	public stateId: number | undefined = 0

	public constructor(
		uid?: number | undefined,
		targetId?: number | undefined,
		turnDuration?: number | undefined,
		dispelable?: number | undefined,
		spellId?: number | undefined,
		effectId?: number | undefined,
		parentBoostUid?: number | undefined,
		delta?: number | undefined,
		stateId?: number | undefined
	) {
		super(
			uid,
			targetId,
			turnDuration,
			dispelable,
			spellId,
			effectId,
			parentBoostUid,
			delta
		)
		this.stateId = stateId
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeShort(this.stateId!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.stateId = reader.readShort()
	}

	public hydrate(
		data: FightTemporaryBoostStateEffect | Record<string, any>
	): FightTemporaryBoostStateEffect {
		if (data instanceof FightTemporaryBoostStateEffect) {
			return data
		}

		super.hydrate(data)

		this.stateId = data.stateId

		return this
	}
}

export interface RawFightTemporarySpellBoostEffect
	extends RawFightTemporaryBoostEffect {
	id: number
	boostedSpellId: number
}

export class FightTemporarySpellBoostEffect extends FightTemporaryBoostEffect {
	public static id: number = 5674

	public boostedSpellId: number | undefined = 0

	public constructor(
		uid?: number | undefined,
		targetId?: number | undefined,
		turnDuration?: number | undefined,
		dispelable?: number | undefined,
		spellId?: number | undefined,
		effectId?: number | undefined,
		parentBoostUid?: number | undefined,
		delta?: number | undefined,
		boostedSpellId?: number | undefined
	) {
		super(
			uid,
			targetId,
			turnDuration,
			dispelable,
			spellId,
			effectId,
			parentBoostUid,
			delta
		)
		this.boostedSpellId = boostedSpellId
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeVarShort(this.boostedSpellId!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.boostedSpellId = reader.readVarShort()
	}

	public hydrate(
		data: FightTemporarySpellBoostEffect | Record<string, any>
	): FightTemporarySpellBoostEffect {
		if (data instanceof FightTemporarySpellBoostEffect) {
			return data
		}

		super.hydrate(data)

		this.boostedSpellId = data.boostedSpellId

		return this
	}
}

export interface RawFinishMoveInformations {
	id: number
	finishMoveId: number
	finishMoveState: boolean
}

export class FinishMoveInformations extends DofusType {
	public static id: number = 8642

	public finishMoveId: number | undefined = 0
	public finishMoveState: boolean | undefined = false

	public constructor(
		finishMoveId?: number | undefined,
		finishMoveState?: boolean | undefined
	) {
		super()
		this.finishMoveId = finishMoveId
		this.finishMoveState = finishMoveState
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeInt(this.finishMoveId!)
		writer.writeBoolean(this.finishMoveState!)
	}

	public deserialize(reader: BinaryReader): void {
		this.finishMoveId = reader.readInt()
		this.finishMoveState = reader.readBoolean()
	}

	public hydrate(
		data: FinishMoveInformations | Record<string, any>
	): FinishMoveInformations {
		if (data instanceof FinishMoveInformations) {
			return data
		}

		this.finishMoveId = data.finishMoveId
		this.finishMoveState = data.finishMoveState

		return this
	}
}

export interface RawFightStartingPositions {
	id: number
	positionsForChallengers: number[]
	positionsForDefenders: number[]
}

export class FightStartingPositions extends DofusType {
	public static id: number = 956

	public positionsForChallengers: number[] | undefined
	public positionsForDefenders: number[] | undefined

	public constructor(
		positionsForChallengers?: number[] | undefined,
		positionsForDefenders?: number[] | undefined
	) {
		super()
		this.positionsForChallengers = positionsForChallengers
		this.positionsForDefenders = positionsForDefenders
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeShort(this.positionsForChallengers!.length)
		this.positionsForChallengers!.forEach((current: number) =>
			writer.writeVarShort(current)
		)
		writer.writeShort(this.positionsForDefenders!.length)
		this.positionsForDefenders!.forEach((current: number) =>
			writer.writeVarShort(current)
		)
	}

	public deserialize(reader: BinaryReader): void {
		this.positionsForChallengers = []
		const countPositionsForChallengers = reader.readShort()
		for (let i: number = 0; i < countPositionsForChallengers; i++) {
			this.positionsForChallengers.push(reader.readVarShort())
		}
		this.positionsForDefenders = []
		const countPositionsForDefenders = reader.readShort()
		for (let i: number = 0; i < countPositionsForDefenders; i++) {
			this.positionsForDefenders.push(reader.readVarShort())
		}
	}

	public hydrate(
		data: FightStartingPositions | Record<string, any>
	): FightStartingPositions {
		if (data instanceof FightStartingPositions) {
			return data
		}

		this.positionsForChallengers = data.positionsForChallengers
		this.positionsForDefenders = data.positionsForDefenders

		return this
	}
}

export interface RawBasicNamedAllianceInformations
	extends RawBasicAllianceInformations {
	id: number
	allianceName: string
}

export class BasicNamedAllianceInformations extends BasicAllianceInformations {
	public static id: number = 5935

	public allianceName: string | undefined

	public constructor(
		allianceId?: number | undefined,
		allianceTag?: string | undefined,
		allianceName?: string | undefined
	) {
		super(allianceId, allianceTag)
		this.allianceName = allianceName
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeUTF(this.allianceName!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.allianceName = reader.readUTF()
	}

	public hydrate(
		data: BasicNamedAllianceInformations | Record<string, any>
	): BasicNamedAllianceInformations {
		if (data instanceof BasicNamedAllianceInformations) {
			return data
		}

		super.hydrate(data)

		this.allianceName = data.allianceName

		return this
	}
}

export interface RawAllianceInformations
	extends RawBasicNamedAllianceInformations {
	id: number
	allianceEmblem: GuildEmblem
}

export class AllianceInformations extends BasicNamedAllianceInformations {
	public static id: number = 2484

	public allianceEmblem: GuildEmblem | undefined

	public constructor(
		allianceId?: number | undefined,
		allianceTag?: string | undefined,
		allianceName?: string | undefined,
		allianceEmblem?: GuildEmblem | undefined
	) {
		super(allianceId, allianceTag, allianceName)
		this.allianceEmblem = allianceEmblem
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		this.allianceEmblem!.serialize(writer)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.allianceEmblem = new GuildEmblem()
		this.allianceEmblem!.deserialize(reader)
	}

	public hydrate(
		data: AllianceInformations | Record<string, any>
	): AllianceInformations {
		if (data instanceof AllianceInformations) {
			return data
		}

		super.hydrate(data)

		this.allianceEmblem = new GuildEmblem().hydrate(data.allianceEmblem)

		return this
	}
}

export interface RawFightTeamMemberCharacterInformations
	extends RawFightTeamMemberInformations {
	id: number
	name: string
	level: number
}

export class FightTeamMemberCharacterInformations extends FightTeamMemberInformations {
	public static id: number = 9851

	public name: string | undefined
	public level: number | undefined = 0

	public constructor(
		id_?: number | undefined,
		name?: string | undefined,
		level?: number | undefined
	) {
		super(id_)
		this.name = name
		this.level = level
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeUTF(this.name!)
		writer.writeVarShort(this.level!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.name = reader.readUTF()
		this.level = reader.readVarShort()
	}

	public hydrate(
		data: FightTeamMemberCharacterInformations | Record<string, any>
	): FightTeamMemberCharacterInformations {
		if (data instanceof FightTeamMemberCharacterInformations) {
			return data
		}

		super.hydrate(data)

		this.name = data.name
		this.level = data.level

		return this
	}
}

export interface RawFightTeamMemberWithAllianceCharacterInformations
	extends RawFightTeamMemberCharacterInformations {
	id: number
	allianceInfos: BasicAllianceInformations
}

export class FightTeamMemberWithAllianceCharacterInformations extends FightTeamMemberCharacterInformations {
	public static id: number = 8004

	public allianceInfos: BasicAllianceInformations | undefined

	public constructor(
		id_?: number | undefined,
		name?: string | undefined,
		level?: number | undefined,
		allianceInfos?: BasicAllianceInformations | undefined
	) {
		super(id_, name, level)
		this.allianceInfos = allianceInfos
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		this.allianceInfos!.serialize(writer)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.allianceInfos = new BasicAllianceInformations()
		this.allianceInfos!.deserialize(reader)
	}

	public hydrate(
		data: FightTeamMemberWithAllianceCharacterInformations | Record<string, any>
	): FightTeamMemberWithAllianceCharacterInformations {
		if (data instanceof FightTeamMemberWithAllianceCharacterInformations) {
			return data
		}

		super.hydrate(data)

		this.allianceInfos = new BasicAllianceInformations().hydrate(
			data.allianceInfos
		)

		return this
	}
}

export interface RawExtendedBreachBranch extends RawBreachBranch {
	id: number
	rewards: BreachReward[]
	modifier: number
	prize: number
}

export class ExtendedBreachBranch extends BreachBranch {
	public static id: number = 4962

	public rewards: BreachReward[] | undefined
	public modifier: number | undefined = 0
	public prize: number | undefined = 0

	public constructor(
		room?: number | undefined,
		element?: number | undefined,
		bosses?: MonsterInGroupLightInformations[] | undefined,
		map?: number | undefined,
		score?: number | undefined,
		relativeScore?: number | undefined,
		monsters?: MonsterInGroupLightInformations[] | undefined,
		rewards?: BreachReward[] | undefined,
		modifier?: number | undefined,
		prize?: number | undefined
	) {
		super(room, element, bosses, map, score, relativeScore, monsters)
		this.rewards = rewards
		this.modifier = modifier
		this.prize = prize
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeShort(this.rewards!.length)
		this.rewards!.forEach((current) => {
			current.serialize(writer)
		})
		writer.writeVarInt(this.modifier!)
		writer.writeVarInt(this.prize!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.rewards = []
		const countRewards = reader.readShort()
		for (let i: number = 0; i < countRewards; i++) {
			const type: BreachReward = new BreachReward()
			type.deserialize(reader)
			this.rewards.push(type)
		}
		this.modifier = reader.readVarInt()
		this.prize = reader.readVarInt()
	}

	public hydrate(
		data: ExtendedBreachBranch | Record<string, any>
	): ExtendedBreachBranch {
		if (data instanceof ExtendedBreachBranch) {
			return data
		}

		super.hydrate(data)

		this.rewards = data.rewards.map(
			(dataElement: BreachReward | Record<string, any>): BreachReward => {
				if (dataElement instanceof BreachReward) {
					return dataElement
				} else {
					return new BreachReward().hydrate(dataElement)
				}
			}
		)
		this.modifier = data.modifier
		this.prize = data.prize

		return this
	}
}

export interface RawBreachReward {
	id: number
	id_: number
	buyLocks: number[]
	buyCriterion: string
	remainingQty: number
	price: number
}

export class BreachReward extends DofusType {
	public static id: number = 5533

	public id_: number | undefined = 0
	public buyLocks: number[] | undefined
	public buyCriterion: string | undefined
	public remainingQty: number | undefined = 0
	public price: number | undefined = 0

	public constructor(
		id_?: number | undefined,
		buyLocks?: number[] | undefined,
		buyCriterion?: string | undefined,
		remainingQty?: number | undefined,
		price?: number | undefined
	) {
		super()
		this.id_ = id_
		this.buyLocks = buyLocks
		this.buyCriterion = buyCriterion
		this.remainingQty = remainingQty
		this.price = price
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarInt(this.id_!)
		writer.writeShort(this.buyLocks!.length)
		this.buyLocks!.forEach((current: number) => writer.writeByte(current))
		writer.writeUTF(this.buyCriterion!)
		writer.writeVarInt(this.remainingQty!)
		writer.writeVarInt(this.price!)
	}

	public deserialize(reader: BinaryReader): void {
		this.id_ = reader.readVarInt()
		this.buyLocks = []
		const countBuyLocks = reader.readShort()
		for (let i: number = 0; i < countBuyLocks; i++) {
			this.buyLocks.push(reader.readByte())
		}
		this.buyCriterion = reader.readUTF()
		this.remainingQty = reader.readVarInt()
		this.price = reader.readVarInt()
	}

	public hydrate(data: BreachReward | Record<string, any>): BreachReward {
		if (data instanceof BreachReward) {
			return data
		}

		this.id_ = data.id_
		this.buyLocks = data.buyLocks
		this.buyCriterion = data.buyCriterion
		this.remainingQty = data.remainingQty
		this.price = data.price

		return this
	}
}

export interface RawHouseGuildedInformations
	extends RawHouseInstanceInformations {
	id: number
	guildInfo: GuildInformations
}

export class HouseGuildedInformations extends HouseInstanceInformations {
	public static id: number = 2823

	public guildInfo: GuildInformations | undefined

	public constructor(
		secondHand?: boolean | undefined,
		isLocked?: boolean | undefined,
		isSaleLocked?: boolean | undefined,
		instanceId?: number | undefined,
		ownerName?: string | undefined,
		price?: number | undefined,
		guildInfo?: GuildInformations | undefined
	) {
		super(secondHand, isLocked, isSaleLocked, instanceId, ownerName, price)
		this.guildInfo = guildInfo
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		this.guildInfo!.serialize(writer)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.guildInfo = new GuildInformations()
		this.guildInfo!.deserialize(reader)
	}

	public hydrate(
		data: HouseGuildedInformations | Record<string, any>
	): HouseGuildedInformations {
		if (data instanceof HouseGuildedInformations) {
			return data
		}

		super.hydrate(data)

		this.guildInfo = new GuildInformations().hydrate(data.guildInfo)

		return this
	}
}

export interface RawFightOptionsInformations {
	id: number
	isSecret: boolean
	isRestrictedToPartyOnly: boolean
	isClosed: boolean
	isAskingForHelp: boolean
}

export class FightOptionsInformations extends DofusType {
	public static id: number = 1420

	public isSecret: boolean | undefined = false
	public isRestrictedToPartyOnly: boolean | undefined = false
	public isClosed: boolean | undefined = false
	public isAskingForHelp: boolean | undefined = false

	public constructor(
		isSecret?: boolean | undefined,
		isRestrictedToPartyOnly?: boolean | undefined,
		isClosed?: boolean | undefined,
		isAskingForHelp?: boolean | undefined
	) {
		super()
		this.isSecret = isSecret
		this.isRestrictedToPartyOnly = isRestrictedToPartyOnly
		this.isClosed = isClosed
		this.isAskingForHelp = isAskingForHelp
	}

	public serialize(writer: BinaryWriter): void {
		let box0: number = 0
		box0 = setFlag(box0, 0, this.isSecret!)
		box0 = setFlag(box0, 1, this.isRestrictedToPartyOnly!)
		box0 = setFlag(box0, 2, this.isClosed!)
		box0 = setFlag(box0, 3, this.isAskingForHelp!)
		writer.writeByte(box0)
	}

	public deserialize(reader: BinaryReader): void {
		const box0 = reader.readByte()
		this.isSecret = getFlag(box0, 0)
		this.isRestrictedToPartyOnly = getFlag(box0, 1)
		this.isClosed = getFlag(box0, 2)
		this.isAskingForHelp = getFlag(box0, 3)
	}

	public hydrate(
		data: FightOptionsInformations | Record<string, any>
	): FightOptionsInformations {
		if (data instanceof FightOptionsInformations) {
			return data
		}

		this.isSecret = data.isSecret
		this.isRestrictedToPartyOnly = data.isRestrictedToPartyOnly
		this.isClosed = data.isClosed
		this.isAskingForHelp = data.isAskingForHelp

		return this
	}
}

export interface RawFightTeamMemberTaxCollectorInformations
	extends RawFightTeamMemberInformations {
	id: number
	firstNameId: number
	lastNameId: number
	level: number
	guildId: number
	uid: number
}

export class FightTeamMemberTaxCollectorInformations extends FightTeamMemberInformations {
	public static id: number = 431

	public firstNameId: number | undefined = 0
	public lastNameId: number | undefined = 0
	public level: number | undefined = 0
	public guildId: number | undefined = 0
	public uid: number | undefined = 0

	public constructor(
		id_?: number | undefined,
		firstNameId?: number | undefined,
		lastNameId?: number | undefined,
		level?: number | undefined,
		guildId?: number | undefined,
		uid?: number | undefined
	) {
		super(id_)
		this.firstNameId = firstNameId
		this.lastNameId = lastNameId
		this.level = level
		this.guildId = guildId
		this.uid = uid
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeVarShort(this.firstNameId!)
		writer.writeVarShort(this.lastNameId!)
		writer.writeByte(this.level!)
		writer.writeVarInt(this.guildId!)
		writer.writeDouble(this.uid!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.firstNameId = reader.readVarShort()
		this.lastNameId = reader.readVarShort()
		this.level = reader.readByte()
		this.guildId = reader.readVarInt()
		this.uid = reader.readDouble()
	}

	public hydrate(
		data: FightTeamMemberTaxCollectorInformations | Record<string, any>
	): FightTeamMemberTaxCollectorInformations {
		if (data instanceof FightTeamMemberTaxCollectorInformations) {
			return data
		}

		super.hydrate(data)

		this.firstNameId = data.firstNameId
		this.lastNameId = data.lastNameId
		this.level = data.level
		this.guildId = data.guildId
		this.uid = data.uid

		return this
	}
}

export interface RawTaxCollectorStaticExtendedInformations
	extends RawTaxCollectorStaticInformations {
	id: number
	allianceIdentity: AllianceInformations
}

export class TaxCollectorStaticExtendedInformations extends TaxCollectorStaticInformations {
	public static id: number = 6436

	public allianceIdentity: AllianceInformations | undefined

	public constructor(
		firstNameId?: number | undefined,
		lastNameId?: number | undefined,
		guildIdentity?: GuildInformations | undefined,
		callerId?: number | undefined,
		allianceIdentity?: AllianceInformations | undefined
	) {
		super(firstNameId, lastNameId, guildIdentity, callerId)
		this.allianceIdentity = allianceIdentity
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		this.allianceIdentity!.serialize(writer)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.allianceIdentity = new AllianceInformations()
		this.allianceIdentity!.deserialize(reader)
	}

	public hydrate(
		data: TaxCollectorStaticExtendedInformations | Record<string, any>
	): TaxCollectorStaticExtendedInformations {
		if (data instanceof TaxCollectorStaticExtendedInformations) {
			return data
		}

		super.hydrate(data)

		this.allianceIdentity = new AllianceInformations().hydrate(
			data.allianceIdentity
		)

		return this
	}
}

export interface RawGameRolePlayTreasureHintInformations
	extends RawGameRolePlayActorInformations {
	id: number
	npcId: number
}

export class GameRolePlayTreasureHintInformations extends GameRolePlayActorInformations {
	public static id: number = 5073

	public npcId: number | undefined = 0

	public constructor(
		contextualId?: number | undefined,
		disposition?: EntityDispositionInformations | undefined,
		look?: EntityLook | undefined,
		npcId?: number | undefined
	) {
		super(contextualId, disposition, look)
		this.npcId = npcId
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeVarShort(this.npcId!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.npcId = reader.readVarShort()
	}

	public hydrate(
		data: GameRolePlayTreasureHintInformations | Record<string, any>
	): GameRolePlayTreasureHintInformations {
		if (data instanceof GameRolePlayTreasureHintInformations) {
			return data
		}

		super.hydrate(data)

		this.npcId = data.npcId

		return this
	}
}

export interface RawFightResultMutantListEntry
	extends RawFightResultFighterListEntry {
	id: number
	level: number
}

export class FightResultMutantListEntry extends FightResultFighterListEntry {
	public static id: number = 6988

	public level: number | undefined = 0

	public constructor(
		outcome?: number | undefined,
		wave?: number | undefined,
		rewards?: FightLoot | undefined,
		id_?: number | undefined,
		alive?: boolean | undefined,
		level?: number | undefined
	) {
		super(outcome, wave, rewards, id_, alive)
		this.level = level
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeVarShort(this.level!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.level = reader.readVarShort()
	}

	public hydrate(
		data: FightResultMutantListEntry | Record<string, any>
	): FightResultMutantListEntry {
		if (data instanceof FightResultMutantListEntry) {
			return data
		}

		super.hydrate(data)

		this.level = data.level

		return this
	}
}

export interface RawTreasureHuntStep {
	id: number
}

export class TreasureHuntStep extends DofusType {
	public static id: number = 5041

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public serialize(writer: BinaryWriter): void {}

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public deserialize(reader: BinaryReader): void {}

	public hydrate(
		data: TreasureHuntStep | Record<string, any>
	): TreasureHuntStep {
		if (data instanceof TreasureHuntStep) {
			return data
		}

		return this
	}
}

export interface RawTreasureHuntStepFight extends RawTreasureHuntStep {
	id: number
}

export class TreasureHuntStepFight extends TreasureHuntStep {
	public static id: number = 6367

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public serialize(writer: BinaryWriter): void {}

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public deserialize(reader: BinaryReader): void {}

	public hydrate(
		data: TreasureHuntStepFight | Record<string, any>
	): TreasureHuntStepFight {
		if (data instanceof TreasureHuntStepFight) {
			return data
		}

		return this
	}
}

export interface RawMapCoordinates {
	id: number
	worldX: number
	worldY: number
}

export class MapCoordinates extends DofusType {
	public static id: number = 2571

	public worldX: number | undefined = 0
	public worldY: number | undefined = 0

	public constructor(worldX?: number | undefined, worldY?: number | undefined) {
		super()
		this.worldX = worldX
		this.worldY = worldY
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeShort(this.worldX!)
		writer.writeShort(this.worldY!)
	}

	public deserialize(reader: BinaryReader): void {
		this.worldX = reader.readShort()
		this.worldY = reader.readShort()
	}

	public hydrate(data: MapCoordinates | Record<string, any>): MapCoordinates {
		if (data instanceof MapCoordinates) {
			return data
		}

		this.worldX = data.worldX
		this.worldY = data.worldY

		return this
	}
}

export interface RawFriendSpouseInformations {
	id: number
	spouseAccountId: number
	spouseId: number
	spouseName: string
	spouseLevel: number
	breed: number
	sex: number
	spouseEntityLook: EntityLook
	guildInfo: GuildInformations
	alignmentSide: number
}

export class FriendSpouseInformations extends DofusType {
	public static id: number = 4533

	public spouseAccountId: number | undefined = 0
	public spouseId: number | undefined = 0
	public spouseName: string | undefined
	public spouseLevel: number | undefined = 0
	public breed: number | undefined = 0
	public sex: number | undefined = 0
	public spouseEntityLook: EntityLook | undefined
	public guildInfo: GuildInformations | undefined
	public alignmentSide: number | undefined = 0

	public constructor(
		spouseAccountId?: number | undefined,
		spouseId?: number | undefined,
		spouseName?: string | undefined,
		spouseLevel?: number | undefined,
		breed?: number | undefined,
		sex?: number | undefined,
		spouseEntityLook?: EntityLook | undefined,
		guildInfo?: GuildInformations | undefined,
		alignmentSide?: number | undefined
	) {
		super()
		this.spouseAccountId = spouseAccountId
		this.spouseId = spouseId
		this.spouseName = spouseName
		this.spouseLevel = spouseLevel
		this.breed = breed
		this.sex = sex
		this.spouseEntityLook = spouseEntityLook
		this.guildInfo = guildInfo
		this.alignmentSide = alignmentSide
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeInt(this.spouseAccountId!)
		writer.writeVarLong(this.spouseId!)
		writer.writeUTF(this.spouseName!)
		writer.writeVarShort(this.spouseLevel!)
		writer.writeByte(this.breed!)
		writer.writeByte(this.sex!)
		this.spouseEntityLook!.serialize(writer)
		this.guildInfo!.serialize(writer)
		writer.writeByte(this.alignmentSide!)
	}

	public deserialize(reader: BinaryReader): void {
		this.spouseAccountId = reader.readInt()
		this.spouseId = reader.readVarLong()
		this.spouseName = reader.readUTF()
		this.spouseLevel = reader.readVarShort()
		this.breed = reader.readByte()
		this.sex = reader.readByte()
		this.spouseEntityLook = new EntityLook()
		this.spouseEntityLook!.deserialize(reader)
		this.guildInfo = new GuildInformations()
		this.guildInfo!.deserialize(reader)
		this.alignmentSide = reader.readByte()
	}

	public hydrate(
		data: FriendSpouseInformations | Record<string, any>
	): FriendSpouseInformations {
		if (data instanceof FriendSpouseInformations) {
			return data
		}

		this.spouseAccountId = data.spouseAccountId
		this.spouseId = data.spouseId
		this.spouseName = data.spouseName
		this.spouseLevel = data.spouseLevel
		this.breed = data.breed
		this.sex = data.sex
		this.spouseEntityLook = new EntityLook().hydrate(data.spouseEntityLook)
		this.guildInfo = new GuildInformations().hydrate(data.guildInfo)
		this.alignmentSide = data.alignmentSide

		return this
	}
}

export interface RawFriendSpouseOnlineInformations
	extends RawFriendSpouseInformations {
	id: number
	inFight: boolean
	followSpouse: boolean
	mapId: number
	subAreaId: number
}

export class FriendSpouseOnlineInformations extends FriendSpouseInformations {
	public static id: number = 7417

	public inFight: boolean | undefined = false
	public followSpouse: boolean | undefined = false
	public mapId: number | undefined = 0
	public subAreaId: number | undefined = 0

	public constructor(
		spouseAccountId?: number | undefined,
		spouseId?: number | undefined,
		spouseName?: string | undefined,
		spouseLevel?: number | undefined,
		breed?: number | undefined,
		sex?: number | undefined,
		spouseEntityLook?: EntityLook | undefined,
		guildInfo?: GuildInformations | undefined,
		alignmentSide?: number | undefined,
		inFight?: boolean | undefined,
		followSpouse?: boolean | undefined,
		mapId?: number | undefined,
		subAreaId?: number | undefined
	) {
		super(
			spouseAccountId,
			spouseId,
			spouseName,
			spouseLevel,
			breed,
			sex,
			spouseEntityLook,
			guildInfo,
			alignmentSide
		)
		this.inFight = inFight
		this.followSpouse = followSpouse
		this.mapId = mapId
		this.subAreaId = subAreaId
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		let box0: number = 0
		box0 = setFlag(box0, 0, this.inFight!)
		box0 = setFlag(box0, 1, this.followSpouse!)
		writer.writeByte(box0)
		writer.writeDouble(this.mapId!)
		writer.writeVarShort(this.subAreaId!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		const box0 = reader.readByte()
		this.inFight = getFlag(box0, 0)
		this.followSpouse = getFlag(box0, 1)
		this.mapId = reader.readDouble()
		this.subAreaId = reader.readVarShort()
	}

	public hydrate(
		data: FriendSpouseOnlineInformations | Record<string, any>
	): FriendSpouseOnlineInformations {
		if (data instanceof FriendSpouseOnlineInformations) {
			return data
		}

		super.hydrate(data)

		this.inFight = data.inFight
		this.followSpouse = data.followSpouse
		this.mapId = data.mapId
		this.subAreaId = data.subAreaId

		return this
	}
}

export interface RawCharacterMinimalPlusLookAndGradeInformations
	extends RawCharacterMinimalPlusLookInformations {
	id: number
	grade: number
}

export class CharacterMinimalPlusLookAndGradeInformations extends CharacterMinimalPlusLookInformations {
	public static id: number = 651

	public grade: number | undefined = 0

	public constructor(
		id_?: number | undefined,
		name?: string | undefined,
		level?: number | undefined,
		entityLook?: EntityLook | undefined,
		breed?: number | undefined,
		grade?: number | undefined
	) {
		super(id_, name, level, entityLook, breed)
		this.grade = grade
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeVarInt(this.grade!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.grade = reader.readVarInt()
	}

	public hydrate(
		data: CharacterMinimalPlusLookAndGradeInformations | Record<string, any>
	): CharacterMinimalPlusLookAndGradeInformations {
		if (data instanceof CharacterMinimalPlusLookAndGradeInformations) {
			return data
		}

		super.hydrate(data)

		this.grade = data.grade

		return this
	}
}

export interface RawStatisticData {
	id: number
}

export class StatisticData extends DofusType {
	public static id: number = 7795

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public serialize(writer: BinaryWriter): void {}

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public deserialize(reader: BinaryReader): void {}

	public hydrate(data: StatisticData | Record<string, any>): StatisticData {
		if (data instanceof StatisticData) {
			return data
		}

		return this
	}
}

export interface RawStatisticDataShort extends RawStatisticData {
	id: number
	value: number
}

export class StatisticDataShort extends StatisticData {
	public static id: number = 4749

	public value: number | undefined = 0

	public constructor(value?: number | undefined) {
		super()
		this.value = value
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeShort(this.value!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.value = reader.readShort()
	}

	public hydrate(
		data: StatisticDataShort | Record<string, any>
	): StatisticDataShort {
		if (data instanceof StatisticDataShort) {
			return data
		}

		this.value = data.value

		return this
	}
}

export interface RawFightResultAdditionalData {
	id: number
}

export class FightResultAdditionalData extends DofusType {
	public static id: number = 5618

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public serialize(writer: BinaryWriter): void {}

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public deserialize(reader: BinaryReader): void {}

	public hydrate(
		data: FightResultAdditionalData | Record<string, any>
	): FightResultAdditionalData {
		if (data instanceof FightResultAdditionalData) {
			return data
		}

		return this
	}
}

export interface RawFightResultExperienceData
	extends RawFightResultAdditionalData {
	id: number
	showExperience: boolean
	showExperienceLevelFloor: boolean
	showExperienceNextLevelFloor: boolean
	showExperienceFightDelta: boolean
	showExperienceForGuild: boolean
	showExperienceForMount: boolean
	isIncarnationExperience: boolean
	experience: number
	experienceLevelFloor: number
	experienceNextLevelFloor: number
	experienceFightDelta: number
	experienceForGuild: number
	experienceForMount: number
	rerollExperienceMul: number
}

export class FightResultExperienceData extends FightResultAdditionalData {
	public static id: number = 2135

	public showExperience: boolean | undefined = false
	public showExperienceLevelFloor: boolean | undefined = false
	public showExperienceNextLevelFloor: boolean | undefined = false
	public showExperienceFightDelta: boolean | undefined = false
	public showExperienceForGuild: boolean | undefined = false
	public showExperienceForMount: boolean | undefined = false
	public isIncarnationExperience: boolean | undefined = false
	public experience: number | undefined = 0
	public experienceLevelFloor: number | undefined = 0
	public experienceNextLevelFloor: number | undefined = 0
	public experienceFightDelta: number | undefined = 0
	public experienceForGuild: number | undefined = 0
	public experienceForMount: number | undefined = 0
	public rerollExperienceMul: number | undefined = 0

	public constructor(
		showExperience?: boolean | undefined,
		showExperienceLevelFloor?: boolean | undefined,
		showExperienceNextLevelFloor?: boolean | undefined,
		showExperienceFightDelta?: boolean | undefined,
		showExperienceForGuild?: boolean | undefined,
		showExperienceForMount?: boolean | undefined,
		isIncarnationExperience?: boolean | undefined,
		experience?: number | undefined,
		experienceLevelFloor?: number | undefined,
		experienceNextLevelFloor?: number | undefined,
		experienceFightDelta?: number | undefined,
		experienceForGuild?: number | undefined,
		experienceForMount?: number | undefined,
		rerollExperienceMul?: number | undefined
	) {
		super()
		this.showExperience = showExperience
		this.showExperienceLevelFloor = showExperienceLevelFloor
		this.showExperienceNextLevelFloor = showExperienceNextLevelFloor
		this.showExperienceFightDelta = showExperienceFightDelta
		this.showExperienceForGuild = showExperienceForGuild
		this.showExperienceForMount = showExperienceForMount
		this.isIncarnationExperience = isIncarnationExperience
		this.experience = experience
		this.experienceLevelFloor = experienceLevelFloor
		this.experienceNextLevelFloor = experienceNextLevelFloor
		this.experienceFightDelta = experienceFightDelta
		this.experienceForGuild = experienceForGuild
		this.experienceForMount = experienceForMount
		this.rerollExperienceMul = rerollExperienceMul
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		let box0: number = 0
		box0 = setFlag(box0, 0, this.showExperience!)
		box0 = setFlag(box0, 1, this.showExperienceLevelFloor!)
		box0 = setFlag(box0, 2, this.showExperienceNextLevelFloor!)
		box0 = setFlag(box0, 3, this.showExperienceFightDelta!)
		box0 = setFlag(box0, 4, this.showExperienceForGuild!)
		box0 = setFlag(box0, 5, this.showExperienceForMount!)
		box0 = setFlag(box0, 6, this.isIncarnationExperience!)
		writer.writeByte(box0)
		writer.writeVarLong(this.experience!)
		writer.writeVarLong(this.experienceLevelFloor!)
		writer.writeVarLong(this.experienceNextLevelFloor!)
		writer.writeVarLong(this.experienceFightDelta!)
		writer.writeVarLong(this.experienceForGuild!)
		writer.writeVarLong(this.experienceForMount!)
		writer.writeByte(this.rerollExperienceMul!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		const box0 = reader.readByte()
		this.showExperience = getFlag(box0, 0)
		this.showExperienceLevelFloor = getFlag(box0, 1)
		this.showExperienceNextLevelFloor = getFlag(box0, 2)
		this.showExperienceFightDelta = getFlag(box0, 3)
		this.showExperienceForGuild = getFlag(box0, 4)
		this.showExperienceForMount = getFlag(box0, 5)
		this.isIncarnationExperience = getFlag(box0, 6)
		this.experience = reader.readVarLong()
		this.experienceLevelFloor = reader.readVarLong()
		this.experienceNextLevelFloor = reader.readVarLong()
		this.experienceFightDelta = reader.readVarLong()
		this.experienceForGuild = reader.readVarLong()
		this.experienceForMount = reader.readVarLong()
		this.rerollExperienceMul = reader.readByte()
	}

	public hydrate(
		data: FightResultExperienceData | Record<string, any>
	): FightResultExperienceData {
		if (data instanceof FightResultExperienceData) {
			return data
		}

		this.showExperience = data.showExperience
		this.showExperienceLevelFloor = data.showExperienceLevelFloor
		this.showExperienceNextLevelFloor = data.showExperienceNextLevelFloor
		this.showExperienceFightDelta = data.showExperienceFightDelta
		this.showExperienceForGuild = data.showExperienceForGuild
		this.showExperienceForMount = data.showExperienceForMount
		this.isIncarnationExperience = data.isIncarnationExperience
		this.experience = data.experience
		this.experienceLevelFloor = data.experienceLevelFloor
		this.experienceNextLevelFloor = data.experienceNextLevelFloor
		this.experienceFightDelta = data.experienceFightDelta
		this.experienceForGuild = data.experienceForGuild
		this.experienceForMount = data.experienceForMount
		this.rerollExperienceMul = data.rerollExperienceMul

		return this
	}
}

export interface RawObjectEffectString extends RawObjectEffect {
	id: number
	value: string
}

export class ObjectEffectString extends ObjectEffect {
	public static id: number = 2216

	public value: string | undefined

	public constructor(
		actionId?: number | undefined,
		value?: string | undefined
	) {
		super(actionId)
		this.value = value
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeUTF(this.value!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.value = reader.readUTF()
	}

	public hydrate(
		data: ObjectEffectString | Record<string, any>
	): ObjectEffectString {
		if (data instanceof ObjectEffectString) {
			return data
		}

		super.hydrate(data)

		this.value = data.value

		return this
	}
}

export interface RawPreset {
	id: number
	id_: number
}

export class Preset extends DofusType {
	public static id: number = 2126

	public id_: number | undefined = 0

	public constructor(id_?: number | undefined) {
		super()
		this.id_ = id_
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeShort(this.id_!)
	}

	public deserialize(reader: BinaryReader): void {
		this.id_ = reader.readShort()
	}

	public hydrate(data: Preset | Record<string, any>): Preset {
		if (data instanceof Preset) {
			return data
		}

		this.id_ = data.id_

		return this
	}
}

export interface RawIdolsPreset extends RawPreset {
	id: number
	iconId: number
	idolIds: number[]
}

export class IdolsPreset extends Preset {
	public static id: number = 1498

	public iconId: number | undefined = 0
	public idolIds: number[] | undefined

	public constructor(
		id_?: number | undefined,
		iconId?: number | undefined,
		idolIds?: number[] | undefined
	) {
		super(id_)
		this.iconId = iconId
		this.idolIds = idolIds
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeShort(this.iconId!)
		writer.writeShort(this.idolIds!.length)
		this.idolIds!.forEach((current: number) => writer.writeVarShort(current))
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.iconId = reader.readShort()
		this.idolIds = []
		const countIdolIds = reader.readShort()
		for (let i: number = 0; i < countIdolIds; i++) {
			this.idolIds.push(reader.readVarShort())
		}
	}

	public hydrate(data: IdolsPreset | Record<string, any>): IdolsPreset {
		if (data instanceof IdolsPreset) {
			return data
		}

		super.hydrate(data)

		this.iconId = data.iconId
		this.idolIds = data.idolIds

		return this
	}
}

export class AllianceGetPlayerApplicationMessage extends DofusMessage {
	public static id: number = 4833

	constructor() {
		super()
	}

	public serialize(writer: BinaryWriter): void {}

	public deserialize(reader: BinaryReader): void {}
}

export interface RawAlliancedGuildFactSheetInformations
	extends RawGuildInformations {
	id: number
	allianceInfos: BasicNamedAllianceInformations
}

export class AlliancedGuildFactSheetInformations extends GuildInformations {
	public static id: number = 920

	public allianceInfos: BasicNamedAllianceInformations | undefined

	public constructor(
		guildId?: number | undefined,
		guildName?: string | undefined,
		guildLevel?: number | undefined,
		guildEmblem?: GuildEmblem | undefined,
		allianceInfos?: BasicNamedAllianceInformations | undefined
	) {
		super(guildId, guildName, guildLevel, guildEmblem)
		this.allianceInfos = allianceInfos
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		this.allianceInfos!.serialize(writer)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.allianceInfos = new BasicNamedAllianceInformations()
		this.allianceInfos!.deserialize(reader)
	}

	public hydrate(
		data: AlliancedGuildFactSheetInformations | Record<string, any>
	): AlliancedGuildFactSheetInformations {
		if (data instanceof AlliancedGuildFactSheetInformations) {
			return data
		}

		super.hydrate(data)

		this.allianceInfos = new BasicNamedAllianceInformations().hydrate(
			data.allianceInfos
		)

		return this
	}
}

export interface RawForgettableSpellsPreset extends RawPreset {
	id: number
	baseSpellsPreset: SpellsPreset
	forgettableSpells: SpellForPreset[]
}

export class ForgettableSpellsPreset extends Preset {
	public static id: number = 7096

	public baseSpellsPreset: SpellsPreset | undefined
	public forgettableSpells: SpellForPreset[] | undefined

	public constructor(
		id_?: number | undefined,
		baseSpellsPreset?: SpellsPreset | undefined,
		forgettableSpells?: SpellForPreset[] | undefined
	) {
		super(id_)
		this.baseSpellsPreset = baseSpellsPreset
		this.forgettableSpells = forgettableSpells
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		this.baseSpellsPreset!.serialize(writer)
		writer.writeShort(this.forgettableSpells!.length)
		this.forgettableSpells!.forEach((current) => {
			current.serialize(writer)
		})
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.baseSpellsPreset = new SpellsPreset()
		this.baseSpellsPreset!.deserialize(reader)
		this.forgettableSpells = []
		const countForgettableSpells = reader.readShort()
		for (let i: number = 0; i < countForgettableSpells; i++) {
			const type: SpellForPreset = new SpellForPreset()
			type.deserialize(reader)
			this.forgettableSpells.push(type)
		}
	}

	public hydrate(
		data: ForgettableSpellsPreset | Record<string, any>
	): ForgettableSpellsPreset {
		if (data instanceof ForgettableSpellsPreset) {
			return data
		}

		super.hydrate(data)

		this.baseSpellsPreset = new SpellsPreset().hydrate(data.baseSpellsPreset)
		this.forgettableSpells = data.forgettableSpells.map(
			(dataElement: SpellForPreset | Record<string, any>): SpellForPreset => {
				if (dataElement instanceof SpellForPreset) {
					return dataElement
				} else {
					return new SpellForPreset().hydrate(dataElement)
				}
			}
		)

		return this
	}
}

export interface RawShortcut {
	id: number
	slot: number
}

export class Shortcut extends DofusType {
	public static id: number = 8239

	public slot: number | undefined = 0

	public constructor(slot?: number | undefined) {
		super()
		this.slot = slot
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeByte(this.slot!)
	}

	public deserialize(reader: BinaryReader): void {
		this.slot = reader.readByte()
	}

	public hydrate(data: Shortcut | Record<string, any>): Shortcut {
		if (data instanceof Shortcut) {
			return data
		}

		this.slot = data.slot

		return this
	}
}

export interface RawShortcutSpell extends RawShortcut {
	id: number
	spellId: number
}

export class ShortcutSpell extends Shortcut {
	public static id: number = 3691

	public spellId: number | undefined = 0

	public constructor(slot?: number | undefined, spellId?: number | undefined) {
		super(slot)
		this.spellId = spellId
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeVarShort(this.spellId!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.spellId = reader.readVarShort()
	}

	public hydrate(data: ShortcutSpell | Record<string, any>): ShortcutSpell {
		if (data instanceof ShortcutSpell) {
			return data
		}

		super.hydrate(data)

		this.spellId = data.spellId

		return this
	}
}

export interface RawStatisticDataByte extends RawStatisticData {
	id: number
	value: number
}

export class StatisticDataByte extends StatisticData {
	public static id: number = 3536

	public value: number | undefined = 0

	public constructor(value?: number | undefined) {
		super()
		this.value = value
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeByte(this.value!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.value = reader.readByte()
	}

	public hydrate(
		data: StatisticDataByte | Record<string, any>
	): StatisticDataByte {
		if (data instanceof StatisticDataByte) {
			return data
		}

		this.value = data.value

		return this
	}
}

export interface RawTreasureHuntStepDig extends RawTreasureHuntStep {
	id: number
}

export class TreasureHuntStepDig extends TreasureHuntStep {
	public static id: number = 3298

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public serialize(writer: BinaryWriter): void {}

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public deserialize(reader: BinaryReader): void {}

	public hydrate(
		data: TreasureHuntStepDig | Record<string, any>
	): TreasureHuntStepDig {
		if (data instanceof TreasureHuntStepDig) {
			return data
		}

		return this
	}
}

export interface RawFullStatsPreset extends RawPreset {
	id: number
	stats: CharacterCharacteristicForPreset[]
}

export class FullStatsPreset extends Preset {
	public static id: number = 7986

	public stats: CharacterCharacteristicForPreset[] | undefined

	public constructor(
		id_?: number | undefined,
		stats?: CharacterCharacteristicForPreset[] | undefined
	) {
		super(id_)
		this.stats = stats
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeShort(this.stats!.length)
		this.stats!.forEach((current) => {
			current.serialize(writer)
		})
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.stats = []
		const countStats = reader.readShort()
		for (let i: number = 0; i < countStats; i++) {
			const type: CharacterCharacteristicForPreset = new CharacterCharacteristicForPreset()
			type.deserialize(reader)
			this.stats.push(type)
		}
	}

	public hydrate(data: FullStatsPreset | Record<string, any>): FullStatsPreset {
		if (data instanceof FullStatsPreset) {
			return data
		}

		super.hydrate(data)

		this.stats = data.stats.map(
			(
				dataElement: CharacterCharacteristicForPreset | Record<string, any>
			): CharacterCharacteristicForPreset => {
				if (dataElement instanceof CharacterCharacteristicForPreset) {
					return dataElement
				} else {
					return new CharacterCharacteristicForPreset().hydrate(dataElement)
				}
			}
		)

		return this
	}
}

export interface RawInteractiveElementNamedSkill
	extends RawInteractiveElementSkill {
	id: number
	nameId: number
}

export class InteractiveElementNamedSkill extends InteractiveElementSkill {
	public static id: number = 3347

	public nameId: number | undefined = 0

	public constructor(
		skillId?: number | undefined,
		skillInstanceUid?: number | undefined,
		nameId?: number | undefined
	) {
		super(skillId, skillInstanceUid)
		this.nameId = nameId
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeVarInt(this.nameId!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.nameId = reader.readVarInt()
	}

	public hydrate(
		data: InteractiveElementNamedSkill | Record<string, any>
	): InteractiveElementNamedSkill {
		if (data instanceof InteractiveElementNamedSkill) {
			return data
		}

		super.hydrate(data)

		this.nameId = data.nameId

		return this
	}
}

export interface RawFightResultPvpData extends RawFightResultAdditionalData {
	id: number
	grade: number
	minHonorForGrade: number
	maxHonorForGrade: number
	honor: number
	honorDelta: number
}

export class FightResultPvpData extends FightResultAdditionalData {
	public static id: number = 3462

	public grade: number | undefined = 0
	public minHonorForGrade: number | undefined = 0
	public maxHonorForGrade: number | undefined = 0
	public honor: number | undefined = 0
	public honorDelta: number | undefined = 0

	public constructor(
		grade?: number | undefined,
		minHonorForGrade?: number | undefined,
		maxHonorForGrade?: number | undefined,
		honor?: number | undefined,
		honorDelta?: number | undefined
	) {
		super()
		this.grade = grade
		this.minHonorForGrade = minHonorForGrade
		this.maxHonorForGrade = maxHonorForGrade
		this.honor = honor
		this.honorDelta = honorDelta
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeByte(this.grade!)
		writer.writeVarShort(this.minHonorForGrade!)
		writer.writeVarShort(this.maxHonorForGrade!)
		writer.writeVarShort(this.honor!)
		writer.writeVarShort(this.honorDelta!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.grade = reader.readByte()
		this.minHonorForGrade = reader.readVarShort()
		this.maxHonorForGrade = reader.readVarShort()
		this.honor = reader.readVarShort()
		this.honorDelta = reader.readVarShort()
	}

	public hydrate(
		data: FightResultPvpData | Record<string, any>
	): FightResultPvpData {
		if (data instanceof FightResultPvpData) {
			return data
		}

		this.grade = data.grade
		this.minHonorForGrade = data.minHonorForGrade
		this.maxHonorForGrade = data.maxHonorForGrade
		this.honor = data.honor
		this.honorDelta = data.honorDelta

		return this
	}
}

export interface RawTreasureHuntStepFollowDirectionToHint
	extends RawTreasureHuntStep {
	id: number
	direction: number
	npcId: number
}

export class TreasureHuntStepFollowDirectionToHint extends TreasureHuntStep {
	public static id: number = 5721

	public direction: number | undefined = 1
	public npcId: number | undefined = 0

	public constructor(
		direction?: number | undefined,
		npcId?: number | undefined
	) {
		super()
		this.direction = direction
		this.npcId = npcId
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeByte(this.direction!)
		writer.writeVarShort(this.npcId!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.direction = reader.readByte()
		this.npcId = reader.readVarShort()
	}

	public hydrate(
		data: TreasureHuntStepFollowDirectionToHint | Record<string, any>
	): TreasureHuntStepFollowDirectionToHint {
		if (data instanceof TreasureHuntStepFollowDirectionToHint) {
			return data
		}

		this.direction = data.direction
		this.npcId = data.npcId

		return this
	}
}

export interface RawGuildVersatileInformations {
	id: number
	guildId: number
	leaderId: number
	guildLevel: number
	nbMembers: number
}

export class GuildVersatileInformations extends DofusType {
	public static id: number = 7908

	public guildId: number | undefined = 0
	public leaderId: number | undefined = 0
	public guildLevel: number | undefined = 0
	public nbMembers: number | undefined = 0

	public constructor(
		guildId?: number | undefined,
		leaderId?: number | undefined,
		guildLevel?: number | undefined,
		nbMembers?: number | undefined
	) {
		super()
		this.guildId = guildId
		this.leaderId = leaderId
		this.guildLevel = guildLevel
		this.nbMembers = nbMembers
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarInt(this.guildId!)
		writer.writeVarLong(this.leaderId!)
		writer.writeByte(this.guildLevel!)
		writer.writeByte(this.nbMembers!)
	}

	public deserialize(reader: BinaryReader): void {
		this.guildId = reader.readVarInt()
		this.leaderId = reader.readVarLong()
		this.guildLevel = reader.readByte()
		this.nbMembers = reader.readByte()
	}

	public hydrate(
		data: GuildVersatileInformations | Record<string, any>
	): GuildVersatileInformations {
		if (data instanceof GuildVersatileInformations) {
			return data
		}

		this.guildId = data.guildId
		this.leaderId = data.leaderId
		this.guildLevel = data.guildLevel
		this.nbMembers = data.nbMembers

		return this
	}
}

export interface RawGuildInAllianceVersatileInformations
	extends RawGuildVersatileInformations {
	id: number
	allianceId: number
}

export class GuildInAllianceVersatileInformations extends GuildVersatileInformations {
	public static id: number = 5949

	public allianceId: number | undefined = 0

	public constructor(
		guildId?: number | undefined,
		leaderId?: number | undefined,
		guildLevel?: number | undefined,
		nbMembers?: number | undefined,
		allianceId?: number | undefined
	) {
		super(guildId, leaderId, guildLevel, nbMembers)
		this.allianceId = allianceId
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeVarInt(this.allianceId!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.allianceId = reader.readVarInt()
	}

	public hydrate(
		data: GuildInAllianceVersatileInformations | Record<string, any>
	): GuildInAllianceVersatileInformations {
		if (data instanceof GuildInAllianceVersatileInformations) {
			return data
		}

		super.hydrate(data)

		this.allianceId = data.allianceId

		return this
	}
}

export interface RawShortcutObject extends RawShortcut {
	id: number
}

export class ShortcutObject extends Shortcut {
	public static id: number = 5832

	public constructor(slot?: number | undefined) {
		super(slot)
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
	}

	public hydrate(data: ShortcutObject | Record<string, any>): ShortcutObject {
		if (data instanceof ShortcutObject) {
			return data
		}

		super.hydrate(data)

		return this
	}
}

export interface RawObjectEffectDice extends RawObjectEffect {
	id: number
	diceNum: number
	diceSide: number
	diceConst: number
}

export class ObjectEffectDice extends ObjectEffect {
	public static id: number = 2568

	public diceNum: number | undefined = 0
	public diceSide: number | undefined = 0
	public diceConst: number | undefined = 0

	public constructor(
		actionId?: number | undefined,
		diceNum?: number | undefined,
		diceSide?: number | undefined,
		diceConst?: number | undefined
	) {
		super(actionId)
		this.diceNum = diceNum
		this.diceSide = diceSide
		this.diceConst = diceConst
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeVarInt(this.diceNum!)
		writer.writeVarInt(this.diceSide!)
		writer.writeVarInt(this.diceConst!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.diceNum = reader.readVarInt()
		this.diceSide = reader.readVarInt()
		this.diceConst = reader.readVarInt()
	}

	public hydrate(
		data: ObjectEffectDice | Record<string, any>
	): ObjectEffectDice {
		if (data instanceof ObjectEffectDice) {
			return data
		}

		super.hydrate(data)

		this.diceNum = data.diceNum
		this.diceSide = data.diceSide
		this.diceConst = data.diceConst

		return this
	}
}

export interface RawObjectEffectDate extends RawObjectEffect {
	id: number
	year: number
	month: number
	day: number
	hour: number
	minute: number
}

export class ObjectEffectDate extends ObjectEffect {
	public static id: number = 2036

	public year: number | undefined = 0
	public month: number | undefined = 0
	public day: number | undefined = 0
	public hour: number | undefined = 0
	public minute: number | undefined = 0

	public constructor(
		actionId?: number | undefined,
		year?: number | undefined,
		month?: number | undefined,
		day?: number | undefined,
		hour?: number | undefined,
		minute?: number | undefined
	) {
		super(actionId)
		this.year = year
		this.month = month
		this.day = day
		this.hour = hour
		this.minute = minute
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeVarShort(this.year!)
		writer.writeByte(this.month!)
		writer.writeByte(this.day!)
		writer.writeByte(this.hour!)
		writer.writeByte(this.minute!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.year = reader.readVarShort()
		this.month = reader.readByte()
		this.day = reader.readByte()
		this.hour = reader.readByte()
		this.minute = reader.readByte()
	}

	public hydrate(
		data: ObjectEffectDate | Record<string, any>
	): ObjectEffectDate {
		if (data instanceof ObjectEffectDate) {
			return data
		}

		super.hydrate(data)

		this.year = data.year
		this.month = data.month
		this.day = data.day
		this.hour = data.hour
		this.minute = data.minute

		return this
	}
}

export interface RawUpdateMountCharacteristic {
	id: number
	type: number
}

export class UpdateMountCharacteristic extends DofusType {
	public static id: number = 3205

	public type: number | undefined = 0

	public constructor(type?: number | undefined) {
		super()
		this.type = type
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeByte(this.type!)
	}

	public deserialize(reader: BinaryReader): void {
		this.type = reader.readByte()
	}

	public hydrate(
		data: UpdateMountCharacteristic | Record<string, any>
	): UpdateMountCharacteristic {
		if (data instanceof UpdateMountCharacteristic) {
			return data
		}

		this.type = data.type

		return this
	}
}

export interface RawUpdateMountIntegerCharacteristic
	extends RawUpdateMountCharacteristic {
	id: number
	value: number
}

export class UpdateMountIntegerCharacteristic extends UpdateMountCharacteristic {
	public static id: number = 4162

	public value: number | undefined = 0

	public constructor(type?: number | undefined, value?: number | undefined) {
		super(type)
		this.value = value
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeInt(this.value!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.value = reader.readInt()
	}

	public hydrate(
		data: UpdateMountIntegerCharacteristic | Record<string, any>
	): UpdateMountIntegerCharacteristic {
		if (data instanceof UpdateMountIntegerCharacteristic) {
			return data
		}

		super.hydrate(data)

		this.value = data.value

		return this
	}
}

export interface RawShortcutObjectItem extends RawShortcutObject {
	id: number
	itemUID: number
	itemGID: number
}

export class ShortcutObjectItem extends ShortcutObject {
	public static id: number = 8932

	public itemUID: number | undefined = 0
	public itemGID: number | undefined = 0

	public constructor(
		slot?: number | undefined,
		itemUID?: number | undefined,
		itemGID?: number | undefined
	) {
		super(slot)
		this.itemUID = itemUID
		this.itemGID = itemGID
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeInt(this.itemUID!)
		writer.writeInt(this.itemGID!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.itemUID = reader.readInt()
		this.itemGID = reader.readInt()
	}

	public hydrate(
		data: ShortcutObjectItem | Record<string, any>
	): ShortcutObjectItem {
		if (data instanceof ShortcutObjectItem) {
			return data
		}

		super.hydrate(data)

		this.itemUID = data.itemUID
		this.itemGID = data.itemGID

		return this
	}
}

export interface RawQuestObjectiveInformations {
	id: number
	objectiveId: number
	objectiveStatus: boolean
	dialogParams: string[]
}

export class QuestObjectiveInformations extends DofusType {
	public static id: number = 8695

	public objectiveId: number | undefined = 0
	public objectiveStatus: boolean | undefined = false
	public dialogParams: string[] | undefined

	public constructor(
		objectiveId?: number | undefined,
		objectiveStatus?: boolean | undefined,
		dialogParams?: string[] | undefined
	) {
		super()
		this.objectiveId = objectiveId
		this.objectiveStatus = objectiveStatus
		this.dialogParams = dialogParams
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarShort(this.objectiveId!)
		writer.writeBoolean(this.objectiveStatus!)
		writer.writeShort(this.dialogParams!.length)
		this.dialogParams!.forEach((current: string) => writer.writeUTF(current))
	}

	public deserialize(reader: BinaryReader): void {
		this.objectiveId = reader.readVarShort()
		this.objectiveStatus = reader.readBoolean()
		this.dialogParams = []
		const countDialogParams = reader.readShort()
		for (let i: number = 0; i < countDialogParams; i++) {
			this.dialogParams.push(reader.readUTF())
		}
	}

	public hydrate(
		data: QuestObjectiveInformations | Record<string, any>
	): QuestObjectiveInformations {
		if (data instanceof QuestObjectiveInformations) {
			return data
		}

		this.objectiveId = data.objectiveId
		this.objectiveStatus = data.objectiveStatus
		this.dialogParams = data.dialogParams

		return this
	}
}

export interface RawQuestObjectiveInformationsWithCompletion
	extends RawQuestObjectiveInformations {
	id: number
	curCompletion: number
	maxCompletion: number
}

export class QuestObjectiveInformationsWithCompletion extends QuestObjectiveInformations {
	public static id: number = 5778

	public curCompletion: number | undefined = 0
	public maxCompletion: number | undefined = 0

	public constructor(
		objectiveId?: number | undefined,
		objectiveStatus?: boolean | undefined,
		dialogParams?: string[] | undefined,
		curCompletion?: number | undefined,
		maxCompletion?: number | undefined
	) {
		super(objectiveId, objectiveStatus, dialogParams)
		this.curCompletion = curCompletion
		this.maxCompletion = maxCompletion
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeVarShort(this.curCompletion!)
		writer.writeVarShort(this.maxCompletion!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.curCompletion = reader.readVarShort()
		this.maxCompletion = reader.readVarShort()
	}

	public hydrate(
		data: QuestObjectiveInformationsWithCompletion | Record<string, any>
	): QuestObjectiveInformationsWithCompletion {
		if (data instanceof QuestObjectiveInformationsWithCompletion) {
			return data
		}

		super.hydrate(data)

		this.curCompletion = data.curCompletion
		this.maxCompletion = data.maxCompletion

		return this
	}
}

export interface RawFightTeamMemberEntityInformation
	extends RawFightTeamMemberInformations {
	id: number
	entityModelId: number
	level: number
	masterId: number
}

export class FightTeamMemberEntityInformation extends FightTeamMemberInformations {
	public static id: number = 6288

	public entityModelId: number | undefined = 0
	public level: number | undefined = 0
	public masterId: number | undefined = 0

	public constructor(
		id_?: number | undefined,
		entityModelId?: number | undefined,
		level?: number | undefined,
		masterId?: number | undefined
	) {
		super(id_)
		this.entityModelId = entityModelId
		this.level = level
		this.masterId = masterId
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeByte(this.entityModelId!)
		writer.writeVarShort(this.level!)
		writer.writeDouble(this.masterId!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.entityModelId = reader.readByte()
		this.level = reader.readVarShort()
		this.masterId = reader.readDouble()
	}

	public hydrate(
		data: FightTeamMemberEntityInformation | Record<string, any>
	): FightTeamMemberEntityInformation {
		if (data instanceof FightTeamMemberEntityInformation) {
			return data
		}

		super.hydrate(data)

		this.entityModelId = data.entityModelId
		this.level = data.level
		this.masterId = data.masterId

		return this
	}
}

export interface RawUpdateMountBooleanCharacteristic
	extends RawUpdateMountCharacteristic {
	id: number
	value: boolean
}

export class UpdateMountBooleanCharacteristic extends UpdateMountCharacteristic {
	public static id: number = 4340

	public value: boolean | undefined = false

	public constructor(type?: number | undefined, value?: boolean | undefined) {
		super(type)
		this.value = value
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeBoolean(this.value!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.value = reader.readBoolean()
	}

	public hydrate(
		data: UpdateMountBooleanCharacteristic | Record<string, any>
	): UpdateMountBooleanCharacteristic {
		if (data instanceof UpdateMountBooleanCharacteristic) {
			return data
		}

		super.hydrate(data)

		this.value = data.value

		return this
	}
}

export interface RawCharacterMinimalGuildInformations
	extends RawCharacterMinimalPlusLookInformations {
	id: number
	guild: BasicGuildInformations
}

export class CharacterMinimalGuildInformations extends CharacterMinimalPlusLookInformations {
	public static id: number = 6416

	public guild: BasicGuildInformations | undefined

	public constructor(
		id_?: number | undefined,
		name?: string | undefined,
		level?: number | undefined,
		entityLook?: EntityLook | undefined,
		breed?: number | undefined,
		guild?: BasicGuildInformations | undefined
	) {
		super(id_, name, level, entityLook, breed)
		this.guild = guild
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		this.guild!.serialize(writer)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.guild = new BasicGuildInformations()
		this.guild!.deserialize(reader)
	}

	public hydrate(
		data: CharacterMinimalGuildInformations | Record<string, any>
	): CharacterMinimalGuildInformations {
		if (data instanceof CharacterMinimalGuildInformations) {
			return data
		}

		super.hydrate(data)

		this.guild = new BasicGuildInformations().hydrate(data.guild)

		return this
	}
}

export interface RawCharacterMinimalAllianceInformations
	extends RawCharacterMinimalGuildInformations {
	id: number
	alliance: BasicAllianceInformations
}

export class CharacterMinimalAllianceInformations extends CharacterMinimalGuildInformations {
	public static id: number = 9412

	public alliance: BasicAllianceInformations | undefined

	public constructor(
		id_?: number | undefined,
		name?: string | undefined,
		level?: number | undefined,
		entityLook?: EntityLook | undefined,
		breed?: number | undefined,
		guild?: BasicGuildInformations | undefined,
		alliance?: BasicAllianceInformations | undefined
	) {
		super(id_, name, level, entityLook, breed, guild)
		this.alliance = alliance
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		this.alliance!.serialize(writer)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.alliance = new BasicAllianceInformations()
		this.alliance!.deserialize(reader)
	}

	public hydrate(
		data: CharacterMinimalAllianceInformations | Record<string, any>
	): CharacterMinimalAllianceInformations {
		if (data instanceof CharacterMinimalAllianceInformations) {
			return data
		}

		super.hydrate(data)

		this.alliance = new BasicAllianceInformations().hydrate(data.alliance)

		return this
	}
}

export interface RawItemsPreset extends RawPreset {
	id: number
	items: ItemForPreset[]
	mountEquipped: boolean
	look: EntityLook
}

export class ItemsPreset extends Preset {
	public static id: number = 870

	public items: ItemForPreset[] | undefined
	public mountEquipped: boolean | undefined = false
	public look: EntityLook | undefined

	public constructor(
		id_?: number | undefined,
		items?: ItemForPreset[] | undefined,
		mountEquipped?: boolean | undefined,
		look?: EntityLook | undefined
	) {
		super(id_)
		this.items = items
		this.mountEquipped = mountEquipped
		this.look = look
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeShort(this.items!.length)
		this.items!.forEach((current) => {
			current.serialize(writer)
		})
		writer.writeBoolean(this.mountEquipped!)
		this.look!.serialize(writer)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.items = []
		const countItems = reader.readShort()
		for (let i: number = 0; i < countItems; i++) {
			const type: ItemForPreset = new ItemForPreset()
			type.deserialize(reader)
			this.items.push(type)
		}
		this.mountEquipped = reader.readBoolean()
		this.look = new EntityLook()
		this.look!.deserialize(reader)
	}

	public hydrate(data: ItemsPreset | Record<string, any>): ItemsPreset {
		if (data instanceof ItemsPreset) {
			return data
		}

		super.hydrate(data)

		this.items = data.items.map(
			(dataElement: ItemForPreset | Record<string, any>): ItemForPreset => {
				if (dataElement instanceof ItemForPreset) {
					return dataElement
				} else {
					return new ItemForPreset().hydrate(dataElement)
				}
			}
		)
		this.mountEquipped = data.mountEquipped
		this.look = new EntityLook().hydrate(data.look)

		return this
	}
}

export interface RawServerSessionConstant {
	id: number
	id_: number
}

export class ServerSessionConstant extends DofusType {
	public static id: number = 8054

	public id_: number | undefined = 0

	public constructor(id_?: number | undefined) {
		super()
		this.id_ = id_
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarShort(this.id_!)
	}

	public deserialize(reader: BinaryReader): void {
		this.id_ = reader.readVarShort()
	}

	public hydrate(
		data: ServerSessionConstant | Record<string, any>
	): ServerSessionConstant {
		if (data instanceof ServerSessionConstant) {
			return data
		}

		this.id_ = data.id_

		return this
	}
}

export interface RawServerSessionConstantInteger
	extends RawServerSessionConstant {
	id: number
	value: number
}

export class ServerSessionConstantInteger extends ServerSessionConstant {
	public static id: number = 8199

	public value: number | undefined = 0

	public constructor(id_?: number | undefined, value?: number | undefined) {
		super(id_)
		this.value = value
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeInt(this.value!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.value = reader.readInt()
	}

	public hydrate(
		data: ServerSessionConstantInteger | Record<string, any>
	): ServerSessionConstantInteger {
		if (data instanceof ServerSessionConstantInteger) {
			return data
		}

		super.hydrate(data)

		this.value = data.value

		return this
	}
}

export interface RawShortcutEmote extends RawShortcut {
	id: number
	emoteId: number
}

export class ShortcutEmote extends Shortcut {
	public static id: number = 9088

	public emoteId: number | undefined = 0

	public constructor(slot?: number | undefined, emoteId?: number | undefined) {
		super(slot)
		this.emoteId = emoteId
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeByte(this.emoteId!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.emoteId = reader.readByte()
	}

	public hydrate(data: ShortcutEmote | Record<string, any>): ShortcutEmote {
		if (data instanceof ShortcutEmote) {
			return data
		}

		super.hydrate(data)

		this.emoteId = data.emoteId

		return this
	}
}

export interface RawTaxCollectorComplementaryInformations {
	id: number
}

export class TaxCollectorComplementaryInformations extends DofusType {
	public static id: number = 1561

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public serialize(writer: BinaryWriter): void {}

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public deserialize(reader: BinaryReader): void {}

	public hydrate(
		data: TaxCollectorComplementaryInformations | Record<string, any>
	): TaxCollectorComplementaryInformations {
		if (data instanceof TaxCollectorComplementaryInformations) {
			return data
		}

		return this
	}
}

export interface RawTaxCollectorLootInformations
	extends RawTaxCollectorComplementaryInformations {
	id: number
	kamas: number
	experience: number
	pods: number
	itemsValue: number
}

export class TaxCollectorLootInformations extends TaxCollectorComplementaryInformations {
	public static id: number = 4070

	public kamas: number | undefined = 0
	public experience: number | undefined = 0
	public pods: number | undefined = 0
	public itemsValue: number | undefined = 0

	public constructor(
		kamas?: number | undefined,
		experience?: number | undefined,
		pods?: number | undefined,
		itemsValue?: number | undefined
	) {
		super()
		this.kamas = kamas
		this.experience = experience
		this.pods = pods
		this.itemsValue = itemsValue
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeVarLong(this.kamas!)
		writer.writeVarLong(this.experience!)
		writer.writeVarInt(this.pods!)
		writer.writeVarLong(this.itemsValue!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.kamas = reader.readVarLong()
		this.experience = reader.readVarLong()
		this.pods = reader.readVarInt()
		this.itemsValue = reader.readVarLong()
	}

	public hydrate(
		data: TaxCollectorLootInformations | Record<string, any>
	): TaxCollectorLootInformations {
		if (data instanceof TaxCollectorLootInformations) {
			return data
		}

		this.kamas = data.kamas
		this.experience = data.experience
		this.pods = data.pods
		this.itemsValue = data.itemsValue

		return this
	}
}

export interface RawMapCoordinatesAndId extends RawMapCoordinates {
	id: number
	mapId: number
}

export class MapCoordinatesAndId extends MapCoordinates {
	public static id: number = 5358

	public mapId: number | undefined = 0

	public constructor(
		worldX?: number | undefined,
		worldY?: number | undefined,
		mapId?: number | undefined
	) {
		super(worldX, worldY)
		this.mapId = mapId
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeDouble(this.mapId!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.mapId = reader.readDouble()
	}

	public hydrate(
		data: MapCoordinatesAndId | Record<string, any>
	): MapCoordinatesAndId {
		if (data instanceof MapCoordinatesAndId) {
			return data
		}

		super.hydrate(data)

		this.mapId = data.mapId

		return this
	}
}

export interface RawEntitiesPreset extends RawPreset {
	id: number
	iconId: number
	entityIds: number[]
}

export class EntitiesPreset extends Preset {
	public static id: number = 4714

	public iconId: number | undefined = 0
	public entityIds: number[] | undefined

	public constructor(
		id_?: number | undefined,
		iconId?: number | undefined,
		entityIds?: number[] | undefined
	) {
		super(id_)
		this.iconId = iconId
		this.entityIds = entityIds
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeShort(this.iconId!)
		writer.writeShort(this.entityIds!.length)
		this.entityIds!.forEach((current: number) => writer.writeVarShort(current))
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.iconId = reader.readShort()
		this.entityIds = []
		const countEntityIds = reader.readShort()
		for (let i: number = 0; i < countEntityIds; i++) {
			this.entityIds.push(reader.readVarShort())
		}
	}

	public hydrate(data: EntitiesPreset | Record<string, any>): EntitiesPreset {
		if (data instanceof EntitiesPreset) {
			return data
		}

		super.hydrate(data)

		this.iconId = data.iconId
		this.entityIds = data.entityIds

		return this
	}
}

export interface RawDebtInformation {
	id: number
	id_: number
	timestamp: number
}

export class DebtInformation extends DofusType {
	public static id: number = 9957

	public id_: number | undefined = 0
	public timestamp: number | undefined = 0

	public constructor(id_?: number | undefined, timestamp?: number | undefined) {
		super()
		this.id_ = id_
		this.timestamp = timestamp
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeDouble(this.id_!)
		writer.writeDouble(this.timestamp!)
	}

	public deserialize(reader: BinaryReader): void {
		this.id_ = reader.readDouble()
		this.timestamp = reader.readDouble()
	}

	public hydrate(data: DebtInformation | Record<string, any>): DebtInformation {
		if (data instanceof DebtInformation) {
			return data
		}

		this.id_ = data.id_
		this.timestamp = data.timestamp

		return this
	}
}

export interface RawPaddockGuildedInformations
	extends RawPaddockBuyableInformations {
	id: number
	deserted: boolean
	guildInfo: GuildInformations
}

export class PaddockGuildedInformations extends PaddockBuyableInformations {
	public static id: number = 5112

	public deserted: boolean | undefined = false
	public guildInfo: GuildInformations | undefined

	public constructor(
		price?: number | undefined,
		locked?: boolean | undefined,
		deserted?: boolean | undefined,
		guildInfo?: GuildInformations | undefined
	) {
		super(price, locked)
		this.deserted = deserted
		this.guildInfo = guildInfo
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeBoolean(this.deserted!)
		this.guildInfo!.serialize(writer)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.deserted = reader.readBoolean()
		this.guildInfo = new GuildInformations()
		this.guildInfo!.deserialize(reader)
	}

	public hydrate(
		data: PaddockGuildedInformations | Record<string, any>
	): PaddockGuildedInformations {
		if (data instanceof PaddockGuildedInformations) {
			return data
		}

		super.hydrate(data)

		this.deserted = data.deserted
		this.guildInfo = new GuildInformations().hydrate(data.guildInfo)

		return this
	}
}

export interface RawKamaDebtInformation extends RawDebtInformation {
	id: number
	kamas: number
}

export class KamaDebtInformation extends DebtInformation {
	public static id: number = 9275

	public kamas: number | undefined = 0

	public constructor(
		id_?: number | undefined,
		timestamp?: number | undefined,
		kamas?: number | undefined
	) {
		super(id_, timestamp)
		this.kamas = kamas
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeVarLong(this.kamas!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.kamas = reader.readVarLong()
	}

	public hydrate(
		data: KamaDebtInformation | Record<string, any>
	): KamaDebtInformation {
		if (data instanceof KamaDebtInformation) {
			return data
		}

		super.hydrate(data)

		this.kamas = data.kamas

		return this
	}
}

export interface RawStatisticDataString extends RawStatisticData {
	id: number
	value: string
}

export class StatisticDataString extends StatisticData {
	public static id: number = 9818

	public value: string | undefined

	public constructor(value?: string | undefined) {
		super()
		this.value = value
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeUTF(this.value!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.value = reader.readUTF()
	}

	public hydrate(
		data: StatisticDataString | Record<string, any>
	): StatisticDataString {
		if (data instanceof StatisticDataString) {
			return data
		}

		this.value = data.value

		return this
	}
}

export interface RawPresetsContainerPreset extends RawPreset {
	id: number
	presets: Preset[]
}

export class PresetsContainerPreset extends Preset {
	public static id: number = 2645

	public presets: Preset[] | undefined

	public constructor(id_?: number | undefined, presets?: Preset[] | undefined) {
		super(id_)
		this.presets = presets
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeShort(this.presets!.length)
		this.presets!.forEach((current) => {
			writer.writeShort(current.id)
			current.serialize(writer)
		})
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.presets = []
		const countPresets = reader.readShort()
		for (let i: number = 0; i < countPresets; i++) {
			const presetsTypeId: number = reader.readShort()
			const type: Preset = new types[presetsTypeId]() as Preset
			type.deserialize(reader)
			this.presets.push(type)
		}
	}

	public hydrate(
		data: PresetsContainerPreset | Record<string, any>
	): PresetsContainerPreset {
		if (data instanceof PresetsContainerPreset) {
			return data
		}

		super.hydrate(data)

		this.presets = data.presets.map(
			(dataElement: Preset | Record<string, any>): Preset => {
				if (dataElement instanceof Preset) {
					return dataElement
				} else {
					return (new types[dataElement.id]() as Preset).hydrate(dataElement)
				}
			}
		)

		return this
	}
}

export interface RawIconNamedPreset extends RawPresetsContainerPreset {
	id: number
	iconId: number
	name: string
}

export class IconNamedPreset extends PresetsContainerPreset {
	public static id: number = 3146

	public iconId: number | undefined = 0
	public name: string | undefined

	public constructor(
		id_?: number | undefined,
		presets?: Preset[] | undefined,
		iconId?: number | undefined,
		name?: string | undefined
	) {
		super(id_, presets)
		this.iconId = iconId
		this.name = name
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeShort(this.iconId!)
		writer.writeUTF(this.name!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.iconId = reader.readShort()
		this.name = reader.readUTF()
	}

	public hydrate(data: IconNamedPreset | Record<string, any>): IconNamedPreset {
		if (data instanceof IconNamedPreset) {
			return data
		}

		super.hydrate(data)

		this.iconId = data.iconId
		this.name = data.name

		return this
	}
}

export interface RawServerSessionConstantString
	extends RawServerSessionConstant {
	id: number
	value: string
}

export class ServerSessionConstantString extends ServerSessionConstant {
	public static id: number = 133

	public value: string | undefined

	public constructor(id_?: number | undefined, value?: string | undefined) {
		super(id_)
		this.value = value
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeUTF(this.value!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.value = reader.readUTF()
	}

	public hydrate(
		data: ServerSessionConstantString | Record<string, any>
	): ServerSessionConstantString {
		if (data instanceof ServerSessionConstantString) {
			return data
		}

		super.hydrate(data)

		this.value = data.value

		return this
	}
}

export interface RawQuestActiveDetailedInformations
	extends RawQuestActiveInformations {
	id: number
	stepId: number
	objectives: QuestObjectiveInformations[]
}

export class QuestActiveDetailedInformations extends QuestActiveInformations {
	public static id: number = 3438

	public stepId: number | undefined = 0
	public objectives: QuestObjectiveInformations[] | undefined

	public constructor(
		questId?: number | undefined,
		stepId?: number | undefined,
		objectives?: QuestObjectiveInformations[] | undefined
	) {
		super(questId)
		this.stepId = stepId
		this.objectives = objectives
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeVarShort(this.stepId!)
		writer.writeShort(this.objectives!.length)
		this.objectives!.forEach((current) => {
			writer.writeShort(current.id)
			current.serialize(writer)
		})
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.stepId = reader.readVarShort()
		this.objectives = []
		const countObjectives = reader.readShort()
		for (let i: number = 0; i < countObjectives; i++) {
			const objectivesTypeId: number = reader.readShort()
			const type: QuestObjectiveInformations = new types[
				objectivesTypeId
			]() as QuestObjectiveInformations
			type.deserialize(reader)
			this.objectives.push(type)
		}
	}

	public hydrate(
		data: QuestActiveDetailedInformations | Record<string, any>
	): QuestActiveDetailedInformations {
		if (data instanceof QuestActiveDetailedInformations) {
			return data
		}

		super.hydrate(data)

		this.stepId = data.stepId
		this.objectives = data.objectives.map(
			(
				dataElement: QuestObjectiveInformations | Record<string, any>
			): QuestObjectiveInformations => {
				if (dataElement instanceof QuestObjectiveInformations) {
					return dataElement
				} else {
					return (new types[
						dataElement.id
					]() as QuestObjectiveInformations).hydrate(dataElement)
				}
			}
		)

		return this
	}
}

export interface RawShortcutEntitiesPreset extends RawShortcut {
	id: number
	presetId: number
}

export class ShortcutEntitiesPreset extends Shortcut {
	public static id: number = 6700

	public presetId: number | undefined = 0

	public constructor(slot?: number | undefined, presetId?: number | undefined) {
		super(slot)
		this.presetId = presetId
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeShort(this.presetId!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.presetId = reader.readShort()
	}

	public hydrate(
		data: ShortcutEntitiesPreset | Record<string, any>
	): ShortcutEntitiesPreset {
		if (data instanceof ShortcutEntitiesPreset) {
			return data
		}

		super.hydrate(data)

		this.presetId = data.presetId

		return this
	}
}

export interface RawObjectEffectCreature extends RawObjectEffect {
	id: number
	monsterFamilyId: number
}

export class ObjectEffectCreature extends ObjectEffect {
	public static id: number = 9295

	public monsterFamilyId: number | undefined = 0

	public constructor(
		actionId?: number | undefined,
		monsterFamilyId?: number | undefined
	) {
		super(actionId)
		this.monsterFamilyId = monsterFamilyId
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeVarShort(this.monsterFamilyId!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.monsterFamilyId = reader.readVarShort()
	}

	public hydrate(
		data: ObjectEffectCreature | Record<string, any>
	): ObjectEffectCreature {
		if (data instanceof ObjectEffectCreature) {
			return data
		}

		super.hydrate(data)

		this.monsterFamilyId = data.monsterFamilyId

		return this
	}
}

export interface RawObjectEffectLadder extends RawObjectEffectCreature {
	id: number
	monsterCount: number
}

export class ObjectEffectLadder extends ObjectEffectCreature {
	public static id: number = 6916

	public monsterCount: number | undefined = 0

	public constructor(
		actionId?: number | undefined,
		monsterFamilyId?: number | undefined,
		monsterCount?: number | undefined
	) {
		super(actionId, monsterFamilyId)
		this.monsterCount = monsterCount
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeVarInt(this.monsterCount!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.monsterCount = reader.readVarInt()
	}

	public hydrate(
		data: ObjectEffectLadder | Record<string, any>
	): ObjectEffectLadder {
		if (data instanceof ObjectEffectLadder) {
			return data
		}

		super.hydrate(data)

		this.monsterCount = data.monsterCount

		return this
	}
}

export interface RawFightTeamMemberMonsterInformations
	extends RawFightTeamMemberInformations {
	id: number
	monsterId: number
	grade: number
}

export class FightTeamMemberMonsterInformations extends FightTeamMemberInformations {
	public static id: number = 8081

	public monsterId: number | undefined = 0
	public grade: number | undefined = 0

	public constructor(
		id_?: number | undefined,
		monsterId?: number | undefined,
		grade?: number | undefined
	) {
		super(id_)
		this.monsterId = monsterId
		this.grade = grade
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeInt(this.monsterId!)
		writer.writeByte(this.grade!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.monsterId = reader.readInt()
		this.grade = reader.readByte()
	}

	public hydrate(
		data: FightTeamMemberMonsterInformations | Record<string, any>
	): FightTeamMemberMonsterInformations {
		if (data instanceof FightTeamMemberMonsterInformations) {
			return data
		}

		super.hydrate(data)

		this.monsterId = data.monsterId
		this.grade = data.grade

		return this
	}
}

export interface RawShortcutObjectIdolsPreset extends RawShortcutObject {
	id: number
	presetId: number
}

export class ShortcutObjectIdolsPreset extends ShortcutObject {
	public static id: number = 9809

	public presetId: number | undefined = 0

	public constructor(slot?: number | undefined, presetId?: number | undefined) {
		super(slot)
		this.presetId = presetId
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeShort(this.presetId!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.presetId = reader.readShort()
	}

	public hydrate(
		data: ShortcutObjectIdolsPreset | Record<string, any>
	): ShortcutObjectIdolsPreset {
		if (data instanceof ShortcutObjectIdolsPreset) {
			return data
		}

		super.hydrate(data)

		this.presetId = data.presetId

		return this
	}
}

export interface RawShortcutObjectPreset extends RawShortcutObject {
	id: number
	presetId: number
}

export class ShortcutObjectPreset extends ShortcutObject {
	public static id: number = 1783

	public presetId: number | undefined = 0

	public constructor(slot?: number | undefined, presetId?: number | undefined) {
		super(slot)
		this.presetId = presetId
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeShort(this.presetId!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.presetId = reader.readShort()
	}

	public hydrate(
		data: ShortcutObjectPreset | Record<string, any>
	): ShortcutObjectPreset {
		if (data instanceof ShortcutObjectPreset) {
			return data
		}

		super.hydrate(data)

		this.presetId = data.presetId

		return this
	}
}

export interface RawTaxCollectorGuildInformations
	extends RawTaxCollectorComplementaryInformations {
	id: number
	guild: BasicGuildInformations
}

export class TaxCollectorGuildInformations extends TaxCollectorComplementaryInformations {
	public static id: number = 343

	public guild: BasicGuildInformations | undefined

	public constructor(guild?: BasicGuildInformations | undefined) {
		super()
		this.guild = guild
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		this.guild!.serialize(writer)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.guild = new BasicGuildInformations()
		this.guild!.deserialize(reader)
	}

	public hydrate(
		data: TaxCollectorGuildInformations | Record<string, any>
	): TaxCollectorGuildInformations {
		if (data instanceof TaxCollectorGuildInformations) {
			return data
		}

		this.guild = new BasicGuildInformations().hydrate(data.guild)

		return this
	}
}

export interface RawTaxCollectorWaitingForHelpInformations
	extends RawTaxCollectorComplementaryInformations {
	id: number
	waitingForHelpInfo: ProtectedEntityWaitingForHelpInfo
}

export class TaxCollectorWaitingForHelpInformations extends TaxCollectorComplementaryInformations {
	public static id: number = 3744

	public waitingForHelpInfo: ProtectedEntityWaitingForHelpInfo | undefined

	public constructor(
		waitingForHelpInfo?: ProtectedEntityWaitingForHelpInfo | undefined
	) {
		super()
		this.waitingForHelpInfo = waitingForHelpInfo
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		this.waitingForHelpInfo!.serialize(writer)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.waitingForHelpInfo = new ProtectedEntityWaitingForHelpInfo()
		this.waitingForHelpInfo!.deserialize(reader)
	}

	public hydrate(
		data: TaxCollectorWaitingForHelpInformations | Record<string, any>
	): TaxCollectorWaitingForHelpInformations {
		if (data instanceof TaxCollectorWaitingForHelpInformations) {
			return data
		}

		this.waitingForHelpInfo = new ProtectedEntityWaitingForHelpInfo().hydrate(
			data.waitingForHelpInfo
		)

		return this
	}
}

export interface RawStatsPreset extends RawPreset {
	id: number
	stats: SimpleCharacterCharacteristicForPreset[]
}

export class StatsPreset extends Preset {
	public static id: number = 440

	public stats: SimpleCharacterCharacteristicForPreset[] | undefined

	public constructor(
		id_?: number | undefined,
		stats?: SimpleCharacterCharacteristicForPreset[] | undefined
	) {
		super(id_)
		this.stats = stats
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeShort(this.stats!.length)
		this.stats!.forEach((current) => {
			current.serialize(writer)
		})
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.stats = []
		const countStats = reader.readShort()
		for (let i: number = 0; i < countStats; i++) {
			const type: SimpleCharacterCharacteristicForPreset = new SimpleCharacterCharacteristicForPreset()
			type.deserialize(reader)
			this.stats.push(type)
		}
	}

	public hydrate(data: StatsPreset | Record<string, any>): StatsPreset {
		if (data instanceof StatsPreset) {
			return data
		}

		super.hydrate(data)

		this.stats = data.stats.map(
			(
				dataElement:
					| SimpleCharacterCharacteristicForPreset
					| Record<string, any>
			): SimpleCharacterCharacteristicForPreset => {
				if (dataElement instanceof SimpleCharacterCharacteristicForPreset) {
					return dataElement
				} else {
					return new SimpleCharacterCharacteristicForPreset().hydrate(
						dataElement
					)
				}
			}
		)

		return this
	}
}

export interface RawObjectEffectDuration extends RawObjectEffect {
	id: number
	days: number
	hours: number
	minutes: number
}

export class ObjectEffectDuration extends ObjectEffect {
	public static id: number = 7748

	public days: number | undefined = 0
	public hours: number | undefined = 0
	public minutes: number | undefined = 0

	public constructor(
		actionId?: number | undefined,
		days?: number | undefined,
		hours?: number | undefined,
		minutes?: number | undefined
	) {
		super(actionId)
		this.days = days
		this.hours = hours
		this.minutes = minutes
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeVarShort(this.days!)
		writer.writeByte(this.hours!)
		writer.writeByte(this.minutes!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.days = reader.readVarShort()
		this.hours = reader.readByte()
		this.minutes = reader.readByte()
	}

	public hydrate(
		data: ObjectEffectDuration | Record<string, any>
	): ObjectEffectDuration {
		if (data instanceof ObjectEffectDuration) {
			return data
		}

		super.hydrate(data)

		this.days = data.days
		this.hours = data.hours
		this.minutes = data.minutes

		return this
	}
}

export interface RawGameFightFighterLightInformations {
	id: number
	sex: boolean
	alive: boolean
	id_: number
	wave: number
	level: number
	breed: number
}

export class GameFightFighterLightInformations extends DofusType {
	public static id: number = 6683

	public sex: boolean | undefined = false
	public alive: boolean | undefined = false
	public id_: number | undefined = 0
	public wave: number | undefined = 0
	public level: number | undefined = 0
	public breed: number | undefined = 0

	public constructor(
		sex?: boolean | undefined,
		alive?: boolean | undefined,
		id_?: number | undefined,
		wave?: number | undefined,
		level?: number | undefined,
		breed?: number | undefined
	) {
		super()
		this.sex = sex
		this.alive = alive
		this.id_ = id_
		this.wave = wave
		this.level = level
		this.breed = breed
	}

	public serialize(writer: BinaryWriter): void {
		let box0: number = 0
		box0 = setFlag(box0, 0, this.sex!)
		box0 = setFlag(box0, 1, this.alive!)
		writer.writeByte(box0)
		writer.writeDouble(this.id_!)
		writer.writeByte(this.wave!)
		writer.writeVarShort(this.level!)
		writer.writeByte(this.breed!)
	}

	public deserialize(reader: BinaryReader): void {
		const box0 = reader.readByte()
		this.sex = getFlag(box0, 0)
		this.alive = getFlag(box0, 1)
		this.id_ = reader.readDouble()
		this.wave = reader.readByte()
		this.level = reader.readVarShort()
		this.breed = reader.readByte()
	}

	public hydrate(
		data: GameFightFighterLightInformations | Record<string, any>
	): GameFightFighterLightInformations {
		if (data instanceof GameFightFighterLightInformations) {
			return data
		}

		this.sex = data.sex
		this.alive = data.alive
		this.id_ = data.id_
		this.wave = data.wave
		this.level = data.level
		this.breed = data.breed

		return this
	}
}

export interface RawGameFightFighterMonsterLightInformations
	extends RawGameFightFighterLightInformations {
	id: number
	creatureGenericId: number
}

export class GameFightFighterMonsterLightInformations extends GameFightFighterLightInformations {
	public static id: number = 6947

	public creatureGenericId: number | undefined = 0

	public constructor(
		sex?: boolean | undefined,
		alive?: boolean | undefined,
		id_?: number | undefined,
		wave?: number | undefined,
		level?: number | undefined,
		breed?: number | undefined,
		creatureGenericId?: number | undefined
	) {
		super(sex, alive, id_, wave, level, breed)
		this.creatureGenericId = creatureGenericId
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeVarShort(this.creatureGenericId!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.creatureGenericId = reader.readVarShort()
	}

	public hydrate(
		data: GameFightFighterMonsterLightInformations | Record<string, any>
	): GameFightFighterMonsterLightInformations {
		if (data instanceof GameFightFighterMonsterLightInformations) {
			return data
		}

		super.hydrate(data)

		this.creatureGenericId = data.creatureGenericId

		return this
	}
}

export interface RawGameFightFighterTaxCollectorLightInformations
	extends RawGameFightFighterLightInformations {
	id: number
	firstNameId: number
	lastNameId: number
}

export class GameFightFighterTaxCollectorLightInformations extends GameFightFighterLightInformations {
	public static id: number = 8613

	public firstNameId: number | undefined = 0
	public lastNameId: number | undefined = 0

	public constructor(
		sex?: boolean | undefined,
		alive?: boolean | undefined,
		id_?: number | undefined,
		wave?: number | undefined,
		level?: number | undefined,
		breed?: number | undefined,
		firstNameId?: number | undefined,
		lastNameId?: number | undefined
	) {
		super(sex, alive, id_, wave, level, breed)
		this.firstNameId = firstNameId
		this.lastNameId = lastNameId
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeVarShort(this.firstNameId!)
		writer.writeVarShort(this.lastNameId!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.firstNameId = reader.readVarShort()
		this.lastNameId = reader.readVarShort()
	}

	public hydrate(
		data: GameFightFighterTaxCollectorLightInformations | Record<string, any>
	): GameFightFighterTaxCollectorLightInformations {
		if (data instanceof GameFightFighterTaxCollectorLightInformations) {
			return data
		}

		super.hydrate(data)

		this.firstNameId = data.firstNameId
		this.lastNameId = data.lastNameId

		return this
	}
}

export interface RawFightAllianceTeamInformations
	extends RawFightTeamInformations {
	id: number
	relation: number
}

export class FightAllianceTeamInformations extends FightTeamInformations {
	public static id: number = 5175

	public relation: number | undefined = 0

	public constructor(
		teamId?: number | undefined,
		leaderId?: number | undefined,
		teamSide?: number | undefined,
		teamTypeId?: number | undefined,
		nbWaves?: number | undefined,
		teamMembers?: FightTeamMemberInformations[] | undefined,
		relation?: number | undefined
	) {
		super(teamId, leaderId, teamSide, teamTypeId, nbWaves, teamMembers)
		this.relation = relation
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeByte(this.relation!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.relation = reader.readByte()
	}

	public hydrate(
		data: FightAllianceTeamInformations | Record<string, any>
	): FightAllianceTeamInformations {
		if (data instanceof FightAllianceTeamInformations) {
			return data
		}

		super.hydrate(data)

		this.relation = data.relation

		return this
	}
}

export interface RawCharacterHardcoreOrEpicInformations
	extends RawCharacterBaseInformations {
	id: number
	deathState: number
	deathCount: number
	deathMaxLevel: number
}

export class CharacterHardcoreOrEpicInformations extends CharacterBaseInformations {
	public static id: number = 3059

	public deathState: number | undefined = 0
	public deathCount: number | undefined = 0
	public deathMaxLevel: number | undefined = 0

	public constructor(
		id_?: number | undefined,
		name?: string | undefined,
		level?: number | undefined,
		entityLook?: EntityLook | undefined,
		breed?: number | undefined,
		sex?: boolean | undefined,
		deathState?: number | undefined,
		deathCount?: number | undefined,
		deathMaxLevel?: number | undefined
	) {
		super(id_, name, level, entityLook, breed, sex)
		this.deathState = deathState
		this.deathCount = deathCount
		this.deathMaxLevel = deathMaxLevel
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeByte(this.deathState!)
		writer.writeVarShort(this.deathCount!)
		writer.writeVarShort(this.deathMaxLevel!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.deathState = reader.readByte()
		this.deathCount = reader.readVarShort()
		this.deathMaxLevel = reader.readVarShort()
	}

	public hydrate(
		data: CharacterHardcoreOrEpicInformations | Record<string, any>
	): CharacterHardcoreOrEpicInformations {
		if (data instanceof CharacterHardcoreOrEpicInformations) {
			return data
		}

		super.hydrate(data)

		this.deathState = data.deathState
		this.deathCount = data.deathCount
		this.deathMaxLevel = data.deathMaxLevel

		return this
	}
}

export interface RawGameFightFighterEntityLightInformation
	extends RawGameFightFighterLightInformations {
	id: number
	entityModelId: number
	masterId: number
}

export class GameFightFighterEntityLightInformation extends GameFightFighterLightInformations {
	public static id: number = 6182

	public entityModelId: number | undefined = 0
	public masterId: number | undefined = 0

	public constructor(
		sex?: boolean | undefined,
		alive?: boolean | undefined,
		id_?: number | undefined,
		wave?: number | undefined,
		level?: number | undefined,
		breed?: number | undefined,
		entityModelId?: number | undefined,
		masterId?: number | undefined
	) {
		super(sex, alive, id_, wave, level, breed)
		this.entityModelId = entityModelId
		this.masterId = masterId
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeByte(this.entityModelId!)
		writer.writeDouble(this.masterId!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.entityModelId = reader.readByte()
		this.masterId = reader.readDouble()
	}

	public hydrate(
		data: GameFightFighterEntityLightInformation | Record<string, any>
	): GameFightFighterEntityLightInformation {
		if (data instanceof GameFightFighterEntityLightInformation) {
			return data
		}

		super.hydrate(data)

		this.entityModelId = data.entityModelId
		this.masterId = data.masterId

		return this
	}
}

export interface RawServerSessionConstantLong extends RawServerSessionConstant {
	id: number
	value: number
}

export class ServerSessionConstantLong extends ServerSessionConstant {
	public static id: number = 2488

	public value: number | undefined = 0

	public constructor(id_?: number | undefined, value?: number | undefined) {
		super(id_)
		this.value = value
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeDouble(this.value!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.value = reader.readDouble()
	}

	public hydrate(
		data: ServerSessionConstantLong | Record<string, any>
	): ServerSessionConstantLong {
		if (data instanceof ServerSessionConstantLong) {
			return data
		}

		super.hydrate(data)

		this.value = data.value

		return this
	}
}

export interface RawInteractiveElementWithAgeBonus
	extends RawInteractiveElement {
	id: number
	ageBonus: number
}

export class InteractiveElementWithAgeBonus extends InteractiveElement {
	public static id: number = 3396

	public ageBonus: number | undefined = 0

	public constructor(
		elementId?: number | undefined,
		elementTypeId?: number | undefined,
		enabledSkills?: InteractiveElementSkill[] | undefined,
		disabledSkills?: InteractiveElementSkill[] | undefined,
		onCurrentMap?: boolean | undefined,
		ageBonus?: number | undefined
	) {
		super(elementId, elementTypeId, enabledSkills, disabledSkills, onCurrentMap)
		this.ageBonus = ageBonus
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeShort(this.ageBonus!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.ageBonus = reader.readShort()
	}

	public hydrate(
		data: InteractiveElementWithAgeBonus | Record<string, any>
	): InteractiveElementWithAgeBonus {
		if (data instanceof InteractiveElementWithAgeBonus) {
			return data
		}

		super.hydrate(data)

		this.ageBonus = data.ageBonus

		return this
	}
}

export interface RawStatisticDataInt extends RawStatisticData {
	id: number
	value: number
}

export class StatisticDataInt extends StatisticData {
	public static id: number = 4640

	public value: number | undefined = 0

	public constructor(value?: number | undefined) {
		super()
		this.value = value
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeInt(this.value!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.value = reader.readInt()
	}

	public hydrate(
		data: StatisticDataInt | Record<string, any>
	): StatisticDataInt {
		if (data instanceof StatisticDataInt) {
			return data
		}

		this.value = data.value

		return this
	}
}

export interface RawAllianceFactSheetInformations
	extends RawAllianceInformations {
	id: number
	creationDate: number
}

export class AllianceFactSheetInformations extends AllianceInformations {
	public static id: number = 6853

	public creationDate: number | undefined = 0

	public constructor(
		allianceId?: number | undefined,
		allianceTag?: string | undefined,
		allianceName?: string | undefined,
		allianceEmblem?: GuildEmblem | undefined,
		creationDate?: number | undefined
	) {
		super(allianceId, allianceTag, allianceName, allianceEmblem)
		this.creationDate = creationDate
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeInt(this.creationDate!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.creationDate = reader.readInt()
	}

	public hydrate(
		data: AllianceFactSheetInformations | Record<string, any>
	): AllianceFactSheetInformations {
		if (data instanceof AllianceFactSheetInformations) {
			return data
		}

		super.hydrate(data)

		this.creationDate = data.creationDate

		return this
	}
}

export interface RawGameFightFighterNamedLightInformations
	extends RawGameFightFighterLightInformations {
	id: number
	name: string
}

export class GameFightFighterNamedLightInformations extends GameFightFighterLightInformations {
	public static id: number = 8143

	public name: string | undefined

	public constructor(
		sex?: boolean | undefined,
		alive?: boolean | undefined,
		id_?: number | undefined,
		wave?: number | undefined,
		level?: number | undefined,
		breed?: number | undefined,
		name?: string | undefined
	) {
		super(sex, alive, id_, wave, level, breed)
		this.name = name
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeUTF(this.name!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.name = reader.readUTF()
	}

	public hydrate(
		data: GameFightFighterNamedLightInformations | Record<string, any>
	): GameFightFighterNamedLightInformations {
		if (data instanceof GameFightFighterNamedLightInformations) {
			return data
		}

		super.hydrate(data)

		this.name = data.name

		return this
	}
}

export interface RawTreasureHuntStepFollowDirectionToPOI
	extends RawTreasureHuntStep {
	id: number
	direction: number
	poiLabelId: number
}

export class TreasureHuntStepFollowDirectionToPOI extends TreasureHuntStep {
	public static id: number = 7951

	public direction: number | undefined = 1
	public poiLabelId: number | undefined = 0

	public constructor(
		direction?: number | undefined,
		poiLabelId?: number | undefined
	) {
		super()
		this.direction = direction
		this.poiLabelId = poiLabelId
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeByte(this.direction!)
		writer.writeVarShort(this.poiLabelId!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.direction = reader.readByte()
		this.poiLabelId = reader.readVarShort()
	}

	public hydrate(
		data: TreasureHuntStepFollowDirectionToPOI | Record<string, any>
	): TreasureHuntStepFollowDirectionToPOI {
		if (data instanceof TreasureHuntStepFollowDirectionToPOI) {
			return data
		}

		this.direction = data.direction
		this.poiLabelId = data.poiLabelId

		return this
	}
}

export interface RawStatisticDataBoolean extends RawStatisticData {
	id: number
	value: boolean
}

export class StatisticDataBoolean extends StatisticData {
	public static id: number = 3779

	public value: boolean | undefined = false

	public constructor(value?: boolean | undefined) {
		super()
		this.value = value
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeBoolean(this.value!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.value = reader.readBoolean()
	}

	public hydrate(
		data: StatisticDataBoolean | Record<string, any>
	): StatisticDataBoolean {
		if (data instanceof StatisticDataBoolean) {
			return data
		}

		this.value = data.value

		return this
	}
}

export interface RawExtendedLockedBreachBranch extends RawExtendedBreachBranch {
	id: number
	unlockPrice: number
}

export class ExtendedLockedBreachBranch extends ExtendedBreachBranch {
	public static id: number = 3547

	public unlockPrice: number | undefined = 0

	public constructor(
		room?: number | undefined,
		element?: number | undefined,
		bosses?: MonsterInGroupLightInformations[] | undefined,
		map?: number | undefined,
		score?: number | undefined,
		relativeScore?: number | undefined,
		monsters?: MonsterInGroupLightInformations[] | undefined,
		rewards?: BreachReward[] | undefined,
		modifier?: number | undefined,
		prize?: number | undefined,
		unlockPrice?: number | undefined
	) {
		super(
			room,
			element,
			bosses,
			map,
			score,
			relativeScore,
			monsters,
			rewards,
			modifier,
			prize
		)
		this.unlockPrice = unlockPrice
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeVarInt(this.unlockPrice!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.unlockPrice = reader.readVarInt()
	}

	public hydrate(
		data: ExtendedLockedBreachBranch | Record<string, any>
	): ExtendedLockedBreachBranch {
		if (data instanceof ExtendedLockedBreachBranch) {
			return data
		}

		super.hydrate(data)

		this.unlockPrice = data.unlockPrice

		return this
	}
}

export interface RawPartyIdol extends RawIdol {
	id: number
	ownersIds: number[]
}

export class PartyIdol extends Idol {
	public static id: number = 5714

	public ownersIds: number[] | undefined

	public constructor(
		id_?: number | undefined,
		xpBonusPercent?: number | undefined,
		dropBonusPercent?: number | undefined,
		ownersIds?: number[] | undefined
	) {
		super(id_, xpBonusPercent, dropBonusPercent)
		this.ownersIds = ownersIds
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeShort(this.ownersIds!.length)
		this.ownersIds!.forEach((current: number) => writer.writeVarLong(current))
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.ownersIds = []
		const countOwnersIds = reader.readShort()
		for (let i: number = 0; i < countOwnersIds; i++) {
			this.ownersIds.push(reader.readVarLong())
		}
	}

	public hydrate(data: PartyIdol | Record<string, any>): PartyIdol {
		if (data instanceof PartyIdol) {
			return data
		}

		super.hydrate(data)

		this.ownersIds = data.ownersIds

		return this
	}
}

export interface RawGameFightMonsterWithAlignmentInformations
	extends RawGameFightMonsterInformations {
	id: number
	alignmentInfos: ActorAlignmentInformations
}

export class GameFightMonsterWithAlignmentInformations extends GameFightMonsterInformations {
	public static id: number = 1318

	public alignmentInfos: ActorAlignmentInformations | undefined

	public constructor(
		contextualId?: number | undefined,
		disposition?: EntityDispositionInformations | undefined,
		look?: EntityLook | undefined,
		spawnInfo?: GameContextBasicSpawnInformation | undefined,
		wave?: number | undefined,
		stats?: GameFightMinimalStats | undefined,
		previousPositions?: number[] | undefined,
		creatureGenericId?: number | undefined,
		creatureGrade?: number | undefined,
		creatureLevel?: number | undefined,
		alignmentInfos?: ActorAlignmentInformations | undefined
	) {
		super(
			contextualId,
			disposition,
			look,
			spawnInfo,
			wave,
			stats,
			previousPositions,
			creatureGenericId,
			creatureGrade,
			creatureLevel
		)
		this.alignmentInfos = alignmentInfos
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		this.alignmentInfos!.serialize(writer)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.alignmentInfos = new ActorAlignmentInformations()
		this.alignmentInfos!.deserialize(reader)
	}

	public hydrate(
		data: GameFightMonsterWithAlignmentInformations | Record<string, any>
	): GameFightMonsterWithAlignmentInformations {
		if (data instanceof GameFightMonsterWithAlignmentInformations) {
			return data
		}

		super.hydrate(data)

		this.alignmentInfos = new ActorAlignmentInformations().hydrate(
			data.alignmentInfos
		)

		return this
	}
}

export interface RawMapCoordinatesExtended extends RawMapCoordinatesAndId {
	id: number
	subAreaId: number
}

export class MapCoordinatesExtended extends MapCoordinatesAndId {
	public static id: number = 1591

	public subAreaId: number | undefined = 0

	public constructor(
		worldX?: number | undefined,
		worldY?: number | undefined,
		mapId?: number | undefined,
		subAreaId?: number | undefined
	) {
		super(worldX, worldY, mapId)
		this.subAreaId = subAreaId
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeVarShort(this.subAreaId!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.subAreaId = reader.readVarShort()
	}

	public hydrate(
		data: MapCoordinatesExtended | Record<string, any>
	): MapCoordinatesExtended {
		if (data instanceof MapCoordinatesExtended) {
			return data
		}

		super.hydrate(data)

		this.subAreaId = data.subAreaId

		return this
	}
}

export interface RawTreasureHuntStepFollowDirection
	extends RawTreasureHuntStep {
	id: number
	direction: number
	mapCount: number
}

export class TreasureHuntStepFollowDirection extends TreasureHuntStep {
	public static id: number = 1881

	public direction: number | undefined = 1
	public mapCount: number | undefined = 0

	public constructor(
		direction?: number | undefined,
		mapCount?: number | undefined
	) {
		super()
		this.direction = direction
		this.mapCount = mapCount
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeByte(this.direction!)
		writer.writeVarShort(this.mapCount!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.direction = reader.readByte()
		this.mapCount = reader.readVarShort()
	}

	public hydrate(
		data: TreasureHuntStepFollowDirection | Record<string, any>
	): TreasureHuntStepFollowDirection {
		if (data instanceof TreasureHuntStepFollowDirection) {
			return data
		}

		this.direction = data.direction
		this.mapCount = data.mapCount

		return this
	}
}

export interface RawShortcutSmiley extends RawShortcut {
	id: number
	smileyId: number
}

export class ShortcutSmiley extends Shortcut {
	public static id: number = 2344

	public smileyId: number | undefined = 0

	public constructor(slot?: number | undefined, smileyId?: number | undefined) {
		super(slot)
		this.smileyId = smileyId
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeVarShort(this.smileyId!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.smileyId = reader.readVarShort()
	}

	public hydrate(data: ShortcutSmiley | Record<string, any>): ShortcutSmiley {
		if (data instanceof ShortcutSmiley) {
			return data
		}

		super.hydrate(data)

		this.smileyId = data.smileyId

		return this
	}
}

export interface RawObjectEffectMinMax extends RawObjectEffect {
	id: number
	min: number
	max: number
}

export class ObjectEffectMinMax extends ObjectEffect {
	public static id: number = 9076

	public min: number | undefined = 0
	public max: number | undefined = 0

	public constructor(
		actionId?: number | undefined,
		min?: number | undefined,
		max?: number | undefined
	) {
		super(actionId)
		this.min = min
		this.max = max
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeVarInt(this.min!)
		writer.writeVarInt(this.max!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.min = reader.readVarInt()
		this.max = reader.readVarInt()
	}

	public hydrate(
		data: ObjectEffectMinMax | Record<string, any>
	): ObjectEffectMinMax {
		if (data instanceof ObjectEffectMinMax) {
			return data
		}

		super.hydrate(data)

		this.min = data.min
		this.max = data.max

		return this
	}
}

export interface RawSpellsPreset extends RawPreset {
	id: number
	spells: SpellForPreset[]
}

export class SpellsPreset extends Preset {
	public static id: number = 3404

	public spells: SpellForPreset[] | undefined

	public constructor(
		id_?: number | undefined,
		spells?: SpellForPreset[] | undefined
	) {
		super(id_)
		this.spells = spells
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeShort(this.spells!.length)
		this.spells!.forEach((current) => {
			current.serialize(writer)
		})
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.spells = []
		const countSpells = reader.readShort()
		for (let i: number = 0; i < countSpells; i++) {
			const type: SpellForPreset = new SpellForPreset()
			type.deserialize(reader)
			this.spells.push(type)
		}
	}

	public hydrate(data: SpellsPreset | Record<string, any>): SpellsPreset {
		if (data instanceof SpellsPreset) {
			return data
		}

		super.hydrate(data)

		this.spells = data.spells.map(
			(dataElement: SpellForPreset | Record<string, any>): SpellForPreset => {
				if (dataElement instanceof SpellForPreset) {
					return dataElement
				} else {
					return new SpellForPreset().hydrate(dataElement)
				}
			}
		)

		return this
	}
}

export interface RawObjectEffectMount extends RawObjectEffect {
	id: number
	sex: boolean
	isRideable: boolean
	isFeconded: boolean
	isFecondationReady: boolean
	id_: number
	expirationDate: number
	model: number
	name: string
	owner: string
	level: number
	reproductionCount: number
	reproductionCountMax: number
	effects: ObjectEffectInteger[]
	capacities: number[]
}

export class ObjectEffectMount extends ObjectEffect {
	public static id: number = 8688

	public sex: boolean | undefined = false
	public isRideable: boolean | undefined = false
	public isFeconded: boolean | undefined = false
	public isFecondationReady: boolean | undefined = false
	public id_: number | undefined = 0
	public expirationDate: number | undefined = 0
	public model: number | undefined = 0
	public name: string | undefined
	public owner: string | undefined
	public level: number | undefined = 0
	public reproductionCount: number | undefined = 0
	public reproductionCountMax: number | undefined = 0
	public effects: ObjectEffectInteger[] | undefined
	public capacities: number[] | undefined

	public constructor(
		actionId?: number | undefined,
		sex?: boolean | undefined,
		isRideable?: boolean | undefined,
		isFeconded?: boolean | undefined,
		isFecondationReady?: boolean | undefined,
		id_?: number | undefined,
		expirationDate?: number | undefined,
		model?: number | undefined,
		name?: string | undefined,
		owner?: string | undefined,
		level?: number | undefined,
		reproductionCount?: number | undefined,
		reproductionCountMax?: number | undefined,
		effects?: ObjectEffectInteger[] | undefined,
		capacities?: number[] | undefined
	) {
		super(actionId)
		this.sex = sex
		this.isRideable = isRideable
		this.isFeconded = isFeconded
		this.isFecondationReady = isFecondationReady
		this.id_ = id_
		this.expirationDate = expirationDate
		this.model = model
		this.name = name
		this.owner = owner
		this.level = level
		this.reproductionCount = reproductionCount
		this.reproductionCountMax = reproductionCountMax
		this.effects = effects
		this.capacities = capacities
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		let box0: number = 0
		box0 = setFlag(box0, 0, this.sex!)
		box0 = setFlag(box0, 1, this.isRideable!)
		box0 = setFlag(box0, 2, this.isFeconded!)
		box0 = setFlag(box0, 3, this.isFecondationReady!)
		writer.writeByte(box0)
		writer.writeVarLong(this.id_!)
		writer.writeVarLong(this.expirationDate!)
		writer.writeVarInt(this.model!)
		writer.writeUTF(this.name!)
		writer.writeUTF(this.owner!)
		writer.writeByte(this.level!)
		writer.writeVarInt(this.reproductionCount!)
		writer.writeVarInt(this.reproductionCountMax!)
		writer.writeShort(this.effects!.length)
		this.effects!.forEach((current) => {
			current.serialize(writer)
		})
		writer.writeShort(this.capacities!.length)
		this.capacities!.forEach((current: number) => writer.writeVarInt(current))
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		const box0 = reader.readByte()
		this.sex = getFlag(box0, 0)
		this.isRideable = getFlag(box0, 1)
		this.isFeconded = getFlag(box0, 2)
		this.isFecondationReady = getFlag(box0, 3)
		this.id_ = reader.readVarLong()
		this.expirationDate = reader.readVarLong()
		this.model = reader.readVarInt()
		this.name = reader.readUTF()
		this.owner = reader.readUTF()
		this.level = reader.readByte()
		this.reproductionCount = reader.readVarInt()
		this.reproductionCountMax = reader.readVarInt()
		this.effects = []
		const countEffects = reader.readShort()
		for (let i: number = 0; i < countEffects; i++) {
			const type: ObjectEffectInteger = new ObjectEffectInteger()
			type.deserialize(reader)
			this.effects.push(type)
		}
		this.capacities = []
		const countCapacities = reader.readShort()
		for (let i: number = 0; i < countCapacities; i++) {
			this.capacities.push(reader.readVarInt())
		}
	}

	public hydrate(
		data: ObjectEffectMount | Record<string, any>
	): ObjectEffectMount {
		if (data instanceof ObjectEffectMount) {
			return data
		}

		super.hydrate(data)

		this.sex = data.sex
		this.isRideable = data.isRideable
		this.isFeconded = data.isFeconded
		this.isFecondationReady = data.isFecondationReady
		this.id_ = data.id_
		this.expirationDate = data.expirationDate
		this.model = data.model
		this.name = data.name
		this.owner = data.owner
		this.level = data.level
		this.reproductionCount = data.reproductionCount
		this.reproductionCountMax = data.reproductionCountMax
		this.effects = data.effects.map(
			(
				dataElement: ObjectEffectInteger | Record<string, any>
			): ObjectEffectInteger => {
				if (dataElement instanceof ObjectEffectInteger) {
					return dataElement
				} else {
					return new ObjectEffectInteger().hydrate(dataElement)
				}
			}
		)
		this.capacities = data.capacities

		return this
	}
}

export interface RawItemForPreset {
	id: number
	position: number
	objGid: number
	objUid: number
}

export class ItemForPreset extends DofusType {
	public static id: number = 6103

	public position: number | undefined = 63
	public objGid: number | undefined = 0
	public objUid: number | undefined = 0

	public constructor(
		position?: number | undefined,
		objGid?: number | undefined,
		objUid?: number | undefined
	) {
		super()
		this.position = position
		this.objGid = objGid
		this.objUid = objUid
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeShort(this.position!)
		writer.writeVarShort(this.objGid!)
		writer.writeVarInt(this.objUid!)
	}

	public deserialize(reader: BinaryReader): void {
		this.position = reader.readShort()
		this.objGid = reader.readVarShort()
		this.objUid = reader.readVarInt()
	}

	public hydrate(data: ItemForPreset | Record<string, any>): ItemForPreset {
		if (data instanceof ItemForPreset) {
			return data
		}

		this.position = data.position
		this.objGid = data.objGid
		this.objUid = data.objUid

		return this
	}
}

export interface RawMountClientData {
	id: number
	sex: boolean
	isRideable: boolean
	isWild: boolean
	isFecondationReady: boolean
	useHarnessColors: boolean
	id_: number
	model: number
	ancestor: number[]
	behaviors: number[]
	name: string
	ownerId: number
	experience: number
	experienceForLevel: number
	experienceForNextLevel: number
	level: number
	maxPods: number
	stamina: number
	staminaMax: number
	maturity: number
	maturityForAdult: number
	energy: number
	energyMax: number
	serenity: number
	aggressivityMax: number
	serenityMax: number
	love: number
	loveMax: number
	fecondationTime: number
	boostLimiter: number
	boostMax: number
	reproductionCount: number
	reproductionCountMax: number
	harnessGID: number
	effectList: ObjectEffectInteger[]
}

export class MountClientData extends DofusType {
	public static id: number = 3510

	public sex: boolean | undefined = false
	public isRideable: boolean | undefined = false
	public isWild: boolean | undefined = false
	public isFecondationReady: boolean | undefined = false
	public useHarnessColors: boolean | undefined = false
	public id_: number | undefined = 0
	public model: number | undefined = 0
	public ancestor: number[] | undefined
	public behaviors: number[] | undefined
	public name: string | undefined
	public ownerId: number | undefined = 0
	public experience: number | undefined = 0
	public experienceForLevel: number | undefined = 0
	public experienceForNextLevel: number | undefined = 0
	public level: number | undefined = 0
	public maxPods: number | undefined = 0
	public stamina: number | undefined = 0
	public staminaMax: number | undefined = 0
	public maturity: number | undefined = 0
	public maturityForAdult: number | undefined = 0
	public energy: number | undefined = 0
	public energyMax: number | undefined = 0
	public serenity: number | undefined = 0
	public aggressivityMax: number | undefined = 0
	public serenityMax: number | undefined = 0
	public love: number | undefined = 0
	public loveMax: number | undefined = 0
	public fecondationTime: number | undefined = 0
	public boostLimiter: number | undefined = 0
	public boostMax: number | undefined = 0
	public reproductionCount: number | undefined = 0
	public reproductionCountMax: number | undefined = 0
	public harnessGID: number | undefined = 0
	public effectList: ObjectEffectInteger[] | undefined

	public constructor(
		sex?: boolean | undefined,
		isRideable?: boolean | undefined,
		isWild?: boolean | undefined,
		isFecondationReady?: boolean | undefined,
		useHarnessColors?: boolean | undefined,
		id_?: number | undefined,
		model?: number | undefined,
		ancestor?: number[] | undefined,
		behaviors?: number[] | undefined,
		name?: string | undefined,
		ownerId?: number | undefined,
		experience?: number | undefined,
		experienceForLevel?: number | undefined,
		experienceForNextLevel?: number | undefined,
		level?: number | undefined,
		maxPods?: number | undefined,
		stamina?: number | undefined,
		staminaMax?: number | undefined,
		maturity?: number | undefined,
		maturityForAdult?: number | undefined,
		energy?: number | undefined,
		energyMax?: number | undefined,
		serenity?: number | undefined,
		aggressivityMax?: number | undefined,
		serenityMax?: number | undefined,
		love?: number | undefined,
		loveMax?: number | undefined,
		fecondationTime?: number | undefined,
		boostLimiter?: number | undefined,
		boostMax?: number | undefined,
		reproductionCount?: number | undefined,
		reproductionCountMax?: number | undefined,
		harnessGID?: number | undefined,
		effectList?: ObjectEffectInteger[] | undefined
	) {
		super()
		this.sex = sex
		this.isRideable = isRideable
		this.isWild = isWild
		this.isFecondationReady = isFecondationReady
		this.useHarnessColors = useHarnessColors
		this.id_ = id_
		this.model = model
		this.ancestor = ancestor
		this.behaviors = behaviors
		this.name = name
		this.ownerId = ownerId
		this.experience = experience
		this.experienceForLevel = experienceForLevel
		this.experienceForNextLevel = experienceForNextLevel
		this.level = level
		this.maxPods = maxPods
		this.stamina = stamina
		this.staminaMax = staminaMax
		this.maturity = maturity
		this.maturityForAdult = maturityForAdult
		this.energy = energy
		this.energyMax = energyMax
		this.serenity = serenity
		this.aggressivityMax = aggressivityMax
		this.serenityMax = serenityMax
		this.love = love
		this.loveMax = loveMax
		this.fecondationTime = fecondationTime
		this.boostLimiter = boostLimiter
		this.boostMax = boostMax
		this.reproductionCount = reproductionCount
		this.reproductionCountMax = reproductionCountMax
		this.harnessGID = harnessGID
		this.effectList = effectList
	}

	public serialize(writer: BinaryWriter): void {
		let box0: number = 0
		box0 = setFlag(box0, 0, this.sex!)
		box0 = setFlag(box0, 1, this.isRideable!)
		box0 = setFlag(box0, 2, this.isWild!)
		box0 = setFlag(box0, 3, this.isFecondationReady!)
		box0 = setFlag(box0, 4, this.useHarnessColors!)
		writer.writeByte(box0)
		writer.writeDouble(this.id_!)
		writer.writeVarInt(this.model!)
		writer.writeShort(this.ancestor!.length)
		this.ancestor!.forEach((current: number) => writer.writeInt(current))
		writer.writeShort(this.behaviors!.length)
		this.behaviors!.forEach((current: number) => writer.writeInt(current))
		writer.writeUTF(this.name!)
		writer.writeInt(this.ownerId!)
		writer.writeVarLong(this.experience!)
		writer.writeVarLong(this.experienceForLevel!)
		writer.writeDouble(this.experienceForNextLevel!)
		writer.writeByte(this.level!)
		writer.writeVarInt(this.maxPods!)
		writer.writeVarInt(this.stamina!)
		writer.writeVarInt(this.staminaMax!)
		writer.writeVarInt(this.maturity!)
		writer.writeVarInt(this.maturityForAdult!)
		writer.writeVarInt(this.energy!)
		writer.writeVarInt(this.energyMax!)
		writer.writeInt(this.serenity!)
		writer.writeInt(this.aggressivityMax!)
		writer.writeVarInt(this.serenityMax!)
		writer.writeVarInt(this.love!)
		writer.writeVarInt(this.loveMax!)
		writer.writeInt(this.fecondationTime!)
		writer.writeInt(this.boostLimiter!)
		writer.writeDouble(this.boostMax!)
		writer.writeInt(this.reproductionCount!)
		writer.writeVarInt(this.reproductionCountMax!)
		writer.writeVarShort(this.harnessGID!)
		writer.writeShort(this.effectList!.length)
		this.effectList!.forEach((current) => {
			current.serialize(writer)
		})
	}

	public deserialize(reader: BinaryReader): void {
		const box0 = reader.readByte()
		this.sex = getFlag(box0, 0)
		this.isRideable = getFlag(box0, 1)
		this.isWild = getFlag(box0, 2)
		this.isFecondationReady = getFlag(box0, 3)
		this.useHarnessColors = getFlag(box0, 4)
		this.id_ = reader.readDouble()
		this.model = reader.readVarInt()
		this.ancestor = []
		const countAncestor = reader.readShort()
		for (let i: number = 0; i < countAncestor; i++) {
			this.ancestor.push(reader.readInt())
		}
		this.behaviors = []
		const countBehaviors = reader.readShort()
		for (let i: number = 0; i < countBehaviors; i++) {
			this.behaviors.push(reader.readInt())
		}
		this.name = reader.readUTF()
		this.ownerId = reader.readInt()
		this.experience = reader.readVarLong()
		this.experienceForLevel = reader.readVarLong()
		this.experienceForNextLevel = reader.readDouble()
		this.level = reader.readByte()
		this.maxPods = reader.readVarInt()
		this.stamina = reader.readVarInt()
		this.staminaMax = reader.readVarInt()
		this.maturity = reader.readVarInt()
		this.maturityForAdult = reader.readVarInt()
		this.energy = reader.readVarInt()
		this.energyMax = reader.readVarInt()
		this.serenity = reader.readInt()
		this.aggressivityMax = reader.readInt()
		this.serenityMax = reader.readVarInt()
		this.love = reader.readVarInt()
		this.loveMax = reader.readVarInt()
		this.fecondationTime = reader.readInt()
		this.boostLimiter = reader.readInt()
		this.boostMax = reader.readDouble()
		this.reproductionCount = reader.readInt()
		this.reproductionCountMax = reader.readVarInt()
		this.harnessGID = reader.readVarShort()
		this.effectList = []
		const countEffectList = reader.readShort()
		for (let i: number = 0; i < countEffectList; i++) {
			const type: ObjectEffectInteger = new ObjectEffectInteger()
			type.deserialize(reader)
			this.effectList.push(type)
		}
	}

	public hydrate(data: MountClientData | Record<string, any>): MountClientData {
		if (data instanceof MountClientData) {
			return data
		}

		this.sex = data.sex
		this.isRideable = data.isRideable
		this.isWild = data.isWild
		this.isFecondationReady = data.isFecondationReady
		this.useHarnessColors = data.useHarnessColors
		this.id_ = data.id_
		this.model = data.model
		this.ancestor = data.ancestor
		this.behaviors = data.behaviors
		this.name = data.name
		this.ownerId = data.ownerId
		this.experience = data.experience
		this.experienceForLevel = data.experienceForLevel
		this.experienceForNextLevel = data.experienceForNextLevel
		this.level = data.level
		this.maxPods = data.maxPods
		this.stamina = data.stamina
		this.staminaMax = data.staminaMax
		this.maturity = data.maturity
		this.maturityForAdult = data.maturityForAdult
		this.energy = data.energy
		this.energyMax = data.energyMax
		this.serenity = data.serenity
		this.aggressivityMax = data.aggressivityMax
		this.serenityMax = data.serenityMax
		this.love = data.love
		this.loveMax = data.loveMax
		this.fecondationTime = data.fecondationTime
		this.boostLimiter = data.boostLimiter
		this.boostMax = data.boostMax
		this.reproductionCount = data.reproductionCount
		this.reproductionCountMax = data.reproductionCountMax
		this.harnessGID = data.harnessGID
		this.effectList = data.effectList.map(
			(
				dataElement: ObjectEffectInteger | Record<string, any>
			): ObjectEffectInteger => {
				if (dataElement instanceof ObjectEffectInteger) {
					return dataElement
				} else {
					return new ObjectEffectInteger().hydrate(dataElement)
				}
			}
		)

		return this
	}
}

export interface RawFightLoot {
	id: number
	objects: number[]
	kamas: number
}

export class FightLoot extends DofusType {
	public static id: number = 7757

	public objects: number[] | undefined
	public kamas: number | undefined = 0

	public constructor(
		objects?: number[] | undefined,
		kamas?: number | undefined
	) {
		super()
		this.objects = objects
		this.kamas = kamas
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeShort(this.objects!.length)
		this.objects!.forEach((current: number) => writer.writeVarInt(current))
		writer.writeVarLong(this.kamas!)
	}

	public deserialize(reader: BinaryReader): void {
		this.objects = []
		const countObjects = reader.readShort()
		for (let i: number = 0; i < countObjects; i++) {
			this.objects.push(reader.readVarInt())
		}
		this.kamas = reader.readVarLong()
	}

	public hydrate(data: FightLoot | Record<string, any>): FightLoot {
		if (data instanceof FightLoot) {
			return data
		}

		this.objects = data.objects
		this.kamas = data.kamas

		return this
	}
}

export interface RawTreasureHuntFlag {
	id: number
	mapId: number
	state: number
}

export class TreasureHuntFlag extends DofusType {
	public static id: number = 2701

	public mapId: number | undefined = 0
	public state: number | undefined = 0

	public constructor(mapId?: number | undefined, state?: number | undefined) {
		super()
		this.mapId = mapId
		this.state = state
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeDouble(this.mapId!)
		writer.writeByte(this.state!)
	}

	public deserialize(reader: BinaryReader): void {
		this.mapId = reader.readDouble()
		this.state = reader.readByte()
	}

	public hydrate(
		data: TreasureHuntFlag | Record<string, any>
	): TreasureHuntFlag {
		if (data instanceof TreasureHuntFlag) {
			return data
		}

		this.mapId = data.mapId
		this.state = data.state

		return this
	}
}

export interface RawObjectItemMinimalInformation extends RawItem {
	id: number
	objectGID: number
	effects: ObjectEffect[]
}

export class ObjectItemMinimalInformation extends Item {
	public static id: number = 4416

	public objectGID: number | undefined = 0
	public effects: ObjectEffect[] | undefined

	public constructor(
		objectGID?: number | undefined,
		effects?: ObjectEffect[] | undefined
	) {
		super()
		this.objectGID = objectGID
		this.effects = effects
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeVarShort(this.objectGID!)
		writer.writeShort(this.effects!.length)
		this.effects!.forEach((current) => {
			writer.writeShort(current.id)
			current.serialize(writer)
		})
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.objectGID = reader.readVarShort()
		this.effects = []
		const countEffects = reader.readShort()
		for (let i: number = 0; i < countEffects; i++) {
			const effectsTypeId: number = reader.readShort()
			const type: ObjectEffect = new types[effectsTypeId]() as ObjectEffect
			type.deserialize(reader)
			this.effects.push(type)
		}
	}

	public hydrate(
		data: ObjectItemMinimalInformation | Record<string, any>
	): ObjectItemMinimalInformation {
		if (data instanceof ObjectItemMinimalInformation) {
			return data
		}

		this.objectGID = data.objectGID
		this.effects = data.effects.map(
			(dataElement: ObjectEffect | Record<string, any>): ObjectEffect => {
				if (dataElement instanceof ObjectEffect) {
					return dataElement
				} else {
					return (new types[dataElement.id]() as ObjectEffect).hydrate(
						dataElement
					)
				}
			}
		)

		return this
	}
}

export interface RawObjectItemInformationWithQuantity
	extends RawObjectItemMinimalInformation {
	id: number
	quantity: number
}

export class ObjectItemInformationWithQuantity extends ObjectItemMinimalInformation {
	public static id: number = 6404

	public quantity: number | undefined = 0

	public constructor(
		objectGID?: number | undefined,
		effects?: ObjectEffect[] | undefined,
		quantity?: number | undefined
	) {
		super(objectGID, effects)
		this.quantity = quantity
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeVarInt(this.quantity!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.quantity = reader.readVarInt()
	}

	public hydrate(
		data: ObjectItemInformationWithQuantity | Record<string, any>
	): ObjectItemInformationWithQuantity {
		if (data instanceof ObjectItemInformationWithQuantity) {
			return data
		}

		super.hydrate(data)

		this.quantity = data.quantity

		return this
	}
}

export interface RawStartupActionAddObject {
	id: number
	uid: number
	title: string
	text: string
	descUrl: string
	pictureUrl: string
	items: ObjectItemInformationWithQuantity[]
}

export class StartupActionAddObject extends DofusType {
	public static id: number = 5320

	public uid: number | undefined = 0
	public title: string | undefined
	public text: string | undefined
	public descUrl: string | undefined
	public pictureUrl: string | undefined
	public items: ObjectItemInformationWithQuantity[] | undefined

	public constructor(
		uid?: number | undefined,
		title?: string | undefined,
		text?: string | undefined,
		descUrl?: string | undefined,
		pictureUrl?: string | undefined,
		items?: ObjectItemInformationWithQuantity[] | undefined
	) {
		super()
		this.uid = uid
		this.title = title
		this.text = text
		this.descUrl = descUrl
		this.pictureUrl = pictureUrl
		this.items = items
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeInt(this.uid!)
		writer.writeUTF(this.title!)
		writer.writeUTF(this.text!)
		writer.writeUTF(this.descUrl!)
		writer.writeUTF(this.pictureUrl!)
		writer.writeShort(this.items!.length)
		this.items!.forEach((current) => {
			current.serialize(writer)
		})
	}

	public deserialize(reader: BinaryReader): void {
		this.uid = reader.readInt()
		this.title = reader.readUTF()
		this.text = reader.readUTF()
		this.descUrl = reader.readUTF()
		this.pictureUrl = reader.readUTF()
		this.items = []
		const countItems = reader.readShort()
		for (let i: number = 0; i < countItems; i++) {
			const type: ObjectItemInformationWithQuantity = new ObjectItemInformationWithQuantity()
			type.deserialize(reader)
			this.items.push(type)
		}
	}

	public hydrate(
		data: StartupActionAddObject | Record<string, any>
	): StartupActionAddObject {
		if (data instanceof StartupActionAddObject) {
			return data
		}

		this.uid = data.uid
		this.title = data.title
		this.text = data.text
		this.descUrl = data.descUrl
		this.pictureUrl = data.pictureUrl
		this.items = data.items.map(
			(
				dataElement: ObjectItemInformationWithQuantity | Record<string, any>
			): ObjectItemInformationWithQuantity => {
				if (dataElement instanceof ObjectItemInformationWithQuantity) {
					return dataElement
				} else {
					return new ObjectItemInformationWithQuantity().hydrate(dataElement)
				}
			}
		)

		return this
	}
}

export interface RawCharacterRemodelingInformation
	extends RawAbstractCharacterInformation {
	id: number
	name: string
	breed: number
	sex: boolean
	cosmeticId: number
	colors: number[]
}

export class CharacterRemodelingInformation extends AbstractCharacterInformation {
	public static id: number = 2924

	public name: string | undefined
	public breed: number | undefined = 0
	public sex: boolean | undefined = false
	public cosmeticId: number | undefined = 0
	public colors: number[] | undefined

	public constructor(
		id_?: number | undefined,
		name?: string | undefined,
		breed?: number | undefined,
		sex?: boolean | undefined,
		cosmeticId?: number | undefined,
		colors?: number[] | undefined
	) {
		super(id_)
		this.name = name
		this.breed = breed
		this.sex = sex
		this.cosmeticId = cosmeticId
		this.colors = colors
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeUTF(this.name!)
		writer.writeByte(this.breed!)
		writer.writeBoolean(this.sex!)
		writer.writeVarShort(this.cosmeticId!)
		writer.writeShort(this.colors!.length)
		this.colors!.forEach((current: number) => writer.writeInt(current))
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.name = reader.readUTF()
		this.breed = reader.readByte()
		this.sex = reader.readBoolean()
		this.cosmeticId = reader.readVarShort()
		this.colors = []
		const countColors = reader.readShort()
		for (let i: number = 0; i < countColors; i++) {
			this.colors.push(reader.readInt())
		}
	}

	public hydrate(
		data: CharacterRemodelingInformation | Record<string, any>
	): CharacterRemodelingInformation {
		if (data instanceof CharacterRemodelingInformation) {
			return data
		}

		super.hydrate(data)

		this.name = data.name
		this.breed = data.breed
		this.sex = data.sex
		this.cosmeticId = data.cosmeticId
		this.colors = data.colors

		return this
	}
}

export interface RawCharacterToRemodelInformations
	extends RawCharacterRemodelingInformation {
	id: number
	possibleChangeMask: number
	mandatoryChangeMask: number
}

export class CharacterToRemodelInformations extends CharacterRemodelingInformation {
	public static id: number = 1292

	public possibleChangeMask: number | undefined = 0
	public mandatoryChangeMask: number | undefined = 0

	public constructor(
		id_?: number | undefined,
		name?: string | undefined,
		breed?: number | undefined,
		sex?: boolean | undefined,
		cosmeticId?: number | undefined,
		colors?: number[] | undefined,
		possibleChangeMask?: number | undefined,
		mandatoryChangeMask?: number | undefined
	) {
		super(id_, name, breed, sex, cosmeticId, colors)
		this.possibleChangeMask = possibleChangeMask
		this.mandatoryChangeMask = mandatoryChangeMask
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeByte(this.possibleChangeMask!)
		writer.writeByte(this.mandatoryChangeMask!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.possibleChangeMask = reader.readByte()
		this.mandatoryChangeMask = reader.readByte()
	}

	public hydrate(
		data: CharacterToRemodelInformations | Record<string, any>
	): CharacterToRemodelInformations {
		if (data instanceof CharacterToRemodelInformations) {
			return data
		}

		super.hydrate(data)

		this.possibleChangeMask = data.possibleChangeMask
		this.mandatoryChangeMask = data.mandatoryChangeMask

		return this
	}
}

export interface RawRemodelingInformation {
	id: number
	name: string
	breed: number
	sex: boolean
	cosmeticId: number
	colors: number[]
}

export class RemodelingInformation extends DofusType {
	public static id: number = 7815

	public name: string | undefined
	public breed: number | undefined = 0
	public sex: boolean | undefined = false
	public cosmeticId: number | undefined = 0
	public colors: number[] | undefined

	public constructor(
		name?: string | undefined,
		breed?: number | undefined,
		sex?: boolean | undefined,
		cosmeticId?: number | undefined,
		colors?: number[] | undefined
	) {
		super()
		this.name = name
		this.breed = breed
		this.sex = sex
		this.cosmeticId = cosmeticId
		this.colors = colors
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeUTF(this.name!)
		writer.writeByte(this.breed!)
		writer.writeBoolean(this.sex!)
		writer.writeVarShort(this.cosmeticId!)
		writer.writeShort(this.colors!.length)
		this.colors!.forEach((current: number) => writer.writeInt(current))
	}

	public deserialize(reader: BinaryReader): void {
		this.name = reader.readUTF()
		this.breed = reader.readByte()
		this.sex = reader.readBoolean()
		this.cosmeticId = reader.readVarShort()
		this.colors = []
		const countColors = reader.readShort()
		for (let i: number = 0; i < countColors; i++) {
			this.colors.push(reader.readInt())
		}
	}

	public hydrate(
		data: RemodelingInformation | Record<string, any>
	): RemodelingInformation {
		if (data instanceof RemodelingInformation) {
			return data
		}

		this.name = data.name
		this.breed = data.breed
		this.sex = data.sex
		this.cosmeticId = data.cosmeticId
		this.colors = data.colors

		return this
	}
}

export interface RawVersion {
	id: number
	major: number
	minor: number
	code: number
	build: number
	buildType: number
}

export class Version extends DofusType {
	public static id: number = 6752

	public major: number | undefined = 0
	public minor: number | undefined = 0
	public code: number | undefined = 0
	public build: number | undefined = 0
	public buildType: number | undefined = 0

	public constructor(
		major?: number | undefined,
		minor?: number | undefined,
		code?: number | undefined,
		build?: number | undefined,
		buildType?: number | undefined
	) {
		super()
		this.major = major
		this.minor = minor
		this.code = code
		this.build = build
		this.buildType = buildType
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeByte(this.major!)
		writer.writeByte(this.minor!)
		writer.writeByte(this.code!)
		writer.writeInt(this.build!)
		writer.writeByte(this.buildType!)
	}

	public deserialize(reader: BinaryReader): void {
		this.major = reader.readByte()
		this.minor = reader.readByte()
		this.code = reader.readByte()
		this.build = reader.readInt()
		this.buildType = reader.readByte()
	}

	public hydrate(data: Version | Record<string, any>): Version {
		if (data instanceof Version) {
			return data
		}

		this.major = data.major
		this.minor = data.minor
		this.code = data.code
		this.build = data.build
		this.buildType = data.buildType

		return this
	}
}

export interface RawSimpleCharacterCharacteristicForPreset {
	id: number
	keyword: string
	base: number
	additionnal: number
}

export class SimpleCharacterCharacteristicForPreset extends DofusType {
	public static id: number = 1231

	public keyword: string | undefined
	public base: number | undefined = 0
	public additionnal: number | undefined = 0

	public constructor(
		keyword?: string | undefined,
		base?: number | undefined,
		additionnal?: number | undefined
	) {
		super()
		this.keyword = keyword
		this.base = base
		this.additionnal = additionnal
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeUTF(this.keyword!)
		writer.writeVarShort(this.base!)
		writer.writeVarShort(this.additionnal!)
	}

	public deserialize(reader: BinaryReader): void {
		this.keyword = reader.readUTF()
		this.base = reader.readVarShort()
		this.additionnal = reader.readVarShort()
	}

	public hydrate(
		data: SimpleCharacterCharacteristicForPreset | Record<string, any>
	): SimpleCharacterCharacteristicForPreset {
		if (data instanceof SimpleCharacterCharacteristicForPreset) {
			return data
		}

		this.keyword = data.keyword
		this.base = data.base
		this.additionnal = data.additionnal

		return this
	}
}

export interface RawCharacterCharacteristicForPreset
	extends RawSimpleCharacterCharacteristicForPreset {
	id: number
	stuff: number
}

export class CharacterCharacteristicForPreset extends SimpleCharacterCharacteristicForPreset {
	public static id: number = 7508

	public stuff: number | undefined = 0

	public constructor(
		keyword?: string | undefined,
		base?: number | undefined,
		additionnal?: number | undefined,
		stuff?: number | undefined
	) {
		super(keyword, base, additionnal)
		this.stuff = stuff
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeVarShort(this.stuff!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.stuff = reader.readVarShort()
	}

	public hydrate(
		data: CharacterCharacteristicForPreset | Record<string, any>
	): CharacterCharacteristicForPreset {
		if (data instanceof CharacterCharacteristicForPreset) {
			return data
		}

		super.hydrate(data)

		this.stuff = data.stuff

		return this
	}
}

export interface RawSpellForPreset {
	id: number
	spellId: number
	shortcuts: number[]
}

export class SpellForPreset extends DofusType {
	public static id: number = 6884

	public spellId: number | undefined = 0
	public shortcuts: number[] | undefined

	public constructor(
		spellId?: number | undefined,
		shortcuts?: number[] | undefined
	) {
		super()
		this.spellId = spellId
		this.shortcuts = shortcuts
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarShort(this.spellId!)
		writer.writeShort(this.shortcuts!.length)
		this.shortcuts!.forEach((current: number) => writer.writeShort(current))
	}

	public deserialize(reader: BinaryReader): void {
		this.spellId = reader.readVarShort()
		this.shortcuts = []
		const countShortcuts = reader.readShort()
		for (let i: number = 0; i < countShortcuts; i++) {
			this.shortcuts.push(reader.readShort())
		}
	}

	public hydrate(data: SpellForPreset | Record<string, any>): SpellForPreset {
		if (data instanceof SpellForPreset) {
			return data
		}

		this.spellId = data.spellId
		this.shortcuts = data.shortcuts

		return this
	}
}

export interface RawAchievement {
	id: number
	id_: number
	finishedObjective: AchievementObjective[]
	startedObjectives: AchievementStartedObjective[]
}

export class Achievement extends DofusType {
	public static id: number = 3448

	public id_: number | undefined = 0
	public finishedObjective: AchievementObjective[] | undefined
	public startedObjectives: AchievementStartedObjective[] | undefined

	public constructor(
		id_?: number | undefined,
		finishedObjective?: AchievementObjective[] | undefined,
		startedObjectives?: AchievementStartedObjective[] | undefined
	) {
		super()
		this.id_ = id_
		this.finishedObjective = finishedObjective
		this.startedObjectives = startedObjectives
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarShort(this.id_!)
		writer.writeShort(this.finishedObjective!.length)
		this.finishedObjective!.forEach((current) => {
			current.serialize(writer)
		})
		writer.writeShort(this.startedObjectives!.length)
		this.startedObjectives!.forEach((current) => {
			current.serialize(writer)
		})
	}

	public deserialize(reader: BinaryReader): void {
		this.id_ = reader.readVarShort()
		this.finishedObjective = []
		const countFinishedObjective = reader.readShort()
		for (let i: number = 0; i < countFinishedObjective; i++) {
			const type: AchievementObjective = new AchievementObjective()
			type.deserialize(reader)
			this.finishedObjective.push(type)
		}
		this.startedObjectives = []
		const countStartedObjectives = reader.readShort()
		for (let i: number = 0; i < countStartedObjectives; i++) {
			const type: AchievementStartedObjective = new AchievementStartedObjective()
			type.deserialize(reader)
			this.startedObjectives.push(type)
		}
	}

	public hydrate(data: Achievement | Record<string, any>): Achievement {
		if (data instanceof Achievement) {
			return data
		}

		this.id_ = data.id_
		this.finishedObjective = data.finishedObjective.map(
			(
				dataElement: AchievementObjective | Record<string, any>
			): AchievementObjective => {
				if (dataElement instanceof AchievementObjective) {
					return dataElement
				} else {
					return new AchievementObjective().hydrate(dataElement)
				}
			}
		)
		this.startedObjectives = data.startedObjectives.map(
			(
				dataElement: AchievementStartedObjective | Record<string, any>
			): AchievementStartedObjective => {
				if (dataElement instanceof AchievementStartedObjective) {
					return dataElement
				} else {
					return new AchievementStartedObjective().hydrate(dataElement)
				}
			}
		)

		return this
	}
}

export interface RawObjectItemNotInContainer extends RawItem {
	id: number
	objectGID: number
	effects: ObjectEffect[]
	objectUID: number
	quantity: number
}

export class ObjectItemNotInContainer extends Item {
	public static id: number = 4752

	public objectGID: number | undefined = 0
	public effects: ObjectEffect[] | undefined
	public objectUID: number | undefined = 0
	public quantity: number | undefined = 0

	public constructor(
		objectGID?: number | undefined,
		effects?: ObjectEffect[] | undefined,
		objectUID?: number | undefined,
		quantity?: number | undefined
	) {
		super()
		this.objectGID = objectGID
		this.effects = effects
		this.objectUID = objectUID
		this.quantity = quantity
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeVarShort(this.objectGID!)
		writer.writeShort(this.effects!.length)
		this.effects!.forEach((current) => {
			writer.writeShort(current.id)
			current.serialize(writer)
		})
		writer.writeVarInt(this.objectUID!)
		writer.writeVarInt(this.quantity!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.objectGID = reader.readVarShort()
		this.effects = []
		const countEffects = reader.readShort()
		for (let i: number = 0; i < countEffects; i++) {
			const effectsTypeId: number = reader.readShort()
			const type: ObjectEffect = new types[effectsTypeId]() as ObjectEffect
			type.deserialize(reader)
			this.effects.push(type)
		}
		this.objectUID = reader.readVarInt()
		this.quantity = reader.readVarInt()
	}

	public hydrate(
		data: ObjectItemNotInContainer | Record<string, any>
	): ObjectItemNotInContainer {
		if (data instanceof ObjectItemNotInContainer) {
			return data
		}

		this.objectGID = data.objectGID
		this.effects = data.effects.map(
			(dataElement: ObjectEffect | Record<string, any>): ObjectEffect => {
				if (dataElement instanceof ObjectEffect) {
					return dataElement
				} else {
					return (new types[dataElement.id]() as ObjectEffect).hydrate(
						dataElement
					)
				}
			}
		)
		this.objectUID = data.objectUID
		this.quantity = data.quantity

		return this
	}
}

export interface RawObjectItemToSell extends RawItem {
	id: number
	objectGID: number
	effects: ObjectEffect[]
	objectUID: number
	quantity: number
	objectPrice: number
}

export class ObjectItemToSell extends Item {
	public static id: number = 446

	public objectGID: number | undefined = 0
	public effects: ObjectEffect[] | undefined
	public objectUID: number | undefined = 0
	public quantity: number | undefined = 0
	public objectPrice: number | undefined = 0

	public constructor(
		objectGID?: number | undefined,
		effects?: ObjectEffect[] | undefined,
		objectUID?: number | undefined,
		quantity?: number | undefined,
		objectPrice?: number | undefined
	) {
		super()
		this.objectGID = objectGID
		this.effects = effects
		this.objectUID = objectUID
		this.quantity = quantity
		this.objectPrice = objectPrice
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeVarShort(this.objectGID!)
		writer.writeShort(this.effects!.length)
		this.effects!.forEach((current) => {
			writer.writeShort(current.id)
			current.serialize(writer)
		})
		writer.writeVarInt(this.objectUID!)
		writer.writeVarInt(this.quantity!)
		writer.writeVarLong(this.objectPrice!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.objectGID = reader.readVarShort()
		this.effects = []
		const countEffects = reader.readShort()
		for (let i: number = 0; i < countEffects; i++) {
			const effectsTypeId: number = reader.readShort()
			const type: ObjectEffect = new types[effectsTypeId]() as ObjectEffect
			type.deserialize(reader)
			this.effects.push(type)
		}
		this.objectUID = reader.readVarInt()
		this.quantity = reader.readVarInt()
		this.objectPrice = reader.readVarLong()
	}

	public hydrate(
		data: ObjectItemToSell | Record<string, any>
	): ObjectItemToSell {
		if (data instanceof ObjectItemToSell) {
			return data
		}

		this.objectGID = data.objectGID
		this.effects = data.effects.map(
			(dataElement: ObjectEffect | Record<string, any>): ObjectEffect => {
				if (dataElement instanceof ObjectEffect) {
					return dataElement
				} else {
					return (new types[dataElement.id]() as ObjectEffect).hydrate(
						dataElement
					)
				}
			}
		)
		this.objectUID = data.objectUID
		this.quantity = data.quantity
		this.objectPrice = data.objectPrice

		return this
	}
}

export interface RawTaxCollectorFightersInformation {
	id: number
	collectorId: number
	allyCharactersInformations: CharacterMinimalPlusLookInformations[]
	enemyCharactersInformations: CharacterMinimalPlusLookInformations[]
}

export class TaxCollectorFightersInformation extends DofusType {
	public static id: number = 2594

	public collectorId: number | undefined = 0
	public allyCharactersInformations:
		| CharacterMinimalPlusLookInformations[]
		| undefined
	public enemyCharactersInformations:
		| CharacterMinimalPlusLookInformations[]
		| undefined

	public constructor(
		collectorId?: number | undefined,
		allyCharactersInformations?:
			| CharacterMinimalPlusLookInformations[]
			| undefined,
		enemyCharactersInformations?:
			| CharacterMinimalPlusLookInformations[]
			| undefined
	) {
		super()
		this.collectorId = collectorId
		this.allyCharactersInformations = allyCharactersInformations
		this.enemyCharactersInformations = enemyCharactersInformations
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeDouble(this.collectorId!)
		writer.writeShort(this.allyCharactersInformations!.length)
		this.allyCharactersInformations!.forEach((current) => {
			writer.writeShort(current.id)
			current.serialize(writer)
		})
		writer.writeShort(this.enemyCharactersInformations!.length)
		this.enemyCharactersInformations!.forEach((current) => {
			writer.writeShort(current.id)
			current.serialize(writer)
		})
	}

	public deserialize(reader: BinaryReader): void {
		this.collectorId = reader.readDouble()
		this.allyCharactersInformations = []
		const countAllyCharactersInformations = reader.readShort()
		for (let i: number = 0; i < countAllyCharactersInformations; i++) {
			const allyCharactersInformationsTypeId: number = reader.readShort()
			const type: CharacterMinimalPlusLookInformations = new types[
				allyCharactersInformationsTypeId
			]() as CharacterMinimalPlusLookInformations
			type.deserialize(reader)
			this.allyCharactersInformations.push(type)
		}
		this.enemyCharactersInformations = []
		const countEnemyCharactersInformations = reader.readShort()
		for (let i: number = 0; i < countEnemyCharactersInformations; i++) {
			const enemyCharactersInformationsTypeId: number = reader.readShort()
			const type: CharacterMinimalPlusLookInformations = new types[
				enemyCharactersInformationsTypeId
			]() as CharacterMinimalPlusLookInformations
			type.deserialize(reader)
			this.enemyCharactersInformations.push(type)
		}
	}

	public hydrate(
		data: TaxCollectorFightersInformation | Record<string, any>
	): TaxCollectorFightersInformation {
		if (data instanceof TaxCollectorFightersInformation) {
			return data
		}

		this.collectorId = data.collectorId
		this.allyCharactersInformations = data.allyCharactersInformations.map(
			(
				dataElement: CharacterMinimalPlusLookInformations | Record<string, any>
			): CharacterMinimalPlusLookInformations => {
				if (dataElement instanceof CharacterMinimalPlusLookInformations) {
					return dataElement
				} else {
					return (new types[
						dataElement.id
					]() as CharacterMinimalPlusLookInformations).hydrate(dataElement)
				}
			}
		)
		this.enemyCharactersInformations = data.enemyCharactersInformations.map(
			(
				dataElement: CharacterMinimalPlusLookInformations | Record<string, any>
			): CharacterMinimalPlusLookInformations => {
				if (dataElement instanceof CharacterMinimalPlusLookInformations) {
					return dataElement
				} else {
					return (new types[
						dataElement.id
					]() as CharacterMinimalPlusLookInformations).hydrate(dataElement)
				}
			}
		)

		return this
	}
}

export interface RawTeleportDestination {
	id: number
	type: number
	mapId: number
	subAreaId: number
	level: number
	cost: number
}

export class TeleportDestination extends DofusType {
	public static id: number = 6506

	public type: number | undefined = 0
	public mapId: number | undefined = 0
	public subAreaId: number | undefined = 0
	public level: number | undefined = 0
	public cost: number | undefined = 0

	public constructor(
		type?: number | undefined,
		mapId?: number | undefined,
		subAreaId?: number | undefined,
		level?: number | undefined,
		cost?: number | undefined
	) {
		super()
		this.type = type
		this.mapId = mapId
		this.subAreaId = subAreaId
		this.level = level
		this.cost = cost
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeByte(this.type!)
		writer.writeDouble(this.mapId!)
		writer.writeVarShort(this.subAreaId!)
		writer.writeVarShort(this.level!)
		writer.writeVarShort(this.cost!)
	}

	public deserialize(reader: BinaryReader): void {
		this.type = reader.readByte()
		this.mapId = reader.readDouble()
		this.subAreaId = reader.readVarShort()
		this.level = reader.readVarShort()
		this.cost = reader.readVarShort()
	}

	public hydrate(
		data: TeleportDestination | Record<string, any>
	): TeleportDestination {
		if (data instanceof TeleportDestination) {
			return data
		}

		this.type = data.type
		this.mapId = data.mapId
		this.subAreaId = data.subAreaId
		this.level = data.level
		this.cost = data.cost

		return this
	}
}

export interface RawMonsterBoosts {
	id: number
	id_: number
	xpBoost: number
	dropBoost: number
}

export class MonsterBoosts extends DofusType {
	public static id: number = 4497

	public id_: number | undefined = 0
	public xpBoost: number | undefined = 0
	public dropBoost: number | undefined = 0

	public constructor(
		id_?: number | undefined,
		xpBoost?: number | undefined,
		dropBoost?: number | undefined
	) {
		super()
		this.id_ = id_
		this.xpBoost = xpBoost
		this.dropBoost = dropBoost
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarInt(this.id_!)
		writer.writeVarShort(this.xpBoost!)
		writer.writeVarShort(this.dropBoost!)
	}

	public deserialize(reader: BinaryReader): void {
		this.id_ = reader.readVarInt()
		this.xpBoost = reader.readVarShort()
		this.dropBoost = reader.readVarShort()
	}

	public hydrate(data: MonsterBoosts | Record<string, any>): MonsterBoosts {
		if (data instanceof MonsterBoosts) {
			return data
		}

		this.id_ = data.id_
		this.xpBoost = data.xpBoost
		this.dropBoost = data.dropBoost

		return this
	}
}

export interface RawDecraftedItemStackInfo {
	id: number
	objectUID: number
	bonusMin: number
	bonusMax: number
	runesId: number[]
	runesQty: number[]
}

export class DecraftedItemStackInfo extends DofusType {
	public static id: number = 3237

	public objectUID: number | undefined = 0
	public bonusMin: number | undefined = 0
	public bonusMax: number | undefined = 0
	public runesId: number[] | undefined
	public runesQty: number[] | undefined

	public constructor(
		objectUID?: number | undefined,
		bonusMin?: number | undefined,
		bonusMax?: number | undefined,
		runesId?: number[] | undefined,
		runesQty?: number[] | undefined
	) {
		super()
		this.objectUID = objectUID
		this.bonusMin = bonusMin
		this.bonusMax = bonusMax
		this.runesId = runesId
		this.runesQty = runesQty
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarInt(this.objectUID!)
		writer.writeFloat(this.bonusMin!)
		writer.writeFloat(this.bonusMax!)
		writer.writeShort(this.runesId!.length)
		this.runesId!.forEach((current: number) => writer.writeVarShort(current))
		writer.writeShort(this.runesQty!.length)
		this.runesQty!.forEach((current: number) => writer.writeVarInt(current))
	}

	public deserialize(reader: BinaryReader): void {
		this.objectUID = reader.readVarInt()
		this.bonusMin = reader.readFloat()
		this.bonusMax = reader.readFloat()
		this.runesId = []
		const countRunesId = reader.readShort()
		for (let i: number = 0; i < countRunesId; i++) {
			this.runesId.push(reader.readVarShort())
		}
		this.runesQty = []
		const countRunesQty = reader.readShort()
		for (let i: number = 0; i < countRunesQty; i++) {
			this.runesQty.push(reader.readVarInt())
		}
	}

	public hydrate(
		data: DecraftedItemStackInfo | Record<string, any>
	): DecraftedItemStackInfo {
		if (data instanceof DecraftedItemStackInfo) {
			return data
		}

		this.objectUID = data.objectUID
		this.bonusMin = data.bonusMin
		this.bonusMax = data.bonusMax
		this.runesId = data.runesId
		this.runesQty = data.runesQty

		return this
	}
}

export interface RawTaxCollectorBasicInformations {
	id: number
	firstNameId: number
	lastNameId: number
	worldX: number
	worldY: number
	mapId: number
	subAreaId: number
}

export class TaxCollectorBasicInformations extends DofusType {
	public static id: number = 7137

	public firstNameId: number | undefined = 0
	public lastNameId: number | undefined = 0
	public worldX: number | undefined = 0
	public worldY: number | undefined = 0
	public mapId: number | undefined = 0
	public subAreaId: number | undefined = 0

	public constructor(
		firstNameId?: number | undefined,
		lastNameId?: number | undefined,
		worldX?: number | undefined,
		worldY?: number | undefined,
		mapId?: number | undefined,
		subAreaId?: number | undefined
	) {
		super()
		this.firstNameId = firstNameId
		this.lastNameId = lastNameId
		this.worldX = worldX
		this.worldY = worldY
		this.mapId = mapId
		this.subAreaId = subAreaId
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarShort(this.firstNameId!)
		writer.writeVarShort(this.lastNameId!)
		writer.writeShort(this.worldX!)
		writer.writeShort(this.worldY!)
		writer.writeDouble(this.mapId!)
		writer.writeVarShort(this.subAreaId!)
	}

	public deserialize(reader: BinaryReader): void {
		this.firstNameId = reader.readVarShort()
		this.lastNameId = reader.readVarShort()
		this.worldX = reader.readShort()
		this.worldY = reader.readShort()
		this.mapId = reader.readDouble()
		this.subAreaId = reader.readVarShort()
	}

	public hydrate(
		data: TaxCollectorBasicInformations | Record<string, any>
	): TaxCollectorBasicInformations {
		if (data instanceof TaxCollectorBasicInformations) {
			return data
		}

		this.firstNameId = data.firstNameId
		this.lastNameId = data.lastNameId
		this.worldX = data.worldX
		this.worldY = data.worldY
		this.mapId = data.mapId
		this.subAreaId = data.subAreaId

		return this
	}
}

export interface RawPartyMemberGeoPosition {
	id: number
	memberId: number
	worldX: number
	worldY: number
	mapId: number
	subAreaId: number
}

export class PartyMemberGeoPosition extends DofusType {
	public static id: number = 6428

	public memberId: number | undefined = 0
	public worldX: number | undefined = 0
	public worldY: number | undefined = 0
	public mapId: number | undefined = 0
	public subAreaId: number | undefined = 0

	public constructor(
		memberId?: number | undefined,
		worldX?: number | undefined,
		worldY?: number | undefined,
		mapId?: number | undefined,
		subAreaId?: number | undefined
	) {
		super()
		this.memberId = memberId
		this.worldX = worldX
		this.worldY = worldY
		this.mapId = mapId
		this.subAreaId = subAreaId
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeInt(this.memberId!)
		writer.writeShort(this.worldX!)
		writer.writeShort(this.worldY!)
		writer.writeDouble(this.mapId!)
		writer.writeVarShort(this.subAreaId!)
	}

	public deserialize(reader: BinaryReader): void {
		this.memberId = reader.readInt()
		this.worldX = reader.readShort()
		this.worldY = reader.readShort()
		this.mapId = reader.readDouble()
		this.subAreaId = reader.readVarShort()
	}

	public hydrate(
		data: PartyMemberGeoPosition | Record<string, any>
	): PartyMemberGeoPosition {
		if (data instanceof PartyMemberGeoPosition) {
			return data
		}

		this.memberId = data.memberId
		this.worldX = data.worldX
		this.worldY = data.worldY
		this.mapId = data.mapId
		this.subAreaId = data.subAreaId

		return this
	}
}

export interface RawObjectItemToSellInNpcShop
	extends RawObjectItemMinimalInformation {
	id: number
	objectPrice: number
	buyCriterion: string
}

export class ObjectItemToSellInNpcShop extends ObjectItemMinimalInformation {
	public static id: number = 2852

	public objectPrice: number | undefined = 0
	public buyCriterion: string | undefined

	public constructor(
		objectGID?: number | undefined,
		effects?: ObjectEffect[] | undefined,
		objectPrice?: number | undefined,
		buyCriterion?: string | undefined
	) {
		super(objectGID, effects)
		this.objectPrice = objectPrice
		this.buyCriterion = buyCriterion
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeVarLong(this.objectPrice!)
		writer.writeUTF(this.buyCriterion!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.objectPrice = reader.readVarLong()
		this.buyCriterion = reader.readUTF()
	}

	public hydrate(
		data: ObjectItemToSellInNpcShop | Record<string, any>
	): ObjectItemToSellInNpcShop {
		if (data instanceof ObjectItemToSellInNpcShop) {
			return data
		}

		super.hydrate(data)

		this.objectPrice = data.objectPrice
		this.buyCriterion = data.buyCriterion

		return this
	}
}

export interface RawObjectItemToSellInBid extends RawObjectItemToSell {
	id: number
	unsoldDelay: number
}

export class ObjectItemToSellInBid extends ObjectItemToSell {
	public static id: number = 4082

	public unsoldDelay: number | undefined = 0

	public constructor(
		objectGID?: number | undefined,
		effects?: ObjectEffect[] | undefined,
		objectUID?: number | undefined,
		quantity?: number | undefined,
		objectPrice?: number | undefined,
		unsoldDelay?: number | undefined
	) {
		super(objectGID, effects, objectUID, quantity, objectPrice)
		this.unsoldDelay = unsoldDelay
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeInt(this.unsoldDelay!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.unsoldDelay = reader.readInt()
	}

	public hydrate(
		data: ObjectItemToSellInBid | Record<string, any>
	): ObjectItemToSellInBid {
		if (data instanceof ObjectItemToSellInBid) {
			return data
		}

		super.hydrate(data)

		this.unsoldDelay = data.unsoldDelay

		return this
	}
}

export interface RawSellerBuyerDescriptor {
	id: number
	quantities: number[]
	types: number[]
	taxPercentage: number
	taxModificationPercentage: number
	maxItemLevel: number
	maxItemPerAccount: number
	npcContextualId: number
	unsoldDelay: number
}

export class SellerBuyerDescriptor extends DofusType {
	public static id: number = 7048

	public quantities: number[] | undefined
	public types: number[] | undefined
	public taxPercentage: number | undefined = 0
	public taxModificationPercentage: number | undefined = 0
	public maxItemLevel: number | undefined = 0
	public maxItemPerAccount: number | undefined = 0
	public npcContextualId: number | undefined = 0
	public unsoldDelay: number | undefined = 0

	public constructor(
		quantities?: number[] | undefined,
		types?: number[] | undefined,
		taxPercentage?: number | undefined,
		taxModificationPercentage?: number | undefined,
		maxItemLevel?: number | undefined,
		maxItemPerAccount?: number | undefined,
		npcContextualId?: number | undefined,
		unsoldDelay?: number | undefined
	) {
		super()
		this.quantities = quantities
		this.types = types
		this.taxPercentage = taxPercentage
		this.taxModificationPercentage = taxModificationPercentage
		this.maxItemLevel = maxItemLevel
		this.maxItemPerAccount = maxItemPerAccount
		this.npcContextualId = npcContextualId
		this.unsoldDelay = unsoldDelay
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeShort(this.quantities!.length)
		this.quantities!.forEach((current: number) => writer.writeVarInt(current))
		writer.writeShort(this.types!.length)
		this.types!.forEach((current: number) => writer.writeVarInt(current))
		writer.writeFloat(this.taxPercentage!)
		writer.writeFloat(this.taxModificationPercentage!)
		writer.writeByte(this.maxItemLevel!)
		writer.writeVarInt(this.maxItemPerAccount!)
		writer.writeInt(this.npcContextualId!)
		writer.writeVarShort(this.unsoldDelay!)
	}

	public deserialize(reader: BinaryReader): void {
		this.quantities = []
		const countQuantities = reader.readShort()
		for (let i: number = 0; i < countQuantities; i++) {
			this.quantities.push(reader.readVarInt())
		}
		this.types = []
		const countTypes = reader.readShort()
		for (let i: number = 0; i < countTypes; i++) {
			this.types.push(reader.readVarInt())
		}
		this.taxPercentage = reader.readFloat()
		this.taxModificationPercentage = reader.readFloat()
		this.maxItemLevel = reader.readByte()
		this.maxItemPerAccount = reader.readVarInt()
		this.npcContextualId = reader.readInt()
		this.unsoldDelay = reader.readVarShort()
	}

	public hydrate(
		data: SellerBuyerDescriptor | Record<string, any>
	): SellerBuyerDescriptor {
		if (data instanceof SellerBuyerDescriptor) {
			return data
		}

		this.quantities = data.quantities
		this.types = data.types
		this.taxPercentage = data.taxPercentage
		this.taxModificationPercentage = data.taxModificationPercentage
		this.maxItemLevel = data.maxItemLevel
		this.maxItemPerAccount = data.maxItemPerAccount
		this.npcContextualId = data.npcContextualId
		this.unsoldDelay = data.unsoldDelay

		return this
	}
}

export interface RawJobCrafterDirectoryEntryPlayerInfo {
	id: number
	playerId: number
	playerName: string
	alignmentSide: number
	breed: number
	sex: boolean
	isInWorkshop: boolean
	worldX: number
	worldY: number
	mapId: number
	subAreaId: number
	canCraftLegendary: boolean
	status: PlayerStatus
}

export class JobCrafterDirectoryEntryPlayerInfo extends DofusType {
	public static id: number = 8534

	public playerId: number | undefined = 0
	public playerName: string | undefined
	public alignmentSide: number | undefined = 0
	public breed: number | undefined = 0
	public sex: boolean | undefined = false
	public isInWorkshop: boolean | undefined = false
	public worldX: number | undefined = 0
	public worldY: number | undefined = 0
	public mapId: number | undefined = 0
	public subAreaId: number | undefined = 0
	public canCraftLegendary: boolean | undefined = false
	public status: PlayerStatus | undefined

	public constructor(
		playerId?: number | undefined,
		playerName?: string | undefined,
		alignmentSide?: number | undefined,
		breed?: number | undefined,
		sex?: boolean | undefined,
		isInWorkshop?: boolean | undefined,
		worldX?: number | undefined,
		worldY?: number | undefined,
		mapId?: number | undefined,
		subAreaId?: number | undefined,
		canCraftLegendary?: boolean | undefined,
		status?: PlayerStatus | undefined
	) {
		super()
		this.playerId = playerId
		this.playerName = playerName
		this.alignmentSide = alignmentSide
		this.breed = breed
		this.sex = sex
		this.isInWorkshop = isInWorkshop
		this.worldX = worldX
		this.worldY = worldY
		this.mapId = mapId
		this.subAreaId = subAreaId
		this.canCraftLegendary = canCraftLegendary
		this.status = status
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarLong(this.playerId!)
		writer.writeUTF(this.playerName!)
		writer.writeByte(this.alignmentSide!)
		writer.writeByte(this.breed!)
		writer.writeBoolean(this.sex!)
		writer.writeBoolean(this.isInWorkshop!)
		writer.writeShort(this.worldX!)
		writer.writeShort(this.worldY!)
		writer.writeDouble(this.mapId!)
		writer.writeVarShort(this.subAreaId!)
		writer.writeBoolean(this.canCraftLegendary!)
		writer.writeShort(this.status!.id)
		this.status!.serialize(writer)
	}

	public deserialize(reader: BinaryReader): void {
		this.playerId = reader.readVarLong()
		this.playerName = reader.readUTF()
		this.alignmentSide = reader.readByte()
		this.breed = reader.readByte()
		this.sex = reader.readBoolean()
		this.isInWorkshop = reader.readBoolean()
		this.worldX = reader.readShort()
		this.worldY = reader.readShort()
		this.mapId = reader.readDouble()
		this.subAreaId = reader.readVarShort()
		this.canCraftLegendary = reader.readBoolean()
		const statusTypeId: number = reader.readShort()
		this.status = new types[statusTypeId]() as PlayerStatus
		this.status!.deserialize(reader)
	}

	public hydrate(
		data: JobCrafterDirectoryEntryPlayerInfo | Record<string, any>
	): JobCrafterDirectoryEntryPlayerInfo {
		if (data instanceof JobCrafterDirectoryEntryPlayerInfo) {
			return data
		}

		this.playerId = data.playerId
		this.playerName = data.playerName
		this.alignmentSide = data.alignmentSide
		this.breed = data.breed
		this.sex = data.sex
		this.isInWorkshop = data.isInWorkshop
		this.worldX = data.worldX
		this.worldY = data.worldY
		this.mapId = data.mapId
		this.subAreaId = data.subAreaId
		this.canCraftLegendary = data.canCraftLegendary
		this.status = (new types[data.status.id]() as PlayerStatus).hydrate(
			data.status
		)
		return this
	}
}

export interface RawJobCrafterDirectoryEntryJobInfo {
	id: number
	jobId: number
	jobLevel: number
	free: boolean
	minLevel: number
}

export class JobCrafterDirectoryEntryJobInfo extends DofusType {
	public static id: number = 3458

	public jobId: number | undefined = 0
	public jobLevel: number | undefined = 0
	public free: boolean | undefined = false
	public minLevel: number | undefined = 0

	public constructor(
		jobId?: number | undefined,
		jobLevel?: number | undefined,
		free?: boolean | undefined,
		minLevel?: number | undefined
	) {
		super()
		this.jobId = jobId
		this.jobLevel = jobLevel
		this.free = free
		this.minLevel = minLevel
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeByte(this.jobId!)
		writer.writeByte(this.jobLevel!)
		writer.writeBoolean(this.free!)
		writer.writeByte(this.minLevel!)
	}

	public deserialize(reader: BinaryReader): void {
		this.jobId = reader.readByte()
		this.jobLevel = reader.readByte()
		this.free = reader.readBoolean()
		this.minLevel = reader.readByte()
	}

	public hydrate(
		data: JobCrafterDirectoryEntryJobInfo | Record<string, any>
	): JobCrafterDirectoryEntryJobInfo {
		if (data instanceof JobCrafterDirectoryEntryJobInfo) {
			return data
		}

		this.jobId = data.jobId
		this.jobLevel = data.jobLevel
		this.free = data.free
		this.minLevel = data.minLevel

		return this
	}
}

export interface RawJobCrafterDirectoryListEntry {
	id: number
	playerInfo: JobCrafterDirectoryEntryPlayerInfo
	jobInfo: JobCrafterDirectoryEntryJobInfo
}

export class JobCrafterDirectoryListEntry extends DofusType {
	public static id: number = 1757

	public playerInfo: JobCrafterDirectoryEntryPlayerInfo | undefined
	public jobInfo: JobCrafterDirectoryEntryJobInfo | undefined

	public constructor(
		playerInfo?: JobCrafterDirectoryEntryPlayerInfo | undefined,
		jobInfo?: JobCrafterDirectoryEntryJobInfo | undefined
	) {
		super()
		this.playerInfo = playerInfo
		this.jobInfo = jobInfo
	}

	public serialize(writer: BinaryWriter): void {
		this.playerInfo!.serialize(writer)
		this.jobInfo!.serialize(writer)
	}

	public deserialize(reader: BinaryReader): void {
		this.playerInfo = new JobCrafterDirectoryEntryPlayerInfo()
		this.playerInfo!.deserialize(reader)
		this.jobInfo = new JobCrafterDirectoryEntryJobInfo()
		this.jobInfo!.deserialize(reader)
	}

	public hydrate(
		data: JobCrafterDirectoryListEntry | Record<string, any>
	): JobCrafterDirectoryListEntry {
		if (data instanceof JobCrafterDirectoryListEntry) {
			return data
		}

		this.playerInfo = new JobCrafterDirectoryEntryPlayerInfo().hydrate(
			data.playerInfo
		)
		this.jobInfo = new JobCrafterDirectoryEntryJobInfo().hydrate(data.jobInfo)

		return this
	}
}

export interface RawFightExternalInformations {
	id: number
	fightId: number
	fightType: number
	fightStart: number
	fightSpectatorLocked: boolean
	fightTeams: FightTeamLightInformations[]
	fightTeamsOptions: FightOptionsInformations[]
}

export class FightExternalInformations extends DofusType {
	public static id: number = 1397

	public fightId: number | undefined = 0
	public fightType: number | undefined = 0
	public fightStart: number | undefined = 0
	public fightSpectatorLocked: boolean | undefined = false
	public fightTeams: FightTeamLightInformations[] | undefined
	public fightTeamsOptions: FightOptionsInformations[] | undefined

	public constructor(
		fightId?: number | undefined,
		fightType?: number | undefined,
		fightStart?: number | undefined,
		fightSpectatorLocked?: boolean | undefined,
		fightTeams?: FightTeamLightInformations[] | undefined,
		fightTeamsOptions?: FightOptionsInformations[] | undefined
	) {
		super()
		this.fightId = fightId
		this.fightType = fightType
		this.fightStart = fightStart
		this.fightSpectatorLocked = fightSpectatorLocked
		this.fightTeams = fightTeams
		this.fightTeamsOptions = fightTeamsOptions
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarShort(this.fightId!)
		writer.writeByte(this.fightType!)
		writer.writeInt(this.fightStart!)
		writer.writeBoolean(this.fightSpectatorLocked!)
		this.fightTeams!.forEach((current) => {
			current.serialize(writer)
		})
		this.fightTeamsOptions!.forEach((current) => {
			current.serialize(writer)
		})
	}

	public deserialize(reader: BinaryReader): void {
		this.fightId = reader.readVarShort()
		this.fightType = reader.readByte()
		this.fightStart = reader.readInt()
		this.fightSpectatorLocked = reader.readBoolean()
		this.fightTeams = []
		for (let i: number = 0; i < 2; i++) {
			const type: FightTeamLightInformations = new FightTeamLightInformations()
			type.deserialize(reader)
			this.fightTeams.push(type)
		}
		this.fightTeamsOptions = []
		for (let i: number = 0; i < 2; i++) {
			const type: FightOptionsInformations = new FightOptionsInformations()
			type.deserialize(reader)
			this.fightTeamsOptions.push(type)
		}
	}

	public hydrate(
		data: FightExternalInformations | Record<string, any>
	): FightExternalInformations {
		if (data instanceof FightExternalInformations) {
			return data
		}

		this.fightId = data.fightId
		this.fightType = data.fightType
		this.fightStart = data.fightStart
		this.fightSpectatorLocked = data.fightSpectatorLocked
		this.fightTeams = data.fightTeams.map(
			(
				dataElement: FightTeamLightInformations | Record<string, any>
			): FightTeamLightInformations => {
				if (dataElement instanceof FightTeamLightInformations) {
					return dataElement
				} else {
					return new FightTeamLightInformations().hydrate(dataElement)
				}
			}
		)
		this.fightTeamsOptions = data.fightTeamsOptions.map(
			(
				dataElement: FightOptionsInformations | Record<string, any>
			): FightOptionsInformations => {
				if (dataElement instanceof FightOptionsInformations) {
					return dataElement
				} else {
					return new FightOptionsInformations().hydrate(dataElement)
				}
			}
		)

		return this
	}
}

export interface RawJobCrafterDirectorySettings {
	id: number
	jobId: number
	minLevel: number
	free: boolean
}

export class JobCrafterDirectorySettings extends DofusType {
	public static id: number = 4792

	public jobId: number | undefined = 0
	public minLevel: number | undefined = 0
	public free: boolean | undefined = false

	public constructor(
		jobId?: number | undefined,
		minLevel?: number | undefined,
		free?: boolean | undefined
	) {
		super()
		this.jobId = jobId
		this.minLevel = minLevel
		this.free = free
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeByte(this.jobId!)
		writer.writeByte(this.minLevel!)
		writer.writeBoolean(this.free!)
	}

	public deserialize(reader: BinaryReader): void {
		this.jobId = reader.readByte()
		this.minLevel = reader.readByte()
		this.free = reader.readBoolean()
	}

	public hydrate(
		data: JobCrafterDirectorySettings | Record<string, any>
	): JobCrafterDirectorySettings {
		if (data instanceof JobCrafterDirectorySettings) {
			return data
		}

		this.jobId = data.jobId
		this.minLevel = data.minLevel
		this.free = data.free

		return this
	}
}

export interface RawArenaRankInfos {
	id: number
	ranking: ArenaRanking
	leagueRanking: ArenaLeagueRanking
	victoryCount: number
	fightcount: number
	numFightNeededForLadder: number
}

export class ArenaRankInfos extends DofusType {
	public static id: number = 7040

	public ranking: ArenaRanking | undefined
	public leagueRanking: ArenaLeagueRanking | undefined
	public victoryCount: number | undefined = 0
	public fightcount: number | undefined = 0
	public numFightNeededForLadder: number | undefined = 0

	public constructor(
		ranking?: ArenaRanking | undefined,
		leagueRanking?: ArenaLeagueRanking | undefined,
		victoryCount?: number | undefined,
		fightcount?: number | undefined,
		numFightNeededForLadder?: number | undefined
	) {
		super()
		this.ranking = ranking
		this.leagueRanking = leagueRanking
		this.victoryCount = victoryCount
		this.fightcount = fightcount
		this.numFightNeededForLadder = numFightNeededForLadder
	}

	public serialize(writer: BinaryWriter): void {
		this.ranking!.serialize(writer)
		this.leagueRanking!.serialize(writer)
		writer.writeVarShort(this.victoryCount!)
		writer.writeVarShort(this.fightcount!)
		writer.writeShort(this.numFightNeededForLadder!)
	}

	public deserialize(reader: BinaryReader): void {
		this.ranking = new ArenaRanking()
		this.ranking!.deserialize(reader)
		this.leagueRanking = new ArenaLeagueRanking()
		this.leagueRanking!.deserialize(reader)
		this.victoryCount = reader.readVarShort()
		this.fightcount = reader.readVarShort()
		this.numFightNeededForLadder = reader.readShort()
	}

	public hydrate(data: ArenaRankInfos | Record<string, any>): ArenaRankInfos {
		if (data instanceof ArenaRankInfos) {
			return data
		}

		this.ranking = new ArenaRanking().hydrate(data.ranking)
		this.leagueRanking = new ArenaLeagueRanking().hydrate(data.leagueRanking)
		this.victoryCount = data.victoryCount
		this.fightcount = data.fightcount
		this.numFightNeededForLadder = data.numFightNeededForLadder

		return this
	}
}

export interface RawJobExperience {
	id: number
	jobId: number
	jobLevel: number
	jobXP: number
	jobXpLevelFloor: number
	jobXpNextLevelFloor: number
}

export class JobExperience extends DofusType {
	public static id: number = 6401

	public jobId: number | undefined = 0
	public jobLevel: number | undefined = 0
	public jobXP: number | undefined = 0
	public jobXpLevelFloor: number | undefined = 0
	public jobXpNextLevelFloor: number | undefined = 0

	public constructor(
		jobId?: number | undefined,
		jobLevel?: number | undefined,
		jobXP?: number | undefined,
		jobXpLevelFloor?: number | undefined,
		jobXpNextLevelFloor?: number | undefined
	) {
		super()
		this.jobId = jobId
		this.jobLevel = jobLevel
		this.jobXP = jobXP
		this.jobXpLevelFloor = jobXpLevelFloor
		this.jobXpNextLevelFloor = jobXpNextLevelFloor
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeByte(this.jobId!)
		writer.writeByte(this.jobLevel!)
		writer.writeVarLong(this.jobXP!)
		writer.writeVarLong(this.jobXpLevelFloor!)
		writer.writeVarLong(this.jobXpNextLevelFloor!)
	}

	public deserialize(reader: BinaryReader): void {
		this.jobId = reader.readByte()
		this.jobLevel = reader.readByte()
		this.jobXP = reader.readVarLong()
		this.jobXpLevelFloor = reader.readVarLong()
		this.jobXpNextLevelFloor = reader.readVarLong()
	}

	public hydrate(data: JobExperience | Record<string, any>): JobExperience {
		if (data instanceof JobExperience) {
			return data
		}

		this.jobId = data.jobId
		this.jobLevel = data.jobLevel
		this.jobXP = data.jobXP
		this.jobXpLevelFloor = data.jobXpLevelFloor
		this.jobXpNextLevelFloor = data.jobXpNextLevelFloor

		return this
	}
}

export interface RawAllianceVersatileInformations {
	id: number
	allianceId: number
	nbGuilds: number
	nbMembers: number
	nbSubarea: number
}

export class AllianceVersatileInformations extends DofusType {
	public static id: number = 3013

	public allianceId: number | undefined = 0
	public nbGuilds: number | undefined = 0
	public nbMembers: number | undefined = 0
	public nbSubarea: number | undefined = 0

	public constructor(
		allianceId?: number | undefined,
		nbGuilds?: number | undefined,
		nbMembers?: number | undefined,
		nbSubarea?: number | undefined
	) {
		super()
		this.allianceId = allianceId
		this.nbGuilds = nbGuilds
		this.nbMembers = nbMembers
		this.nbSubarea = nbSubarea
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarInt(this.allianceId!)
		writer.writeVarShort(this.nbGuilds!)
		writer.writeVarShort(this.nbMembers!)
		writer.writeVarShort(this.nbSubarea!)
	}

	public deserialize(reader: BinaryReader): void {
		this.allianceId = reader.readVarInt()
		this.nbGuilds = reader.readVarShort()
		this.nbMembers = reader.readVarShort()
		this.nbSubarea = reader.readVarShort()
	}

	public hydrate(
		data: AllianceVersatileInformations | Record<string, any>
	): AllianceVersatileInformations {
		if (data instanceof AllianceVersatileInformations) {
			return data
		}

		this.allianceId = data.allianceId
		this.nbGuilds = data.nbGuilds
		this.nbMembers = data.nbMembers
		this.nbSubarea = data.nbSubarea

		return this
	}
}

export interface RawPrismFightersInformation {
	id: number
	subAreaId: number
	waitingForHelpInfo: ProtectedEntityWaitingForHelpInfo
	allyCharactersInformations: CharacterMinimalPlusLookInformations[]
	enemyCharactersInformations: CharacterMinimalPlusLookInformations[]
}

export class PrismFightersInformation extends DofusType {
	public static id: number = 4016

	public subAreaId: number | undefined = 0
	public waitingForHelpInfo: ProtectedEntityWaitingForHelpInfo | undefined
	public allyCharactersInformations:
		| CharacterMinimalPlusLookInformations[]
		| undefined
	public enemyCharactersInformations:
		| CharacterMinimalPlusLookInformations[]
		| undefined

	public constructor(
		subAreaId?: number | undefined,
		waitingForHelpInfo?: ProtectedEntityWaitingForHelpInfo | undefined,
		allyCharactersInformations?:
			| CharacterMinimalPlusLookInformations[]
			| undefined,
		enemyCharactersInformations?:
			| CharacterMinimalPlusLookInformations[]
			| undefined
	) {
		super()
		this.subAreaId = subAreaId
		this.waitingForHelpInfo = waitingForHelpInfo
		this.allyCharactersInformations = allyCharactersInformations
		this.enemyCharactersInformations = enemyCharactersInformations
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarShort(this.subAreaId!)
		this.waitingForHelpInfo!.serialize(writer)
		writer.writeShort(this.allyCharactersInformations!.length)
		this.allyCharactersInformations!.forEach((current) => {
			writer.writeShort(current.id)
			current.serialize(writer)
		})
		writer.writeShort(this.enemyCharactersInformations!.length)
		this.enemyCharactersInformations!.forEach((current) => {
			writer.writeShort(current.id)
			current.serialize(writer)
		})
	}

	public deserialize(reader: BinaryReader): void {
		this.subAreaId = reader.readVarShort()
		this.waitingForHelpInfo = new ProtectedEntityWaitingForHelpInfo()
		this.waitingForHelpInfo!.deserialize(reader)
		this.allyCharactersInformations = []
		const countAllyCharactersInformations = reader.readShort()
		for (let i: number = 0; i < countAllyCharactersInformations; i++) {
			const allyCharactersInformationsTypeId: number = reader.readShort()
			const type: CharacterMinimalPlusLookInformations = new types[
				allyCharactersInformationsTypeId
			]() as CharacterMinimalPlusLookInformations
			type.deserialize(reader)
			this.allyCharactersInformations.push(type)
		}
		this.enemyCharactersInformations = []
		const countEnemyCharactersInformations = reader.readShort()
		for (let i: number = 0; i < countEnemyCharactersInformations; i++) {
			const enemyCharactersInformationsTypeId: number = reader.readShort()
			const type: CharacterMinimalPlusLookInformations = new types[
				enemyCharactersInformationsTypeId
			]() as CharacterMinimalPlusLookInformations
			type.deserialize(reader)
			this.enemyCharactersInformations.push(type)
		}
	}

	public hydrate(
		data: PrismFightersInformation | Record<string, any>
	): PrismFightersInformation {
		if (data instanceof PrismFightersInformation) {
			return data
		}

		this.subAreaId = data.subAreaId
		this.waitingForHelpInfo = new ProtectedEntityWaitingForHelpInfo().hydrate(
			data.waitingForHelpInfo
		)
		this.allyCharactersInformations = data.allyCharactersInformations.map(
			(
				dataElement: CharacterMinimalPlusLookInformations | Record<string, any>
			): CharacterMinimalPlusLookInformations => {
				if (dataElement instanceof CharacterMinimalPlusLookInformations) {
					return dataElement
				} else {
					return (new types[
						dataElement.id
					]() as CharacterMinimalPlusLookInformations).hydrate(dataElement)
				}
			}
		)
		this.enemyCharactersInformations = data.enemyCharactersInformations.map(
			(
				dataElement: CharacterMinimalPlusLookInformations | Record<string, any>
			): CharacterMinimalPlusLookInformations => {
				if (dataElement instanceof CharacterMinimalPlusLookInformations) {
					return dataElement
				} else {
					return (new types[
						dataElement.id
					]() as CharacterMinimalPlusLookInformations).hydrate(dataElement)
				}
			}
		)

		return this
	}
}

export interface RawHavenBagFurnitureInformation {
	id: number
	cellId: number
	funitureId: number
	orientation: number
}

export class HavenBagFurnitureInformation extends DofusType {
	public static id: number = 6102

	public cellId: number | undefined = 0
	public funitureId: number | undefined = 0
	public orientation: number | undefined = 0

	public constructor(
		cellId?: number | undefined,
		funitureId?: number | undefined,
		orientation?: number | undefined
	) {
		super()
		this.cellId = cellId
		this.funitureId = funitureId
		this.orientation = orientation
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarShort(this.cellId!)
		writer.writeInt(this.funitureId!)
		writer.writeByte(this.orientation!)
	}

	public deserialize(reader: BinaryReader): void {
		this.cellId = reader.readVarShort()
		this.funitureId = reader.readInt()
		this.orientation = reader.readByte()
	}

	public hydrate(
		data: HavenBagFurnitureInformation | Record<string, any>
	): HavenBagFurnitureInformation {
		if (data instanceof HavenBagFurnitureInformation) {
			return data
		}

		this.cellId = data.cellId
		this.funitureId = data.funitureId
		this.orientation = data.orientation

		return this
	}
}

export interface RawBufferInformation {
	id: number
	id_: number
	amount: number
}

export class BufferInformation extends DofusType {
	public static id: number = 7482

	public id_: number | undefined = 0
	public amount: number | undefined = 0

	public constructor(id_?: number | undefined, amount?: number | undefined) {
		super()
		this.id_ = id_
		this.amount = amount
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarLong(this.id_!)
		writer.writeVarLong(this.amount!)
	}

	public deserialize(reader: BinaryReader): void {
		this.id_ = reader.readVarLong()
		this.amount = reader.readVarLong()
	}

	public hydrate(
		data: BufferInformation | Record<string, any>
	): BufferInformation {
		if (data instanceof BufferInformation) {
			return data
		}

		this.id_ = data.id_
		this.amount = data.amount

		return this
	}
}

export interface RawAnomalySubareaInformation {
	id: number
	subAreaId: number
	rewardRate: number
	hasAnomaly: boolean
	anomalyClosingTime: number
}

export class AnomalySubareaInformation extends DofusType {
	public static id: number = 9877

	public subAreaId: number | undefined = 0
	public rewardRate: number | undefined = 0
	public hasAnomaly: boolean | undefined = false
	public anomalyClosingTime: number | undefined = 0

	public constructor(
		subAreaId?: number | undefined,
		rewardRate?: number | undefined,
		hasAnomaly?: boolean | undefined,
		anomalyClosingTime?: number | undefined
	) {
		super()
		this.subAreaId = subAreaId
		this.rewardRate = rewardRate
		this.hasAnomaly = hasAnomaly
		this.anomalyClosingTime = anomalyClosingTime
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarShort(this.subAreaId!)
		writer.writeVarShort(this.rewardRate!)
		writer.writeBoolean(this.hasAnomaly!)
		writer.writeVarLong(this.anomalyClosingTime!)
	}

	public deserialize(reader: BinaryReader): void {
		this.subAreaId = reader.readVarShort()
		this.rewardRate = reader.readVarShort()
		this.hasAnomaly = reader.readBoolean()
		this.anomalyClosingTime = reader.readVarLong()
	}

	public hydrate(
		data: AnomalySubareaInformation | Record<string, any>
	): AnomalySubareaInformation {
		if (data instanceof AnomalySubareaInformation) {
			return data
		}

		this.subAreaId = data.subAreaId
		this.rewardRate = data.rewardRate
		this.hasAnomaly = data.hasAnomaly
		this.anomalyClosingTime = data.anomalyClosingTime

		return this
	}
}

export interface RawPaddockInformationsForSell {
	id: number
	guildOwner: string
	worldX: number
	worldY: number
	subAreaId: number
	nbMount: number
	nbObject: number
	price: number
}

export class PaddockInformationsForSell extends DofusType {
	public static id: number = 4946

	public guildOwner: string | undefined
	public worldX: number | undefined = 0
	public worldY: number | undefined = 0
	public subAreaId: number | undefined = 0
	public nbMount: number | undefined = 0
	public nbObject: number | undefined = 0
	public price: number | undefined = 0

	public constructor(
		guildOwner?: string | undefined,
		worldX?: number | undefined,
		worldY?: number | undefined,
		subAreaId?: number | undefined,
		nbMount?: number | undefined,
		nbObject?: number | undefined,
		price?: number | undefined
	) {
		super()
		this.guildOwner = guildOwner
		this.worldX = worldX
		this.worldY = worldY
		this.subAreaId = subAreaId
		this.nbMount = nbMount
		this.nbObject = nbObject
		this.price = price
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeUTF(this.guildOwner!)
		writer.writeShort(this.worldX!)
		writer.writeShort(this.worldY!)
		writer.writeVarShort(this.subAreaId!)
		writer.writeByte(this.nbMount!)
		writer.writeByte(this.nbObject!)
		writer.writeVarLong(this.price!)
	}

	public deserialize(reader: BinaryReader): void {
		this.guildOwner = reader.readUTF()
		this.worldX = reader.readShort()
		this.worldY = reader.readShort()
		this.subAreaId = reader.readVarShort()
		this.nbMount = reader.readByte()
		this.nbObject = reader.readByte()
		this.price = reader.readVarLong()
	}

	public hydrate(
		data: PaddockInformationsForSell | Record<string, any>
	): PaddockInformationsForSell {
		if (data instanceof PaddockInformationsForSell) {
			return data
		}

		this.guildOwner = data.guildOwner
		this.worldX = data.worldX
		this.worldY = data.worldY
		this.subAreaId = data.subAreaId
		this.nbMount = data.nbMount
		this.nbObject = data.nbObject
		this.price = data.price

		return this
	}
}

export interface RawCharacterMinimalGuildPublicInformations
	extends RawCharacterMinimalInformations {
	id: number
	rank: number
}

export class CharacterMinimalGuildPublicInformations extends CharacterMinimalInformations {
	public static id: number = 2887

	public rank: number | undefined = 0

	public constructor(
		id_?: number | undefined,
		name?: string | undefined,
		level?: number | undefined,
		rank?: number | undefined
	) {
		super(id_, name, level)
		this.rank = rank
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeVarInt(this.rank!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.rank = reader.readVarInt()
	}

	public hydrate(
		data: CharacterMinimalGuildPublicInformations | Record<string, any>
	): CharacterMinimalGuildPublicInformations {
		if (data instanceof CharacterMinimalGuildPublicInformations) {
			return data
		}

		super.hydrate(data)

		this.rank = data.rank

		return this
	}
}

export interface RawEntityInformation {
	id: number
	id_: number
	experience: number
	status: boolean
}

export class EntityInformation extends DofusType {
	public static id: number = 6556

	public id_: number | undefined = 0
	public experience: number | undefined = 0
	public status: boolean | undefined = false

	public constructor(
		id_?: number | undefined,
		experience?: number | undefined,
		status?: boolean | undefined
	) {
		super()
		this.id_ = id_
		this.experience = experience
		this.status = status
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarShort(this.id_!)
		writer.writeVarInt(this.experience!)
		writer.writeBoolean(this.status!)
	}

	public deserialize(reader: BinaryReader): void {
		this.id_ = reader.readVarShort()
		this.experience = reader.readVarInt()
		this.status = reader.readBoolean()
	}

	public hydrate(
		data: EntityInformation | Record<string, any>
	): EntityInformation {
		if (data instanceof EntityInformation) {
			return data
		}

		this.id_ = data.id_
		this.experience = data.experience
		this.status = data.status

		return this
	}
}

export interface RawAlignmentWarEffortInformation {
	id: number
	alignmentSide: number
	alignmentWarEffort: number
}

export class AlignmentWarEffortInformation extends DofusType {
	public static id: number = 2771

	public alignmentSide: number | undefined = 0
	public alignmentWarEffort: number | undefined = 0

	public constructor(
		alignmentSide?: number | undefined,
		alignmentWarEffort?: number | undefined
	) {
		super()
		this.alignmentSide = alignmentSide
		this.alignmentWarEffort = alignmentWarEffort
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeByte(this.alignmentSide!)
		writer.writeVarLong(this.alignmentWarEffort!)
	}

	public deserialize(reader: BinaryReader): void {
		this.alignmentSide = reader.readByte()
		this.alignmentWarEffort = reader.readVarLong()
	}

	public hydrate(
		data: AlignmentWarEffortInformation | Record<string, any>
	): AlignmentWarEffortInformation {
		if (data instanceof AlignmentWarEffortInformation) {
			return data
		}

		this.alignmentSide = data.alignmentSide
		this.alignmentWarEffort = data.alignmentWarEffort

		return this
	}
}

export interface RawRecycledItem {
	id: number
	id_: number
	qty: number
}

export class RecycledItem extends DofusType {
	public static id: number = 3630

	public id_: number | undefined = 0
	public qty: number | undefined = 0

	public constructor(id_?: number | undefined, qty?: number | undefined) {
		super()
		this.id_ = id_
		this.qty = qty
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarShort(this.id_!)
		writer.writeUInt(this.qty!)
	}

	public deserialize(reader: BinaryReader): void {
		this.id_ = reader.readVarShort()
		this.qty = reader.readUInt()
	}

	public hydrate(data: RecycledItem | Record<string, any>): RecycledItem {
		if (data instanceof RecycledItem) {
			return data
		}

		this.id_ = data.id_
		this.qty = data.qty

		return this
	}
}

export interface RawHouseInformationsForSell {
	id: number
	instanceId: number
	secondHand: boolean
	modelId: number
	ownerAccountId: number
	ownerName: string
	ownerCharacterName: string
	worldX: number
	worldY: number
	subAreaId: number
	nbRoom: number
	nbChest: number
	skillListIds: number[]
	isLocked: boolean
	price: number
}

export class HouseInformationsForSell extends DofusType {
	public static id: number = 8489

	public instanceId: number | undefined = 0
	public secondHand: boolean | undefined = false
	public modelId: number | undefined = 0
	public ownerAccountId: number | undefined = 0
	public ownerName: string | undefined
	public ownerCharacterName: string | undefined
	public worldX: number | undefined = 0
	public worldY: number | undefined = 0
	public subAreaId: number | undefined = 0
	public nbRoom: number | undefined = 0
	public nbChest: number | undefined = 0
	public skillListIds: number[] | undefined
	public isLocked: boolean | undefined = false
	public price: number | undefined = 0

	public constructor(
		instanceId?: number | undefined,
		secondHand?: boolean | undefined,
		modelId?: number | undefined,
		ownerAccountId?: number | undefined,
		ownerName?: string | undefined,
		ownerCharacterName?: string | undefined,
		worldX?: number | undefined,
		worldY?: number | undefined,
		subAreaId?: number | undefined,
		nbRoom?: number | undefined,
		nbChest?: number | undefined,
		skillListIds?: number[] | undefined,
		isLocked?: boolean | undefined,
		price?: number | undefined
	) {
		super()
		this.instanceId = instanceId
		this.secondHand = secondHand
		this.modelId = modelId
		this.ownerAccountId = ownerAccountId
		this.ownerName = ownerName
		this.ownerCharacterName = ownerCharacterName
		this.worldX = worldX
		this.worldY = worldY
		this.subAreaId = subAreaId
		this.nbRoom = nbRoom
		this.nbChest = nbChest
		this.skillListIds = skillListIds
		this.isLocked = isLocked
		this.price = price
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeInt(this.instanceId!)
		writer.writeBoolean(this.secondHand!)
		writer.writeVarInt(this.modelId!)
		writer.writeInt(this.ownerAccountId!)
		writer.writeUTF(this.ownerName!)
		writer.writeUTF(this.ownerCharacterName!)
		writer.writeShort(this.worldX!)
		writer.writeShort(this.worldY!)
		writer.writeVarShort(this.subAreaId!)
		writer.writeByte(this.nbRoom!)
		writer.writeByte(this.nbChest!)
		writer.writeShort(this.skillListIds!.length)
		this.skillListIds!.forEach((current: number) => writer.writeInt(current))
		writer.writeBoolean(this.isLocked!)
		writer.writeVarLong(this.price!)
	}

	public deserialize(reader: BinaryReader): void {
		this.instanceId = reader.readInt()
		this.secondHand = reader.readBoolean()
		this.modelId = reader.readVarInt()
		this.ownerAccountId = reader.readInt()
		this.ownerName = reader.readUTF()
		this.ownerCharacterName = reader.readUTF()
		this.worldX = reader.readShort()
		this.worldY = reader.readShort()
		this.subAreaId = reader.readVarShort()
		this.nbRoom = reader.readByte()
		this.nbChest = reader.readByte()
		this.skillListIds = []
		const countSkillListIds = reader.readShort()
		for (let i: number = 0; i < countSkillListIds; i++) {
			this.skillListIds.push(reader.readInt())
		}
		this.isLocked = reader.readBoolean()
		this.price = reader.readVarLong()
	}

	public hydrate(
		data: HouseInformationsForSell | Record<string, any>
	): HouseInformationsForSell {
		if (data instanceof HouseInformationsForSell) {
			return data
		}

		this.instanceId = data.instanceId
		this.secondHand = data.secondHand
		this.modelId = data.modelId
		this.ownerAccountId = data.ownerAccountId
		this.ownerName = data.ownerName
		this.ownerCharacterName = data.ownerCharacterName
		this.worldX = data.worldX
		this.worldY = data.worldY
		this.subAreaId = data.subAreaId
		this.nbRoom = data.nbRoom
		this.nbChest = data.nbChest
		this.skillListIds = data.skillListIds
		this.isLocked = data.isLocked
		this.price = data.price

		return this
	}
}

export interface RawJobBookSubscription {
	id: number
	jobId: number
	subscribed: boolean
}

export class JobBookSubscription extends DofusType {
	public static id: number = 8818

	public jobId: number | undefined = 0
	public subscribed: boolean | undefined = false

	public constructor(
		jobId?: number | undefined,
		subscribed?: boolean | undefined
	) {
		super()
		this.jobId = jobId
		this.subscribed = subscribed
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeByte(this.jobId!)
		writer.writeBoolean(this.subscribed!)
	}

	public deserialize(reader: BinaryReader): void {
		this.jobId = reader.readByte()
		this.subscribed = reader.readBoolean()
	}

	public hydrate(
		data: JobBookSubscription | Record<string, any>
	): JobBookSubscription {
		if (data instanceof JobBookSubscription) {
			return data
		}

		this.jobId = data.jobId
		this.subscribed = data.subscribed

		return this
	}
}

export interface RawGoldItem extends RawItem {
	id: number
	sum: number
}

export class GoldItem extends Item {
	public static id: number = 4296

	public sum: number | undefined = 0

	public constructor(sum?: number | undefined) {
		super()
		this.sum = sum
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeVarLong(this.sum!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.sum = reader.readVarLong()
	}

	public hydrate(data: GoldItem | Record<string, any>): GoldItem {
		if (data instanceof GoldItem) {
			return data
		}

		this.sum = data.sum

		return this
	}
}

export interface RawObjectItemToSellInHumanVendorShop extends RawItem {
	id: number
	objectGID: number
	effects: ObjectEffect[]
	objectUID: number
	quantity: number
	objectPrice: number
	publicPrice: number
}

export class ObjectItemToSellInHumanVendorShop extends Item {
	public static id: number = 8040

	public objectGID: number | undefined = 0
	public effects: ObjectEffect[] | undefined
	public objectUID: number | undefined = 0
	public quantity: number | undefined = 0
	public objectPrice: number | undefined = 0
	public publicPrice: number | undefined = 0

	public constructor(
		objectGID?: number | undefined,
		effects?: ObjectEffect[] | undefined,
		objectUID?: number | undefined,
		quantity?: number | undefined,
		objectPrice?: number | undefined,
		publicPrice?: number | undefined
	) {
		super()
		this.objectGID = objectGID
		this.effects = effects
		this.objectUID = objectUID
		this.quantity = quantity
		this.objectPrice = objectPrice
		this.publicPrice = publicPrice
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeVarShort(this.objectGID!)
		writer.writeShort(this.effects!.length)
		this.effects!.forEach((current) => {
			writer.writeShort(current.id)
			current.serialize(writer)
		})
		writer.writeVarInt(this.objectUID!)
		writer.writeVarInt(this.quantity!)
		writer.writeVarLong(this.objectPrice!)
		writer.writeVarLong(this.publicPrice!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.objectGID = reader.readVarShort()
		this.effects = []
		const countEffects = reader.readShort()
		for (let i: number = 0; i < countEffects; i++) {
			const effectsTypeId: number = reader.readShort()
			const type: ObjectEffect = new types[effectsTypeId]() as ObjectEffect
			type.deserialize(reader)
			this.effects.push(type)
		}
		this.objectUID = reader.readVarInt()
		this.quantity = reader.readVarInt()
		this.objectPrice = reader.readVarLong()
		this.publicPrice = reader.readVarLong()
	}

	public hydrate(
		data: ObjectItemToSellInHumanVendorShop | Record<string, any>
	): ObjectItemToSellInHumanVendorShop {
		if (data instanceof ObjectItemToSellInHumanVendorShop) {
			return data
		}

		this.objectGID = data.objectGID
		this.effects = data.effects.map(
			(dataElement: ObjectEffect | Record<string, any>): ObjectEffect => {
				if (dataElement instanceof ObjectEffect) {
					return dataElement
				} else {
					return (new types[dataElement.id]() as ObjectEffect).hydrate(
						dataElement
					)
				}
			}
		)
		this.objectUID = data.objectUID
		this.quantity = data.quantity
		this.objectPrice = data.objectPrice
		this.publicPrice = data.publicPrice

		return this
	}
}

export interface RawObjectItemQuantity extends RawItem {
	id: number
	objectUID: number
	quantity: number
}

export class ObjectItemQuantity extends Item {
	public static id: number = 3184

	public objectUID: number | undefined = 0
	public quantity: number | undefined = 0

	public constructor(
		objectUID?: number | undefined,
		quantity?: number | undefined
	) {
		super()
		this.objectUID = objectUID
		this.quantity = quantity
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeVarInt(this.objectUID!)
		writer.writeVarInt(this.quantity!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.objectUID = reader.readVarInt()
		this.quantity = reader.readVarInt()
	}

	public hydrate(
		data: ObjectItemQuantity | Record<string, any>
	): ObjectItemQuantity {
		if (data instanceof ObjectItemQuantity) {
			return data
		}

		this.objectUID = data.objectUID
		this.quantity = data.quantity

		return this
	}
}

export interface RawEntityMovementInformations {
	id: number
	id_: number
	steps: number[]
}

export class EntityMovementInformations extends DofusType {
	public static id: number = 8915

	public id_: number | undefined = 0
	public steps: number[] | undefined

	public constructor(id_?: number | undefined, steps?: number[] | undefined) {
		super()
		this.id_ = id_
		this.steps = steps
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeInt(this.id_!)
		writer.writeShort(this.steps!.length)
		this.steps!.forEach((current: number) => writer.writeByte(current))
	}

	public deserialize(reader: BinaryReader): void {
		this.id_ = reader.readInt()
		this.steps = []
		const countSteps = reader.readShort()
		for (let i: number = 0; i < countSteps; i++) {
			this.steps.push(reader.readByte())
		}
	}

	public hydrate(
		data: EntityMovementInformations | Record<string, any>
	): EntityMovementInformations {
		if (data instanceof EntityMovementInformations) {
			return data
		}

		this.id_ = data.id_
		this.steps = data.steps

		return this
	}
}

export interface RawBidExchangerObjectInfo {
	id: number
	objectUID: number
	objectGID: number
	objectType: number
	effects: ObjectEffect[]
	prices: number[]
}

export class BidExchangerObjectInfo extends DofusType {
	public static id: number = 9234

	public objectUID: number | undefined = 0
	public objectGID: number | undefined = 0
	public objectType: number | undefined = 0
	public effects: ObjectEffect[] | undefined
	public prices: number[] | undefined

	public constructor(
		objectUID?: number | undefined,
		objectGID?: number | undefined,
		objectType?: number | undefined,
		effects?: ObjectEffect[] | undefined,
		prices?: number[] | undefined
	) {
		super()
		this.objectUID = objectUID
		this.objectGID = objectGID
		this.objectType = objectType
		this.effects = effects
		this.prices = prices
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarInt(this.objectUID!)
		writer.writeVarShort(this.objectGID!)
		writer.writeInt(this.objectType!)
		writer.writeShort(this.effects!.length)
		this.effects!.forEach((current) => {
			writer.writeShort(current.id)
			current.serialize(writer)
		})
		writer.writeShort(this.prices!.length)
		this.prices!.forEach((current: number) => writer.writeVarLong(current))
	}

	public deserialize(reader: BinaryReader): void {
		this.objectUID = reader.readVarInt()
		this.objectGID = reader.readVarShort()
		this.objectType = reader.readInt()
		this.effects = []
		const countEffects = reader.readShort()
		for (let i: number = 0; i < countEffects; i++) {
			const effectsTypeId: number = reader.readShort()
			const type: ObjectEffect = new types[effectsTypeId]() as ObjectEffect
			type.deserialize(reader)
			this.effects.push(type)
		}
		this.prices = []
		const countPrices = reader.readShort()
		for (let i: number = 0; i < countPrices; i++) {
			this.prices.push(reader.readVarLong())
		}
	}

	public hydrate(
		data: BidExchangerObjectInfo | Record<string, any>
	): BidExchangerObjectInfo {
		if (data instanceof BidExchangerObjectInfo) {
			return data
		}

		this.objectUID = data.objectUID
		this.objectGID = data.objectGID
		this.objectType = data.objectType
		this.effects = data.effects.map(
			(dataElement: ObjectEffect | Record<string, any>): ObjectEffect => {
				if (dataElement instanceof ObjectEffect) {
					return dataElement
				} else {
					return (new types[dataElement.id]() as ObjectEffect).hydrate(
						dataElement
					)
				}
			}
		)
		this.prices = data.prices

		return this
	}
}

export interface RawLeagueFriendInformations
	extends RawAbstractContactInformations {
	id: number
	playerId: number
	playerName: string
	breed: number
	sex: boolean
	level: number
	leagueId: number
	totalLeaguePoints: number
	ladderPosition: number
}

export class LeagueFriendInformations extends AbstractContactInformations {
	public static id: number = 1189

	public playerId: number | undefined = 0
	public playerName: string | undefined
	public breed: number | undefined = 0
	public sex: boolean | undefined = false
	public level: number | undefined = 0
	public leagueId: number | undefined = 0
	public totalLeaguePoints: number | undefined = 0
	public ladderPosition: number | undefined = 0

	public constructor(
		accountId?: number | undefined,
		accountName?: string | undefined,
		playerId?: number | undefined,
		playerName?: string | undefined,
		breed?: number | undefined,
		sex?: boolean | undefined,
		level?: number | undefined,
		leagueId?: number | undefined,
		totalLeaguePoints?: number | undefined,
		ladderPosition?: number | undefined
	) {
		super(accountId, accountName)
		this.playerId = playerId
		this.playerName = playerName
		this.breed = breed
		this.sex = sex
		this.level = level
		this.leagueId = leagueId
		this.totalLeaguePoints = totalLeaguePoints
		this.ladderPosition = ladderPosition
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeVarLong(this.playerId!)
		writer.writeUTF(this.playerName!)
		writer.writeByte(this.breed!)
		writer.writeBoolean(this.sex!)
		writer.writeVarShort(this.level!)
		writer.writeVarShort(this.leagueId!)
		writer.writeVarShort(this.totalLeaguePoints!)
		writer.writeInt(this.ladderPosition!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.playerId = reader.readVarLong()
		this.playerName = reader.readUTF()
		this.breed = reader.readByte()
		this.sex = reader.readBoolean()
		this.level = reader.readVarShort()
		this.leagueId = reader.readVarShort()
		this.totalLeaguePoints = reader.readVarShort()
		this.ladderPosition = reader.readInt()
	}

	public hydrate(
		data: LeagueFriendInformations | Record<string, any>
	): LeagueFriendInformations {
		if (data instanceof LeagueFriendInformations) {
			return data
		}

		super.hydrate(data)

		this.playerId = data.playerId
		this.playerName = data.playerName
		this.breed = data.breed
		this.sex = data.sex
		this.level = data.level
		this.leagueId = data.leagueId
		this.totalLeaguePoints = data.totalLeaguePoints
		this.ladderPosition = data.ladderPosition

		return this
	}
}

export interface RawAtlasPointsInformations {
	id: number
	type: number
	coords: MapCoordinatesExtended[]
}

export class AtlasPointsInformations extends DofusType {
	public static id: number = 6171

	public type: number | undefined = 0
	public coords: MapCoordinatesExtended[] | undefined

	public constructor(
		type?: number | undefined,
		coords?: MapCoordinatesExtended[] | undefined
	) {
		super()
		this.type = type
		this.coords = coords
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeByte(this.type!)
		writer.writeShort(this.coords!.length)
		this.coords!.forEach((current) => {
			current.serialize(writer)
		})
	}

	public deserialize(reader: BinaryReader): void {
		this.type = reader.readByte()
		this.coords = []
		const countCoords = reader.readShort()
		for (let i: number = 0; i < countCoords; i++) {
			const type: MapCoordinatesExtended = new MapCoordinatesExtended()
			type.deserialize(reader)
			this.coords.push(type)
		}
	}

	public hydrate(
		data: AtlasPointsInformations | Record<string, any>
	): AtlasPointsInformations {
		if (data instanceof AtlasPointsInformations) {
			return data
		}

		this.type = data.type
		this.coords = data.coords.map(
			(
				dataElement: MapCoordinatesExtended | Record<string, any>
			): MapCoordinatesExtended => {
				if (dataElement instanceof MapCoordinatesExtended) {
					return dataElement
				} else {
					return new MapCoordinatesExtended().hydrate(dataElement)
				}
			}
		)

		return this
	}
}

export interface RawGuildEmblem {
	id: number
	symbolShape: number
	symbolColor: number
	backgroundShape: number
	backgroundColor: number
}

export class GuildEmblem extends DofusType {
	public static id: number = 6377

	public symbolShape: number | undefined = 0
	public symbolColor: number | undefined = 0
	public backgroundShape: number | undefined = 0
	public backgroundColor: number | undefined = 0

	public constructor(
		symbolShape?: number | undefined,
		symbolColor?: number | undefined,
		backgroundShape?: number | undefined,
		backgroundColor?: number | undefined
	) {
		super()
		this.symbolShape = symbolShape
		this.symbolColor = symbolColor
		this.backgroundShape = backgroundShape
		this.backgroundColor = backgroundColor
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarShort(this.symbolShape!)
		writer.writeInt(this.symbolColor!)
		writer.writeByte(this.backgroundShape!)
		writer.writeInt(this.backgroundColor!)
	}

	public deserialize(reader: BinaryReader): void {
		this.symbolShape = reader.readVarShort()
		this.symbolColor = reader.readInt()
		this.backgroundShape = reader.readByte()
		this.backgroundColor = reader.readInt()
	}

	public hydrate(data: GuildEmblem | Record<string, any>): GuildEmblem {
		if (data instanceof GuildEmblem) {
			return data
		}

		this.symbolShape = data.symbolShape
		this.symbolColor = data.symbolColor
		this.backgroundShape = data.backgroundShape
		this.backgroundColor = data.backgroundColor

		return this
	}
}

export interface RawAdditionalTaxCollectorInformations {
	id: number
	collectorCallerName: string
	date: number
}

export class AdditionalTaxCollectorInformations extends DofusType {
	public static id: number = 9191

	public collectorCallerName: string | undefined
	public date: number | undefined = 0

	public constructor(
		collectorCallerName?: string | undefined,
		date?: number | undefined
	) {
		super()
		this.collectorCallerName = collectorCallerName
		this.date = date
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeUTF(this.collectorCallerName!)
		writer.writeInt(this.date!)
	}

	public deserialize(reader: BinaryReader): void {
		this.collectorCallerName = reader.readUTF()
		this.date = reader.readInt()
	}

	public hydrate(
		data: AdditionalTaxCollectorInformations | Record<string, any>
	): AdditionalTaxCollectorInformations {
		if (data instanceof AdditionalTaxCollectorInformations) {
			return data
		}

		this.collectorCallerName = data.collectorCallerName
		this.date = data.date

		return this
	}
}

export interface RawProtectedEntityWaitingForHelpInfo {
	id: number
	timeLeftBeforeFight: number
	waitTimeForPlacement: number
	nbPositionForDefensors: number
}

export class ProtectedEntityWaitingForHelpInfo extends DofusType {
	public static id: number = 6130

	public timeLeftBeforeFight: number | undefined = 0
	public waitTimeForPlacement: number | undefined = 0
	public nbPositionForDefensors: number | undefined = 0

	public constructor(
		timeLeftBeforeFight?: number | undefined,
		waitTimeForPlacement?: number | undefined,
		nbPositionForDefensors?: number | undefined
	) {
		super()
		this.timeLeftBeforeFight = timeLeftBeforeFight
		this.waitTimeForPlacement = waitTimeForPlacement
		this.nbPositionForDefensors = nbPositionForDefensors
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeInt(this.timeLeftBeforeFight!)
		writer.writeInt(this.waitTimeForPlacement!)
		writer.writeByte(this.nbPositionForDefensors!)
	}

	public deserialize(reader: BinaryReader): void {
		this.timeLeftBeforeFight = reader.readInt()
		this.waitTimeForPlacement = reader.readInt()
		this.nbPositionForDefensors = reader.readByte()
	}

	public hydrate(
		data: ProtectedEntityWaitingForHelpInfo | Record<string, any>
	): ProtectedEntityWaitingForHelpInfo {
		if (data instanceof ProtectedEntityWaitingForHelpInfo) {
			return data
		}

		this.timeLeftBeforeFight = data.timeLeftBeforeFight
		this.waitTimeForPlacement = data.waitTimeForPlacement
		this.nbPositionForDefensors = data.nbPositionForDefensors

		return this
	}
}

export interface RawMountInformationsForPaddock {
	id: number
	modelId: number
	name: string
	ownerName: string
}

export class MountInformationsForPaddock extends DofusType {
	public static id: number = 4454

	public modelId: number | undefined = 0
	public name: string | undefined
	public ownerName: string | undefined

	public constructor(
		modelId?: number | undefined,
		name?: string | undefined,
		ownerName?: string | undefined
	) {
		super()
		this.modelId = modelId
		this.name = name
		this.ownerName = ownerName
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarShort(this.modelId!)
		writer.writeUTF(this.name!)
		writer.writeUTF(this.ownerName!)
	}

	public deserialize(reader: BinaryReader): void {
		this.modelId = reader.readVarShort()
		this.name = reader.readUTF()
		this.ownerName = reader.readUTF()
	}

	public hydrate(
		data: MountInformationsForPaddock | Record<string, any>
	): MountInformationsForPaddock {
		if (data instanceof MountInformationsForPaddock) {
			return data
		}

		this.modelId = data.modelId
		this.name = data.name
		this.ownerName = data.ownerName

		return this
	}
}

export interface RawObjectEffects {
	id: number
	effects: ObjectEffect[]
}

export class ObjectEffects extends DofusType {
	public static id: number = 4843

	public effects: ObjectEffect[] | undefined

	public constructor(effects?: ObjectEffect[] | undefined) {
		super()
		this.effects = effects
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeShort(this.effects!.length)
		this.effects!.forEach((current) => {
			writer.writeShort(current.id)
			current.serialize(writer)
		})
	}

	public deserialize(reader: BinaryReader): void {
		this.effects = []
		const countEffects = reader.readShort()
		for (let i: number = 0; i < countEffects; i++) {
			const effectsTypeId: number = reader.readShort()
			const type: ObjectEffect = new types[effectsTypeId]() as ObjectEffect
			type.deserialize(reader)
			this.effects.push(type)
		}
	}

	public hydrate(data: ObjectEffects | Record<string, any>): ObjectEffects {
		if (data instanceof ObjectEffects) {
			return data
		}

		this.effects = data.effects.map(
			(dataElement: ObjectEffect | Record<string, any>): ObjectEffect => {
				if (dataElement instanceof ObjectEffect) {
					return dataElement
				} else {
					return (new types[dataElement.id]() as ObjectEffect).hydrate(
						dataElement
					)
				}
			}
		)

		return this
	}
}

export interface RawAchievementObjective {
	id: number
	id_: number
	maxValue: number
}

export class AchievementObjective extends DofusType {
	public static id: number = 1608

	public id_: number | undefined = 0
	public maxValue: number | undefined = 0

	public constructor(id_?: number | undefined, maxValue?: number | undefined) {
		super()
		this.id_ = id_
		this.maxValue = maxValue
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarInt(this.id_!)
		writer.writeVarShort(this.maxValue!)
	}

	public deserialize(reader: BinaryReader): void {
		this.id_ = reader.readVarInt()
		this.maxValue = reader.readVarShort()
	}

	public hydrate(
		data: AchievementObjective | Record<string, any>
	): AchievementObjective {
		if (data instanceof AchievementObjective) {
			return data
		}

		this.id_ = data.id_
		this.maxValue = data.maxValue

		return this
	}
}

export interface RawAchievementStartedObjective
	extends RawAchievementObjective {
	id: number
	value: number
}

export class AchievementStartedObjective extends AchievementObjective {
	public static id: number = 262

	public value: number | undefined = 0

	public constructor(
		id_?: number | undefined,
		maxValue?: number | undefined,
		value?: number | undefined
	) {
		super(id_, maxValue)
		this.value = value
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeVarShort(this.value!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.value = reader.readVarShort()
	}

	public hydrate(
		data: AchievementStartedObjective | Record<string, any>
	): AchievementStartedObjective {
		if (data instanceof AchievementStartedObjective) {
			return data
		}

		super.hydrate(data)

		this.value = data.value

		return this
	}
}

export interface RawFightTeamLightInformations
	extends RawAbstractFightTeamInformations {
	id: number
	hasFriend: boolean
	hasGuildMember: boolean
	hasAllianceMember: boolean
	hasGroupMember: boolean
	hasMyTaxCollector: boolean
	teamMembersCount: number
	meanLevel: number
}

export class FightTeamLightInformations extends AbstractFightTeamInformations {
	public static id: number = 6266

	public hasFriend: boolean | undefined = false
	public hasGuildMember: boolean | undefined = false
	public hasAllianceMember: boolean | undefined = false
	public hasGroupMember: boolean | undefined = false
	public hasMyTaxCollector: boolean | undefined = false
	public teamMembersCount: number | undefined = 0
	public meanLevel: number | undefined = 0

	public constructor(
		teamId?: number | undefined,
		leaderId?: number | undefined,
		teamSide?: number | undefined,
		teamTypeId?: number | undefined,
		nbWaves?: number | undefined,
		hasFriend?: boolean | undefined,
		hasGuildMember?: boolean | undefined,
		hasAllianceMember?: boolean | undefined,
		hasGroupMember?: boolean | undefined,
		hasMyTaxCollector?: boolean | undefined,
		teamMembersCount?: number | undefined,
		meanLevel?: number | undefined
	) {
		super(teamId, leaderId, teamSide, teamTypeId, nbWaves)
		this.hasFriend = hasFriend
		this.hasGuildMember = hasGuildMember
		this.hasAllianceMember = hasAllianceMember
		this.hasGroupMember = hasGroupMember
		this.hasMyTaxCollector = hasMyTaxCollector
		this.teamMembersCount = teamMembersCount
		this.meanLevel = meanLevel
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		let box0: number = 0
		box0 = setFlag(box0, 0, this.hasFriend!)
		box0 = setFlag(box0, 1, this.hasGuildMember!)
		box0 = setFlag(box0, 2, this.hasAllianceMember!)
		box0 = setFlag(box0, 3, this.hasGroupMember!)
		box0 = setFlag(box0, 4, this.hasMyTaxCollector!)
		writer.writeByte(box0)
		writer.writeByte(this.teamMembersCount!)
		writer.writeVarInt(this.meanLevel!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		const box0 = reader.readByte()
		this.hasFriend = getFlag(box0, 0)
		this.hasGuildMember = getFlag(box0, 1)
		this.hasAllianceMember = getFlag(box0, 2)
		this.hasGroupMember = getFlag(box0, 3)
		this.hasMyTaxCollector = getFlag(box0, 4)
		this.teamMembersCount = reader.readByte()
		this.meanLevel = reader.readVarInt()
	}

	public hydrate(
		data: FightTeamLightInformations | Record<string, any>
	): FightTeamLightInformations {
		if (data instanceof FightTeamLightInformations) {
			return data
		}

		super.hydrate(data)

		this.hasFriend = data.hasFriend
		this.hasGuildMember = data.hasGuildMember
		this.hasAllianceMember = data.hasAllianceMember
		this.hasGroupMember = data.hasGroupMember
		this.hasMyTaxCollector = data.hasMyTaxCollector
		this.teamMembersCount = data.teamMembersCount
		this.meanLevel = data.meanLevel

		return this
	}
}

export interface RawArenaRanking {
	id: number
	rank: number
	bestRank: number
}

export class ArenaRanking extends DofusType {
	public static id: number = 7102

	public rank: number | undefined = 0
	public bestRank: number | undefined = 0

	public constructor(rank?: number | undefined, bestRank?: number | undefined) {
		super()
		this.rank = rank
		this.bestRank = bestRank
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarShort(this.rank!)
		writer.writeVarShort(this.bestRank!)
	}

	public deserialize(reader: BinaryReader): void {
		this.rank = reader.readVarShort()
		this.bestRank = reader.readVarShort()
	}

	public hydrate(data: ArenaRanking | Record<string, any>): ArenaRanking {
		if (data instanceof ArenaRanking) {
			return data
		}

		this.rank = data.rank
		this.bestRank = data.bestRank

		return this
	}
}

export interface RawArenaLeagueRanking {
	id: number
	rank: number
	leagueId: number
	leaguePoints: number
	totalLeaguePoints: number
	ladderPosition: number
}

export class ArenaLeagueRanking extends DofusType {
	public static id: number = 125

	public rank: number | undefined = 0
	public leagueId: number | undefined = 0
	public leaguePoints: number | undefined = 0
	public totalLeaguePoints: number | undefined = 0
	public ladderPosition: number | undefined = 0

	public constructor(
		rank?: number | undefined,
		leagueId?: number | undefined,
		leaguePoints?: number | undefined,
		totalLeaguePoints?: number | undefined,
		ladderPosition?: number | undefined
	) {
		super()
		this.rank = rank
		this.leagueId = leagueId
		this.leaguePoints = leaguePoints
		this.totalLeaguePoints = totalLeaguePoints
		this.ladderPosition = ladderPosition
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarShort(this.rank!)
		writer.writeVarShort(this.leagueId!)
		writer.writeVarShort(this.leaguePoints!)
		writer.writeVarShort(this.totalLeaguePoints!)
		writer.writeInt(this.ladderPosition!)
	}

	public deserialize(reader: BinaryReader): void {
		this.rank = reader.readVarShort()
		this.leagueId = reader.readVarShort()
		this.leaguePoints = reader.readVarShort()
		this.totalLeaguePoints = reader.readVarShort()
		this.ladderPosition = reader.readInt()
	}

	public hydrate(
		data: ArenaLeagueRanking | Record<string, any>
	): ArenaLeagueRanking {
		if (data instanceof ArenaLeagueRanking) {
			return data
		}

		this.rank = data.rank
		this.leagueId = data.leagueId
		this.leaguePoints = data.leaguePoints
		this.totalLeaguePoints = data.totalLeaguePoints
		this.ladderPosition = data.ladderPosition

		return this
	}
}

export interface RawBasicPingMessage {
	id: number
	quiet: boolean
}

export class BasicPingMessage extends DofusMessage {
	public static id: number = 6075

	public quiet: boolean | undefined = false

	public constructor(quiet?: boolean | undefined) {
		super()
		this.quiet = quiet
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeBoolean(this.quiet!)
	}

	public deserialize(reader: BinaryReader): void {
		this.quiet = reader.readBoolean()
	}

	public hydrate(
		data: BasicPingMessage | Record<string, any>
	): BasicPingMessage {
		if (data instanceof BasicPingMessage) {
			return data
		}

		this.quiet = data.quiet

		return this
	}
}

export interface RawGameFightSynchronizeMessage {
	id: number
	fighters: GameFightFighterInformations[]
}

export class GameFightSynchronizeMessage extends DofusMessage {
	public static id: number = 4824

	public fighters: GameFightFighterInformations[] | undefined

	public constructor(fighters?: GameFightFighterInformations[] | undefined) {
		super()
		this.fighters = fighters
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeShort(this.fighters!.length)
		this.fighters!.forEach((current) => {
			writer.writeShort(current.id)
			current.serialize(writer)
		})
	}

	public deserialize(reader: BinaryReader): void {
		this.fighters = []
		const countFighters = reader.readShort()
		for (let i: number = 0; i < countFighters; i++) {
			const fightersTypeId: number = reader.readShort()
			const type: GameFightFighterInformations = new types[
				fightersTypeId
			]() as GameFightFighterInformations
			type.deserialize(reader)
			this.fighters.push(type)
		}
	}

	public hydrate(
		data: GameFightSynchronizeMessage | Record<string, any>
	): GameFightSynchronizeMessage {
		if (data instanceof GameFightSynchronizeMessage) {
			return data
		}

		this.fighters = data.fighters.map(
			(
				dataElement: GameFightFighterInformations | Record<string, any>
			): GameFightFighterInformations => {
				if (dataElement instanceof GameFightFighterInformations) {
					return dataElement
				} else {
					return (new types[
						dataElement.id
					]() as GameFightFighterInformations).hydrate(dataElement)
				}
			}
		)

		return this
	}
}

export interface RawAbstractGameActionMessage {
	id: number
	actionId: number
	sourceId: number
}

export class AbstractGameActionMessage extends DofusMessage {
	public static id: number = 8791

	public actionId: number | undefined = 0
	public sourceId: number | undefined = 0

	public constructor(
		actionId?: number | undefined,
		sourceId?: number | undefined
	) {
		super()
		this.actionId = actionId
		this.sourceId = sourceId
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarShort(this.actionId!)
		writer.writeDouble(this.sourceId!)
	}

	public deserialize(reader: BinaryReader): void {
		this.actionId = reader.readVarShort()
		this.sourceId = reader.readDouble()
	}

	public hydrate(
		data: AbstractGameActionMessage | Record<string, any>
	): AbstractGameActionMessage {
		if (data instanceof AbstractGameActionMessage) {
			return data
		}

		this.actionId = data.actionId
		this.sourceId = data.sourceId

		return this
	}
}

export interface RawAbstractGameActionFightTargetedAbilityMessage
	extends RawAbstractGameActionMessage {
	id: number
	silentCast: boolean
	verboseCast: boolean
	targetId: number
	destinationCellId: number
	critical: number
}

export class AbstractGameActionFightTargetedAbilityMessage extends AbstractGameActionMessage {
	public static id = 7655

	public silentCast: boolean | undefined = false
	public verboseCast: boolean | undefined = false
	public targetId: number | undefined = 0
	public destinationCellId: number | undefined = 0
	public critical: number | undefined = 1

	public constructor(
		actionId?: number | undefined,
		sourceId?: number | undefined,
		silentCast?: boolean | undefined,
		verboseCast?: boolean | undefined,
		targetId?: number | undefined,
		destinationCellId?: number | undefined,
		critical?: number | undefined
	) {
		super(actionId, sourceId)
		this.silentCast = silentCast
		this.verboseCast = verboseCast
		this.targetId = targetId
		this.destinationCellId = destinationCellId
		this.critical = critical
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		let box0: number = 0
		box0 = setFlag(box0, 0, this.silentCast!)
		box0 = setFlag(box0, 1, this.verboseCast!)
		writer.writeByte(box0)
		writer.writeDouble(this.targetId!)
		writer.writeShort(this.destinationCellId!)
		writer.writeByte(this.critical!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		const box0 = reader.readByte()
		this.silentCast = getFlag(box0, 0)
		this.verboseCast = getFlag(box0, 1)
		this.targetId = reader.readDouble()
		this.destinationCellId = reader.readShort()
		this.critical = reader.readByte()
	}

	public hydrate(
		data: AbstractGameActionFightTargetedAbilityMessage | Record<string, any>
	): AbstractGameActionFightTargetedAbilityMessage {
		if (data instanceof AbstractGameActionFightTargetedAbilityMessage) {
			return data
		}

		super.hydrate(data)

		this.silentCast = data.silentCast
		this.verboseCast = data.verboseCast
		this.targetId = data.targetId
		this.destinationCellId = data.destinationCellId
		this.critical = data.critical

		return this
	}
}

export interface RawGameActionFightSpellCastMessage
	extends RawAbstractGameActionFightTargetedAbilityMessage {
	id: number
	spellId: number
	spellLevel: number
	portalsIds: number[]
}

export class GameActionFightSpellCastMessage extends AbstractGameActionFightTargetedAbilityMessage {
	public static id = 5026

	public spellId: number | undefined = 0
	public spellLevel: number | undefined = 0
	public portalsIds: number[] | undefined

	public constructor(
		actionId?: number | undefined,
		sourceId?: number | undefined,
		silentCast?: boolean | undefined,
		verboseCast?: boolean | undefined,
		targetId?: number | undefined,
		destinationCellId?: number | undefined,
		critical?: number | undefined,
		spellId?: number | undefined,
		spellLevel?: number | undefined,
		portalsIds?: number[] | undefined
	) {
		super(
			actionId,
			sourceId,
			silentCast,
			verboseCast,
			targetId,
			destinationCellId,
			critical
		)
		this.spellId = spellId
		this.spellLevel = spellLevel
		this.portalsIds = portalsIds
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeVarShort(this.spellId!)
		writer.writeShort(this.spellLevel!)
		writer.writeShort(this.portalsIds!.length)
		this.portalsIds!.forEach((current: number) => writer.writeShort(current))
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.spellId = reader.readVarShort()
		this.spellLevel = reader.readShort()
		this.portalsIds = []
		const countPortalsIds = reader.readShort()
		for (let i: number = 0; i < countPortalsIds; i++) {
			this.portalsIds.push(reader.readShort())
		}
	}

	public hydrate(
		data: GameActionFightSpellCastMessage | Record<string, any>
	): GameActionFightSpellCastMessage {
		if (data instanceof GameActionFightSpellCastMessage) {
			return data
		}

		super.hydrate(data)

		this.spellId = data.spellId
		this.spellLevel = data.spellLevel
		this.portalsIds = data.portalsIds

		return this
	}
}

export interface RawGameActionFightDispellMessage
	extends RawAbstractGameActionMessage {
	id: number
	targetId: number
	verboseCast: boolean
}

export class GameActionFightDispellMessage extends AbstractGameActionMessage {
	public static id = 1408

	public targetId: number | undefined = 0
	public verboseCast: boolean | undefined = false

	public constructor(
		actionId?: number | undefined,
		sourceId?: number | undefined,
		targetId?: number | undefined,
		verboseCast?: boolean | undefined
	) {
		super(actionId, sourceId)
		this.targetId = targetId
		this.verboseCast = verboseCast
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeDouble(this.targetId!)
		writer.writeBoolean(this.verboseCast!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.targetId = reader.readDouble()
		this.verboseCast = reader.readBoolean()
	}

	public hydrate(
		data: GameActionFightDispellMessage | Record<string, any>
	): GameActionFightDispellMessage {
		if (data instanceof GameActionFightDispellMessage) {
			return data
		}

		super.hydrate(data)

		this.targetId = data.targetId
		this.verboseCast = data.verboseCast

		return this
	}
}

export interface RawGameActionFightDispellEffectMessage
	extends RawGameActionFightDispellMessage {
	id: number
	boostUID: number
}

export class GameActionFightDispellEffectMessage extends GameActionFightDispellMessage {
	public static id = 7947

	public boostUID: number | undefined = 0

	public constructor(
		actionId?: number | undefined,
		sourceId?: number | undefined,
		targetId?: number | undefined,
		verboseCast?: boolean | undefined,
		boostUID?: number | undefined
	) {
		super(actionId, sourceId, targetId, verboseCast)
		this.boostUID = boostUID
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeInt(this.boostUID!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.boostUID = reader.readInt()
	}

	public hydrate(
		data: GameActionFightDispellEffectMessage | Record<string, any>
	): GameActionFightDispellEffectMessage {
		if (data instanceof GameActionFightDispellEffectMessage) {
			return data
		}

		super.hydrate(data)

		this.boostUID = data.boostUID

		return this
	}
}

export interface RawGameActionFightTriggerEffectMessage
	extends RawGameActionFightDispellEffectMessage {
	id: number
}

export class GameActionFightTriggerEffectMessage extends GameActionFightDispellEffectMessage {
	public static id = 9562

	public constructor(
		actionId?: number | undefined,
		sourceId?: number | undefined,
		targetId?: number | undefined,
		verboseCast?: boolean | undefined,
		boostUID?: number | undefined
	) {
		super(actionId, sourceId, targetId, verboseCast, boostUID)
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
	}

	public hydrate(
		data: GameActionFightTriggerEffectMessage | Record<string, any>
	): GameActionFightTriggerEffectMessage {
		if (data instanceof GameActionFightTriggerEffectMessage) {
			return data
		}

		super.hydrate(data)

		return this
	}
}

export interface RawGameActionFightTackledMessage
	extends RawAbstractGameActionMessage {
	id: number
	tacklersIds: number[]
}

export class GameActionFightTackledMessage extends AbstractGameActionMessage {
	public static id = 3775

	public tacklersIds: number[] | undefined

	public constructor(
		actionId?: number | undefined,
		sourceId?: number | undefined,
		tacklersIds?: number[] | undefined
	) {
		super(actionId, sourceId)
		this.tacklersIds = tacklersIds
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeShort(this.tacklersIds!.length)
		this.tacklersIds!.forEach((current: number) => writer.writeDouble(current))
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.tacklersIds = []
		const countTacklersIds = reader.readShort()
		for (let i: number = 0; i < countTacklersIds; i++) {
			this.tacklersIds.push(reader.readDouble())
		}
	}

	public hydrate(
		data: GameActionFightTackledMessage | Record<string, any>
	): GameActionFightTackledMessage {
		if (data instanceof GameActionFightTackledMessage) {
			return data
		}

		super.hydrate(data)

		this.tacklersIds = data.tacklersIds

		return this
	}
}

export interface RawGameActionFightInvisibilityMessage
	extends RawAbstractGameActionMessage {
	id: number
	targetId: number
	state: number
}

export class GameActionFightInvisibilityMessage extends AbstractGameActionMessage {
	public static id = 1575

	public targetId: number | undefined = 0
	public state: number | undefined = 0

	public constructor(
		actionId?: number | undefined,
		sourceId?: number | undefined,
		targetId?: number | undefined,
		state?: number | undefined
	) {
		super(actionId, sourceId)
		this.targetId = targetId
		this.state = state
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeDouble(this.targetId!)
		writer.writeByte(this.state!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.targetId = reader.readDouble()
		this.state = reader.readByte()
	}

	public hydrate(
		data: GameActionFightInvisibilityMessage | Record<string, any>
	): GameActionFightInvisibilityMessage {
		if (data instanceof GameActionFightInvisibilityMessage) {
			return data
		}

		super.hydrate(data)

		this.targetId = data.targetId
		this.state = data.state

		return this
	}
}

export interface RawGameActionFightCloseCombatMessage
	extends RawAbstractGameActionFightTargetedAbilityMessage {
	id: number
	weaponGenericId: number
}

export class GameActionFightCloseCombatMessage extends AbstractGameActionFightTargetedAbilityMessage {
	public static id = 2232

	public weaponGenericId: number | undefined = 0

	public constructor(
		actionId?: number | undefined,
		sourceId?: number | undefined,
		silentCast?: boolean | undefined,
		verboseCast?: boolean | undefined,
		targetId?: number | undefined,
		destinationCellId?: number | undefined,
		critical?: number | undefined,
		weaponGenericId?: number | undefined
	) {
		super(
			actionId,
			sourceId,
			silentCast,
			verboseCast,
			targetId,
			destinationCellId,
			critical
		)
		this.weaponGenericId = weaponGenericId
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeVarShort(this.weaponGenericId!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.weaponGenericId = reader.readVarShort()
	}

	public hydrate(
		data: GameActionFightCloseCombatMessage | Record<string, any>
	): GameActionFightCloseCombatMessage {
		if (data instanceof GameActionFightCloseCombatMessage) {
			return data
		}

		super.hydrate(data)

		this.weaponGenericId = data.weaponGenericId

		return this
	}
}

export interface RawGameFightShowFighterMessage {
	id: number
	informations: GameFightFighterInformations
}

export class GameFightShowFighterMessage extends DofusMessage {
	public static id: number = 3884

	public informations: GameFightFighterInformations | undefined

	public constructor(informations?: GameFightFighterInformations | undefined) {
		super()
		this.informations = informations
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeShort(this.informations!.id)
		this.informations!.serialize(writer)
	}

	public deserialize(reader: BinaryReader): void {
		const informationsTypeId: number = reader.readShort()
		this.informations = new types[
			informationsTypeId
		]() as GameFightFighterInformations
		this.informations!.deserialize(reader)
	}

	public hydrate(
		data: GameFightShowFighterMessage | Record<string, any>
	): GameFightShowFighterMessage {
		if (data instanceof GameFightShowFighterMessage) {
			return data
		}

		this.informations = (new types[
			data.informations.id
		]() as GameFightFighterInformations).hydrate(data.informations)
		return this
	}
}

export interface RawGameFightShowFighterRandomStaticPoseMessage
	extends RawGameFightShowFighterMessage {
	id: number
}

export class GameFightShowFighterRandomStaticPoseMessage extends GameFightShowFighterMessage {
	public static id = 6588

	public constructor(informations?: GameFightFighterInformations | undefined) {
		super(informations)
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
	}

	public hydrate(
		data: GameFightShowFighterRandomStaticPoseMessage | Record<string, any>
	): GameFightShowFighterRandomStaticPoseMessage {
		if (data instanceof GameFightShowFighterRandomStaticPoseMessage) {
			return data
		}

		super.hydrate(data)

		return this
	}
}

export interface RawGameActionFightReduceDamagesMessage
	extends RawAbstractGameActionMessage {
	id: number
	targetId: number
	amount: number
}

export class GameActionFightReduceDamagesMessage extends AbstractGameActionMessage {
	public static id = 6074

	public targetId: number | undefined = 0
	public amount: number | undefined = 0

	public constructor(
		actionId?: number | undefined,
		sourceId?: number | undefined,
		targetId?: number | undefined,
		amount?: number | undefined
	) {
		super(actionId, sourceId)
		this.targetId = targetId
		this.amount = amount
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeDouble(this.targetId!)
		writer.writeVarInt(this.amount!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.targetId = reader.readDouble()
		this.amount = reader.readVarInt()
	}

	public hydrate(
		data: GameActionFightReduceDamagesMessage | Record<string, any>
	): GameActionFightReduceDamagesMessage {
		if (data instanceof GameActionFightReduceDamagesMessage) {
			return data
		}

		super.hydrate(data)

		this.targetId = data.targetId
		this.amount = data.amount

		return this
	}
}

export interface RawGameActionFightLifePointsGainMessage
	extends RawAbstractGameActionMessage {
	id: number
	targetId: number
	delta: number
}

export class GameActionFightLifePointsGainMessage extends AbstractGameActionMessage {
	public static id = 1531

	public targetId: number | undefined = 0
	public delta: number | undefined = 0

	public constructor(
		actionId?: number | undefined,
		sourceId?: number | undefined,
		targetId?: number | undefined,
		delta?: number | undefined
	) {
		super(actionId, sourceId)
		this.targetId = targetId
		this.delta = delta
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeDouble(this.targetId!)
		writer.writeVarInt(this.delta!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.targetId = reader.readDouble()
		this.delta = reader.readVarInt()
	}

	public hydrate(
		data: GameActionFightLifePointsGainMessage | Record<string, any>
	): GameActionFightLifePointsGainMessage {
		if (data instanceof GameActionFightLifePointsGainMessage) {
			return data
		}

		super.hydrate(data)

		this.targetId = data.targetId
		this.delta = data.delta

		return this
	}
}

export interface RawGameActionFightModifyEffectsDurationMessage
	extends RawAbstractGameActionMessage {
	id: number
	targetId: number
	delta: number
}

export class GameActionFightModifyEffectsDurationMessage extends AbstractGameActionMessage {
	public static id = 6413

	public targetId: number | undefined = 0
	public delta: number | undefined = 0

	public constructor(
		actionId?: number | undefined,
		sourceId?: number | undefined,
		targetId?: number | undefined,
		delta?: number | undefined
	) {
		super(actionId, sourceId)
		this.targetId = targetId
		this.delta = delta
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeDouble(this.targetId!)
		writer.writeShort(this.delta!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.targetId = reader.readDouble()
		this.delta = reader.readShort()
	}

	public hydrate(
		data: GameActionFightModifyEffectsDurationMessage | Record<string, any>
	): GameActionFightModifyEffectsDurationMessage {
		if (data instanceof GameActionFightModifyEffectsDurationMessage) {
			return data
		}

		super.hydrate(data)

		this.targetId = data.targetId
		this.delta = data.delta

		return this
	}
}

export interface RawGameActionFightTeleportOnSameMapMessage
	extends RawAbstractGameActionMessage {
	id: number
	targetId: number
	cellId: number
}

export class GameActionFightTeleportOnSameMapMessage extends AbstractGameActionMessage {
	public static id = 9063

	public targetId: number | undefined = 0
	public cellId: number | undefined = 0

	public constructor(
		actionId?: number | undefined,
		sourceId?: number | undefined,
		targetId?: number | undefined,
		cellId?: number | undefined
	) {
		super(actionId, sourceId)
		this.targetId = targetId
		this.cellId = cellId
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeDouble(this.targetId!)
		writer.writeShort(this.cellId!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.targetId = reader.readDouble()
		this.cellId = reader.readShort()
	}

	public hydrate(
		data: GameActionFightTeleportOnSameMapMessage | Record<string, any>
	): GameActionFightTeleportOnSameMapMessage {
		if (data instanceof GameActionFightTeleportOnSameMapMessage) {
			return data
		}

		super.hydrate(data)

		this.targetId = data.targetId
		this.cellId = data.cellId

		return this
	}
}

export interface RawGameActionFightInvisibleDetectedMessage
	extends RawAbstractGameActionMessage {
	id: number
	targetId: number
	cellId: number
}

export class GameActionFightInvisibleDetectedMessage extends AbstractGameActionMessage {
	public static id = 4730

	public targetId: number | undefined = 0
	public cellId: number | undefined = 0

	public constructor(
		actionId?: number | undefined,
		sourceId?: number | undefined,
		targetId?: number | undefined,
		cellId?: number | undefined
	) {
		super(actionId, sourceId)
		this.targetId = targetId
		this.cellId = cellId
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeDouble(this.targetId!)
		writer.writeShort(this.cellId!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.targetId = reader.readDouble()
		this.cellId = reader.readShort()
	}

	public hydrate(
		data: GameActionFightInvisibleDetectedMessage | Record<string, any>
	): GameActionFightInvisibleDetectedMessage {
		if (data instanceof GameActionFightInvisibleDetectedMessage) {
			return data
		}

		super.hydrate(data)

		this.targetId = data.targetId
		this.cellId = data.cellId

		return this
	}
}

export interface RawGameActionFightDispellSpellMessage
	extends RawGameActionFightDispellMessage {
	id: number
	spellId: number
}

export class GameActionFightDispellSpellMessage extends GameActionFightDispellMessage {
	public static id = 9184

	public spellId: number | undefined = 0

	public constructor(
		actionId?: number | undefined,
		sourceId?: number | undefined,
		targetId?: number | undefined,
		verboseCast?: boolean | undefined,
		spellId?: number | undefined
	) {
		super(actionId, sourceId, targetId, verboseCast)
		this.spellId = spellId
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeVarShort(this.spellId!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.spellId = reader.readVarShort()
	}

	public hydrate(
		data: GameActionFightDispellSpellMessage | Record<string, any>
	): GameActionFightDispellSpellMessage {
		if (data instanceof GameActionFightDispellSpellMessage) {
			return data
		}

		super.hydrate(data)

		this.spellId = data.spellId

		return this
	}
}

export interface RawGameFightTurnListMessage {
	id: number
	ids: number[]
	deadsIds: number[]
}

export class GameFightTurnListMessage extends DofusMessage {
	public static id: number = 9365

	public ids: number[] | undefined
	public deadsIds: number[] | undefined

	public constructor(
		ids?: number[] | undefined,
		deadsIds?: number[] | undefined
	) {
		super()
		this.ids = ids
		this.deadsIds = deadsIds
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeShort(this.ids!.length)
		this.ids!.forEach((current: number) => writer.writeDouble(current))
		writer.writeShort(this.deadsIds!.length)
		this.deadsIds!.forEach((current: number) => writer.writeDouble(current))
	}

	public deserialize(reader: BinaryReader): void {
		this.ids = []
		const countIds = reader.readShort()
		for (let i: number = 0; i < countIds; i++) {
			this.ids.push(reader.readDouble())
		}
		this.deadsIds = []
		const countDeadsIds = reader.readShort()
		for (let i: number = 0; i < countDeadsIds; i++) {
			this.deadsIds.push(reader.readDouble())
		}
	}

	public hydrate(
		data: GameFightTurnListMessage | Record<string, any>
	): GameFightTurnListMessage {
		if (data instanceof GameFightTurnListMessage) {
			return data
		}

		this.ids = data.ids
		this.deadsIds = data.deadsIds

		return this
	}
}

export interface RawGameActionFightChangeLookMessage
	extends RawAbstractGameActionMessage {
	id: number
	targetId: number
	entityLook: EntityLook
}

export class GameActionFightChangeLookMessage extends AbstractGameActionMessage {
	public static id = 5574

	public targetId: number | undefined = 0
	public entityLook: EntityLook | undefined

	public constructor(
		actionId?: number | undefined,
		sourceId?: number | undefined,
		targetId?: number | undefined,
		entityLook?: EntityLook | undefined
	) {
		super(actionId, sourceId)
		this.targetId = targetId
		this.entityLook = entityLook
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeDouble(this.targetId!)
		this.entityLook!.serialize(writer)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.targetId = reader.readDouble()
		this.entityLook = new EntityLook()
		this.entityLook!.deserialize(reader)
	}

	public hydrate(
		data: GameActionFightChangeLookMessage | Record<string, any>
	): GameActionFightChangeLookMessage {
		if (data instanceof GameActionFightChangeLookMessage) {
			return data
		}

		super.hydrate(data)

		this.targetId = data.targetId
		this.entityLook = new EntityLook().hydrate(data.entityLook)

		return this
	}
}

export interface RawGameActionFightDodgePointLossMessage
	extends RawAbstractGameActionMessage {
	id: number
	targetId: number
	amount: number
}

export class GameActionFightDodgePointLossMessage extends AbstractGameActionMessage {
	public static id = 7952

	public targetId: number | undefined = 0
	public amount: number | undefined = 0

	public constructor(
		actionId?: number | undefined,
		sourceId?: number | undefined,
		targetId?: number | undefined,
		amount?: number | undefined
	) {
		super(actionId, sourceId)
		this.targetId = targetId
		this.amount = amount
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeDouble(this.targetId!)
		writer.writeVarShort(this.amount!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.targetId = reader.readDouble()
		this.amount = reader.readVarShort()
	}

	public hydrate(
		data: GameActionFightDodgePointLossMessage | Record<string, any>
	): GameActionFightDodgePointLossMessage {
		if (data instanceof GameActionFightDodgePointLossMessage) {
			return data
		}

		super.hydrate(data)

		this.targetId = data.targetId
		this.amount = data.amount

		return this
	}
}

export interface RawSequenceStartMessage {
	id: number
	sequenceType: number
	authorId: number
}

export class SequenceStartMessage extends DofusMessage {
	public static id: number = 5293

	public sequenceType: number | undefined = 0
	public authorId: number | undefined = 0

	public constructor(
		sequenceType?: number | undefined,
		authorId?: number | undefined
	) {
		super()
		this.sequenceType = sequenceType
		this.authorId = authorId
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeByte(this.sequenceType!)
		writer.writeDouble(this.authorId!)
	}

	public deserialize(reader: BinaryReader): void {
		this.sequenceType = reader.readByte()
		this.authorId = reader.readDouble()
	}

	public hydrate(
		data: SequenceStartMessage | Record<string, any>
	): SequenceStartMessage {
		if (data instanceof SequenceStartMessage) {
			return data
		}

		this.sequenceType = data.sequenceType
		this.authorId = data.authorId

		return this
	}
}

export interface RawGameActionFightSpellImmunityMessage
	extends RawAbstractGameActionMessage {
	id: number
	targetId: number
	spellId: number
}

export class GameActionFightSpellImmunityMessage extends AbstractGameActionMessage {
	public static id = 1076

	public targetId: number | undefined = 0
	public spellId: number | undefined = 0

	public constructor(
		actionId?: number | undefined,
		sourceId?: number | undefined,
		targetId?: number | undefined,
		spellId?: number | undefined
	) {
		super(actionId, sourceId)
		this.targetId = targetId
		this.spellId = spellId
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeDouble(this.targetId!)
		writer.writeVarShort(this.spellId!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.targetId = reader.readDouble()
		this.spellId = reader.readVarShort()
	}

	public hydrate(
		data: GameActionFightSpellImmunityMessage | Record<string, any>
	): GameActionFightSpellImmunityMessage {
		if (data instanceof GameActionFightSpellImmunityMessage) {
			return data
		}

		super.hydrate(data)

		this.targetId = data.targetId
		this.spellId = data.spellId

		return this
	}
}

export interface RawGameActionFightDispellableEffectMessage
	extends RawAbstractGameActionMessage {
	id: number
	effect: AbstractFightDispellableEffect
}

export class GameActionFightDispellableEffectMessage extends AbstractGameActionMessage {
	public static id = 5910

	public effect: AbstractFightDispellableEffect | undefined

	public constructor(
		actionId?: number | undefined,
		sourceId?: number | undefined,
		effect?: AbstractFightDispellableEffect | undefined
	) {
		super(actionId, sourceId)
		this.effect = effect
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeShort(this.effect!.id)
		this.effect!.serialize(writer)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		const effectTypeId: number = reader.readShort()
		this.effect = new types[effectTypeId]() as AbstractFightDispellableEffect
		this.effect!.deserialize(reader)
	}

	public hydrate(
		data: GameActionFightDispellableEffectMessage | Record<string, any>
	): GameActionFightDispellableEffectMessage {
		if (data instanceof GameActionFightDispellableEffectMessage) {
			return data
		}

		super.hydrate(data)

		this.effect = (new types[
			data.effect.id
		]() as AbstractFightDispellableEffect).hydrate(data.effect)
		return this
	}
}

export interface RawGameActionFightVanishMessage
	extends RawAbstractGameActionMessage {
	id: number
	targetId: number
}

export class GameActionFightVanishMessage extends AbstractGameActionMessage {
	public static id = 622

	public targetId: number | undefined = 0

	public constructor(
		actionId?: number | undefined,
		sourceId?: number | undefined,
		targetId?: number | undefined
	) {
		super(actionId, sourceId)
		this.targetId = targetId
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeDouble(this.targetId!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.targetId = reader.readDouble()
	}

	public hydrate(
		data: GameActionFightVanishMessage | Record<string, any>
	): GameActionFightVanishMessage {
		if (data instanceof GameActionFightVanishMessage) {
			return data
		}

		super.hydrate(data)

		this.targetId = data.targetId

		return this
	}
}

export interface RawGameActionFightThrowCharacterMessage
	extends RawAbstractGameActionMessage {
	id: number
	targetId: number
	cellId: number
}

export class GameActionFightThrowCharacterMessage extends AbstractGameActionMessage {
	public static id = 9016

	public targetId: number | undefined = 0
	public cellId: number | undefined = 0

	public constructor(
		actionId?: number | undefined,
		sourceId?: number | undefined,
		targetId?: number | undefined,
		cellId?: number | undefined
	) {
		super(actionId, sourceId)
		this.targetId = targetId
		this.cellId = cellId
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeDouble(this.targetId!)
		writer.writeShort(this.cellId!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.targetId = reader.readDouble()
		this.cellId = reader.readShort()
	}

	public hydrate(
		data: GameActionFightThrowCharacterMessage | Record<string, any>
	): GameActionFightThrowCharacterMessage {
		if (data instanceof GameActionFightThrowCharacterMessage) {
			return data
		}

		super.hydrate(data)

		this.targetId = data.targetId
		this.cellId = data.cellId

		return this
	}
}

export interface RawGameActionFightMultipleSummonMessage
	extends RawAbstractGameActionMessage {
	id: number
	summons: GameContextSummonsInformation[]
}

export class GameActionFightMultipleSummonMessage extends AbstractGameActionMessage {
	public static id = 5036

	public summons: GameContextSummonsInformation[] | undefined

	public constructor(
		actionId?: number | undefined,
		sourceId?: number | undefined,
		summons?: GameContextSummonsInformation[] | undefined
	) {
		super(actionId, sourceId)
		this.summons = summons
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeShort(this.summons!.length)
		this.summons!.forEach((current) => {
			writer.writeShort(current.id)
			current.serialize(writer)
		})
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.summons = []
		const countSummons = reader.readShort()
		for (let i: number = 0; i < countSummons; i++) {
			const summonsTypeId: number = reader.readShort()
			const type: GameContextSummonsInformation = new types[
				summonsTypeId
			]() as GameContextSummonsInformation
			type.deserialize(reader)
			this.summons.push(type)
		}
	}

	public hydrate(
		data: GameActionFightMultipleSummonMessage | Record<string, any>
	): GameActionFightMultipleSummonMessage {
		if (data instanceof GameActionFightMultipleSummonMessage) {
			return data
		}

		super.hydrate(data)

		this.summons = data.summons.map(
			(
				dataElement: GameContextSummonsInformation | Record<string, any>
			): GameContextSummonsInformation => {
				if (dataElement instanceof GameContextSummonsInformation) {
					return dataElement
				} else {
					return (new types[
						dataElement.id
					]() as GameContextSummonsInformation).hydrate(dataElement)
				}
			}
		)

		return this
	}
}

export interface RawGameFightRefreshFighterMessage {
	id: number
	informations: GameContextActorInformations
}

export class GameFightRefreshFighterMessage extends DofusMessage {
	public static id: number = 986

	public informations: GameContextActorInformations | undefined

	public constructor(informations?: GameContextActorInformations | undefined) {
		super()
		this.informations = informations
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeShort(this.informations!.id)
		this.informations!.serialize(writer)
	}

	public deserialize(reader: BinaryReader): void {
		const informationsTypeId: number = reader.readShort()
		this.informations = new types[
			informationsTypeId
		]() as GameContextActorInformations
		this.informations!.deserialize(reader)
	}

	public hydrate(
		data: GameFightRefreshFighterMessage | Record<string, any>
	): GameFightRefreshFighterMessage {
		if (data instanceof GameFightRefreshFighterMessage) {
			return data
		}

		this.informations = (new types[
			data.informations.id
		]() as GameContextActorInformations).hydrate(data.informations)
		return this
	}
}

export interface RawGameActionFightSlideMessage
	extends RawAbstractGameActionMessage {
	id: number
	targetId: number
	startCellId: number
	endCellId: number
}

export class GameActionFightSlideMessage extends AbstractGameActionMessage {
	public static id = 1549

	public targetId: number | undefined = 0
	public startCellId: number | undefined = 0
	public endCellId: number | undefined = 0

	public constructor(
		actionId?: number | undefined,
		sourceId?: number | undefined,
		targetId?: number | undefined,
		startCellId?: number | undefined,
		endCellId?: number | undefined
	) {
		super(actionId, sourceId)
		this.targetId = targetId
		this.startCellId = startCellId
		this.endCellId = endCellId
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeDouble(this.targetId!)
		writer.writeShort(this.startCellId!)
		writer.writeShort(this.endCellId!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.targetId = reader.readDouble()
		this.startCellId = reader.readShort()
		this.endCellId = reader.readShort()
	}

	public hydrate(
		data: GameActionFightSlideMessage | Record<string, any>
	): GameActionFightSlideMessage {
		if (data instanceof GameActionFightSlideMessage) {
			return data
		}

		super.hydrate(data)

		this.targetId = data.targetId
		this.startCellId = data.startCellId
		this.endCellId = data.endCellId

		return this
	}
}

export interface RawGameActionFightKillMessage
	extends RawAbstractGameActionMessage {
	id: number
	targetId: number
}

export class GameActionFightKillMessage extends AbstractGameActionMessage {
	public static id = 8275

	public targetId: number | undefined = 0

	public constructor(
		actionId?: number | undefined,
		sourceId?: number | undefined,
		targetId?: number | undefined
	) {
		super(actionId, sourceId)
		this.targetId = targetId
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeDouble(this.targetId!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.targetId = reader.readDouble()
	}

	public hydrate(
		data: GameActionFightKillMessage | Record<string, any>
	): GameActionFightKillMessage {
		if (data instanceof GameActionFightKillMessage) {
			return data
		}

		super.hydrate(data)

		this.targetId = data.targetId

		return this
	}
}

export interface RawGameActionFightMarkCellsMessage
	extends RawAbstractGameActionMessage {
	id: number
	mark: GameActionMark
}

export class GameActionFightMarkCellsMessage extends AbstractGameActionMessage {
	public static id = 1538

	public mark: GameActionMark | undefined

	public constructor(
		actionId?: number | undefined,
		sourceId?: number | undefined,
		mark?: GameActionMark | undefined
	) {
		super(actionId, sourceId)
		this.mark = mark
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		this.mark!.serialize(writer)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.mark = new GameActionMark()
		this.mark!.deserialize(reader)
	}

	public hydrate(
		data: GameActionFightMarkCellsMessage | Record<string, any>
	): GameActionFightMarkCellsMessage {
		if (data instanceof GameActionFightMarkCellsMessage) {
			return data
		}

		super.hydrate(data)

		this.mark = new GameActionMark().hydrate(data.mark)

		return this
	}
}

export interface RawGameActionFightSpellCooldownVariationMessage
	extends RawAbstractGameActionMessage {
	id: number
	targetId: number
	spellId: number
	value: number
}

export class GameActionFightSpellCooldownVariationMessage extends AbstractGameActionMessage {
	public static id = 772

	public targetId: number | undefined = 0
	public spellId: number | undefined = 0
	public value: number | undefined = 0

	public constructor(
		actionId?: number | undefined,
		sourceId?: number | undefined,
		targetId?: number | undefined,
		spellId?: number | undefined,
		value?: number | undefined
	) {
		super(actionId, sourceId)
		this.targetId = targetId
		this.spellId = spellId
		this.value = value
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeDouble(this.targetId!)
		writer.writeVarShort(this.spellId!)
		writer.writeVarShort(this.value!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.targetId = reader.readDouble()
		this.spellId = reader.readVarShort()
		this.value = reader.readVarShort()
	}

	public hydrate(
		data: GameActionFightSpellCooldownVariationMessage | Record<string, any>
	): GameActionFightSpellCooldownVariationMessage {
		if (data instanceof GameActionFightSpellCooldownVariationMessage) {
			return data
		}

		super.hydrate(data)

		this.targetId = data.targetId
		this.spellId = data.spellId
		this.value = data.value

		return this
	}
}

export interface RawFighterStatsListMessage {
	id: number
	stats: CharacterCharacteristicsInformations
}

export class FighterStatsListMessage extends DofusMessage {
	public static id: number = 7728

	public stats: CharacterCharacteristicsInformations | undefined

	public constructor(stats?: CharacterCharacteristicsInformations | undefined) {
		super()
		this.stats = stats
	}

	public serialize(writer: BinaryWriter): void {
		this.stats!.serialize(writer)
	}

	public deserialize(reader: BinaryReader): void {
		this.stats = new CharacterCharacteristicsInformations()
		this.stats!.deserialize(reader)
	}

	public hydrate(
		data: FighterStatsListMessage | Record<string, any>
	): FighterStatsListMessage {
		if (data instanceof FighterStatsListMessage) {
			return data
		}

		return this
	}
}

export interface RawGameMapMovementMessage {
	id: number
	keyMovements: number[]
	forcedDirection: number
	actorId: number
}

export class GameMapMovementMessage extends DofusMessage {
	public static id: number = 5371

	public keyMovements: number[] | undefined
	public forcedDirection: number | undefined = 0
	public actorId: number | undefined = 0

	public constructor(
		keyMovements?: number[] | undefined,
		forcedDirection?: number | undefined,
		actorId?: number | undefined
	) {
		super()
		this.keyMovements = keyMovements
		this.forcedDirection = forcedDirection
		this.actorId = actorId
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeShort(this.keyMovements!.length)
		this.keyMovements!.forEach((current: number) => writer.writeShort(current))
		writer.writeShort(this.forcedDirection!)
		writer.writeDouble(this.actorId!)
	}

	public deserialize(reader: BinaryReader): void {
		this.keyMovements = []
		const countKeyMovements = reader.readShort()
		for (let i: number = 0; i < countKeyMovements; i++) {
			this.keyMovements.push(reader.readShort())
		}
		this.forcedDirection = reader.readShort()
		this.actorId = reader.readDouble()
	}

	public hydrate(
		data: GameMapMovementMessage | Record<string, any>
	): GameMapMovementMessage {
		if (data instanceof GameMapMovementMessage) {
			return data
		}

		this.keyMovements = data.keyMovements
		this.forcedDirection = data.forcedDirection
		this.actorId = data.actorId

		return this
	}
}

export interface RawGameActionFightSummonMessage
	extends RawAbstractGameActionMessage {
	id: number
	summons: GameFightFighterInformations[]
}

export class GameActionFightSummonMessage extends AbstractGameActionMessage {
	public static id = 8796

	public summons: GameFightFighterInformations[] | undefined

	public constructor(
		actionId?: number | undefined,
		sourceId?: number | undefined,
		summons?: GameFightFighterInformations[] | undefined
	) {
		super(actionId, sourceId)
		this.summons = summons
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeShort(this.summons!.length)
		this.summons!.forEach((current) => {
			writer.writeShort(current.id)
			current.serialize(writer)
		})
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.summons = []
		const countSummons = reader.readShort()
		for (let i: number = 0; i < countSummons; i++) {
			const summonsTypeId: number = reader.readShort()
			const type: GameFightFighterInformations = new types[
				summonsTypeId
			]() as GameFightFighterInformations
			type.deserialize(reader)
			this.summons.push(type)
		}
	}

	public hydrate(
		data: GameActionFightSummonMessage | Record<string, any>
	): GameActionFightSummonMessage {
		if (data instanceof GameActionFightSummonMessage) {
			return data
		}

		super.hydrate(data)

		this.summons = data.summons.map(
			(
				dataElement: GameFightFighterInformations | Record<string, any>
			): GameFightFighterInformations => {
				if (dataElement instanceof GameFightFighterInformations) {
					return dataElement
				} else {
					return (new types[
						dataElement.id
					]() as GameFightFighterInformations).hydrate(dataElement)
				}
			}
		)

		return this
	}
}

export interface RawGameActionFightDropCharacterMessage
	extends RawAbstractGameActionMessage {
	id: number
	targetId: number
	cellId: number
}

export class GameActionFightDropCharacterMessage extends AbstractGameActionMessage {
	public static id = 8910

	public targetId: number | undefined = 0
	public cellId: number | undefined = 0

	public constructor(
		actionId?: number | undefined,
		sourceId?: number | undefined,
		targetId?: number | undefined,
		cellId?: number | undefined
	) {
		super(actionId, sourceId)
		this.targetId = targetId
		this.cellId = cellId
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeDouble(this.targetId!)
		writer.writeShort(this.cellId!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.targetId = reader.readDouble()
		this.cellId = reader.readShort()
	}

	public hydrate(
		data: GameActionFightDropCharacterMessage | Record<string, any>
	): GameActionFightDropCharacterMessage {
		if (data instanceof GameActionFightDropCharacterMessage) {
			return data
		}

		super.hydrate(data)

		this.targetId = data.targetId
		this.cellId = data.cellId

		return this
	}
}

export interface RawGameActionFightTriggerGlyphTrapMessage
	extends RawAbstractGameActionMessage {
	id: number
	markId: number
	markImpactCell: number
	triggeringCharacterId: number
	triggeredSpellId: number
}

export class GameActionFightTriggerGlyphTrapMessage extends AbstractGameActionMessage {
	public static id = 8084

	public markId: number | undefined = 0
	public markImpactCell: number | undefined = 0
	public triggeringCharacterId: number | undefined = 0
	public triggeredSpellId: number | undefined = 0

	public constructor(
		actionId?: number | undefined,
		sourceId?: number | undefined,
		markId?: number | undefined,
		markImpactCell?: number | undefined,
		triggeringCharacterId?: number | undefined,
		triggeredSpellId?: number | undefined
	) {
		super(actionId, sourceId)
		this.markId = markId
		this.markImpactCell = markImpactCell
		this.triggeringCharacterId = triggeringCharacterId
		this.triggeredSpellId = triggeredSpellId
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeShort(this.markId!)
		writer.writeVarShort(this.markImpactCell!)
		writer.writeDouble(this.triggeringCharacterId!)
		writer.writeVarShort(this.triggeredSpellId!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.markId = reader.readShort()
		this.markImpactCell = reader.readVarShort()
		this.triggeringCharacterId = reader.readDouble()
		this.triggeredSpellId = reader.readVarShort()
	}

	public hydrate(
		data: GameActionFightTriggerGlyphTrapMessage | Record<string, any>
	): GameActionFightTriggerGlyphTrapMessage {
		if (data instanceof GameActionFightTriggerGlyphTrapMessage) {
			return data
		}

		super.hydrate(data)

		this.markId = data.markId
		this.markImpactCell = data.markImpactCell
		this.triggeringCharacterId = data.triggeringCharacterId
		this.triggeredSpellId = data.triggeredSpellId

		return this
	}
}

export interface RawGameActionFightDeathMessage
	extends RawAbstractGameActionMessage {
	id: number
	targetId: number
}

export class GameActionFightDeathMessage extends AbstractGameActionMessage {
	public static id = 3225

	public targetId: number | undefined = 0

	public constructor(
		actionId?: number | undefined,
		sourceId?: number | undefined,
		targetId?: number | undefined
	) {
		super(actionId, sourceId)
		this.targetId = targetId
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeDouble(this.targetId!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.targetId = reader.readDouble()
	}

	public hydrate(
		data: GameActionFightDeathMessage | Record<string, any>
	): GameActionFightDeathMessage {
		if (data instanceof GameActionFightDeathMessage) {
			return data
		}

		super.hydrate(data)

		this.targetId = data.targetId

		return this
	}
}

export interface RawGameActionFightStealKamaMessage
	extends RawAbstractGameActionMessage {
	id: number
	targetId: number
	amount: number
}

export class GameActionFightStealKamaMessage extends AbstractGameActionMessage {
	public static id = 6663

	public targetId: number | undefined = 0
	public amount: number | undefined = 0

	public constructor(
		actionId?: number | undefined,
		sourceId?: number | undefined,
		targetId?: number | undefined,
		amount?: number | undefined
	) {
		super(actionId, sourceId)
		this.targetId = targetId
		this.amount = amount
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeDouble(this.targetId!)
		writer.writeVarLong(this.amount!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.targetId = reader.readDouble()
		this.amount = reader.readVarLong()
	}

	public hydrate(
		data: GameActionFightStealKamaMessage | Record<string, any>
	): GameActionFightStealKamaMessage {
		if (data instanceof GameActionFightStealKamaMessage) {
			return data
		}

		super.hydrate(data)

		this.targetId = data.targetId
		this.amount = data.amount

		return this
	}
}

export interface RawGameActionFightPointsVariationMessage
	extends RawAbstractGameActionMessage {
	id: number
	targetId: number
	delta: number
}

export class GameActionFightPointsVariationMessage extends AbstractGameActionMessage {
	public static id = 5415

	public targetId: number | undefined = 0
	public delta: number | undefined = 0

	public constructor(
		actionId?: number | undefined,
		sourceId?: number | undefined,
		targetId?: number | undefined,
		delta?: number | undefined
	) {
		super(actionId, sourceId)
		this.targetId = targetId
		this.delta = delta
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeDouble(this.targetId!)
		writer.writeShort(this.delta!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.targetId = reader.readDouble()
		this.delta = reader.readShort()
	}

	public hydrate(
		data: GameActionFightPointsVariationMessage | Record<string, any>
	): GameActionFightPointsVariationMessage {
		if (data instanceof GameActionFightPointsVariationMessage) {
			return data
		}

		super.hydrate(data)

		this.targetId = data.targetId
		this.delta = data.delta

		return this
	}
}

export interface RawSequenceEndMessage {
	id: number
	actionId: number
	authorId: number
	sequenceType: number
}

export class SequenceEndMessage extends DofusMessage {
	public static id: number = 7632

	public actionId: number | undefined = 0
	public authorId: number | undefined = 0
	public sequenceType: number | undefined = 0

	public constructor(
		actionId?: number | undefined,
		authorId?: number | undefined,
		sequenceType?: number | undefined
	) {
		super()
		this.actionId = actionId
		this.authorId = authorId
		this.sequenceType = sequenceType
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarShort(this.actionId!)
		writer.writeDouble(this.authorId!)
		writer.writeByte(this.sequenceType!)
	}

	public deserialize(reader: BinaryReader): void {
		this.actionId = reader.readVarShort()
		this.authorId = reader.readDouble()
		this.sequenceType = reader.readByte()
	}

	public hydrate(
		data: SequenceEndMessage | Record<string, any>
	): SequenceEndMessage {
		if (data instanceof SequenceEndMessage) {
			return data
		}

		this.actionId = data.actionId
		this.authorId = data.authorId
		this.sequenceType = data.sequenceType

		return this
	}
}

export interface RawGameActionFightLifePointsLostMessage
	extends RawAbstractGameActionMessage {
	id: number
	targetId: number
	loss: number
	permanentDamages: number
	elementId: number
}

export class GameActionFightLifePointsLostMessage extends AbstractGameActionMessage {
	public static id = 8747

	public targetId: number | undefined = 0
	public loss: number | undefined = 0
	public permanentDamages: number | undefined = 0
	public elementId: number | undefined = 0

	public constructor(
		actionId?: number | undefined,
		sourceId?: number | undefined,
		targetId?: number | undefined,
		loss?: number | undefined,
		permanentDamages?: number | undefined,
		elementId?: number | undefined
	) {
		super(actionId, sourceId)
		this.targetId = targetId
		this.loss = loss
		this.permanentDamages = permanentDamages
		this.elementId = elementId
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeDouble(this.targetId!)
		writer.writeVarInt(this.loss!)
		writer.writeVarInt(this.permanentDamages!)
		writer.writeVarInt(this.elementId!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.targetId = reader.readDouble()
		this.loss = reader.readVarInt()
		this.permanentDamages = reader.readVarInt()
		this.elementId = reader.readVarInt()
	}

	public hydrate(
		data: GameActionFightLifePointsLostMessage | Record<string, any>
	): GameActionFightLifePointsLostMessage {
		if (data instanceof GameActionFightLifePointsLostMessage) {
			return data
		}

		super.hydrate(data)

		this.targetId = data.targetId
		this.loss = data.loss
		this.permanentDamages = data.permanentDamages
		this.elementId = data.elementId

		return this
	}
}

export interface RawGameActionFightLifeAndShieldPointsLostMessage
	extends RawGameActionFightLifePointsLostMessage {
	id: number
	shieldLoss: number
}

export class GameActionFightLifeAndShieldPointsLostMessage extends GameActionFightLifePointsLostMessage {
	public static id = 423

	public shieldLoss: number | undefined = 0

	public constructor(
		actionId?: number | undefined,
		sourceId?: number | undefined,
		targetId?: number | undefined,
		loss?: number | undefined,
		permanentDamages?: number | undefined,
		elementId?: number | undefined,
		shieldLoss?: number | undefined
	) {
		super(actionId, sourceId, targetId, loss, permanentDamages, elementId)
		this.shieldLoss = shieldLoss
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeVarShort(this.shieldLoss!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.shieldLoss = reader.readVarShort()
	}

	public hydrate(
		data: GameActionFightLifeAndShieldPointsLostMessage | Record<string, any>
	): GameActionFightLifeAndShieldPointsLostMessage {
		if (data instanceof GameActionFightLifeAndShieldPointsLostMessage) {
			return data
		}

		super.hydrate(data)

		this.shieldLoss = data.shieldLoss

		return this
	}
}

export interface RawGameActionFightReflectSpellMessage
	extends RawAbstractGameActionMessage {
	id: number
	targetId: number
}

export class GameActionFightReflectSpellMessage extends AbstractGameActionMessage {
	public static id = 1453

	public targetId: number | undefined = 0

	public constructor(
		actionId?: number | undefined,
		sourceId?: number | undefined,
		targetId?: number | undefined
	) {
		super(actionId, sourceId)
		this.targetId = targetId
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeDouble(this.targetId!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.targetId = reader.readDouble()
	}

	public hydrate(
		data: GameActionFightReflectSpellMessage | Record<string, any>
	): GameActionFightReflectSpellMessage {
		if (data instanceof GameActionFightReflectSpellMessage) {
			return data
		}

		super.hydrate(data)

		this.targetId = data.targetId

		return this
	}
}

export interface RawGameActionFightCarryCharacterMessage
	extends RawAbstractGameActionMessage {
	id: number
	targetId: number
	cellId: number
}

export class GameActionFightCarryCharacterMessage extends AbstractGameActionMessage {
	public static id = 3652

	public targetId: number | undefined = 0
	public cellId: number | undefined = 0

	public constructor(
		actionId?: number | undefined,
		sourceId?: number | undefined,
		targetId?: number | undefined,
		cellId?: number | undefined
	) {
		super(actionId, sourceId)
		this.targetId = targetId
		this.cellId = cellId
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeDouble(this.targetId!)
		writer.writeShort(this.cellId!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.targetId = reader.readDouble()
		this.cellId = reader.readShort()
	}

	public hydrate(
		data: GameActionFightCarryCharacterMessage | Record<string, any>
	): GameActionFightCarryCharacterMessage {
		if (data instanceof GameActionFightCarryCharacterMessage) {
			return data
		}

		super.hydrate(data)

		this.targetId = data.targetId
		this.cellId = data.cellId

		return this
	}
}

export interface RawGameActionFightActivateGlyphTrapMessage
	extends RawAbstractGameActionMessage {
	id: number
	markId: number
	active: boolean
}

export class GameActionFightActivateGlyphTrapMessage extends AbstractGameActionMessage {
	public static id = 449

	public markId: number | undefined = 0
	public active: boolean | undefined = false

	public constructor(
		actionId?: number | undefined,
		sourceId?: number | undefined,
		markId?: number | undefined,
		active?: boolean | undefined
	) {
		super(actionId, sourceId)
		this.markId = markId
		this.active = active
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeShort(this.markId!)
		writer.writeBoolean(this.active!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.markId = reader.readShort()
		this.active = reader.readBoolean()
	}

	public hydrate(
		data: GameActionFightActivateGlyphTrapMessage | Record<string, any>
	): GameActionFightActivateGlyphTrapMessage {
		if (data instanceof GameActionFightActivateGlyphTrapMessage) {
			return data
		}

		super.hydrate(data)

		this.markId = data.markId
		this.active = data.active

		return this
	}
}

export interface RawGameActionFightUnmarkCellsMessage
	extends RawAbstractGameActionMessage {
	id: number
	markId: number
}

export class GameActionFightUnmarkCellsMessage extends AbstractGameActionMessage {
	public static id = 4963

	public markId: number | undefined = 0

	public constructor(
		actionId?: number | undefined,
		sourceId?: number | undefined,
		markId?: number | undefined
	) {
		super(actionId, sourceId)
		this.markId = markId
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeShort(this.markId!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.markId = reader.readShort()
	}

	public hydrate(
		data: GameActionFightUnmarkCellsMessage | Record<string, any>
	): GameActionFightUnmarkCellsMessage {
		if (data instanceof GameActionFightUnmarkCellsMessage) {
			return data
		}

		super.hydrate(data)

		this.markId = data.markId

		return this
	}
}

export interface RawGameActionFightReflectDamagesMessage
	extends RawAbstractGameActionMessage {
	id: number
	targetId: number
}

export class GameActionFightReflectDamagesMessage extends AbstractGameActionMessage {
	public static id = 7605

	public targetId: number | undefined = 0

	public constructor(
		actionId?: number | undefined,
		sourceId?: number | undefined,
		targetId?: number | undefined
	) {
		super(actionId, sourceId)
		this.targetId = targetId
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeDouble(this.targetId!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.targetId = reader.readDouble()
	}

	public hydrate(
		data: GameActionFightReflectDamagesMessage | Record<string, any>
	): GameActionFightReflectDamagesMessage {
		if (data instanceof GameActionFightReflectDamagesMessage) {
			return data
		}

		super.hydrate(data)

		this.targetId = data.targetId

		return this
	}
}

export interface RawGameActionFightExchangePositionsMessage
	extends RawAbstractGameActionMessage {
	id: number
	targetId: number
	casterCellId: number
	targetCellId: number
}

export class GameActionFightExchangePositionsMessage extends AbstractGameActionMessage {
	public static id = 640

	public targetId: number | undefined = 0
	public casterCellId: number | undefined = 0
	public targetCellId: number | undefined = 0

	public constructor(
		actionId?: number | undefined,
		sourceId?: number | undefined,
		targetId?: number | undefined,
		casterCellId?: number | undefined,
		targetCellId?: number | undefined
	) {
		super(actionId, sourceId)
		this.targetId = targetId
		this.casterCellId = casterCellId
		this.targetCellId = targetCellId
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeDouble(this.targetId!)
		writer.writeShort(this.casterCellId!)
		writer.writeShort(this.targetCellId!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.targetId = reader.readDouble()
		this.casterCellId = reader.readShort()
		this.targetCellId = reader.readShort()
	}

	public hydrate(
		data: GameActionFightExchangePositionsMessage | Record<string, any>
	): GameActionFightExchangePositionsMessage {
		if (data instanceof GameActionFightExchangePositionsMessage) {
			return data
		}

		super.hydrate(data)

		this.targetId = data.targetId
		this.casterCellId = data.casterCellId
		this.targetCellId = data.targetCellId

		return this
	}
}

export interface RawMapComplementaryInformationsDataMessage {
	id: number
	subAreaId: number
	mapId: number
	houses: HouseInformations[]
	actors: GameRolePlayActorInformations[]
	interactiveElements: InteractiveElement[]
	statedElements: StatedElement[]
	obstacles: MapObstacle[]
	fights: FightCommonInformations[]
	hasAggressiveMonsters: boolean
	fightStartPositions: FightStartingPositions
}

export class MapComplementaryInformationsDataMessage extends DofusMessage {
	public static id: number = 7827

	public subAreaId: number | undefined = 0
	public mapId: number | undefined = 0
	public houses: HouseInformations[] | undefined
	public actors: GameRolePlayActorInformations[] | undefined
	public interactiveElements: InteractiveElement[] | undefined
	public statedElements: StatedElement[] | undefined
	public obstacles: MapObstacle[] | undefined
	public fights: FightCommonInformations[] | undefined
	public hasAggressiveMonsters: boolean | undefined = false
	public fightStartPositions: FightStartingPositions | undefined

	public constructor(
		subAreaId?: number | undefined,
		mapId?: number | undefined,
		houses?: HouseInformations[] | undefined,
		actors?: GameRolePlayActorInformations[] | undefined,
		interactiveElements?: InteractiveElement[] | undefined,
		statedElements?: StatedElement[] | undefined,
		obstacles?: MapObstacle[] | undefined,
		fights?: FightCommonInformations[] | undefined,
		hasAggressiveMonsters?: boolean | undefined,
		fightStartPositions?: FightStartingPositions | undefined
	) {
		super()
		this.subAreaId = subAreaId
		this.mapId = mapId
		this.houses = houses
		this.actors = actors
		this.interactiveElements = interactiveElements
		this.statedElements = statedElements
		this.obstacles = obstacles
		this.fights = fights
		this.hasAggressiveMonsters = hasAggressiveMonsters
		this.fightStartPositions = fightStartPositions
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarShort(this.subAreaId!)
		writer.writeDouble(this.mapId!)
		writer.writeShort(this.houses!.length)
		this.houses!.forEach((current) => {
			writer.writeShort(current.id)
			current.serialize(writer)
		})
		writer.writeShort(this.actors!.length)
		this.actors!.forEach((current) => {
			writer.writeShort(current.id)
			current.serialize(writer)
		})
		writer.writeShort(this.interactiveElements!.length)
		this.interactiveElements!.forEach((current) => {
			writer.writeShort(current.id)
			current.serialize(writer)
		})
		writer.writeShort(this.statedElements!.length)
		this.statedElements!.forEach((current) => {
			current.serialize(writer)
		})
		writer.writeShort(this.obstacles!.length)
		this.obstacles!.forEach((current) => {
			current.serialize(writer)
		})
		writer.writeShort(this.fights!.length)
		this.fights!.forEach((current) => {
			current.serialize(writer)
		})
		writer.writeBoolean(this.hasAggressiveMonsters!)
		this.fightStartPositions!.serialize(writer)
	}

	public deserialize(reader: BinaryReader): void {
		this.subAreaId = reader.readVarShort()
		this.mapId = reader.readDouble()
		this.houses = []
		const countHouses = reader.readShort()
		for (let i: number = 0; i < countHouses; i++) {
			const housesTypeId: number = reader.readShort()
			const type: HouseInformations = new types[
				housesTypeId
			]() as HouseInformations
			type.deserialize(reader)
			this.houses.push(type)
		}
		this.actors = []
		const countActors = reader.readShort()
		for (let i: number = 0; i < countActors; i++) {
			const actorsTypeId: number = reader.readShort()
			const type: GameRolePlayActorInformations = new types[
				actorsTypeId
			]() as GameRolePlayActorInformations
			type.deserialize(reader)
			this.actors.push(type)
		}
		this.interactiveElements = []
		const countInteractiveElements = reader.readShort()
		for (let i: number = 0; i < countInteractiveElements; i++) {
			const interactiveElementsTypeId: number = reader.readShort()
			const type: InteractiveElement = new types[
				interactiveElementsTypeId
			]() as InteractiveElement
			type.deserialize(reader)
			this.interactiveElements.push(type)
		}
		this.statedElements = []
		const countStatedElements = reader.readShort()
		for (let i: number = 0; i < countStatedElements; i++) {
			const type: StatedElement = new StatedElement()
			type.deserialize(reader)
			this.statedElements.push(type)
		}
		this.obstacles = []
		const countObstacles = reader.readShort()
		for (let i: number = 0; i < countObstacles; i++) {
			const type: MapObstacle = new MapObstacle()
			type.deserialize(reader)
			this.obstacles.push(type)
		}
		this.fights = []
		const countFights = reader.readShort()
		for (let i: number = 0; i < countFights; i++) {
			const type: FightCommonInformations = new FightCommonInformations()
			type.deserialize(reader)
			this.fights.push(type)
		}
		this.hasAggressiveMonsters = reader.readBoolean()
		this.fightStartPositions = new FightStartingPositions()
		this.fightStartPositions!.deserialize(reader)
	}

	public hydrate(
		data: MapComplementaryInformationsDataMessage | Record<string, any>
	): MapComplementaryInformationsDataMessage {
		if (data instanceof MapComplementaryInformationsDataMessage) {
			return data
		}

		this.subAreaId = data.subAreaId
		this.mapId = data.mapId
		this.houses = data.houses.map(
			(
				dataElement: HouseInformations | Record<string, any>
			): HouseInformations => {
				if (dataElement instanceof HouseInformations) {
					return dataElement
				} else {
					return (new types[dataElement.id]() as HouseInformations).hydrate(
						dataElement
					)
				}
			}
		)
		this.actors = data.actors.map(
			(
				dataElement: GameRolePlayActorInformations | Record<string, any>
			): GameRolePlayActorInformations => {
				if (dataElement instanceof GameRolePlayActorInformations) {
					return dataElement
				} else {
					return (new types[
						dataElement.id
					]() as GameRolePlayActorInformations).hydrate(dataElement)
				}
			}
		)
		this.interactiveElements = data.interactiveElements.map(
			(
				dataElement: InteractiveElement | Record<string, any>
			): InteractiveElement => {
				if (dataElement instanceof InteractiveElement) {
					return dataElement
				} else {
					return (new types[dataElement.id]() as InteractiveElement).hydrate(
						dataElement
					)
				}
			}
		)
		this.statedElements = data.statedElements.map(
			(dataElement: StatedElement | Record<string, any>): StatedElement => {
				if (dataElement instanceof StatedElement) {
					return dataElement
				} else {
					return new StatedElement().hydrate(dataElement)
				}
			}
		)
		this.obstacles = data.obstacles.map(
			(dataElement: MapObstacle | Record<string, any>): MapObstacle => {
				if (dataElement instanceof MapObstacle) {
					return dataElement
				} else {
					return new MapObstacle().hydrate(dataElement)
				}
			}
		)
		this.fights = data.fights.map(
			(
				dataElement: FightCommonInformations | Record<string, any>
			): FightCommonInformations => {
				if (dataElement instanceof FightCommonInformations) {
					return dataElement
				} else {
					return new FightCommonInformations().hydrate(dataElement)
				}
			}
		)
		this.hasAggressiveMonsters = data.hasAggressiveMonsters
		this.fightStartPositions = new FightStartingPositions().hydrate(
			data.fightStartPositions
		)

		return this
	}
}

export interface RawMapComplementaryInformationsAnomalyMessage
	extends RawMapComplementaryInformationsDataMessage {
	id: number
	level: number
	closingTime: number
}

export class MapComplementaryInformationsAnomalyMessage extends MapComplementaryInformationsDataMessage {
	public static id = 8604

	public level: number | undefined = 0
	public closingTime: number | undefined = 0

	public constructor(
		subAreaId?: number | undefined,
		mapId?: number | undefined,
		houses?: HouseInformations[] | undefined,
		actors?: GameRolePlayActorInformations[] | undefined,
		interactiveElements?: InteractiveElement[] | undefined,
		statedElements?: StatedElement[] | undefined,
		obstacles?: MapObstacle[] | undefined,
		fights?: FightCommonInformations[] | undefined,
		hasAggressiveMonsters?: boolean | undefined,
		fightStartPositions?: FightStartingPositions | undefined,
		level?: number | undefined,
		closingTime?: number | undefined
	) {
		super(
			subAreaId,
			mapId,
			houses,
			actors,
			interactiveElements,
			statedElements,
			obstacles,
			fights,
			hasAggressiveMonsters,
			fightStartPositions
		)
		this.level = level
		this.closingTime = closingTime
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeVarShort(this.level!)
		writer.writeVarLong(this.closingTime!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.level = reader.readVarShort()
		this.closingTime = reader.readVarLong()
	}

	public hydrate(
		data: MapComplementaryInformationsAnomalyMessage | Record<string, any>
	): MapComplementaryInformationsAnomalyMessage {
		if (data instanceof MapComplementaryInformationsAnomalyMessage) {
			return data
		}

		super.hydrate(data)

		this.level = data.level
		this.closingTime = data.closingTime

		return this
	}
}

export interface RawMapNpcsQuestStatusUpdateMessage {
	id: number
	mapId: number
	npcsIdsWithQuest: number[]
	questFlags: GameRolePlayNpcQuestFlag[]
	npcsIdsWithoutQuest: number[]
}

export class MapNpcsQuestStatusUpdateMessage extends DofusMessage {
	public static id: number = 8038

	public mapId: number | undefined = 0
	public npcsIdsWithQuest: number[] | undefined
	public questFlags: GameRolePlayNpcQuestFlag[] | undefined
	public npcsIdsWithoutQuest: number[] | undefined

	public constructor(
		mapId?: number | undefined,
		npcsIdsWithQuest?: number[] | undefined,
		questFlags?: GameRolePlayNpcQuestFlag[] | undefined,
		npcsIdsWithoutQuest?: number[] | undefined
	) {
		super()
		this.mapId = mapId
		this.npcsIdsWithQuest = npcsIdsWithQuest
		this.questFlags = questFlags
		this.npcsIdsWithoutQuest = npcsIdsWithoutQuest
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeDouble(this.mapId!)
		writer.writeShort(this.npcsIdsWithQuest!.length)
		this.npcsIdsWithQuest!.forEach((current: number) =>
			writer.writeInt(current)
		)
		writer.writeShort(this.questFlags!.length)
		this.questFlags!.forEach((current) => {
			current.serialize(writer)
		})
		writer.writeShort(this.npcsIdsWithoutQuest!.length)
		this.npcsIdsWithoutQuest!.forEach((current: number) =>
			writer.writeInt(current)
		)
	}

	public deserialize(reader: BinaryReader): void {
		this.mapId = reader.readDouble()
		this.npcsIdsWithQuest = []
		const countNpcsIdsWithQuest = reader.readShort()
		for (let i: number = 0; i < countNpcsIdsWithQuest; i++) {
			this.npcsIdsWithQuest.push(reader.readInt())
		}
		this.questFlags = []
		const countQuestFlags = reader.readShort()
		for (let i: number = 0; i < countQuestFlags; i++) {
			const type: GameRolePlayNpcQuestFlag = new GameRolePlayNpcQuestFlag()
			type.deserialize(reader)
			this.questFlags.push(type)
		}
		this.npcsIdsWithoutQuest = []
		const countNpcsIdsWithoutQuest = reader.readShort()
		for (let i: number = 0; i < countNpcsIdsWithoutQuest; i++) {
			this.npcsIdsWithoutQuest.push(reader.readInt())
		}
	}

	public hydrate(
		data: MapNpcsQuestStatusUpdateMessage | Record<string, any>
	): MapNpcsQuestStatusUpdateMessage {
		if (data instanceof MapNpcsQuestStatusUpdateMessage) {
			return data
		}

		this.mapId = data.mapId
		this.npcsIdsWithQuest = data.npcsIdsWithQuest
		this.questFlags = data.questFlags.map(
			(
				dataElement: GameRolePlayNpcQuestFlag | Record<string, any>
			): GameRolePlayNpcQuestFlag => {
				if (dataElement instanceof GameRolePlayNpcQuestFlag) {
					return dataElement
				} else {
					return new GameRolePlayNpcQuestFlag().hydrate(dataElement)
				}
			}
		)
		this.npcsIdsWithoutQuest = data.npcsIdsWithoutQuest

		return this
	}
}

export interface RawGameFightUpdateTeamMessage {
	id: number
	fightId: number
	team: FightTeamInformations
}

export class GameFightUpdateTeamMessage extends DofusMessage {
	public static id: number = 9746

	public fightId: number | undefined = 0
	public team: FightTeamInformations | undefined

	public constructor(
		fightId?: number | undefined,
		team?: FightTeamInformations | undefined
	) {
		super()
		this.fightId = fightId
		this.team = team
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarShort(this.fightId!)
		this.team!.serialize(writer)
	}

	public deserialize(reader: BinaryReader): void {
		this.fightId = reader.readVarShort()
		this.team = new FightTeamInformations()
		this.team!.deserialize(reader)
	}

	public hydrate(
		data: GameFightUpdateTeamMessage | Record<string, any>
	): GameFightUpdateTeamMessage {
		if (data instanceof GameFightUpdateTeamMessage) {
			return data
		}

		this.fightId = data.fightId
		this.team = new FightTeamInformations().hydrate(data.team)

		return this
	}
}

export interface RawGameDataPaddockObjectRemoveMessage {
	id: number
	cellId: number
}

export class GameDataPaddockObjectRemoveMessage extends DofusMessage {
	public static id: number = 5650

	public cellId: number | undefined = 0

	public constructor(cellId?: number | undefined) {
		super()
		this.cellId = cellId
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarShort(this.cellId!)
	}

	public deserialize(reader: BinaryReader): void {
		this.cellId = reader.readVarShort()
	}

	public hydrate(
		data: GameDataPaddockObjectRemoveMessage | Record<string, any>
	): GameDataPaddockObjectRemoveMessage {
		if (data instanceof GameDataPaddockObjectRemoveMessage) {
			return data
		}

		this.cellId = data.cellId

		return this
	}
}

export interface RawObjectGroundRemovedMultipleMessage {
	id: number
	cells: number[]
}

export class ObjectGroundRemovedMultipleMessage extends DofusMessage {
	public static id: number = 420

	public cells: number[] | undefined

	public constructor(cells?: number[] | undefined) {
		super()
		this.cells = cells
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeShort(this.cells!.length)
		this.cells!.forEach((current: number) => writer.writeVarShort(current))
	}

	public deserialize(reader: BinaryReader): void {
		this.cells = []
		const countCells = reader.readShort()
		for (let i: number = 0; i < countCells; i++) {
			this.cells.push(reader.readVarShort())
		}
	}

	public hydrate(
		data: ObjectGroundRemovedMultipleMessage | Record<string, any>
	): ObjectGroundRemovedMultipleMessage {
		if (data instanceof ObjectGroundRemovedMultipleMessage) {
			return data
		}

		this.cells = data.cells

		return this
	}
}

export interface RawGameFightRemoveTeamMemberMessage {
	id: number
	fightId: number
	teamId: number
	charId: number
}

export class GameFightRemoveTeamMemberMessage extends DofusMessage {
	public static id: number = 8993

	public fightId: number | undefined = 0
	public teamId: number | undefined = 2
	public charId: number | undefined = 0

	public constructor(
		fightId?: number | undefined,
		teamId?: number | undefined,
		charId?: number | undefined
	) {
		super()
		this.fightId = fightId
		this.teamId = teamId
		this.charId = charId
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarShort(this.fightId!)
		writer.writeByte(this.teamId!)
		writer.writeDouble(this.charId!)
	}

	public deserialize(reader: BinaryReader): void {
		this.fightId = reader.readVarShort()
		this.teamId = reader.readByte()
		this.charId = reader.readDouble()
	}

	public hydrate(
		data: GameFightRemoveTeamMemberMessage | Record<string, any>
	): GameFightRemoveTeamMemberMessage {
		if (data instanceof GameFightRemoveTeamMemberMessage) {
			return data
		}

		this.fightId = data.fightId
		this.teamId = data.teamId
		this.charId = data.charId

		return this
	}
}

export interface RawEmotePlayRequestMessage {
	id: number
	emoteId: number
}

export class EmotePlayRequestMessage extends DofusMessage {
	public static id: number = 4945

	public emoteId: number | undefined = 0

	public constructor(emoteId?: number | undefined) {
		super()
		this.emoteId = emoteId
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeByte(this.emoteId!)
	}

	public deserialize(reader: BinaryReader): void {
		this.emoteId = reader.readByte()
	}

	public hydrate(
		data: EmotePlayRequestMessage | Record<string, any>
	): EmotePlayRequestMessage {
		if (data instanceof EmotePlayRequestMessage) {
			return data
		}

		this.emoteId = data.emoteId

		return this
	}
}

export interface RawUpdateMapPlayersAgressableStatusMessage {
	id: number
	playerIds: number[]
	enable: number[]
}

export class UpdateMapPlayersAgressableStatusMessage extends DofusMessage {
	public static id: number = 2008

	public playerIds: number[] | undefined
	public enable: number[] | undefined

	public constructor(
		playerIds?: number[] | undefined,
		enable?: number[] | undefined
	) {
		super()
		this.playerIds = playerIds
		this.enable = enable
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeShort(this.playerIds!.length)
		this.playerIds!.forEach((current: number) => writer.writeVarLong(current))
		writer.writeShort(this.enable!.length)
		this.enable!.forEach((current: number) => writer.writeByte(current))
	}

	public deserialize(reader: BinaryReader): void {
		this.playerIds = []
		const countPlayerIds = reader.readShort()
		for (let i: number = 0; i < countPlayerIds; i++) {
			this.playerIds.push(reader.readVarLong())
		}
		this.enable = []
		const countEnable = reader.readShort()
		for (let i: number = 0; i < countEnable; i++) {
			this.enable.push(reader.readByte())
		}
	}

	public hydrate(
		data: UpdateMapPlayersAgressableStatusMessage | Record<string, any>
	): UpdateMapPlayersAgressableStatusMessage {
		if (data instanceof UpdateMapPlayersAgressableStatusMessage) {
			return data
		}

		this.playerIds = data.playerIds
		this.enable = data.enable

		return this
	}
}

export interface RawPaddockMoveItemRequestMessage {
	id: number
	oldCellId: number
	newCellId: number
}

export class PaddockMoveItemRequestMessage extends DofusMessage {
	public static id: number = 5652

	public oldCellId: number | undefined = 0
	public newCellId: number | undefined = 0

	public constructor(
		oldCellId?: number | undefined,
		newCellId?: number | undefined
	) {
		super()
		this.oldCellId = oldCellId
		this.newCellId = newCellId
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarShort(this.oldCellId!)
		writer.writeVarShort(this.newCellId!)
	}

	public deserialize(reader: BinaryReader): void {
		this.oldCellId = reader.readVarShort()
		this.newCellId = reader.readVarShort()
	}

	public hydrate(
		data: PaddockMoveItemRequestMessage | Record<string, any>
	): PaddockMoveItemRequestMessage {
		if (data instanceof PaddockMoveItemRequestMessage) {
			return data
		}

		this.oldCellId = data.oldCellId
		this.newCellId = data.newCellId

		return this
	}
}

export interface RawObjectGroundListAddedMessage {
	id: number
	cells: number[]
	referenceIds: number[]
}

export class ObjectGroundListAddedMessage extends DofusMessage {
	public static id: number = 2797

	public cells: number[] | undefined
	public referenceIds: number[] | undefined

	public constructor(
		cells?: number[] | undefined,
		referenceIds?: number[] | undefined
	) {
		super()
		this.cells = cells
		this.referenceIds = referenceIds
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeShort(this.cells!.length)
		this.cells!.forEach((current: number) => writer.writeVarShort(current))
		writer.writeShort(this.referenceIds!.length)
		this.referenceIds!.forEach((current: number) =>
			writer.writeVarShort(current)
		)
	}

	public deserialize(reader: BinaryReader): void {
		this.cells = []
		const countCells = reader.readShort()
		for (let i: number = 0; i < countCells; i++) {
			this.cells.push(reader.readVarShort())
		}
		this.referenceIds = []
		const countReferenceIds = reader.readShort()
		for (let i: number = 0; i < countReferenceIds; i++) {
			this.referenceIds.push(reader.readVarShort())
		}
	}

	public hydrate(
		data: ObjectGroundListAddedMessage | Record<string, any>
	): ObjectGroundListAddedMessage {
		if (data instanceof ObjectGroundListAddedMessage) {
			return data
		}

		this.cells = data.cells
		this.referenceIds = data.referenceIds

		return this
	}
}

export interface RawUpdateSelfAgressableStatusMessage {
	id: number
	status: number
	probationTime: number
}

export class UpdateSelfAgressableStatusMessage extends DofusMessage {
	public static id: number = 7042

	public status: number | undefined = 0
	public probationTime: number | undefined = 0

	public constructor(
		status?: number | undefined,
		probationTime?: number | undefined
	) {
		super()
		this.status = status
		this.probationTime = probationTime
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeByte(this.status!)
		writer.writeInt(this.probationTime!)
	}

	public deserialize(reader: BinaryReader): void {
		this.status = reader.readByte()
		this.probationTime = reader.readInt()
	}

	public hydrate(
		data: UpdateSelfAgressableStatusMessage | Record<string, any>
	): UpdateSelfAgressableStatusMessage {
		if (data instanceof UpdateSelfAgressableStatusMessage) {
			return data
		}

		this.status = data.status
		this.probationTime = data.probationTime

		return this
	}
}

export interface RawMapComplementaryInformationsWithCoordsMessage
	extends RawMapComplementaryInformationsDataMessage {
	id: number
	worldX: number
	worldY: number
}

export class MapComplementaryInformationsWithCoordsMessage extends MapComplementaryInformationsDataMessage {
	public static id = 5308

	public worldX: number | undefined = 0
	public worldY: number | undefined = 0

	public constructor(
		subAreaId?: number | undefined,
		mapId?: number | undefined,
		houses?: HouseInformations[] | undefined,
		actors?: GameRolePlayActorInformations[] | undefined,
		interactiveElements?: InteractiveElement[] | undefined,
		statedElements?: StatedElement[] | undefined,
		obstacles?: MapObstacle[] | undefined,
		fights?: FightCommonInformations[] | undefined,
		hasAggressiveMonsters?: boolean | undefined,
		fightStartPositions?: FightStartingPositions | undefined,
		worldX?: number | undefined,
		worldY?: number | undefined
	) {
		super(
			subAreaId,
			mapId,
			houses,
			actors,
			interactiveElements,
			statedElements,
			obstacles,
			fights,
			hasAggressiveMonsters,
			fightStartPositions
		)
		this.worldX = worldX
		this.worldY = worldY
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeShort(this.worldX!)
		writer.writeShort(this.worldY!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.worldX = reader.readShort()
		this.worldY = reader.readShort()
	}

	public hydrate(
		data: MapComplementaryInformationsWithCoordsMessage | Record<string, any>
	): MapComplementaryInformationsWithCoordsMessage {
		if (data instanceof MapComplementaryInformationsWithCoordsMessage) {
			return data
		}

		super.hydrate(data)

		this.worldX = data.worldX
		this.worldY = data.worldY

		return this
	}
}

export interface RawGameContextRefreshEntityLookMessage {
	id: number
	id_: number
	look: EntityLook
}

export class GameContextRefreshEntityLookMessage extends DofusMessage {
	public static id: number = 2017

	public id_: number | undefined = 0
	public look: EntityLook | undefined

	public constructor(id_?: number | undefined, look?: EntityLook | undefined) {
		super()
		this.id_ = id_
		this.look = look
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeDouble(this.id_!)
		this.look!.serialize(writer)
	}

	public deserialize(reader: BinaryReader): void {
		this.id_ = reader.readDouble()
		this.look = new EntityLook()
		this.look!.deserialize(reader)
	}

	public hydrate(
		data: GameContextRefreshEntityLookMessage | Record<string, any>
	): GameContextRefreshEntityLookMessage {
		if (data instanceof GameContextRefreshEntityLookMessage) {
			return data
		}

		this.id_ = data.id_
		this.look = new EntityLook().hydrate(data.look)

		return this
	}
}

export interface RawMapComplementaryInformationsDataInHavenBagMessage
	extends RawMapComplementaryInformationsDataMessage {
	id: number
	ownerInformations: CharacterMinimalInformations
	theme: number
	roomId: number
	maxRoomId: number
}

export class MapComplementaryInformationsDataInHavenBagMessage extends MapComplementaryInformationsDataMessage {
	public static id = 4332

	public ownerInformations: CharacterMinimalInformations | undefined
	public theme: number | undefined = 0
	public roomId: number | undefined = 0
	public maxRoomId: number | undefined = 0

	public constructor(
		subAreaId?: number | undefined,
		mapId?: number | undefined,
		houses?: HouseInformations[] | undefined,
		actors?: GameRolePlayActorInformations[] | undefined,
		interactiveElements?: InteractiveElement[] | undefined,
		statedElements?: StatedElement[] | undefined,
		obstacles?: MapObstacle[] | undefined,
		fights?: FightCommonInformations[] | undefined,
		hasAggressiveMonsters?: boolean | undefined,
		fightStartPositions?: FightStartingPositions | undefined,
		ownerInformations?: CharacterMinimalInformations | undefined,
		theme?: number | undefined,
		roomId?: number | undefined,
		maxRoomId?: number | undefined
	) {
		super(
			subAreaId,
			mapId,
			houses,
			actors,
			interactiveElements,
			statedElements,
			obstacles,
			fights,
			hasAggressiveMonsters,
			fightStartPositions
		)
		this.ownerInformations = ownerInformations
		this.theme = theme
		this.roomId = roomId
		this.maxRoomId = maxRoomId
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		this.ownerInformations!.serialize(writer)
		writer.writeByte(this.theme!)
		writer.writeByte(this.roomId!)
		writer.writeByte(this.maxRoomId!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.ownerInformations = new CharacterMinimalInformations()
		this.ownerInformations!.deserialize(reader)
		this.theme = reader.readByte()
		this.roomId = reader.readByte()
		this.maxRoomId = reader.readByte()
	}

	public hydrate(
		data:
			| MapComplementaryInformationsDataInHavenBagMessage
			| Record<string, any>
	): MapComplementaryInformationsDataInHavenBagMessage {
		if (data instanceof MapComplementaryInformationsDataInHavenBagMessage) {
			return data
		}

		super.hydrate(data)

		this.ownerInformations = new CharacterMinimalInformations().hydrate(
			data.ownerInformations
		)
		this.theme = data.theme
		this.roomId = data.roomId
		this.maxRoomId = data.maxRoomId

		return this
	}
}

export interface RawBreachExitResponseMessage {
	id: number
	exited: boolean
}

export class BreachExitResponseMessage extends DofusMessage {
	public static id: number = 3311

	public exited: boolean | undefined = false

	public constructor(exited?: boolean | undefined) {
		super()
		this.exited = exited
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeBoolean(this.exited!)
	}

	public deserialize(reader: BinaryReader): void {
		this.exited = reader.readBoolean()
	}

	public hydrate(
		data: BreachExitResponseMessage | Record<string, any>
	): BreachExitResponseMessage {
		if (data instanceof BreachExitResponseMessage) {
			return data
		}

		this.exited = data.exited

		return this
	}
}

export interface RawPaddockRemoveItemRequestMessage {
	id: number
	cellId: number
}

export class PaddockRemoveItemRequestMessage extends DofusMessage {
	public static id: number = 7954

	public cellId: number | undefined = 0

	public constructor(cellId?: number | undefined) {
		super()
		this.cellId = cellId
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarShort(this.cellId!)
	}

	public deserialize(reader: BinaryReader): void {
		this.cellId = reader.readVarShort()
	}

	public hydrate(
		data: PaddockRemoveItemRequestMessage | Record<string, any>
	): PaddockRemoveItemRequestMessage {
		if (data instanceof PaddockRemoveItemRequestMessage) {
			return data
		}

		this.cellId = data.cellId

		return this
	}
}

export interface RawGameMapChangeOrientationMessage {
	id: number
	orientation: ActorOrientation
}

export class GameMapChangeOrientationMessage extends DofusMessage {
	public static id: number = 5147

	public orientation: ActorOrientation | undefined

	public constructor(orientation?: ActorOrientation | undefined) {
		super()
		this.orientation = orientation
	}

	public serialize(writer: BinaryWriter): void {
		this.orientation!.serialize(writer)
	}

	public deserialize(reader: BinaryReader): void {
		this.orientation = new ActorOrientation()
		this.orientation!.deserialize(reader)
	}

	public hydrate(
		data: GameMapChangeOrientationMessage | Record<string, any>
	): GameMapChangeOrientationMessage {
		if (data instanceof GameMapChangeOrientationMessage) {
			return data
		}

		this.orientation = new ActorOrientation().hydrate(data.orientation)

		return this
	}
}

export interface RawObjectGroundAddedMessage {
	id: number
	cellId: number
	objectGID: number
}

export class ObjectGroundAddedMessage extends DofusMessage {
	public static id: number = 3539

	public cellId: number | undefined = 0
	public objectGID: number | undefined = 0

	public constructor(
		cellId?: number | undefined,
		objectGID?: number | undefined
	) {
		super()
		this.cellId = cellId
		this.objectGID = objectGID
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarShort(this.cellId!)
		writer.writeVarShort(this.objectGID!)
	}

	public deserialize(reader: BinaryReader): void {
		this.cellId = reader.readVarShort()
		this.objectGID = reader.readVarShort()
	}

	public hydrate(
		data: ObjectGroundAddedMessage | Record<string, any>
	): ObjectGroundAddedMessage {
		if (data instanceof ObjectGroundAddedMessage) {
			return data
		}

		this.cellId = data.cellId
		this.objectGID = data.objectGID

		return this
	}
}

export interface RawBreachEnterMessage {
	id: number
	owner: number
}

export class BreachEnterMessage extends DofusMessage {
	public static id: number = 9979

	public owner: number | undefined = 0

	public constructor(owner?: number | undefined) {
		super()
		this.owner = owner
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarLong(this.owner!)
	}

	public deserialize(reader: BinaryReader): void {
		this.owner = reader.readVarLong()
	}

	public hydrate(
		data: BreachEnterMessage | Record<string, any>
	): BreachEnterMessage {
		if (data instanceof BreachEnterMessage) {
			return data
		}

		this.owner = data.owner

		return this
	}
}

export interface RawGameRolePlayShowActorMessage {
	id: number
	informations: GameRolePlayActorInformations
}

export class GameRolePlayShowActorMessage extends DofusMessage {
	public static id: number = 6727

	public informations: GameRolePlayActorInformations | undefined

	public constructor(informations?: GameRolePlayActorInformations | undefined) {
		super()
		this.informations = informations
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeShort(this.informations!.id)
		this.informations!.serialize(writer)
	}

	public deserialize(reader: BinaryReader): void {
		const informationsTypeId: number = reader.readShort()
		this.informations = new types[
			informationsTypeId
		]() as GameRolePlayActorInformations
		this.informations!.deserialize(reader)
	}

	public hydrate(
		data: GameRolePlayShowActorMessage | Record<string, any>
	): GameRolePlayShowActorMessage {
		if (data instanceof GameRolePlayShowActorMessage) {
			return data
		}

		this.informations = (new types[
			data.informations.id
		]() as GameRolePlayActorInformations).hydrate(data.informations)
		return this
	}
}

export interface RawGameDataPlayFarmObjectAnimationMessage {
	id: number
	cellId: number[]
}

export class GameDataPlayFarmObjectAnimationMessage extends DofusMessage {
	public static id: number = 8442

	public cellId: number[] | undefined

	public constructor(cellId?: number[] | undefined) {
		super()
		this.cellId = cellId
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeShort(this.cellId!.length)
		this.cellId!.forEach((current: number) => writer.writeVarShort(current))
	}

	public deserialize(reader: BinaryReader): void {
		this.cellId = []
		const countCellId = reader.readShort()
		for (let i: number = 0; i < countCellId; i++) {
			this.cellId.push(reader.readVarShort())
		}
	}

	public hydrate(
		data: GameDataPlayFarmObjectAnimationMessage | Record<string, any>
	): GameDataPlayFarmObjectAnimationMessage {
		if (data instanceof GameDataPlayFarmObjectAnimationMessage) {
			return data
		}

		this.cellId = data.cellId

		return this
	}
}

export interface RawGameRolePlayShowChallengeMessage {
	id: number
	commonsInfos: FightCommonInformations
}

export class GameRolePlayShowChallengeMessage extends DofusMessage {
	public static id: number = 6006

	public commonsInfos: FightCommonInformations | undefined

	public constructor(commonsInfos?: FightCommonInformations | undefined) {
		super()
		this.commonsInfos = commonsInfos
	}

	public serialize(writer: BinaryWriter): void {
		this.commonsInfos!.serialize(writer)
	}

	public deserialize(reader: BinaryReader): void {
		this.commonsInfos = new FightCommonInformations()
		this.commonsInfos!.deserialize(reader)
	}

	public hydrate(
		data: GameRolePlayShowChallengeMessage | Record<string, any>
	): GameRolePlayShowChallengeMessage {
		if (data instanceof GameRolePlayShowChallengeMessage) {
			return data
		}

		this.commonsInfos = new FightCommonInformations().hydrate(data.commonsInfos)

		return this
	}
}

export interface RawGameRolePlayRemoveChallengeMessage {
	id: number
	fightId: number
}

export class GameRolePlayRemoveChallengeMessage extends DofusMessage {
	public static id: number = 9279

	public fightId: number | undefined = 0

	public constructor(fightId?: number | undefined) {
		super()
		this.fightId = fightId
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarShort(this.fightId!)
	}

	public deserialize(reader: BinaryReader): void {
		this.fightId = reader.readVarShort()
	}

	public hydrate(
		data: GameRolePlayRemoveChallengeMessage | Record<string, any>
	): GameRolePlayRemoveChallengeMessage {
		if (data instanceof GameRolePlayRemoveChallengeMessage) {
			return data
		}

		this.fightId = data.fightId

		return this
	}
}

export interface RawMapRewardRateMessage {
	id: number
	mapRate: number
	subAreaRate: number
	totalRate: number
}

export class MapRewardRateMessage extends DofusMessage {
	public static id: number = 2130

	public mapRate: number | undefined = 0
	public subAreaRate: number | undefined = 0
	public totalRate: number | undefined = 0

	public constructor(
		mapRate?: number | undefined,
		subAreaRate?: number | undefined,
		totalRate?: number | undefined
	) {
		super()
		this.mapRate = mapRate
		this.subAreaRate = subAreaRate
		this.totalRate = totalRate
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarShort(this.mapRate!)
		writer.writeVarShort(this.subAreaRate!)
		writer.writeVarShort(this.totalRate!)
	}

	public deserialize(reader: BinaryReader): void {
		this.mapRate = reader.readVarShort()
		this.subAreaRate = reader.readVarShort()
		this.totalRate = reader.readVarShort()
	}

	public hydrate(
		data: MapRewardRateMessage | Record<string, any>
	): MapRewardRateMessage {
		if (data instanceof MapRewardRateMessage) {
			return data
		}

		this.mapRate = data.mapRate
		this.subAreaRate = data.subAreaRate
		this.totalRate = data.totalRate

		return this
	}
}

export interface RawGameRolePlayMonsterAngryAtPlayerMessage {
	id: number
	playerId: number
	monsterGroupId: number
	angryStartTime: number
	attackTime: number
}

export class GameRolePlayMonsterAngryAtPlayerMessage extends DofusMessage {
	public static id: number = 4325

	public playerId: number | undefined = 0
	public monsterGroupId: number | undefined = 0
	public angryStartTime: number | undefined = 0
	public attackTime: number | undefined = 0

	public constructor(
		playerId?: number | undefined,
		monsterGroupId?: number | undefined,
		angryStartTime?: number | undefined,
		attackTime?: number | undefined
	) {
		super()
		this.playerId = playerId
		this.monsterGroupId = monsterGroupId
		this.angryStartTime = angryStartTime
		this.attackTime = attackTime
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarLong(this.playerId!)
		writer.writeDouble(this.monsterGroupId!)
		writer.writeDouble(this.angryStartTime!)
		writer.writeDouble(this.attackTime!)
	}

	public deserialize(reader: BinaryReader): void {
		this.playerId = reader.readVarLong()
		this.monsterGroupId = reader.readDouble()
		this.angryStartTime = reader.readDouble()
		this.attackTime = reader.readDouble()
	}

	public hydrate(
		data: GameRolePlayMonsterAngryAtPlayerMessage | Record<string, any>
	): GameRolePlayMonsterAngryAtPlayerMessage {
		if (data instanceof GameRolePlayMonsterAngryAtPlayerMessage) {
			return data
		}

		this.playerId = data.playerId
		this.monsterGroupId = data.monsterGroupId
		this.angryStartTime = data.angryStartTime
		this.attackTime = data.attackTime

		return this
	}
}

export interface RawGameDataPaddockObjectAddMessage {
	id: number
	paddockItemDescription: PaddockItem
}

export class GameDataPaddockObjectAddMessage extends DofusMessage {
	public static id: number = 5993

	public paddockItemDescription: PaddockItem | undefined

	public constructor(paddockItemDescription?: PaddockItem | undefined) {
		super()
		this.paddockItemDescription = paddockItemDescription
	}

	public serialize(writer: BinaryWriter): void {
		this.paddockItemDescription!.serialize(writer)
	}

	public deserialize(reader: BinaryReader): void {
		this.paddockItemDescription = new PaddockItem()
		this.paddockItemDescription!.deserialize(reader)
	}

	public hydrate(
		data: GameDataPaddockObjectAddMessage | Record<string, any>
	): GameDataPaddockObjectAddMessage {
		if (data instanceof GameDataPaddockObjectAddMessage) {
			return data
		}

		this.paddockItemDescription = new PaddockItem().hydrate(
			data.paddockItemDescription
		)

		return this
	}
}

export interface RawMapComplementaryInformationsDataInHouseMessage
	extends RawMapComplementaryInformationsDataMessage {
	id: number
	currentHouse: HouseInformationsInside
}

export class MapComplementaryInformationsDataInHouseMessage extends MapComplementaryInformationsDataMessage {
	public static id = 9214

	public currentHouse: HouseInformationsInside | undefined

	public constructor(
		subAreaId?: number | undefined,
		mapId?: number | undefined,
		houses?: HouseInformations[] | undefined,
		actors?: GameRolePlayActorInformations[] | undefined,
		interactiveElements?: InteractiveElement[] | undefined,
		statedElements?: StatedElement[] | undefined,
		obstacles?: MapObstacle[] | undefined,
		fights?: FightCommonInformations[] | undefined,
		hasAggressiveMonsters?: boolean | undefined,
		fightStartPositions?: FightStartingPositions | undefined,
		currentHouse?: HouseInformationsInside | undefined
	) {
		super(
			subAreaId,
			mapId,
			houses,
			actors,
			interactiveElements,
			statedElements,
			obstacles,
			fights,
			hasAggressiveMonsters,
			fightStartPositions
		)
		this.currentHouse = currentHouse
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		this.currentHouse!.serialize(writer)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.currentHouse = new HouseInformationsInside()
		this.currentHouse!.deserialize(reader)
	}

	public hydrate(
		data: MapComplementaryInformationsDataInHouseMessage | Record<string, any>
	): MapComplementaryInformationsDataInHouseMessage {
		if (data instanceof MapComplementaryInformationsDataInHouseMessage) {
			return data
		}

		super.hydrate(data)

		this.currentHouse = new HouseInformationsInside().hydrate(data.currentHouse)

		return this
	}
}

export interface RawStatedMapUpdateMessage {
	id: number
	statedElements: StatedElement[]
}

export class StatedMapUpdateMessage extends DofusMessage {
	public static id: number = 9971

	public statedElements: StatedElement[] | undefined

	public constructor(statedElements?: StatedElement[] | undefined) {
		super()
		this.statedElements = statedElements
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeShort(this.statedElements!.length)
		this.statedElements!.forEach((current) => {
			current.serialize(writer)
		})
	}

	public deserialize(reader: BinaryReader): void {
		this.statedElements = []
		const countStatedElements = reader.readShort()
		for (let i: number = 0; i < countStatedElements; i++) {
			const type: StatedElement = new StatedElement()
			type.deserialize(reader)
			this.statedElements.push(type)
		}
	}

	public hydrate(
		data: StatedMapUpdateMessage | Record<string, any>
	): StatedMapUpdateMessage {
		if (data instanceof StatedMapUpdateMessage) {
			return data
		}

		this.statedElements = data.statedElements.map(
			(dataElement: StatedElement | Record<string, any>): StatedElement => {
				if (dataElement instanceof StatedElement) {
					return dataElement
				} else {
					return new StatedElement().hydrate(dataElement)
				}
			}
		)

		return this
	}
}

export interface RawGameMapChangeOrientationsMessage {
	id: number
	orientations: ActorOrientation[]
}

export class GameMapChangeOrientationsMessage extends DofusMessage {
	public static id: number = 9422

	public orientations: ActorOrientation[] | undefined

	public constructor(orientations?: ActorOrientation[] | undefined) {
		super()
		this.orientations = orientations
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeShort(this.orientations!.length)
		this.orientations!.forEach((current) => {
			current.serialize(writer)
		})
	}

	public deserialize(reader: BinaryReader): void {
		this.orientations = []
		const countOrientations = reader.readShort()
		for (let i: number = 0; i < countOrientations; i++) {
			const type: ActorOrientation = new ActorOrientation()
			type.deserialize(reader)
			this.orientations.push(type)
		}
	}

	public hydrate(
		data: GameMapChangeOrientationsMessage | Record<string, any>
	): GameMapChangeOrientationsMessage {
		if (data instanceof GameMapChangeOrientationsMessage) {
			return data
		}

		this.orientations = data.orientations.map(
			(
				dataElement: ActorOrientation | Record<string, any>
			): ActorOrientation => {
				if (dataElement instanceof ActorOrientation) {
					return dataElement
				} else {
					return new ActorOrientation().hydrate(dataElement)
				}
			}
		)

		return this
	}
}

export interface RawShowCellMessage {
	id: number
	sourceId: number
	cellId: number
}

export class ShowCellMessage extends DofusMessage {
	public static id: number = 6430

	public sourceId: number | undefined = 0
	public cellId: number | undefined = 0

	public constructor(
		sourceId?: number | undefined,
		cellId?: number | undefined
	) {
		super()
		this.sourceId = sourceId
		this.cellId = cellId
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeDouble(this.sourceId!)
		writer.writeVarShort(this.cellId!)
	}

	public deserialize(reader: BinaryReader): void {
		this.sourceId = reader.readDouble()
		this.cellId = reader.readVarShort()
	}

	public hydrate(data: ShowCellMessage | Record<string, any>): ShowCellMessage {
		if (data instanceof ShowCellMessage) {
			return data
		}

		this.sourceId = data.sourceId
		this.cellId = data.cellId

		return this
	}
}

export interface RawHousePropertiesMessage {
	id: number
	houseId: number
	doorsOnMap: number[]
	properties: HouseInstanceInformations
}

export class HousePropertiesMessage extends DofusMessage {
	public static id: number = 3052

	public houseId: number | undefined = 0
	public doorsOnMap: number[] | undefined
	public properties: HouseInstanceInformations | undefined

	public constructor(
		houseId?: number | undefined,
		doorsOnMap?: number[] | undefined,
		properties?: HouseInstanceInformations | undefined
	) {
		super()
		this.houseId = houseId
		this.doorsOnMap = doorsOnMap
		this.properties = properties
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarInt(this.houseId!)
		writer.writeShort(this.doorsOnMap!.length)
		this.doorsOnMap!.forEach((current: number) => writer.writeInt(current))
		writer.writeShort(this.properties!.id)
		this.properties!.serialize(writer)
	}

	public deserialize(reader: BinaryReader): void {
		this.houseId = reader.readVarInt()
		this.doorsOnMap = []
		const countDoorsOnMap = reader.readShort()
		for (let i: number = 0; i < countDoorsOnMap; i++) {
			this.doorsOnMap.push(reader.readInt())
		}
		const propertiesTypeId: number = reader.readShort()
		this.properties = new types[propertiesTypeId]() as HouseInstanceInformations
		this.properties!.deserialize(reader)
	}

	public hydrate(
		data: HousePropertiesMessage | Record<string, any>
	): HousePropertiesMessage {
		if (data instanceof HousePropertiesMessage) {
			return data
		}

		this.houseId = data.houseId
		this.doorsOnMap = data.doorsOnMap
		this.properties = (new types[
			data.properties.id
		]() as HouseInstanceInformations).hydrate(data.properties)
		return this
	}
}

export interface RawGameRolePlayMonsterNotAngryAtPlayerMessage {
	id: number
	playerId: number
	monsterGroupId: number
}

export class GameRolePlayMonsterNotAngryAtPlayerMessage extends DofusMessage {
	public static id: number = 4276

	public playerId: number | undefined = 0
	public monsterGroupId: number | undefined = 0

	public constructor(
		playerId?: number | undefined,
		monsterGroupId?: number | undefined
	) {
		super()
		this.playerId = playerId
		this.monsterGroupId = monsterGroupId
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarLong(this.playerId!)
		writer.writeDouble(this.monsterGroupId!)
	}

	public deserialize(reader: BinaryReader): void {
		this.playerId = reader.readVarLong()
		this.monsterGroupId = reader.readDouble()
	}

	public hydrate(
		data: GameRolePlayMonsterNotAngryAtPlayerMessage | Record<string, any>
	): GameRolePlayMonsterNotAngryAtPlayerMessage {
		if (data instanceof GameRolePlayMonsterNotAngryAtPlayerMessage) {
			return data
		}

		this.playerId = data.playerId
		this.monsterGroupId = data.monsterGroupId

		return this
	}
}

export interface RawBreachTeleportResponseMessage {
	id: number
	teleported: boolean
}

export class BreachTeleportResponseMessage extends DofusMessage {
	public static id: number = 1936

	public teleported: boolean | undefined = false

	public constructor(teleported?: boolean | undefined) {
		super()
		this.teleported = teleported
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeBoolean(this.teleported!)
	}

	public deserialize(reader: BinaryReader): void {
		this.teleported = reader.readBoolean()
	}

	public hydrate(
		data: BreachTeleportResponseMessage | Record<string, any>
	): BreachTeleportResponseMessage {
		if (data instanceof BreachTeleportResponseMessage) {
			return data
		}

		this.teleported = data.teleported

		return this
	}
}

export interface RawGameContextRemoveMultipleElementsMessage {
	id: number
	elementsIds: number[]
}

export class GameContextRemoveMultipleElementsMessage extends DofusMessage {
	public static id: number = 849

	public elementsIds: number[] | undefined

	public constructor(elementsIds?: number[] | undefined) {
		super()
		this.elementsIds = elementsIds
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeShort(this.elementsIds!.length)
		this.elementsIds!.forEach((current: number) => writer.writeDouble(current))
	}

	public deserialize(reader: BinaryReader): void {
		this.elementsIds = []
		const countElementsIds = reader.readShort()
		for (let i: number = 0; i < countElementsIds; i++) {
			this.elementsIds.push(reader.readDouble())
		}
	}

	public hydrate(
		data: GameContextRemoveMultipleElementsMessage | Record<string, any>
	): GameContextRemoveMultipleElementsMessage {
		if (data instanceof GameContextRemoveMultipleElementsMessage) {
			return data
		}

		this.elementsIds = data.elementsIds

		return this
	}
}

export interface RawGameRolePlayShowMultipleActorsMessage {
	id: number
	informationsList: GameRolePlayActorInformations[]
}

export class GameRolePlayShowMultipleActorsMessage extends DofusMessage {
	public static id: number = 224

	public informationsList: GameRolePlayActorInformations[] | undefined

	public constructor(
		informationsList?: GameRolePlayActorInformations[] | undefined
	) {
		super()
		this.informationsList = informationsList
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeShort(this.informationsList!.length)
		this.informationsList!.forEach((current) => {
			writer.writeShort(current.id)
			current.serialize(writer)
		})
	}

	public deserialize(reader: BinaryReader): void {
		this.informationsList = []
		const countInformationsList = reader.readShort()
		for (let i: number = 0; i < countInformationsList; i++) {
			const informationsListTypeId: number = reader.readShort()
			const type: GameRolePlayActorInformations = new types[
				informationsListTypeId
			]() as GameRolePlayActorInformations
			type.deserialize(reader)
			this.informationsList.push(type)
		}
	}

	public hydrate(
		data: GameRolePlayShowMultipleActorsMessage | Record<string, any>
	): GameRolePlayShowMultipleActorsMessage {
		if (data instanceof GameRolePlayShowMultipleActorsMessage) {
			return data
		}

		this.informationsList = data.informationsList.map(
			(
				dataElement: GameRolePlayActorInformations | Record<string, any>
			): GameRolePlayActorInformations => {
				if (dataElement instanceof GameRolePlayActorInformations) {
					return dataElement
				} else {
					return (new types[
						dataElement.id
					]() as GameRolePlayActorInformations).hydrate(dataElement)
				}
			}
		)

		return this
	}
}

export interface RawObjectGroundRemovedMessage {
	id: number
	cell: number
}

export class ObjectGroundRemovedMessage extends DofusMessage {
	public static id: number = 5737

	public cell: number | undefined = 0

	public constructor(cell?: number | undefined) {
		super()
		this.cell = cell
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarShort(this.cell!)
	}

	public deserialize(reader: BinaryReader): void {
		this.cell = reader.readVarShort()
	}

	public hydrate(
		data: ObjectGroundRemovedMessage | Record<string, any>
	): ObjectGroundRemovedMessage {
		if (data instanceof ObjectGroundRemovedMessage) {
			return data
		}

		this.cell = data.cell

		return this
	}
}

export interface RawGameDataPaddockObjectListAddMessage {
	id: number
	paddockItemDescription: PaddockItem[]
}

export class GameDataPaddockObjectListAddMessage extends DofusMessage {
	public static id: number = 8033

	public paddockItemDescription: PaddockItem[] | undefined

	public constructor(paddockItemDescription?: PaddockItem[] | undefined) {
		super()
		this.paddockItemDescription = paddockItemDescription
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeShort(this.paddockItemDescription!.length)
		this.paddockItemDescription!.forEach((current) => {
			current.serialize(writer)
		})
	}

	public deserialize(reader: BinaryReader): void {
		this.paddockItemDescription = []
		const countPaddockItemDescription = reader.readShort()
		for (let i: number = 0; i < countPaddockItemDescription; i++) {
			const type: PaddockItem = new PaddockItem()
			type.deserialize(reader)
			this.paddockItemDescription.push(type)
		}
	}

	public hydrate(
		data: GameDataPaddockObjectListAddMessage | Record<string, any>
	): GameDataPaddockObjectListAddMessage {
		if (data instanceof GameDataPaddockObjectListAddMessage) {
			return data
		}

		this.paddockItemDescription = data.paddockItemDescription.map(
			(dataElement: PaddockItem | Record<string, any>): PaddockItem => {
				if (dataElement instanceof PaddockItem) {
					return dataElement
				} else {
					return new PaddockItem().hydrate(dataElement)
				}
			}
		)

		return this
	}
}

export interface RawAnomalyStateMessage {
	id: number
	subAreaId: number
	open: boolean
	closingTime: number
}

export class AnomalyStateMessage extends DofusMessage {
	public static id: number = 5822

	public subAreaId: number | undefined = 0
	public open: boolean | undefined = false
	public closingTime: number | undefined = 0

	public constructor(
		subAreaId?: number | undefined,
		open?: boolean | undefined,
		closingTime?: number | undefined
	) {
		super()
		this.subAreaId = subAreaId
		this.open = open
		this.closingTime = closingTime
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarShort(this.subAreaId!)
		writer.writeBoolean(this.open!)
		writer.writeVarLong(this.closingTime!)
	}

	public deserialize(reader: BinaryReader): void {
		this.subAreaId = reader.readVarShort()
		this.open = reader.readBoolean()
		this.closingTime = reader.readVarLong()
	}

	public hydrate(
		data: AnomalyStateMessage | Record<string, any>
	): AnomalyStateMessage {
		if (data instanceof AnomalyStateMessage) {
			return data
		}

		this.subAreaId = data.subAreaId
		this.open = data.open
		this.closingTime = data.closingTime

		return this
	}
}

export interface RawMapInformationsRequestMessage {
	id: number
	mapId: number
}

export class MapInformationsRequestMessage extends DofusMessage {
	public static id: number = 231

	public mapId: number | undefined = 0

	public constructor(mapId?: number | undefined) {
		super()
		this.mapId = mapId
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeDouble(this.mapId!)
	}

	public deserialize(reader: BinaryReader): void {
		this.mapId = reader.readDouble()
	}

	public hydrate(
		data: MapInformationsRequestMessage | Record<string, any>
	): MapInformationsRequestMessage {
		if (data instanceof MapInformationsRequestMessage) {
			return data
		}

		this.mapId = data.mapId

		return this
	}
}

export interface RawInteractiveUsedMessage {
	id: number
	entityId: number
	elemId: number
	skillId: number
	duration: number
	canMove: boolean
}

export class InteractiveUsedMessage extends DofusMessage {
	public static id: number = 8434

	public entityId: number | undefined = 0
	public elemId: number | undefined = 0
	public skillId: number | undefined = 0
	public duration: number | undefined = 0
	public canMove: boolean | undefined = false

	public constructor(
		entityId?: number | undefined,
		elemId?: number | undefined,
		skillId?: number | undefined,
		duration?: number | undefined,
		canMove?: boolean | undefined
	) {
		super()
		this.entityId = entityId
		this.elemId = elemId
		this.skillId = skillId
		this.duration = duration
		this.canMove = canMove
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarLong(this.entityId!)
		writer.writeVarInt(this.elemId!)
		writer.writeVarShort(this.skillId!)
		writer.writeVarShort(this.duration!)
		writer.writeBoolean(this.canMove!)
	}

	public deserialize(reader: BinaryReader): void {
		this.entityId = reader.readVarLong()
		this.elemId = reader.readVarInt()
		this.skillId = reader.readVarShort()
		this.duration = reader.readVarShort()
		this.canMove = reader.readBoolean()
	}

	public hydrate(
		data: InteractiveUsedMessage | Record<string, any>
	): InteractiveUsedMessage {
		if (data instanceof InteractiveUsedMessage) {
			return data
		}

		this.entityId = data.entityId
		this.elemId = data.elemId
		this.skillId = data.skillId
		this.duration = data.duration
		this.canMove = data.canMove

		return this
	}
}

export interface RawMapFightCountMessage {
	id: number
	fightCount: number
}

export class MapFightCountMessage extends DofusMessage {
	public static id: number = 1874

	public fightCount: number | undefined = 0

	public constructor(fightCount?: number | undefined) {
		super()
		this.fightCount = fightCount
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarShort(this.fightCount!)
	}

	public deserialize(reader: BinaryReader): void {
		this.fightCount = reader.readVarShort()
	}

	public hydrate(
		data: MapFightCountMessage | Record<string, any>
	): MapFightCountMessage {
		if (data instanceof MapFightCountMessage) {
			return data
		}

		this.fightCount = data.fightCount

		return this
	}
}

export interface RawInteractiveMapUpdateMessage {
	id: number
	interactiveElements: InteractiveElement[]
}

export class InteractiveMapUpdateMessage extends DofusMessage {
	public static id: number = 2058

	public interactiveElements: InteractiveElement[] | undefined

	public constructor(interactiveElements?: InteractiveElement[] | undefined) {
		super()
		this.interactiveElements = interactiveElements
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeShort(this.interactiveElements!.length)
		this.interactiveElements!.forEach((current) => {
			writer.writeShort(current.id)
			current.serialize(writer)
		})
	}

	public deserialize(reader: BinaryReader): void {
		this.interactiveElements = []
		const countInteractiveElements = reader.readShort()
		for (let i: number = 0; i < countInteractiveElements; i++) {
			const interactiveElementsTypeId: number = reader.readShort()
			const type: InteractiveElement = new types[
				interactiveElementsTypeId
			]() as InteractiveElement
			type.deserialize(reader)
			this.interactiveElements.push(type)
		}
	}

	public hydrate(
		data: InteractiveMapUpdateMessage | Record<string, any>
	): InteractiveMapUpdateMessage {
		if (data instanceof InteractiveMapUpdateMessage) {
			return data
		}

		this.interactiveElements = data.interactiveElements.map(
			(
				dataElement: InteractiveElement | Record<string, any>
			): InteractiveElement => {
				if (dataElement instanceof InteractiveElement) {
					return dataElement
				} else {
					return (new types[dataElement.id]() as InteractiveElement).hydrate(
						dataElement
					)
				}
			}
		)

		return this
	}
}

export interface RawGameContextRemoveElementMessage {
	id: number
	id_: number
}

export class GameContextRemoveElementMessage extends DofusMessage {
	public static id: number = 4327

	public id_: number | undefined = 0

	public constructor(id_?: number | undefined) {
		super()
		this.id_ = id_
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeDouble(this.id_!)
	}

	public deserialize(reader: BinaryReader): void {
		this.id_ = reader.readDouble()
	}

	public hydrate(
		data: GameContextRemoveElementMessage | Record<string, any>
	): GameContextRemoveElementMessage {
		if (data instanceof GameContextRemoveElementMessage) {
			return data
		}

		this.id_ = data.id_

		return this
	}
}

export interface RawGameFightOptionStateUpdateMessage {
	id: number
	fightId: number
	teamId: number
	option: number
	state: boolean
}

export class GameFightOptionStateUpdateMessage extends DofusMessage {
	public static id: number = 3750

	public fightId: number | undefined = 0
	public teamId: number | undefined = 2
	public option: number | undefined = 3
	public state: boolean | undefined = false

	public constructor(
		fightId?: number | undefined,
		teamId?: number | undefined,
		option?: number | undefined,
		state?: boolean | undefined
	) {
		super()
		this.fightId = fightId
		this.teamId = teamId
		this.option = option
		this.state = state
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarShort(this.fightId!)
		writer.writeByte(this.teamId!)
		writer.writeByte(this.option!)
		writer.writeBoolean(this.state!)
	}

	public deserialize(reader: BinaryReader): void {
		this.fightId = reader.readVarShort()
		this.teamId = reader.readByte()
		this.option = reader.readByte()
		this.state = reader.readBoolean()
	}

	public hydrate(
		data: GameFightOptionStateUpdateMessage | Record<string, any>
	): GameFightOptionStateUpdateMessage {
		if (data instanceof GameFightOptionStateUpdateMessage) {
			return data
		}

		this.fightId = data.fightId
		this.teamId = data.teamId
		this.option = data.option
		this.state = data.state

		return this
	}
}

export interface RawBreachTeleportRequestMessage {
	id: number
}

export class BreachTeleportRequestMessage extends DofusMessage {
	public static id: number = 6772

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public serialize(writer: BinaryWriter): void {}

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public deserialize(reader: BinaryReader): void {}

	public hydrate(
		data: BreachTeleportRequestMessage | Record<string, any>
	): BreachTeleportRequestMessage {
		if (data instanceof BreachTeleportRequestMessage) {
			return data
		}

		return this
	}
}

export interface RawMapComplementaryInformationsBreachMessage
	extends RawMapComplementaryInformationsDataMessage {
	id: number
	floor: number
	room: number
	infinityMode: number
	branches: BreachBranch[]
}

export class MapComplementaryInformationsBreachMessage extends MapComplementaryInformationsDataMessage {
	public static id = 3106

	public floor: number | undefined = 0
	public room: number | undefined = 0
	public infinityMode: number | undefined = 0
	public branches: BreachBranch[] | undefined

	public constructor(
		subAreaId?: number | undefined,
		mapId?: number | undefined,
		houses?: HouseInformations[] | undefined,
		actors?: GameRolePlayActorInformations[] | undefined,
		interactiveElements?: InteractiveElement[] | undefined,
		statedElements?: StatedElement[] | undefined,
		obstacles?: MapObstacle[] | undefined,
		fights?: FightCommonInformations[] | undefined,
		hasAggressiveMonsters?: boolean | undefined,
		fightStartPositions?: FightStartingPositions | undefined,
		floor?: number | undefined,
		room?: number | undefined,
		infinityMode?: number | undefined,
		branches?: BreachBranch[] | undefined
	) {
		super(
			subAreaId,
			mapId,
			houses,
			actors,
			interactiveElements,
			statedElements,
			obstacles,
			fights,
			hasAggressiveMonsters,
			fightStartPositions
		)
		this.floor = floor
		this.room = room
		this.infinityMode = infinityMode
		this.branches = branches
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeVarInt(this.floor!)
		writer.writeByte(this.room!)
		writer.writeShort(this.infinityMode!)
		writer.writeShort(this.branches!.length)
		this.branches!.forEach((current) => {
			writer.writeShort(current.id)
			current.serialize(writer)
		})
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.floor = reader.readVarInt()
		this.room = reader.readByte()
		this.infinityMode = reader.readShort()
		this.branches = []
		const countBranches = reader.readShort()
		for (let i: number = 0; i < countBranches; i++) {
			const branchesTypeId: number = reader.readShort()
			const type: BreachBranch = new types[branchesTypeId]() as BreachBranch
			type.deserialize(reader)
			this.branches.push(type)
		}
	}

	public hydrate(
		data: MapComplementaryInformationsBreachMessage | Record<string, any>
	): MapComplementaryInformationsBreachMessage {
		if (data instanceof MapComplementaryInformationsBreachMessage) {
			return data
		}

		super.hydrate(data)

		this.floor = data.floor
		this.room = data.room
		this.infinityMode = data.infinityMode
		this.branches = data.branches.map(
			(dataElement: BreachBranch | Record<string, any>): BreachBranch => {
				if (dataElement instanceof BreachBranch) {
					return dataElement
				} else {
					return (new types[dataElement.id]() as BreachBranch).hydrate(
						dataElement
					)
				}
			}
		)

		return this
	}
}

export interface RawGameEntitiesDispositionMessage {
	id: number
	dispositions: IdentifiedEntityDispositionInformations[]
}

export class GameEntitiesDispositionMessage extends DofusMessage {
	public static id: number = 5646

	public dispositions: IdentifiedEntityDispositionInformations[] | undefined

	public constructor(
		dispositions?: IdentifiedEntityDispositionInformations[] | undefined
	) {
		super()
		this.dispositions = dispositions
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeShort(this.dispositions!.length)
		this.dispositions!.forEach((current) => {
			current.serialize(writer)
		})
	}

	public deserialize(reader: BinaryReader): void {
		this.dispositions = []
		const countDispositions = reader.readShort()
		for (let i: number = 0; i < countDispositions; i++) {
			const type: IdentifiedEntityDispositionInformations = new IdentifiedEntityDispositionInformations()
			type.deserialize(reader)
			this.dispositions.push(type)
		}
	}

	public hydrate(
		data: GameEntitiesDispositionMessage | Record<string, any>
	): GameEntitiesDispositionMessage {
		if (data instanceof GameEntitiesDispositionMessage) {
			return data
		}

		this.dispositions = data.dispositions.map(
			(
				dataElement:
					| IdentifiedEntityDispositionInformations
					| Record<string, any>
			): IdentifiedEntityDispositionInformations => {
				if (dataElement instanceof IdentifiedEntityDispositionInformations) {
					return dataElement
				} else {
					return new IdentifiedEntityDispositionInformations().hydrate(
						dataElement
					)
				}
			}
		)

		return this
	}
}

export interface RawShowCellSpectatorMessage extends RawShowCellMessage {
	id: number
	playerName: string
}

export class ShowCellSpectatorMessage extends ShowCellMessage {
	public static id = 9734

	public playerName: string | undefined

	public constructor(
		sourceId?: number | undefined,
		cellId?: number | undefined,
		playerName?: string | undefined
	) {
		super(sourceId, cellId)
		this.playerName = playerName
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeUTF(this.playerName!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.playerName = reader.readUTF()
	}

	public hydrate(
		data: ShowCellSpectatorMessage | Record<string, any>
	): ShowCellSpectatorMessage {
		if (data instanceof ShowCellSpectatorMessage) {
			return data
		}

		super.hydrate(data)

		this.playerName = data.playerName

		return this
	}
}

export interface RawGameFightPlacementSwapPositionsMessage {
	id: number
	dispositions: IdentifiedEntityDispositionInformations[]
}

export class GameFightPlacementSwapPositionsMessage extends DofusMessage {
	public static id: number = 866

	public dispositions: IdentifiedEntityDispositionInformations[] | undefined

	public constructor(
		dispositions?: IdentifiedEntityDispositionInformations[] | undefined
	) {
		super()
		this.dispositions = dispositions
	}

	public serialize(writer: BinaryWriter): void {
		this.dispositions!.forEach((current) => {
			current.serialize(writer)
		})
	}

	public deserialize(reader: BinaryReader): void {
		this.dispositions = []
		for (let i: number = 0; i < 2; i++) {
			const type: IdentifiedEntityDispositionInformations = new IdentifiedEntityDispositionInformations()
			type.deserialize(reader)
			this.dispositions.push(type)
		}
	}

	public hydrate(
		data: GameFightPlacementSwapPositionsMessage | Record<string, any>
	): GameFightPlacementSwapPositionsMessage {
		if (data instanceof GameFightPlacementSwapPositionsMessage) {
			return data
		}

		this.dispositions = data.dispositions.map(
			(
				dataElement:
					| IdentifiedEntityDispositionInformations
					| Record<string, any>
			): IdentifiedEntityDispositionInformations => {
				if (dataElement instanceof IdentifiedEntityDispositionInformations) {
					return dataElement
				} else {
					return new IdentifiedEntityDispositionInformations().hydrate(
						dataElement
					)
				}
			}
		)

		return this
	}
}

export interface RawGameEntityDispositionMessage {
	id: number
	disposition: IdentifiedEntityDispositionInformations
}

export class GameEntityDispositionMessage extends DofusMessage {
	public static id: number = 3636

	public disposition: IdentifiedEntityDispositionInformations | undefined

	public constructor(
		disposition?: IdentifiedEntityDispositionInformations | undefined
	) {
		super()
		this.disposition = disposition
	}

	public serialize(writer: BinaryWriter): void {
		this.disposition!.serialize(writer)
	}

	public deserialize(reader: BinaryReader): void {
		this.disposition = new IdentifiedEntityDispositionInformations()
		this.disposition!.deserialize(reader)
	}

	public hydrate(
		data: GameEntityDispositionMessage | Record<string, any>
	): GameEntityDispositionMessage {
		if (data instanceof GameEntityDispositionMessage) {
			return data
		}

		this.disposition = new IdentifiedEntityDispositionInformations().hydrate(
			data.disposition
		)

		return this
	}
}

export interface RawGameFightHumanReadyStateMessage {
	id: number
	characterId: number
	isReady: boolean
}

export class GameFightHumanReadyStateMessage extends DofusMessage {
	public static id: number = 5755

	public characterId: number | undefined = 0
	public isReady: boolean | undefined = false

	public constructor(
		characterId?: number | undefined,
		isReady?: boolean | undefined
	) {
		super()
		this.characterId = characterId
		this.isReady = isReady
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarLong(this.characterId!)
		writer.writeBoolean(this.isReady!)
	}

	public deserialize(reader: BinaryReader): void {
		this.characterId = reader.readVarLong()
		this.isReady = reader.readBoolean()
	}

	public hydrate(
		data: GameFightHumanReadyStateMessage | Record<string, any>
	): GameFightHumanReadyStateMessage {
		if (data instanceof GameFightHumanReadyStateMessage) {
			return data
		}

		this.characterId = data.characterId
		this.isReady = data.isReady

		return this
	}
}

export interface RawPlayerStatusUpdateMessage {
	id: number
	accountId: number
	playerId: number
	status: PlayerStatus
}

export class PlayerStatusUpdateMessage extends DofusMessage {
	public static id: number = 4865

	public accountId: number | undefined = 0
	public playerId: number | undefined = 0
	public status: PlayerStatus | undefined

	public constructor(
		accountId?: number | undefined,
		playerId?: number | undefined,
		status?: PlayerStatus | undefined
	) {
		super()
		this.accountId = accountId
		this.playerId = playerId
		this.status = status
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeInt(this.accountId!)
		writer.writeVarLong(this.playerId!)
		writer.writeShort(this.status!.id)
		this.status!.serialize(writer)
	}

	public deserialize(reader: BinaryReader): void {
		this.accountId = reader.readInt()
		this.playerId = reader.readVarLong()
		const statusTypeId: number = reader.readShort()
		this.status = new types[statusTypeId]() as PlayerStatus
		this.status!.deserialize(reader)
	}

	public hydrate(
		data: PlayerStatusUpdateMessage | Record<string, any>
	): PlayerStatusUpdateMessage {
		if (data instanceof PlayerStatusUpdateMessage) {
			return data
		}

		this.accountId = data.accountId
		this.playerId = data.playerId
		this.status = (new types[data.status.id]() as PlayerStatus).hydrate(
			data.status
		)
		return this
	}
}

export interface RawGameFightEndMessage {
	id: number
	duration: number
	rewardRate: number
	lootShareLimitMalus: number
	results: FightResultListEntry[]
	namedPartyTeamsOutcomes: NamedPartyTeamWithOutcome[]
}

export class GameFightEndMessage extends DofusMessage {
	public static id: number = 6612

	public duration: number | undefined = 0
	public rewardRate: number | undefined = 0
	public lootShareLimitMalus: number | undefined = 0
	public results: FightResultListEntry[] | undefined
	public namedPartyTeamsOutcomes: NamedPartyTeamWithOutcome[] | undefined

	public constructor(
		duration?: number | undefined,
		rewardRate?: number | undefined,
		lootShareLimitMalus?: number | undefined,
		results?: FightResultListEntry[] | undefined,
		namedPartyTeamsOutcomes?: NamedPartyTeamWithOutcome[] | undefined
	) {
		super()
		this.duration = duration
		this.rewardRate = rewardRate
		this.lootShareLimitMalus = lootShareLimitMalus
		this.results = results
		this.namedPartyTeamsOutcomes = namedPartyTeamsOutcomes
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeInt(this.duration!)
		writer.writeVarShort(this.rewardRate!)
		writer.writeShort(this.lootShareLimitMalus!)
		writer.writeShort(this.results!.length)
		this.results!.forEach((current) => {
			writer.writeShort(current.id)
			current.serialize(writer)
		})
		writer.writeShort(this.namedPartyTeamsOutcomes!.length)
		this.namedPartyTeamsOutcomes!.forEach((current) => {
			current.serialize(writer)
		})
	}

	public deserialize(reader: BinaryReader): void {
		this.duration = reader.readInt()
		this.rewardRate = reader.readVarShort()
		this.lootShareLimitMalus = reader.readShort()
		this.results = []
		const countResults = reader.readShort()
		for (let i: number = 0; i < countResults; i++) {
			const resultsTypeId: number = reader.readShort()
			const type: FightResultListEntry = new types[
				resultsTypeId
			]() as FightResultListEntry
			type.deserialize(reader)
			this.results.push(type)
		}
		this.namedPartyTeamsOutcomes = []
		const countNamedPartyTeamsOutcomes = reader.readShort()
		for (let i: number = 0; i < countNamedPartyTeamsOutcomes; i++) {
			const type: NamedPartyTeamWithOutcome = new NamedPartyTeamWithOutcome()
			type.deserialize(reader)
			this.namedPartyTeamsOutcomes.push(type)
		}
	}

	public hydrate(
		data: GameFightEndMessage | Record<string, any>
	): GameFightEndMessage {
		if (data instanceof GameFightEndMessage) {
			return data
		}

		this.duration = data.duration
		this.rewardRate = data.rewardRate
		this.lootShareLimitMalus = data.lootShareLimitMalus
		this.results = data.results.map(
			(
				dataElement: FightResultListEntry | Record<string, any>
			): FightResultListEntry => {
				if (dataElement instanceof FightResultListEntry) {
					return dataElement
				} else {
					return (new types[dataElement.id]() as FightResultListEntry).hydrate(
						dataElement
					)
				}
			}
		)
		this.namedPartyTeamsOutcomes = data.namedPartyTeamsOutcomes.map(
			(
				dataElement: NamedPartyTeamWithOutcome | Record<string, any>
			): NamedPartyTeamWithOutcome => {
				if (dataElement instanceof NamedPartyTeamWithOutcome) {
					return dataElement
				} else {
					return new NamedPartyTeamWithOutcome().hydrate(dataElement)
				}
			}
		)

		return this
	}
}

export interface RawBreachGameFightEndMessage extends RawGameFightEndMessage {
	id: number
	budget: number
}

export class BreachGameFightEndMessage extends GameFightEndMessage {
	public static id = 6696

	public budget: number | undefined = 0

	public constructor(
		duration?: number | undefined,
		rewardRate?: number | undefined,
		lootShareLimitMalus?: number | undefined,
		results?: FightResultListEntry[] | undefined,
		namedPartyTeamsOutcomes?: NamedPartyTeamWithOutcome[] | undefined,
		budget?: number | undefined
	) {
		super(
			duration,
			rewardRate,
			lootShareLimitMalus,
			results,
			namedPartyTeamsOutcomes
		)
		this.budget = budget
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeInt(this.budget!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.budget = reader.readInt()
	}

	public hydrate(
		data: BreachGameFightEndMessage | Record<string, any>
	): BreachGameFightEndMessage {
		if (data instanceof BreachGameFightEndMessage) {
			return data
		}

		super.hydrate(data)

		this.budget = data.budget

		return this
	}
}

export interface RawChallengeTargetUpdateMessage {
	id: number
	challengeId: number
	targetId: number
}

export class ChallengeTargetUpdateMessage extends DofusMessage {
	public static id: number = 4069

	public challengeId: number | undefined = 0
	public targetId: number | undefined = 0

	public constructor(
		challengeId?: number | undefined,
		targetId?: number | undefined
	) {
		super()
		this.challengeId = challengeId
		this.targetId = targetId
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarShort(this.challengeId!)
		writer.writeDouble(this.targetId!)
	}

	public deserialize(reader: BinaryReader): void {
		this.challengeId = reader.readVarShort()
		this.targetId = reader.readDouble()
	}

	public hydrate(
		data: ChallengeTargetUpdateMessage | Record<string, any>
	): ChallengeTargetUpdateMessage {
		if (data instanceof ChallengeTargetUpdateMessage) {
			return data
		}

		this.challengeId = data.challengeId
		this.targetId = data.targetId

		return this
	}
}

export interface RawGameFightLeaveMessage {
	id: number
	charId: number
}

export class GameFightLeaveMessage extends DofusMessage {
	public static id: number = 4491

	public charId: number | undefined = 0

	public constructor(charId?: number | undefined) {
		super()
		this.charId = charId
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeDouble(this.charId!)
	}

	public deserialize(reader: BinaryReader): void {
		this.charId = reader.readDouble()
	}

	public hydrate(
		data: GameFightLeaveMessage | Record<string, any>
	): GameFightLeaveMessage {
		if (data instanceof GameFightLeaveMessage) {
			return data
		}

		this.charId = data.charId

		return this
	}
}

export interface RawGameFightSpectateMessage {
	id: number
	effects: FightDispellableEffectExtendedInformations[]
	marks: GameActionMark[]
	gameTurn: number
	fightStart: number
	idols: Idol[]
	fxTriggerCounts: GameFightEffectTriggerCount[]
}

export class GameFightSpectateMessage extends DofusMessage {
	public static id: number = 9624

	public effects: FightDispellableEffectExtendedInformations[] | undefined
	public marks: GameActionMark[] | undefined
	public gameTurn: number | undefined = 0
	public fightStart: number | undefined = 0
	public idols: Idol[] | undefined
	public fxTriggerCounts: GameFightEffectTriggerCount[] | undefined

	public constructor(
		effects?: FightDispellableEffectExtendedInformations[] | undefined,
		marks?: GameActionMark[] | undefined,
		gameTurn?: number | undefined,
		fightStart?: number | undefined,
		idols?: Idol[] | undefined,
		fxTriggerCounts?: GameFightEffectTriggerCount[] | undefined
	) {
		super()
		this.effects = effects
		this.marks = marks
		this.gameTurn = gameTurn
		this.fightStart = fightStart
		this.idols = idols
		this.fxTriggerCounts = fxTriggerCounts
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeShort(this.effects!.length)
		this.effects!.forEach((current) => {
			current.serialize(writer)
		})
		writer.writeShort(this.marks!.length)
		this.marks!.forEach((current) => {
			current.serialize(writer)
		})
		writer.writeVarShort(this.gameTurn!)
		writer.writeInt(this.fightStart!)
		writer.writeShort(this.idols!.length)
		this.idols!.forEach((current) => {
			current.serialize(writer)
		})
		writer.writeShort(this.fxTriggerCounts!.length)
		this.fxTriggerCounts!.forEach((current) => {
			current.serialize(writer)
		})
	}

	public deserialize(reader: BinaryReader): void {
		this.effects = []
		const countEffects = reader.readShort()
		for (let i: number = 0; i < countEffects; i++) {
			const type: FightDispellableEffectExtendedInformations = new FightDispellableEffectExtendedInformations()
			type.deserialize(reader)
			this.effects.push(type)
		}
		this.marks = []
		const countMarks = reader.readShort()
		for (let i: number = 0; i < countMarks; i++) {
			const type: GameActionMark = new GameActionMark()
			type.deserialize(reader)
			this.marks.push(type)
		}
		this.gameTurn = reader.readVarShort()
		this.fightStart = reader.readInt()
		this.idols = []
		const countIdols = reader.readShort()
		for (let i: number = 0; i < countIdols; i++) {
			const type: Idol = new Idol()
			type.deserialize(reader)
			this.idols.push(type)
		}
		this.fxTriggerCounts = []
		const countFxTriggerCounts = reader.readShort()
		for (let i: number = 0; i < countFxTriggerCounts; i++) {
			const type: GameFightEffectTriggerCount = new GameFightEffectTriggerCount()
			type.deserialize(reader)
			this.fxTriggerCounts.push(type)
		}
	}

	public hydrate(
		data: GameFightSpectateMessage | Record<string, any>
	): GameFightSpectateMessage {
		if (data instanceof GameFightSpectateMessage) {
			return data
		}

		this.effects = data.effects.map(
			(
				dataElement:
					| FightDispellableEffectExtendedInformations
					| Record<string, any>
			): FightDispellableEffectExtendedInformations => {
				if (dataElement instanceof FightDispellableEffectExtendedInformations) {
					return dataElement
				} else {
					return new FightDispellableEffectExtendedInformations().hydrate(
						dataElement
					)
				}
			}
		)
		this.marks = data.marks.map(
			(dataElement: GameActionMark | Record<string, any>): GameActionMark => {
				if (dataElement instanceof GameActionMark) {
					return dataElement
				} else {
					return new GameActionMark().hydrate(dataElement)
				}
			}
		)
		this.gameTurn = data.gameTurn
		this.fightStart = data.fightStart
		this.idols = data.idols.map(
			(dataElement: Idol | Record<string, any>): Idol => {
				if (dataElement instanceof Idol) {
					return dataElement
				} else {
					return new Idol().hydrate(dataElement)
				}
			}
		)
		this.fxTriggerCounts = data.fxTriggerCounts.map(
			(
				dataElement: GameFightEffectTriggerCount | Record<string, any>
			): GameFightEffectTriggerCount => {
				if (dataElement instanceof GameFightEffectTriggerCount) {
					return dataElement
				} else {
					return new GameFightEffectTriggerCount().hydrate(dataElement)
				}
			}
		)

		return this
	}
}

export interface RawGameFightResumeMessage extends RawGameFightSpectateMessage {
	id: number
	spellCooldowns: GameFightSpellCooldown[]
	summonCount: number
	bombCount: number
}

export class GameFightResumeMessage extends GameFightSpectateMessage {
	public static id = 8007

	public spellCooldowns: GameFightSpellCooldown[] | undefined
	public summonCount: number | undefined = 0
	public bombCount: number | undefined = 0

	public constructor(
		effects?: FightDispellableEffectExtendedInformations[] | undefined,
		marks?: GameActionMark[] | undefined,
		gameTurn?: number | undefined,
		fightStart?: number | undefined,
		idols?: Idol[] | undefined,
		fxTriggerCounts?: GameFightEffectTriggerCount[] | undefined,
		spellCooldowns?: GameFightSpellCooldown[] | undefined,
		summonCount?: number | undefined,
		bombCount?: number | undefined
	) {
		super(effects, marks, gameTurn, fightStart, idols, fxTriggerCounts)
		this.spellCooldowns = spellCooldowns
		this.summonCount = summonCount
		this.bombCount = bombCount
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeShort(this.spellCooldowns!.length)
		this.spellCooldowns!.forEach((current) => {
			current.serialize(writer)
		})
		writer.writeByte(this.summonCount!)
		writer.writeByte(this.bombCount!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.spellCooldowns = []
		const countSpellCooldowns = reader.readShort()
		for (let i: number = 0; i < countSpellCooldowns; i++) {
			const type: GameFightSpellCooldown = new GameFightSpellCooldown()
			type.deserialize(reader)
			this.spellCooldowns.push(type)
		}
		this.summonCount = reader.readByte()
		this.bombCount = reader.readByte()
	}

	public hydrate(
		data: GameFightResumeMessage | Record<string, any>
	): GameFightResumeMessage {
		if (data instanceof GameFightResumeMessage) {
			return data
		}

		super.hydrate(data)

		this.spellCooldowns = data.spellCooldowns.map(
			(
				dataElement: GameFightSpellCooldown | Record<string, any>
			): GameFightSpellCooldown => {
				if (dataElement instanceof GameFightSpellCooldown) {
					return dataElement
				} else {
					return new GameFightSpellCooldown().hydrate(dataElement)
				}
			}
		)
		this.summonCount = data.summonCount
		this.bombCount = data.bombCount

		return this
	}
}

export interface RawGameFightResumeWithSlavesMessage
	extends RawGameFightResumeMessage {
	id: number
	slavesInfo: GameFightResumeSlaveInfo[]
}

export class GameFightResumeWithSlavesMessage extends GameFightResumeMessage {
	public static id = 3940

	public slavesInfo: GameFightResumeSlaveInfo[] | undefined

	public constructor(
		effects?: FightDispellableEffectExtendedInformations[] | undefined,
		marks?: GameActionMark[] | undefined,
		gameTurn?: number | undefined,
		fightStart?: number | undefined,
		idols?: Idol[] | undefined,
		fxTriggerCounts?: GameFightEffectTriggerCount[] | undefined,
		spellCooldowns?: GameFightSpellCooldown[] | undefined,
		summonCount?: number | undefined,
		bombCount?: number | undefined,
		slavesInfo?: GameFightResumeSlaveInfo[] | undefined
	) {
		super(
			effects,
			marks,
			gameTurn,
			fightStart,
			idols,
			fxTriggerCounts,
			spellCooldowns,
			summonCount,
			bombCount
		)
		this.slavesInfo = slavesInfo
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeShort(this.slavesInfo!.length)
		this.slavesInfo!.forEach((current) => {
			current.serialize(writer)
		})
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.slavesInfo = []
		const countSlavesInfo = reader.readShort()
		for (let i: number = 0; i < countSlavesInfo; i++) {
			const type: GameFightResumeSlaveInfo = new GameFightResumeSlaveInfo()
			type.deserialize(reader)
			this.slavesInfo.push(type)
		}
	}

	public hydrate(
		data: GameFightResumeWithSlavesMessage | Record<string, any>
	): GameFightResumeWithSlavesMessage {
		if (data instanceof GameFightResumeWithSlavesMessage) {
			return data
		}

		super.hydrate(data)

		this.slavesInfo = data.slavesInfo.map(
			(
				dataElement: GameFightResumeSlaveInfo | Record<string, any>
			): GameFightResumeSlaveInfo => {
				if (dataElement instanceof GameFightResumeSlaveInfo) {
					return dataElement
				} else {
					return new GameFightResumeSlaveInfo().hydrate(dataElement)
				}
			}
		)

		return this
	}
}

export interface RawCurrentMapMessage {
	id: number
	mapId: number
	mapKey: string
}

export class CurrentMapMessage extends DofusMessage {
	public static id: number = 6179

	public mapId: number | undefined = 0

	public constructor(mapId?: number | undefined) {
		super()
		this.mapId = mapId
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeDouble(this.mapId!)
	}

	public deserialize(reader: BinaryReader): void {
		this.mapId = reader.readDouble()
	}

	public hydrate(
		data: CurrentMapMessage | Record<string, any>
	): CurrentMapMessage {
		if (data instanceof CurrentMapMessage) {
			return data
		}

		this.mapId = data.mapId

		return this
	}
}

export interface RawCurrentMapInstanceMessage extends RawCurrentMapMessage {
	id: number
	instantiatedMapId: number
}

export class CurrentMapInstanceMessage extends CurrentMapMessage {
	public static id = 3125

	public instantiatedMapId: number | undefined = 0

	public constructor(
		mapId?: number | undefined,
		instantiatedMapId?: number | undefined
	) {
		super(mapId)
		this.instantiatedMapId = instantiatedMapId
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeDouble(this.instantiatedMapId!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.instantiatedMapId = reader.readDouble()
	}

	public hydrate(
		data: CurrentMapInstanceMessage | Record<string, any>
	): CurrentMapInstanceMessage {
		if (data instanceof CurrentMapInstanceMessage) {
			return data
		}

		super.hydrate(data)

		this.instantiatedMapId = data.instantiatedMapId

		return this
	}
}

export interface RawGameFightStartingMessage {
	id: number
	fightType: number
	fightId: number
	attackerId: number
	defenderId: number
	containsBoss: boolean
}

export class GameFightStartingMessage extends DofusMessage {
	public static id: number = 3960

	public fightType: number | undefined = 0
	public fightId: number | undefined = 0
	public attackerId: number | undefined = 0
	public defenderId: number | undefined = 0
	public containsBoss: boolean | undefined = false

	public constructor(
		fightType?: number | undefined,
		fightId?: number | undefined,
		attackerId?: number | undefined,
		defenderId?: number | undefined,
		containsBoss?: boolean | undefined
	) {
		super()
		this.fightType = fightType
		this.fightId = fightId
		this.attackerId = attackerId
		this.defenderId = defenderId
		this.containsBoss = containsBoss
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeByte(this.fightType!)
		writer.writeVarShort(this.fightId!)
		writer.writeDouble(this.attackerId!)
		writer.writeDouble(this.defenderId!)
		writer.writeBoolean(this.containsBoss!)
	}

	public deserialize(reader: BinaryReader): void {
		this.fightType = reader.readByte()
		this.fightId = reader.readVarShort()
		this.attackerId = reader.readDouble()
		this.defenderId = reader.readDouble()
		this.containsBoss = reader.readBoolean()
	}

	public hydrate(
		data: GameFightStartingMessage | Record<string, any>
	): GameFightStartingMessage {
		if (data instanceof GameFightStartingMessage) {
			return data
		}

		this.fightType = data.fightType
		this.fightId = data.fightId
		this.attackerId = data.attackerId
		this.defenderId = data.defenderId
		this.containsBoss = data.containsBoss

		return this
	}
}

export interface RawGameFightJoinMessage {
	id: number
	isTeamPhase: boolean
	canBeCancelled: boolean
	canSayReady: boolean
	isFightStarted: boolean
	timeMaxBeforeFightStart: number
	fightType: number
}

export class GameFightJoinMessage extends DofusMessage {
	public static id: number = 685

	public isTeamPhase: boolean | undefined = false
	public canBeCancelled: boolean | undefined = false
	public canSayReady: boolean | undefined = false
	public isFightStarted: boolean | undefined = false
	public timeMaxBeforeFightStart: number | undefined = 0
	public fightType: number | undefined = 0

	public constructor(
		isTeamPhase?: boolean | undefined,
		canBeCancelled?: boolean | undefined,
		canSayReady?: boolean | undefined,
		isFightStarted?: boolean | undefined,
		timeMaxBeforeFightStart?: number | undefined,
		fightType?: number | undefined
	) {
		super()
		this.isTeamPhase = isTeamPhase
		this.canBeCancelled = canBeCancelled
		this.canSayReady = canSayReady
		this.isFightStarted = isFightStarted
		this.timeMaxBeforeFightStart = timeMaxBeforeFightStart
		this.fightType = fightType
	}

	public serialize(writer: BinaryWriter): void {
		let box0: number = 0
		box0 = setFlag(box0, 0, this.isTeamPhase!)
		box0 = setFlag(box0, 1, this.canBeCancelled!)
		box0 = setFlag(box0, 2, this.canSayReady!)
		box0 = setFlag(box0, 3, this.isFightStarted!)
		writer.writeByte(box0)
		writer.writeShort(this.timeMaxBeforeFightStart!)
		writer.writeByte(this.fightType!)
	}

	public deserialize(reader: BinaryReader): void {
		const box0 = reader.readByte()
		this.isTeamPhase = getFlag(box0, 0)
		this.canBeCancelled = getFlag(box0, 1)
		this.canSayReady = getFlag(box0, 2)
		this.isFightStarted = getFlag(box0, 3)
		this.timeMaxBeforeFightStart = reader.readShort()
		this.fightType = reader.readByte()
	}

	public hydrate(
		data: GameFightJoinMessage | Record<string, any>
	): GameFightJoinMessage {
		if (data instanceof GameFightJoinMessage) {
			return data
		}

		this.isTeamPhase = data.isTeamPhase
		this.canBeCancelled = data.canBeCancelled
		this.canSayReady = data.canSayReady
		this.isFightStarted = data.isFightStarted
		this.timeMaxBeforeFightStart = data.timeMaxBeforeFightStart
		this.fightType = data.fightType

		return this
	}
}

export interface RawChallengeTargetsListRequestMessage {
	id: number
	challengeId: number
}

export class ChallengeTargetsListRequestMessage extends DofusMessage {
	public static id: number = 2250

	public challengeId: number | undefined = 0

	public constructor(challengeId?: number | undefined) {
		super()
		this.challengeId = challengeId
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarShort(this.challengeId!)
	}

	public deserialize(reader: BinaryReader): void {
		this.challengeId = reader.readVarShort()
	}

	public hydrate(
		data: ChallengeTargetsListRequestMessage | Record<string, any>
	): ChallengeTargetsListRequestMessage {
		if (data instanceof ChallengeTargetsListRequestMessage) {
			return data
		}

		this.challengeId = data.challengeId

		return this
	}
}

export interface RawGameFightStartMessage {
	id: number
	idols: Idol[]
}

export class GameFightStartMessage extends DofusMessage {
	public static id: number = 5363

	public idols: Idol[] | undefined

	public constructor(idols?: Idol[] | undefined) {
		super()
		this.idols = idols
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeShort(this.idols!.length)
		this.idols!.forEach((current) => {
			current.serialize(writer)
		})
	}

	public deserialize(reader: BinaryReader): void {
		this.idols = []
		const countIdols = reader.readShort()
		for (let i: number = 0; i < countIdols; i++) {
			const type: Idol = new Idol()
			type.deserialize(reader)
			this.idols.push(type)
		}
	}

	public hydrate(
		data: GameFightStartMessage | Record<string, any>
	): GameFightStartMessage {
		if (data instanceof GameFightStartMessage) {
			return data
		}

		this.idols = data.idols.map(
			(dataElement: Idol | Record<string, any>): Idol => {
				if (dataElement instanceof Idol) {
					return dataElement
				} else {
					return new Idol().hydrate(dataElement)
				}
			}
		)

		return this
	}
}

export interface RawGameActionFightNoSpellCastMessage {
	id: number
	spellLevelId: number
}

export class GameActionFightNoSpellCastMessage extends DofusMessage {
	public static id: number = 2159

	public spellLevelId: number | undefined = 0

	public constructor(spellLevelId?: number | undefined) {
		super()
		this.spellLevelId = spellLevelId
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarInt(this.spellLevelId!)
	}

	public deserialize(reader: BinaryReader): void {
		this.spellLevelId = reader.readVarInt()
	}

	public hydrate(
		data: GameActionFightNoSpellCastMessage | Record<string, any>
	): GameActionFightNoSpellCastMessage {
		if (data instanceof GameActionFightNoSpellCastMessage) {
			return data
		}

		this.spellLevelId = data.spellLevelId

		return this
	}
}

export interface RawGameContextDestroyMessage {
	id: number
}

export class GameContextDestroyMessage extends DofusMessage {
	public static id: number = 7633

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public serialize(writer: BinaryWriter): void {}

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public deserialize(reader: BinaryReader): void {}

	public hydrate(
		data: GameContextDestroyMessage | Record<string, any>
	): GameContextDestroyMessage {
		if (data instanceof GameContextDestroyMessage) {
			return data
		}

		return this
	}
}

export interface RawGameFightSpectatorJoinMessage
	extends RawGameFightJoinMessage {
	id: number
	namedPartyTeams: NamedPartyTeam[]
}

export class GameFightSpectatorJoinMessage extends GameFightJoinMessage {
	public static id = 6930

	public namedPartyTeams: NamedPartyTeam[] | undefined

	public constructor(
		isTeamPhase?: boolean | undefined,
		canBeCancelled?: boolean | undefined,
		canSayReady?: boolean | undefined,
		isFightStarted?: boolean | undefined,
		timeMaxBeforeFightStart?: number | undefined,
		fightType?: number | undefined,
		namedPartyTeams?: NamedPartyTeam[] | undefined
	) {
		super(
			isTeamPhase,
			canBeCancelled,
			canSayReady,
			isFightStarted,
			timeMaxBeforeFightStart,
			fightType
		)
		this.namedPartyTeams = namedPartyTeams
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeShort(this.namedPartyTeams!.length)
		this.namedPartyTeams!.forEach((current) => {
			current.serialize(writer)
		})
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.namedPartyTeams = []
		const countNamedPartyTeams = reader.readShort()
		for (let i: number = 0; i < countNamedPartyTeams; i++) {
			const type: NamedPartyTeam = new NamedPartyTeam()
			type.deserialize(reader)
			this.namedPartyTeams.push(type)
		}
	}

	public hydrate(
		data: GameFightSpectatorJoinMessage | Record<string, any>
	): GameFightSpectatorJoinMessage {
		if (data instanceof GameFightSpectatorJoinMessage) {
			return data
		}

		super.hydrate(data)

		this.namedPartyTeams = data.namedPartyTeams.map(
			(dataElement: NamedPartyTeam | Record<string, any>): NamedPartyTeam => {
				if (dataElement instanceof NamedPartyTeam) {
					return dataElement
				} else {
					return new NamedPartyTeam().hydrate(dataElement)
				}
			}
		)

		return this
	}
}

export interface RawChallengeInfoMessage {
	id: number
	challengeId: number
	targetId: number
	xpBonus: number
	dropBonus: number
}

export class ChallengeInfoMessage extends DofusMessage {
	public static id: number = 9675

	public challengeId: number | undefined = 0
	public targetId: number | undefined = 0
	public xpBonus: number | undefined = 0
	public dropBonus: number | undefined = 0

	public constructor(
		challengeId?: number | undefined,
		targetId?: number | undefined,
		xpBonus?: number | undefined,
		dropBonus?: number | undefined
	) {
		super()
		this.challengeId = challengeId
		this.targetId = targetId
		this.xpBonus = xpBonus
		this.dropBonus = dropBonus
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarShort(this.challengeId!)
		writer.writeDouble(this.targetId!)
		writer.writeVarInt(this.xpBonus!)
		writer.writeVarInt(this.dropBonus!)
	}

	public deserialize(reader: BinaryReader): void {
		this.challengeId = reader.readVarShort()
		this.targetId = reader.readDouble()
		this.xpBonus = reader.readVarInt()
		this.dropBonus = reader.readVarInt()
	}

	public hydrate(
		data: ChallengeInfoMessage | Record<string, any>
	): ChallengeInfoMessage {
		if (data instanceof ChallengeInfoMessage) {
			return data
		}

		this.challengeId = data.challengeId
		this.targetId = data.targetId
		this.xpBonus = data.xpBonus
		this.dropBonus = data.dropBonus

		return this
	}
}

export interface RawChallengeTargetsListMessage {
	id: number
	targetIds: number[]
	targetCells: number[]
}

export class ChallengeTargetsListMessage extends DofusMessage {
	public static id: number = 2009

	public targetIds: number[] | undefined
	public targetCells: number[] | undefined

	public constructor(
		targetIds?: number[] | undefined,
		targetCells?: number[] | undefined
	) {
		super()
		this.targetIds = targetIds
		this.targetCells = targetCells
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeShort(this.targetIds!.length)
		this.targetIds!.forEach((current: number) => writer.writeDouble(current))
		writer.writeShort(this.targetCells!.length)
		this.targetCells!.forEach((current: number) => writer.writeShort(current))
	}

	public deserialize(reader: BinaryReader): void {
		this.targetIds = []
		const countTargetIds = reader.readShort()
		for (let i: number = 0; i < countTargetIds; i++) {
			this.targetIds.push(reader.readDouble())
		}
		this.targetCells = []
		const countTargetCells = reader.readShort()
		for (let i: number = 0; i < countTargetCells; i++) {
			this.targetCells.push(reader.readShort())
		}
	}

	public hydrate(
		data: ChallengeTargetsListMessage | Record<string, any>
	): ChallengeTargetsListMessage {
		if (data instanceof ChallengeTargetsListMessage) {
			return data
		}

		this.targetIds = data.targetIds
		this.targetCells = data.targetCells

		return this
	}
}

export interface RawMapObstacleUpdateMessage {
	id: number
	obstacles: MapObstacle[]
}

export class MapObstacleUpdateMessage extends DofusMessage {
	public static id: number = 6903

	public obstacles: MapObstacle[] | undefined

	public constructor(obstacles?: MapObstacle[] | undefined) {
		super()
		this.obstacles = obstacles
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeShort(this.obstacles!.length)
		this.obstacles!.forEach((current) => {
			current.serialize(writer)
		})
	}

	public deserialize(reader: BinaryReader): void {
		this.obstacles = []
		const countObstacles = reader.readShort()
		for (let i: number = 0; i < countObstacles; i++) {
			const type: MapObstacle = new MapObstacle()
			type.deserialize(reader)
			this.obstacles.push(type)
		}
	}

	public hydrate(
		data: MapObstacleUpdateMessage | Record<string, any>
	): MapObstacleUpdateMessage {
		if (data instanceof MapObstacleUpdateMessage) {
			return data
		}

		this.obstacles = data.obstacles.map(
			(dataElement: MapObstacle | Record<string, any>): MapObstacle => {
				if (dataElement instanceof MapObstacle) {
					return dataElement
				} else {
					return new MapObstacle().hydrate(dataElement)
				}
			}
		)

		return this
	}
}

export interface RawArenaFighterLeaveMessage {
	id: number
	leaver: CharacterBasicMinimalInformations
}

export class ArenaFighterLeaveMessage extends DofusMessage {
	public static id: number = 2158

	public leaver: CharacterBasicMinimalInformations | undefined

	public constructor(leaver?: CharacterBasicMinimalInformations | undefined) {
		super()
		this.leaver = leaver
	}

	public serialize(writer: BinaryWriter): void {
		this.leaver!.serialize(writer)
	}

	public deserialize(reader: BinaryReader): void {
		this.leaver = new CharacterBasicMinimalInformations()
		this.leaver!.deserialize(reader)
	}

	public hydrate(
		data: ArenaFighterLeaveMessage | Record<string, any>
	): ArenaFighterLeaveMessage {
		if (data instanceof ArenaFighterLeaveMessage) {
			return data
		}

		this.leaver = new CharacterBasicMinimalInformations().hydrate(data.leaver)

		return this
	}
}

export interface RawGameContextReadyMessage {
	id: number
	mapId: number
}

export class GameContextReadyMessage extends DofusMessage {
	public static id: number = 5960

	public mapId: number | undefined = 0

	public constructor(mapId?: number | undefined) {
		super()
		this.mapId = mapId
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeDouble(this.mapId!)
	}

	public deserialize(reader: BinaryReader): void {
		this.mapId = reader.readDouble()
	}

	public hydrate(
		data: GameContextReadyMessage | Record<string, any>
	): GameContextReadyMessage {
		if (data instanceof GameContextReadyMessage) {
			return data
		}

		this.mapId = data.mapId

		return this
	}
}

export interface RawChallengeResultMessage {
	id: number
	challengeId: number
	success: boolean
}

export class ChallengeResultMessage extends DofusMessage {
	public static id: number = 2089

	public challengeId: number | undefined = 0
	public success: boolean | undefined = false

	public constructor(
		challengeId?: number | undefined,
		success?: boolean | undefined
	) {
		super()
		this.challengeId = challengeId
		this.success = success
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarShort(this.challengeId!)
		writer.writeBoolean(this.success!)
	}

	public deserialize(reader: BinaryReader): void {
		this.challengeId = reader.readVarShort()
		this.success = reader.readBoolean()
	}

	public hydrate(
		data: ChallengeResultMessage | Record<string, any>
	): ChallengeResultMessage {
		if (data instanceof ChallengeResultMessage) {
			return data
		}

		this.challengeId = data.challengeId
		this.success = data.success

		return this
	}
}

export interface RawGameFightTurnStartPlayingMessage {
	id: number
}

export class GameFightTurnStartPlayingMessage extends DofusMessage {
	public static id: number = 5330

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public serialize(writer: BinaryWriter): void {}

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public deserialize(reader: BinaryReader): void {}

	public hydrate(
		data: GameFightTurnStartPlayingMessage | Record<string, any>
	): GameFightTurnStartPlayingMessage {
		if (data instanceof GameFightTurnStartPlayingMessage) {
			return data
		}

		return this
	}
}

export interface RawGameFightNewWaveMessage {
	id: number
	id_: number
	teamId: number
	nbTurnBeforeNextWave: number
}

export class GameFightNewWaveMessage extends DofusMessage {
	public static id: number = 6575

	public id_: number | undefined = 0
	public teamId: number | undefined = 2
	public nbTurnBeforeNextWave: number | undefined = 0

	public constructor(
		id_?: number | undefined,
		teamId?: number | undefined,
		nbTurnBeforeNextWave?: number | undefined
	) {
		super()
		this.id_ = id_
		this.teamId = teamId
		this.nbTurnBeforeNextWave = nbTurnBeforeNextWave
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeByte(this.id_!)
		writer.writeByte(this.teamId!)
		writer.writeShort(this.nbTurnBeforeNextWave!)
	}

	public deserialize(reader: BinaryReader): void {
		this.id_ = reader.readByte()
		this.teamId = reader.readByte()
		this.nbTurnBeforeNextWave = reader.readShort()
	}

	public hydrate(
		data: GameFightNewWaveMessage | Record<string, any>
	): GameFightNewWaveMessage {
		if (data instanceof GameFightNewWaveMessage) {
			return data
		}

		this.id_ = data.id_
		this.teamId = data.teamId
		this.nbTurnBeforeNextWave = data.nbTurnBeforeNextWave

		return this
	}
}

export interface RawGameFightPauseMessage {
	id: number
	isPaused: boolean
}

export class GameFightPauseMessage extends DofusMessage {
	public static id: number = 6427

	public isPaused: boolean | undefined = false

	public constructor(isPaused?: boolean | undefined) {
		super()
		this.isPaused = isPaused
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeBoolean(this.isPaused!)
	}

	public deserialize(reader: BinaryReader): void {
		this.isPaused = reader.readBoolean()
	}

	public hydrate(
		data: GameFightPauseMessage | Record<string, any>
	): GameFightPauseMessage {
		if (data instanceof GameFightPauseMessage) {
			return data
		}

		this.isPaused = data.isPaused

		return this
	}
}

export interface RawSlaveNoLongerControledMessage {
	id: number
	masterId: number
	slaveId: number
}

export class SlaveNoLongerControledMessage extends DofusMessage {
	public static id: number = 6112

	public masterId: number | undefined = 0
	public slaveId: number | undefined = 0

	public constructor(
		masterId?: number | undefined,
		slaveId?: number | undefined
	) {
		super()
		this.masterId = masterId
		this.slaveId = slaveId
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeDouble(this.masterId!)
		writer.writeDouble(this.slaveId!)
	}

	public deserialize(reader: BinaryReader): void {
		this.masterId = reader.readDouble()
		this.slaveId = reader.readDouble()
	}

	public hydrate(
		data: SlaveNoLongerControledMessage | Record<string, any>
	): SlaveNoLongerControledMessage {
		if (data instanceof SlaveNoLongerControledMessage) {
			return data
		}

		this.masterId = data.masterId
		this.slaveId = data.slaveId

		return this
	}
}

export interface RawCharacterStatsListMessage {
	id: number
	stats: CharacterCharacteristicsInformations
}

export class CharacterStatsListMessage extends DofusMessage {
	public static id: number = 5364

	public stats: CharacterCharacteristicsInformations | undefined

	public constructor(stats?: CharacterCharacteristicsInformations | undefined) {
		super()
		this.stats = stats
	}

	public serialize(writer: BinaryWriter): void {
		this.stats!.serialize(writer)
	}

	public deserialize(reader: BinaryReader): void {
		this.stats = new CharacterCharacteristicsInformations()
		this.stats!.deserialize(reader)
	}

	public hydrate(
		data: CharacterStatsListMessage | Record<string, any>
	): CharacterStatsListMessage {
		if (data instanceof CharacterStatsListMessage) {
			return data
		}

		return this
	}
}

export interface RawGameFightTurnStartMessage {
	id: number
	id_: number
	waitTime: number
}

export class GameFightTurnStartMessage extends DofusMessage {
	public static id: number = 7110

	public id_: number | undefined = 0
	public waitTime: number | undefined = 0

	public constructor(id_?: number | undefined, waitTime?: number | undefined) {
		super()
		this.id_ = id_
		this.waitTime = waitTime
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeDouble(this.id_!)
		writer.writeVarInt(this.waitTime!)
	}

	public deserialize(reader: BinaryReader): void {
		this.id_ = reader.readDouble()
		this.waitTime = reader.readVarInt()
	}

	public hydrate(
		data: GameFightTurnStartMessage | Record<string, any>
	): GameFightTurnStartMessage {
		if (data instanceof GameFightTurnStartMessage) {
			return data
		}

		this.id_ = data.id_
		this.waitTime = data.waitTime

		return this
	}
}

export interface RawGameActionAcknowledgementMessage {
	id: number
	valid: boolean
	actionId: number
}

export class GameActionAcknowledgementMessage extends DofusMessage {
	public static id: number = 3790

	public valid: boolean | undefined = false
	public actionId: number | undefined = 0

	public constructor(
		valid?: boolean | undefined,
		actionId?: number | undefined
	) {
		super()
		this.valid = valid
		this.actionId = actionId
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeBoolean(this.valid!)
		writer.writeByte(this.actionId!)
	}

	public deserialize(reader: BinaryReader): void {
		this.valid = reader.readBoolean()
		this.actionId = reader.readByte()
	}

	public hydrate(
		data: GameActionAcknowledgementMessage | Record<string, any>
	): GameActionAcknowledgementMessage {
		if (data instanceof GameActionAcknowledgementMessage) {
			return data
		}

		this.valid = data.valid
		this.actionId = data.actionId

		return this
	}
}

export interface RawGameFightTurnResumeMessage
	extends RawGameFightTurnStartMessage {
	id: number
	remainingTime: number
}

export class GameFightTurnResumeMessage extends GameFightTurnStartMessage {
	public static id = 2330

	public remainingTime: number | undefined = 0

	public constructor(
		id_?: number | undefined,
		waitTime?: number | undefined,
		remainingTime?: number | undefined
	) {
		super(id_, waitTime)
		this.remainingTime = remainingTime
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeVarInt(this.remainingTime!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.remainingTime = reader.readVarInt()
	}

	public hydrate(
		data: GameFightTurnResumeMessage | Record<string, any>
	): GameFightTurnResumeMessage {
		if (data instanceof GameFightTurnResumeMessage) {
			return data
		}

		super.hydrate(data)

		this.remainingTime = data.remainingTime

		return this
	}
}

export interface RawGameFightTurnReadyMessage {
	id: number
	isReady: boolean
}

export class GameFightTurnReadyMessage extends DofusMessage {
	public static id: number = 765

	public isReady: boolean | undefined = false

	public constructor(isReady?: boolean | undefined) {
		super()
		this.isReady = isReady
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeBoolean(this.isReady!)
	}

	public deserialize(reader: BinaryReader): void {
		this.isReady = reader.readBoolean()
	}

	public hydrate(
		data: GameFightTurnReadyMessage | Record<string, any>
	): GameFightTurnReadyMessage {
		if (data instanceof GameFightTurnReadyMessage) {
			return data
		}

		this.isReady = data.isReady

		return this
	}
}

export interface RawGameFightTurnReadyRequestMessage {
	id: number
	id_: number
}

export class GameFightTurnReadyRequestMessage extends DofusMessage {
	public static id: number = 6293

	public id_: number | undefined = 0

	public constructor(id_?: number | undefined) {
		super()
		this.id_ = id_
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeDouble(this.id_!)
	}

	public deserialize(reader: BinaryReader): void {
		this.id_ = reader.readDouble()
	}

	public hydrate(
		data: GameFightTurnReadyRequestMessage | Record<string, any>
	): GameFightTurnReadyRequestMessage {
		if (data instanceof GameFightTurnReadyRequestMessage) {
			return data
		}

		this.id_ = data.id_

		return this
	}
}

export interface RawGameActionUpdateEffectTriggerCountMessage {
	id: number
	targetIds: GameFightEffectTriggerCount[]
}

export class GameActionUpdateEffectTriggerCountMessage extends DofusMessage {
	public static id: number = 2534

	public targetIds: GameFightEffectTriggerCount[] | undefined

	public constructor(targetIds?: GameFightEffectTriggerCount[] | undefined) {
		super()
		this.targetIds = targetIds
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeShort(this.targetIds!.length)
		this.targetIds!.forEach((current) => {
			current.serialize(writer)
		})
	}

	public deserialize(reader: BinaryReader): void {
		this.targetIds = []
		const countTargetIds = reader.readShort()
		for (let i: number = 0; i < countTargetIds; i++) {
			const type: GameFightEffectTriggerCount = new GameFightEffectTriggerCount()
			type.deserialize(reader)
			this.targetIds.push(type)
		}
	}

	public hydrate(
		data: GameActionUpdateEffectTriggerCountMessage | Record<string, any>
	): GameActionUpdateEffectTriggerCountMessage {
		if (data instanceof GameActionUpdateEffectTriggerCountMessage) {
			return data
		}

		this.targetIds = data.targetIds.map(
			(
				dataElement: GameFightEffectTriggerCount | Record<string, any>
			): GameFightEffectTriggerCount => {
				if (dataElement instanceof GameFightEffectTriggerCount) {
					return dataElement
				} else {
					return new GameFightEffectTriggerCount().hydrate(dataElement)
				}
			}
		)

		return this
	}
}

export interface RawGameFightTurnEndMessage {
	id: number
	id_: number
}

export class GameFightTurnEndMessage extends DofusMessage {
	public static id: number = 8856

	public id_: number | undefined = 0

	public constructor(id_?: number | undefined) {
		super()
		this.id_ = id_
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeDouble(this.id_!)
	}

	public deserialize(reader: BinaryReader): void {
		this.id_ = reader.readDouble()
	}

	public hydrate(
		data: GameFightTurnEndMessage | Record<string, any>
	): GameFightTurnEndMessage {
		if (data instanceof GameFightTurnEndMessage) {
			return data
		}

		this.id_ = data.id_

		return this
	}
}

export interface RawGameFightNewRoundMessage {
	id: number
	roundNumber: number
}

export class GameFightNewRoundMessage extends DofusMessage {
	public static id: number = 4660

	public roundNumber: number | undefined = 0

	public constructor(roundNumber?: number | undefined) {
		super()
		this.roundNumber = roundNumber
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarInt(this.roundNumber!)
	}

	public deserialize(reader: BinaryReader): void {
		this.roundNumber = reader.readVarInt()
	}

	public hydrate(
		data: GameFightNewRoundMessage | Record<string, any>
	): GameFightNewRoundMessage {
		if (data instanceof GameFightNewRoundMessage) {
			return data
		}

		this.roundNumber = data.roundNumber

		return this
	}
}

export interface RawRefreshCharacterStatsMessage {
	id: number
	fighterId: number
	stats: GameFightMinimalStats
}

export class RefreshCharacterStatsMessage extends DofusMessage {
	public static id: number = 1497

	public fighterId: number | undefined = 0
	public stats: GameFightMinimalStats | undefined

	public constructor(
		fighterId?: number | undefined,
		stats?: GameFightMinimalStats | undefined
	) {
		super()
		this.fighterId = fighterId
		this.stats = stats
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeDouble(this.fighterId!)
		this.stats!.serialize(writer)
	}

	public deserialize(reader: BinaryReader): void {
		this.fighterId = reader.readDouble()
		this.stats = new GameFightMinimalStats()
		this.stats!.deserialize(reader)
	}

	public hydrate(
		data: RefreshCharacterStatsMessage | Record<string, any>
	): RefreshCharacterStatsMessage {
		if (data instanceof RefreshCharacterStatsMessage) {
			return data
		}

		this.fighterId = data.fighterId
		this.stats = new GameFightMinimalStats().hydrate(data.stats)

		return this
	}
}

export interface RawSlaveSwitchContextMessage {
	id: number
	masterId: number
	slaveId: number
	slaveSpells: SpellItem[]
	slaveStats: CharacterCharacteristicsInformations
	shortcuts: Shortcut[]
}

export class SlaveSwitchContextMessage extends DofusMessage {
	public static id: number = 5295

	public masterId: number | undefined = 0
	public slaveId: number | undefined = 0
	public slaveSpells: SpellItem[] | undefined
	public slaveStats: CharacterCharacteristicsInformations | undefined
	public shortcuts: Shortcut[] | undefined

	public constructor(
		masterId?: number | undefined,
		slaveId?: number | undefined,
		slaveSpells?: SpellItem[] | undefined,
		slaveStats?: CharacterCharacteristicsInformations | undefined,
		shortcuts?: Shortcut[] | undefined
	) {
		super()
		this.masterId = masterId
		this.slaveId = slaveId
		this.slaveSpells = slaveSpells
		this.slaveStats = slaveStats
		this.shortcuts = shortcuts
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeDouble(this.masterId!)
		writer.writeDouble(this.slaveId!)
		writer.writeShort(this.slaveSpells!.length)
		this.slaveSpells!.forEach((current) => {
			current.serialize(writer)
		})
		this.slaveStats!.serialize(writer)
		writer.writeShort(this.shortcuts!.length)
		this.shortcuts!.forEach((current) => {
			writer.writeShort(current.id)
			current.serialize(writer)
		})
	}

	public deserialize(reader: BinaryReader): void {
		this.masterId = reader.readDouble()
		this.slaveId = reader.readDouble()
		this.slaveSpells = []
		const countSlaveSpells = reader.readShort()
		for (let i: number = 0; i < countSlaveSpells; i++) {
			const type: SpellItem = new SpellItem()
			type.deserialize(reader)
			this.slaveSpells.push(type)
		}
		this.slaveStats = new CharacterCharacteristicsInformations()
		this.slaveStats!.deserialize(reader)
		this.shortcuts = []
		const countShortcuts = reader.readShort()
		for (let i: number = 0; i < countShortcuts; i++) {
			const shortcutsTypeId: number = reader.readShort()
			const type: Shortcut = new types[shortcutsTypeId]() as Shortcut
			type.deserialize(reader)
			this.shortcuts.push(type)
		}
	}

	public hydrate(
		data: SlaveSwitchContextMessage | Record<string, any>
	): SlaveSwitchContextMessage {
		if (data instanceof SlaveSwitchContextMessage) {
			return data
		}

		this.masterId = data.masterId
		this.slaveId = data.slaveId
		this.slaveSpells = data.slaveSpells.map(
			(dataElement: SpellItem | Record<string, any>): SpellItem => {
				if (dataElement instanceof SpellItem) {
					return dataElement
				} else {
					return new SpellItem().hydrate(dataElement)
				}
			}
		)
		this.shortcuts = data.shortcuts.map(
			(dataElement: Shortcut | Record<string, any>): Shortcut => {
				if (dataElement instanceof Shortcut) {
					return dataElement
				} else {
					return (new types[dataElement.id]() as Shortcut).hydrate(dataElement)
				}
			}
		)

		return this
	}
}

export interface RawHaapiApiKeyRequestMessage {
	id: number
}

export class HaapiApiKeyRequestMessage extends DofusMessage {
	public static id: number = 2027

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public serialize(writer: BinaryWriter): void {}

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public deserialize(reader: BinaryReader): void {}

	public hydrate(
		data: HaapiApiKeyRequestMessage | Record<string, any>
	): HaapiApiKeyRequestMessage {
		if (data instanceof HaapiApiKeyRequestMessage) {
			return data
		}

		return this
	}
}

export interface RawDebugClearHighlightCellsMessage {
	id: number
}

export class DebugClearHighlightCellsMessage extends DofusMessage {
	public static id: number = 2503

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public serialize(writer: BinaryWriter): void {}

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public deserialize(reader: BinaryReader): void {}

	public hydrate(
		data: DebugClearHighlightCellsMessage | Record<string, any>
	): DebugClearHighlightCellsMessage {
		if (data instanceof DebugClearHighlightCellsMessage) {
			return data
		}

		return this
	}
}

export interface RawDebugHighlightCellsMessage {
	id: number
	color: number
	cells: number[]
}

export class DebugHighlightCellsMessage extends DofusMessage {
	public static id: number = 7861

	public color: number | undefined = 0
	public cells: number[] | undefined

	public constructor(color?: number | undefined, cells?: number[] | undefined) {
		super()
		this.color = color
		this.cells = cells
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeDouble(this.color!)
		writer.writeShort(this.cells!.length)
		this.cells!.forEach((current: number) => writer.writeVarShort(current))
	}

	public deserialize(reader: BinaryReader): void {
		this.color = reader.readDouble()
		this.cells = []
		const countCells = reader.readShort()
		for (let i: number = 0; i < countCells; i++) {
			this.cells.push(reader.readVarShort())
		}
	}

	public hydrate(
		data: DebugHighlightCellsMessage | Record<string, any>
	): DebugHighlightCellsMessage {
		if (data instanceof DebugHighlightCellsMessage) {
			return data
		}

		this.color = data.color
		this.cells = data.cells

		return this
	}
}

export interface RawDebugInClientMessage {
	id: number
	level: number
	message: string
}

export class DebugInClientMessage extends DofusMessage {
	public static id: number = 2283

	public level: number | undefined = 0
	public message: string | undefined

	public constructor(level?: number | undefined, message?: string | undefined) {
		super()
		this.level = level
		this.message = message
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeByte(this.level!)
		writer.writeUTF(this.message!)
	}

	public deserialize(reader: BinaryReader): void {
		this.level = reader.readByte()
		this.message = reader.readUTF()
	}

	public hydrate(
		data: DebugInClientMessage | Record<string, any>
	): DebugInClientMessage {
		if (data instanceof DebugInClientMessage) {
			return data
		}

		this.level = data.level
		this.message = data.message

		return this
	}
}

export interface RawAchievementListMessage {
	id: number
	finishedAchievements: AchievementAchieved[]
}

export class AchievementListMessage extends DofusMessage {
	public static id: number = 8158

	public finishedAchievements: AchievementAchieved[] | undefined

	public constructor(finishedAchievements?: AchievementAchieved[] | undefined) {
		super()
		this.finishedAchievements = finishedAchievements
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeShort(this.finishedAchievements!.length)
		this.finishedAchievements!.forEach((current) => {
			writer.writeShort(current.id)
			current.serialize(writer)
		})
	}

	public deserialize(reader: BinaryReader): void {
		this.finishedAchievements = []
		const countFinishedAchievements = reader.readShort()
		for (let i: number = 0; i < countFinishedAchievements; i++) {
			const finishedAchievementsTypeId: number = reader.readShort()
			const type: AchievementAchieved = new types[
				finishedAchievementsTypeId
			]() as AchievementAchieved
			type.deserialize(reader)
			this.finishedAchievements.push(type)
		}
	}

	public hydrate(
		data: AchievementListMessage | Record<string, any>
	): AchievementListMessage {
		if (data instanceof AchievementListMessage) {
			return data
		}

		this.finishedAchievements = data.finishedAchievements.map(
			(
				dataElement: AchievementAchieved | Record<string, any>
			): AchievementAchieved => {
				if (dataElement instanceof AchievementAchieved) {
					return dataElement
				} else {
					return (new types[dataElement.id]() as AchievementAchieved).hydrate(
						dataElement
					)
				}
			}
		)

		return this
	}
}

export interface RawIdentificationMessage {
	id: number
	autoconnect: boolean
	useCertificate: boolean
	useLoginToken: boolean
	version: Version
	lang: string
	credentials: number[]
	serverId: number
	sessionOptionalSalt: number
	failedAttempts: number[]
}

export class IdentificationMessage extends DofusMessage {
	public static id: number = 4805

	public autoconnect: boolean | undefined = false
	public useCertificate: boolean | undefined = false
	public useLoginToken: boolean | undefined = false
	public version: Version | undefined
	public lang: string | undefined
	public credentials: number[] | undefined
	public serverId: number | undefined = 0
	public sessionOptionalSalt: number | undefined = 0
	public failedAttempts: number[] | undefined

	public constructor(
		autoconnect?: boolean | undefined,
		useCertificate?: boolean | undefined,
		useLoginToken?: boolean | undefined,
		version?: Version | undefined,
		lang?: string | undefined,
		credentials?: number[] | undefined,
		serverId?: number | undefined,
		sessionOptionalSalt?: number | undefined,
		failedAttempts?: number[] | undefined
	) {
		super()
		this.autoconnect = autoconnect
		this.useCertificate = useCertificate
		this.useLoginToken = useLoginToken
		this.version = version
		this.lang = lang
		this.credentials = credentials
		this.serverId = serverId
		this.sessionOptionalSalt = sessionOptionalSalt
		this.failedAttempts = failedAttempts
	}

	public serialize(writer: BinaryWriter): void {
		let box0: number = 0
		box0 = setFlag(box0, 0, this.autoconnect!)
		box0 = setFlag(box0, 1, this.useCertificate!)
		box0 = setFlag(box0, 2, this.useLoginToken!)
		writer.writeByte(box0)
		this.version!.serialize(writer)
		writer.writeUTF(this.lang!)
		writer.writeVarInt(this.credentials!.length)
		this.credentials!.forEach((current: number) => writer.writeByte(current))
		writer.writeShort(this.serverId!)
		writer.writeVarLong(this.sessionOptionalSalt!)
		writer.writeShort(this.failedAttempts!.length)
		this.failedAttempts!.forEach((current: number) =>
			writer.writeVarShort(current)
		)
	}

	public deserialize(reader: BinaryReader): void {
		const box0 = reader.readByte()
		this.autoconnect = getFlag(box0, 0)
		this.useCertificate = getFlag(box0, 1)
		this.useLoginToken = getFlag(box0, 2)
		this.version = new Version()
		this.version!.deserialize(reader)
		this.lang = reader.readUTF()
		this.credentials = []
		const countCredentials = reader.readVarInt()
		for (let i: number = 0; i < countCredentials; i++) {
			this.credentials.push(reader.readByte())
		}
		this.serverId = reader.readShort()
		this.sessionOptionalSalt = reader.readVarLong()
		this.failedAttempts = []
		const countFailedAttempts = reader.readShort()
		for (let i: number = 0; i < countFailedAttempts; i++) {
			this.failedAttempts.push(reader.readVarShort())
		}
	}

	public hydrate(
		data: IdentificationMessage | Record<string, any>
	): IdentificationMessage {
		if (data instanceof IdentificationMessage) {
			return data
		}

		this.autoconnect = data.autoconnect
		this.useCertificate = data.useCertificate
		this.useLoginToken = data.useLoginToken
		this.version = new Version().hydrate(data.version)
		this.lang = data.lang
		this.credentials = data.credentials
		this.serverId = data.serverId
		this.sessionOptionalSalt = data.sessionOptionalSalt
		this.failedAttempts = data.failedAttempts

		return this
	}
}

export interface RawIdentificationAccountForceMessage
	extends RawIdentificationMessage {
	id: number
	forcedAccountLogin: string
}

export class IdentificationAccountForceMessage extends IdentificationMessage {
	public static id = 4574

	public forcedAccountLogin: string | undefined

	public constructor(
		autoconnect?: boolean | undefined,
		useCertificate?: boolean | undefined,
		useLoginToken?: boolean | undefined,
		version?: Version | undefined,
		lang?: string | undefined,
		credentials?: number[] | undefined,
		serverId?: number | undefined,
		sessionOptionalSalt?: number | undefined,
		failedAttempts?: number[] | undefined,
		forcedAccountLogin?: string | undefined
	) {
		super(
			autoconnect,
			useCertificate,
			useLoginToken,
			version,
			lang,
			credentials,
			serverId,
			sessionOptionalSalt,
			failedAttempts
		)
		this.forcedAccountLogin = forcedAccountLogin
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeUTF(this.forcedAccountLogin!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.forcedAccountLogin = reader.readUTF()
	}

	public hydrate(
		data: IdentificationAccountForceMessage | Record<string, any>
	): IdentificationAccountForceMessage {
		if (data instanceof IdentificationAccountForceMessage) {
			return data
		}

		super.hydrate(data)

		this.forcedAccountLogin = data.forcedAccountLogin

		return this
	}
}

export interface RawBasicAckMessage {
	id: number
	seq: number
	lastPacketId: number
}

export class BasicAckMessage extends DofusMessage {
	public static id: number = 9898

	public seq: number | undefined = 0
	public lastPacketId: number | undefined = 0

	public constructor(
		seq?: number | undefined,
		lastPacketId?: number | undefined
	) {
		super()
		this.seq = seq
		this.lastPacketId = lastPacketId
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarInt(this.seq!)
		writer.writeVarShort(this.lastPacketId!)
	}

	public deserialize(reader: BinaryReader): void {
		this.seq = reader.readVarInt()
		this.lastPacketId = reader.readVarShort()
	}

	public hydrate(data: BasicAckMessage | Record<string, any>): BasicAckMessage {
		if (data instanceof BasicAckMessage) {
			return data
		}

		this.seq = data.seq
		this.lastPacketId = data.lastPacketId

		return this
	}
}

export interface RawBasicNoOperationMessage {
	id: number
}

export class BasicNoOperationMessage extends DofusMessage {
	public static id: number = 7318

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public serialize(writer: BinaryWriter): void {}

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public deserialize(reader: BinaryReader): void {}

	public hydrate(
		data: BasicNoOperationMessage | Record<string, any>
	): BasicNoOperationMessage {
		if (data instanceof BasicNoOperationMessage) {
			return data
		}

		return this
	}
}

export interface RawCredentialsAcknowledgementMessage {
	id: number
}

export class CredentialsAcknowledgementMessage extends DofusMessage {
	public static id: number = 4271

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public serialize(writer: BinaryWriter): void {}

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public deserialize(reader: BinaryReader): void {}

	public hydrate(
		data: CredentialsAcknowledgementMessage | Record<string, any>
	): CredentialsAcknowledgementMessage {
		if (data instanceof CredentialsAcknowledgementMessage) {
			return data
		}

		return this
	}
}

export interface RawOnConnectionEventMessage {
	id: number
	eventType: number
}

export class OnConnectionEventMessage extends DofusMessage {
	public static id: number = 4557

	public eventType: number | undefined = 0

	public constructor(eventType?: number | undefined) {
		super()
		this.eventType = eventType
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeByte(this.eventType!)
	}

	public deserialize(reader: BinaryReader): void {
		this.eventType = reader.readByte()
	}

	public hydrate(
		data: OnConnectionEventMessage | Record<string, any>
	): OnConnectionEventMessage {
		if (data instanceof OnConnectionEventMessage) {
			return data
		}

		this.eventType = data.eventType

		return this
	}
}

export interface RawObjectJobAddedMessage {
	id: number
	jobId: number
}

export class ObjectJobAddedMessage extends DofusMessage {
	public static id: number = 5863

	public jobId: number | undefined = 0

	public constructor(jobId?: number | undefined) {
		super()
		this.jobId = jobId
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeByte(this.jobId!)
	}

	public deserialize(reader: BinaryReader): void {
		this.jobId = reader.readByte()
	}

	public hydrate(
		data: ObjectJobAddedMessage | Record<string, any>
	): ObjectJobAddedMessage {
		if (data instanceof ObjectJobAddedMessage) {
			return data
		}

		this.jobId = data.jobId

		return this
	}
}

export interface RawLivingObjectMessageRequestMessage {
	id: number
	msgId: number
	parameters: string[]
	livingObject: number
}

export class LivingObjectMessageRequestMessage extends DofusMessage {
	public static id: number = 6521

	public msgId: number | undefined = 0
	public parameters: string[] | undefined
	public livingObject: number | undefined = 0

	public constructor(
		msgId?: number | undefined,
		parameters?: string[] | undefined,
		livingObject?: number | undefined
	) {
		super()
		this.msgId = msgId
		this.parameters = parameters
		this.livingObject = livingObject
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarShort(this.msgId!)
		writer.writeShort(this.parameters!.length)
		this.parameters!.forEach((current: string) => writer.writeUTF(current))
		writer.writeVarInt(this.livingObject!)
	}

	public deserialize(reader: BinaryReader): void {
		this.msgId = reader.readVarShort()
		this.parameters = []
		const countParameters = reader.readShort()
		for (let i: number = 0; i < countParameters; i++) {
			this.parameters.push(reader.readUTF())
		}
		this.livingObject = reader.readVarInt()
	}

	public hydrate(
		data: LivingObjectMessageRequestMessage | Record<string, any>
	): LivingObjectMessageRequestMessage {
		if (data instanceof LivingObjectMessageRequestMessage) {
			return data
		}

		this.msgId = data.msgId
		this.parameters = data.parameters
		this.livingObject = data.livingObject

		return this
	}
}

export interface RawIdentificationSuccessMessage {
	id: number
	hasRights: boolean
	hasConsoleRight: boolean
	wasAlreadyConnected: boolean
	login: string
	nickname: string
	accountId: number
	communityId: number
	secretQuestion: string
	accountCreation: number
	subscriptionElapsedDuration: number
	subscriptionEndDate: number
	havenbagAvailableRoom: number
}

export class IdentificationSuccessMessage extends DofusMessage {
	public static id: number = 1693

	public hasRights: boolean | undefined = false
	public hasForceRight: boolean | undefined = false
	public nickname: string | undefined
	public tagNumber: string | undefined
	public wasAlreadyConnected: boolean | undefined = false
	public login: string | undefined
	public accountId: number | undefined = 0
	public communityId: number | undefined = 0
	public accountCreation: number | undefined = 0
	public subscriptionEndDate: number | undefined = 0
	public havenbagAvailableRoom: number | undefined = 0

	public constructor(
		hasRights?: boolean | undefined,
		hasForceRight?: boolean | undefined,
		nickname?: string | undefined,
		tagNumber?: string | undefined,
		wasAlreadyConnected?: boolean | undefined,
		login?: string | undefined,
		accountId?: number | undefined,
		communityId?: number | undefined,
		accountCreation?: number | undefined,
		subscriptionEndDate?: number | undefined,
		havenbagAvailableRoom?: number | undefined
	) {
		super()
		this.hasRights = hasRights
		this.hasForceRight = hasForceRight
		this.wasAlreadyConnected = wasAlreadyConnected
		this.login = login
		this.accountId = accountId
		this.communityId = communityId
		this.accountCreation = accountCreation
		this.subscriptionEndDate = subscriptionEndDate
		this.havenbagAvailableRoom = havenbagAvailableRoom
		this.nickname = nickname
		this.tagNumber = tagNumber
	}

	public serialize(writer: BinaryWriter): void {
		let box0: number = 0
		box0 = setFlag(box0, 0, this.hasRights!)
		box0 = setFlag(box0, 1, this.hasForceRight!)
		box0 = setFlag(box0, 2, this.wasAlreadyConnected!)
		writer.writeByte(box0)
		writer.writeUTF(this.login!)
		writer.writeUTF(this?.nickname!)
		writer.writeUTF(this?.tagNumber!)
		writer.writeInt(this.accountId!)
		writer.writeByte(this.communityId!)
		writer.writeDouble(this.accountCreation!)
		writer.writeDouble(this.subscriptionEndDate!)
		writer.writeByte(this.havenbagAvailableRoom!)
	}

	public deserialize(reader: BinaryReader): void {
		const box0 = reader.readByte()
		this.hasRights = getFlag(box0, 0)
		this.hasForceRight = getFlag(box0, 1)
		this.wasAlreadyConnected = getFlag(box0, 2)
		this.login = reader.readUTF()
		this.nickname = reader.readUTF()
		this.tagNumber = reader.readUTF()
		this.accountId = reader.readInt()
		this.communityId = reader.readByte()
		this.accountCreation = reader.readDouble()
		this.subscriptionEndDate = reader.readDouble()
		this.havenbagAvailableRoom = reader.readByte()
	}

	public hydrate(
		data: IdentificationSuccessMessage | Record<string, any>
	): IdentificationSuccessMessage {
		if (data instanceof IdentificationSuccessMessage) {
			return data
		}

		this.hasRights = data.hasRights
		this.hasForceRight = data.hasForceRight
		this.nickname = data.nickname
		this.tagNumber = data.tagNumber
		this.wasAlreadyConnected = data.wasAlreadyConnected
		this.login = data.login
		this.accountId = data.accountId
		this.communityId = data.communityId
		this.accountCreation = data.accountCreation
		this.subscriptionEndDate = data.subscriptionEndDate
		this.havenbagAvailableRoom = data.havenbagAvailableRoom

		return this
	}
}

export interface RawAccountTagInformation {
	nickname: string | undefined
	tagNumber: string | undefined
}

export class AccountTagInformation extends DofusType {
	public static id: number = 6205

	public nickname: string | undefined = ""
	public tagNumber: string | undefined = ""

	public constructor(
		nickname?: string | undefined,
		tagNumber?: string | undefined
	) {
		super()
		this.nickname = nickname
		this.tagNumber = tagNumber
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeUTF(this.nickname!)
		writer.writeUTF(this.tagNumber!)
	}

	public deserialize(reader: BinaryReader): void {
		this.nickname = reader.readUTF()
		this.tagNumber = reader.readUTF()
	}

	public hydrate(
		data: AccountTagInformation | Record<string, any>
	): AccountTagInformation {
		if (data instanceof AccountTagInformation) {
			return data
		}

		this.nickname = data.nickname
		this.tagNumber = data.tagNumber

		return this
	}
}

export interface RawURLOpenMessage {
	id: number
	urlId: number
}

export class URLOpenMessage extends DofusMessage {
	public static id: number = 6945

	public urlId: number | undefined = 0

	public constructor(urlId?: number | undefined) {
		super()
		this.urlId = urlId
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeByte(this.urlId!)
	}

	public deserialize(reader: BinaryReader): void {
		this.urlId = reader.readByte()
	}

	public hydrate(data: URLOpenMessage | Record<string, any>): URLOpenMessage {
		if (data instanceof URLOpenMessage) {
			return data
		}

		this.urlId = data.urlId

		return this
	}
}

export interface RawRawDataMessage {
	id: number
	content: number
}

export class RawDataMessage extends DofusMessage {
	public static id: number = 6253

	public content: number | undefined

	public constructor(content?: number | undefined) {
		super()
		this.content = content
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeByte(this.content!)
	}

	public deserialize(reader: BinaryReader): void {
		this.content = reader.readByte()
	}

	public hydrate(data: RawDataMessage | Record<string, any>): RawDataMessage {
		if (data instanceof RawDataMessage) {
			return data
		}

		this.content = data.content

		return this
	}
}

export interface RawTrustStatusMessage {
	id: number
	trusted: boolean
	certified: boolean
}

export class TrustStatusMessage extends DofusMessage {
	public static id: number = 2545

	public trusted: boolean | undefined = false
	public certified: boolean | undefined = false

	public constructor(
		trusted?: boolean | undefined,
		certified?: boolean | undefined
	) {
		super()
		this.trusted = trusted
		this.certified = certified
	}

	public serialize(writer: BinaryWriter): void {
		let box0: number = 0
		box0 = setFlag(box0, 0, this.trusted!)
		box0 = setFlag(box0, 1, this.certified!)
		writer.writeByte(box0)
	}

	public deserialize(reader: BinaryReader): void {
		const box0 = reader.readByte()
		this.trusted = getFlag(box0, 0)
		this.certified = getFlag(box0, 1)
	}

	public hydrate(
		data: TrustStatusMessage | Record<string, any>
	): TrustStatusMessage {
		if (data instanceof TrustStatusMessage) {
			return data
		}

		this.trusted = data.trusted
		this.certified = data.certified

		return this
	}
}

export interface RawServersListMessage {
	id: number
	servers: GameServerInformations[]
	alreadyConnectedToServerId: number
	canCreateNewCharacter: boolean
}

export class ServersListMessage extends DofusMessage {
	public static id: number = 8557

	public servers: GameServerInformations[] | undefined
	public canCreateNewCharacter: boolean | undefined = false

	public constructor(
		servers?: GameServerInformations[] | undefined,
		canCreateNewCharacter?: boolean | undefined
	) {
		super()
		this.servers = servers
		this.canCreateNewCharacter = canCreateNewCharacter
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeShort(this.servers!.length)
		this.servers!.forEach((current) => {
			current.serialize(writer)
		})
		writer.writeBoolean(this.canCreateNewCharacter!)
	}

	public deserialize(reader: BinaryReader): void {
		this.servers = []
		const countServers = reader.readShort()
		for (let i: number = 0; i < countServers; i++) {
			const type: GameServerInformations = new GameServerInformations()
			type.deserialize(reader)
			this.servers.push(type)
		}
		this.canCreateNewCharacter = reader.readBoolean()
	}

	public hydrate(
		data: ServersListMessage | Record<string, any>
	): ServersListMessage {
		if (data instanceof ServersListMessage) {
			return data
		}

		this.servers = data.servers.map(
			(
				dataElement: GameServerInformations | Record<string, any>
			): GameServerInformations => {
				if (dataElement instanceof GameServerInformations) {
					return dataElement
				} else {
					return new GameServerInformations().hydrate(dataElement)
				}
			}
		)
		this.canCreateNewCharacter = data.canCreateNewCharacter

		return this
	}
}

export interface RawBasicPongMessage {
	id: number
	quiet: boolean
}

export class BasicPongMessage extends DofusMessage {
	public static id: number = 8522

	public quiet: boolean | undefined = false

	public constructor(quiet?: boolean | undefined) {
		super()
		this.quiet = quiet
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeBoolean(this.quiet!)
	}

	public deserialize(reader: BinaryReader): void {
		this.quiet = reader.readBoolean()
	}

	public hydrate(
		data: BasicPongMessage | Record<string, any>
	): BasicPongMessage {
		if (data instanceof BasicPongMessage) {
			return data
		}

		this.quiet = data.quiet

		return this
	}
}

export interface RawBasicLatencyStatsRequestMessage {
	id: number
}

export class BasicLatencyStatsRequestMessage extends DofusMessage {
	public static id: number = 2340

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public serialize(writer: BinaryWriter): void {}

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public deserialize(reader: BinaryReader): void {}

	public hydrate(
		data: BasicLatencyStatsRequestMessage | Record<string, any>
	): BasicLatencyStatsRequestMessage {
		if (data instanceof BasicLatencyStatsRequestMessage) {
			return data
		}

		return this
	}
}

export interface RawBasicLatencyStatsMessage {
	id: number
	latency: number
	sampleCount: number
	max: number
}

export class BasicLatencyStatsMessage extends DofusMessage {
	public static id: number = 9646

	public latency: number | undefined = 0
	public sampleCount: number | undefined = 0
	public max: number | undefined = 0

	public constructor(
		latency?: number | undefined,
		sampleCount?: number | undefined,
		max?: number | undefined
	) {
		super()
		this.latency = latency
		this.sampleCount = sampleCount
		this.max = max
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeShort(this.latency!)
		writer.writeVarShort(this.sampleCount!)
		writer.writeVarShort(this.max!)
	}

	public deserialize(reader: BinaryReader): void {
		this.latency = reader.readShort()
		this.sampleCount = reader.readVarShort()
		this.max = reader.readVarShort()
	}

	public hydrate(
		data: BasicLatencyStatsMessage | Record<string, any>
	): BasicLatencyStatsMessage {
		if (data instanceof BasicLatencyStatsMessage) {
			return data
		}

		this.latency = data.latency
		this.sampleCount = data.sampleCount
		this.max = data.max

		return this
	}
}

export interface RawCheckIntegrityMessage {
	id: number
	data: number[]
}

export class CheckIntegrityMessage extends DofusMessage {
	public static id: number = 8389

	public data: number[] | undefined

	public constructor(data?: number[] | undefined) {
		super()
		this.data = data
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarInt(this.data!.length)
		this.data!.forEach((current: number) => writer.writeByte(current))
	}

	public deserialize(reader: BinaryReader): void {
		this.data = []
		const countData = reader.readVarInt()
		for (let i: number = 0; i < countData; i++) {
			this.data.push(reader.readByte())
		}
	}

	public hydrate(
		data: CheckIntegrityMessage | Record<string, any>
	): CheckIntegrityMessage {
		if (data instanceof CheckIntegrityMessage) {
			return data
		}

		this.data = data.data

		return this
	}
}

export interface RawAdminCommandMessage {
	id: number
	content: string
}

export class AdminCommandMessage extends DofusMessage {
	public static id: number = 7272

  public messageUuid: Uuid | undefined
	public content: string | undefined

	public constructor(content?: string | undefined, messageUuid?: Uuid | undefined) {
		super()
		this.content = content
    this.messageUuid = messageUuid
	}

	public serialize(writer: BinaryWriter): void {
    this.messageUuid?.serialize(writer)
		writer.writeUTF(this.content!)
	}

	public deserialize(reader: BinaryReader): void {
    this.messageUuid = new Uuid()
    this.messageUuid.deserialize(reader)
		this.content = reader.readUTF()
	}

	public hydrate(
		data: AdminCommandMessage | Record<string, any>
	): AdminCommandMessage {
		if (data instanceof AdminCommandMessage) {
			return data
		}

		this.content = data.content

		return this
	}
}

export class Uuid extends DofusType {
  public static id: number = 2009;

  public uuidString: string | undefined = ""

  public contructor(uuidString: string | undefined) {
    this.uuidString = uuidString
  }

  public serialize(writer: BinaryWriter): void {
    writer.writeUTF(this.uuidString!)
  }

  public deserialize(reader: BinaryReader): void {
  this.uuidString = reader.readUTF()
  }
}

export interface RawConsoleMessage {
	id: number
	type: number
	content: string
}

export class ConsoleMessage extends DofusMessage {
	public static id: number = 2223

	public type: number | undefined = 0
	public content: string | undefined

	public constructor(type?: number | undefined, content?: string | undefined) {
		super()
		this.type = type
		this.content = content
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeByte(this.type!)
		writer.writeUTF(this.content!)
	}

	public deserialize(reader: BinaryReader): void {
		this.type = reader.readByte()
		this.content = reader.readUTF()
	}

	public hydrate(data: ConsoleMessage | Record<string, any>): ConsoleMessage {
		if (data instanceof ConsoleMessage) {
			return data
		}

		this.type = data.type
		this.content = data.content

		return this
	}
}

export interface RawQuestListMessage {
	id: number
	finishedQuestsIds: number[]
	finishedQuestsCounts: number[]
	activeQuests: QuestActiveInformations[]
	reinitDoneQuestsIds: number[]
}

export class QuestListMessage extends DofusMessage {
	public static id: number = 3230

	public finishedQuestsIds: number[] | undefined
	public finishedQuestsCounts: number[] | undefined
	public activeQuests: QuestActiveInformations[] | undefined
	public reinitDoneQuestsIds: number[] | undefined

	public constructor(
		finishedQuestsIds?: number[] | undefined,
		finishedQuestsCounts?: number[] | undefined,
		activeQuests?: QuestActiveInformations[] | undefined,
		reinitDoneQuestsIds?: number[] | undefined
	) {
		super()
		this.finishedQuestsIds = finishedQuestsIds
		this.finishedQuestsCounts = finishedQuestsCounts
		this.activeQuests = activeQuests
		this.reinitDoneQuestsIds = reinitDoneQuestsIds
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeShort(this.finishedQuestsIds!.length)
		this.finishedQuestsIds!.forEach((current: number) =>
			writer.writeVarShort(current)
		)
		writer.writeShort(this.finishedQuestsCounts!.length)
		this.finishedQuestsCounts!.forEach((current: number) =>
			writer.writeVarShort(current)
		)
		writer.writeShort(this.activeQuests!.length)
		this.activeQuests!.forEach((current) => {
			writer.writeShort(current.id)
			current.serialize(writer)
		})
		writer.writeShort(this.reinitDoneQuestsIds!.length)
		this.reinitDoneQuestsIds!.forEach((current: number) =>
			writer.writeVarShort(current)
		)
	}

	public deserialize(reader: BinaryReader): void {
		this.finishedQuestsIds = []
		const countFinishedQuestsIds = reader.readShort()
		for (let i: number = 0; i < countFinishedQuestsIds; i++) {
			this.finishedQuestsIds.push(reader.readVarShort())
		}
		this.finishedQuestsCounts = []
		const countFinishedQuestsCounts = reader.readShort()
		for (let i: number = 0; i < countFinishedQuestsCounts; i++) {
			this.finishedQuestsCounts.push(reader.readVarShort())
		}
		this.activeQuests = []
		const countActiveQuests = reader.readShort()
		for (let i: number = 0; i < countActiveQuests; i++) {
			const activeQuestsTypeId: number = reader.readShort()
			const type: QuestActiveInformations = new types[
				activeQuestsTypeId
			]() as QuestActiveInformations
			type.deserialize(reader)
			this.activeQuests.push(type)
		}
		this.reinitDoneQuestsIds = []
		const countReinitDoneQuestsIds = reader.readShort()
		for (let i: number = 0; i < countReinitDoneQuestsIds; i++) {
			this.reinitDoneQuestsIds.push(reader.readVarShort())
		}
	}

	public hydrate(
		data: QuestListMessage | Record<string, any>
	): QuestListMessage {
		if (data instanceof QuestListMessage) {
			return data
		}

		this.finishedQuestsIds = data.finishedQuestsIds
		this.finishedQuestsCounts = data.finishedQuestsCounts
		this.activeQuests = data.activeQuests.map(
			(
				dataElement: QuestActiveInformations | Record<string, any>
			): QuestActiveInformations => {
				if (dataElement instanceof QuestActiveInformations) {
					return dataElement
				} else {
					return (new types[
						dataElement.id
					]() as QuestActiveInformations).hydrate(dataElement)
				}
			}
		)
		this.reinitDoneQuestsIds = data.reinitDoneQuestsIds

		return this
	}
}

export interface RawQuestValidatedMessage {
	id: number
	questId: number
}

export class QuestValidatedMessage extends DofusMessage {
	public static id: number = 7778

	public questId: number | undefined = 0

	public constructor(questId?: number | undefined) {
		super()
		this.questId = questId
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarShort(this.questId!)
	}

	public deserialize(reader: BinaryReader): void {
		this.questId = reader.readVarShort()
	}

	public hydrate(
		data: QuestValidatedMessage | Record<string, any>
	): QuestValidatedMessage {
		if (data instanceof QuestValidatedMessage) {
			return data
		}

		this.questId = data.questId

		return this
	}
}

export interface RawCharacterCreationResultMessage {
	id: number
	result: number
}

export class CharacterCreationResultMessage extends DofusMessage {
	public static id: number = 1293

	public result: number | undefined = 1
	public reason: number | undefined = 1

	public constructor(result?: number | undefined, reason?: number | undefined) {
		super()
		this.result = result
		this.reason = reason
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeByte(this.result!)
		writer.writeByte(this.reason!)
	}

	public deserialize(reader: BinaryReader): void {
		this.result = reader.readByte()
		this.reason = reader.readByte()
	}

	public hydrate(
		data: CharacterCreationResultMessage | Record<string, any>
	): CharacterCreationResultMessage {
		if (data instanceof CharacterCreationResultMessage) {
			return data
		}

		this.result = data.result
		this.reason = data.result

		return this
	}
}

export interface RawNicknameRefusedMessage {
	id: number
	reason: number
}

export class NicknameRefusedMessage extends DofusMessage {
	public static id: number = 1947

	public reason: number | undefined = 99

	public constructor(reason?: number | undefined) {
		super()
		this.reason = reason
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeByte(this.reason!)
	}

	public deserialize(reader: BinaryReader): void {
		this.reason = reader.readByte()
	}

	public hydrate(
		data: NicknameRefusedMessage | Record<string, any>
	): NicknameRefusedMessage {
		if (data instanceof NicknameRefusedMessage) {
			return data
		}

		this.reason = data.reason

		return this
	}
}

export interface RawNicknameAcceptedMessage {
	id: number
}

export class NicknameAcceptedMessage extends DofusMessage {
	public static id: number = 1279

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public serialize(writer: BinaryWriter): void {}

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public deserialize(reader: BinaryReader): void {}

	public hydrate(
		data: NicknameAcceptedMessage | Record<string, any>
	): NicknameAcceptedMessage {
		if (data instanceof NicknameAcceptedMessage) {
			return data
		}

		return this
	}
}

export interface RawHelloGameMessage {
	id: number
}

export class HelloGameMessage extends DofusMessage {
	public static id: number = 6694

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public serialize(writer: BinaryWriter): void {}

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public deserialize(reader: BinaryReader): void {}

	public hydrate(
		data: HelloGameMessage | Record<string, any>
	): HelloGameMessage {
		if (data instanceof HelloGameMessage) {
			return data
		}

		return this
	}
}

export interface RawGuildFactsErrorMessage {
	id: number
	guildId: number
}

export class GuildFactsErrorMessage extends DofusMessage {
	public static id: number = 4710

	public guildId: number | undefined = 0

	public constructor(guildId?: number | undefined) {
		super()
		this.guildId = guildId
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarInt(this.guildId!)
	}

	public deserialize(reader: BinaryReader): void {
		this.guildId = reader.readVarInt()
	}

	public hydrate(
		data: GuildFactsErrorMessage | Record<string, any>
	): GuildFactsErrorMessage {
		if (data instanceof GuildFactsErrorMessage) {
			return data
		}

		this.guildId = data.guildId

		return this
	}
}

export interface RawAchievementDetailedListMessage {
	id: number
	startedAchievements: Achievement[]
	finishedAchievements: Achievement[]
}

export class AchievementDetailedListMessage extends DofusMessage {
	public static id: number = 4505

	public startedAchievements: Achievement[] | undefined
	public finishedAchievements: Achievement[] | undefined

	public constructor(
		startedAchievements?: Achievement[] | undefined,
		finishedAchievements?: Achievement[] | undefined
	) {
		super()
		this.startedAchievements = startedAchievements
		this.finishedAchievements = finishedAchievements
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeShort(this.startedAchievements!.length)
		this.startedAchievements!.forEach((current) => {
			current.serialize(writer)
		})
		writer.writeShort(this.finishedAchievements!.length)
		this.finishedAchievements!.forEach((current) => {
			current.serialize(writer)
		})
	}

	public deserialize(reader: BinaryReader): void {
		this.startedAchievements = []
		const countStartedAchievements = reader.readShort()
		for (let i: number = 0; i < countStartedAchievements; i++) {
			const type: Achievement = new Achievement()
			type.deserialize(reader)
			this.startedAchievements.push(type)
		}
		this.finishedAchievements = []
		const countFinishedAchievements = reader.readShort()
		for (let i: number = 0; i < countFinishedAchievements; i++) {
			const type: Achievement = new Achievement()
			type.deserialize(reader)
			this.finishedAchievements.push(type)
		}
	}

	public hydrate(
		data: AchievementDetailedListMessage | Record<string, any>
	): AchievementDetailedListMessage {
		if (data instanceof AchievementDetailedListMessage) {
			return data
		}

		this.startedAchievements = data.startedAchievements.map(
			(dataElement: Achievement | Record<string, any>): Achievement => {
				if (dataElement instanceof Achievement) {
					return dataElement
				} else {
					return new Achievement().hydrate(dataElement)
				}
			}
		)
		this.finishedAchievements = data.finishedAchievements.map(
			(dataElement: Achievement | Record<string, any>): Achievement => {
				if (dataElement instanceof Achievement) {
					return dataElement
				} else {
					return new Achievement().hydrate(dataElement)
				}
			}
		)

		return this
	}
}

export interface RawAuthenticationTicketAcceptedMessage {
	id: number
}

export class AuthenticationTicketAcceptedMessage extends DofusMessage {
	public static id: number = 9044

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public serialize(writer: BinaryWriter): void {}

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public deserialize(reader: BinaryReader): void {}

	public hydrate(
		data: AuthenticationTicketAcceptedMessage | Record<string, any>
	): AuthenticationTicketAcceptedMessage {
		if (data instanceof AuthenticationTicketAcceptedMessage) {
			return data
		}

		return this
	}
}

export interface RawGuildInvitationStateRecrutedMessage {
	id: number
	invitationState: number
}

export class GuildInvitationStateRecrutedMessage extends DofusMessage {
	public static id: number = 6703

	public invitationState: number | undefined = 0

	public constructor(invitationState?: number | undefined) {
		super()
		this.invitationState = invitationState
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeByte(this.invitationState!)
	}

	public deserialize(reader: BinaryReader): void {
		this.invitationState = reader.readByte()
	}

	public hydrate(
		data: GuildInvitationStateRecrutedMessage | Record<string, any>
	): GuildInvitationStateRecrutedMessage {
		if (data instanceof GuildInvitationStateRecrutedMessage) {
			return data
		}

		this.invitationState = data.invitationState

		return this
	}
}

export interface RawKamasUpdateMessage {
	id: number
	kamasTotal: number
}

export class KamasUpdateMessage extends DofusMessage {
	public static id: number = 7533

	public kamasTotal: number | undefined = 0

	public constructor(kamasTotal?: number | undefined) {
		super()
		this.kamasTotal = kamasTotal
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarLong(this.kamasTotal!)
	}

	public deserialize(reader: BinaryReader): void {
		this.kamasTotal = reader.readVarLong()
	}

	public hydrate(
		data: KamasUpdateMessage | Record<string, any>
	): KamasUpdateMessage {
		if (data instanceof KamasUpdateMessage) {
			return data
		}

		this.kamasTotal = data.kamasTotal

		return this
	}
}

export interface RawStorageObjectsUpdateMessage {
	id: number
	objectList: ObjectItem[]
}

export class StorageObjectsUpdateMessage extends DofusMessage {
	public static id: number = 7292

	public objectList: ObjectItem[] | undefined

	public constructor(objectList?: ObjectItem[] | undefined) {
		super()
		this.objectList = objectList
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeShort(this.objectList!.length)
		this.objectList!.forEach((current) => {
			current.serialize(writer)
		})
	}

	public deserialize(reader: BinaryReader): void {
		this.objectList = []
		const countObjectList = reader.readShort()
		for (let i: number = 0; i < countObjectList; i++) {
			const type: ObjectItem = new ObjectItem()
			type.deserialize(reader)
			this.objectList.push(type)
		}
	}

	public hydrate(
		data: StorageObjectsUpdateMessage | Record<string, any>
	): StorageObjectsUpdateMessage {
		if (data instanceof StorageObjectsUpdateMessage) {
			return data
		}

		this.objectList = data.objectList.map(
			(dataElement: ObjectItem | Record<string, any>): ObjectItem => {
				if (dataElement instanceof ObjectItem) {
					return dataElement
				} else {
					return new ObjectItem().hydrate(dataElement)
				}
			}
		)

		return this
	}
}

export interface RawGuildInvitedMessage {
	id: number
	recruterId: number
	recruterName: string
	guildInfo: BasicGuildInformations
}

export class GuildInvitedMessage extends DofusMessage {
	public static id: number = 3343

	public recruterId: number | undefined = 0
	public recruterName: string | undefined
	public guildInfo: BasicGuildInformations | undefined

	public constructor(
		recruterId?: number | undefined,
		recruterName?: string | undefined,
		guildInfo?: BasicGuildInformations | undefined
	) {
		super()
		this.recruterId = recruterId
		this.recruterName = recruterName
		this.guildInfo = guildInfo
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarLong(this.recruterId!)
		writer.writeUTF(this.recruterName!)
		this.guildInfo!.serialize(writer)
	}

	public deserialize(reader: BinaryReader): void {
		this.recruterId = reader.readVarLong()
		this.recruterName = reader.readUTF()
		this.guildInfo = new BasicGuildInformations()
		this.guildInfo!.deserialize(reader)
	}

	public hydrate(
		data: GuildInvitedMessage | Record<string, any>
	): GuildInvitedMessage {
		if (data instanceof GuildInvitedMessage) {
			return data
		}

		this.recruterId = data.recruterId
		this.recruterName = data.recruterName
		this.guildInfo = new BasicGuildInformations().hydrate(data.guildInfo)

		return this
	}
}

export interface RawShortcutBarContentMessage {
	id: number
	barType: number
	shortcuts: Shortcut[]
}

export class ShortcutBarContentMessage extends DofusMessage {
	public static id: number = 4852

	public barType: number | undefined = 0
	public shortcuts: Shortcut[] | undefined

	public constructor(
		barType?: number | undefined,
		shortcuts?: Shortcut[] | undefined
	) {
		super()
		this.barType = barType
		this.shortcuts = shortcuts
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeByte(this.barType!)
		writer.writeShort(this.shortcuts!.length)
		this.shortcuts!.forEach((current) => {
			writer.writeShort(current.id)
			current.serialize(writer)
		})
	}

	public deserialize(reader: BinaryReader): void {
		this.barType = reader.readByte()
		this.shortcuts = []
		const countShortcuts = reader.readShort()
		for (let i: number = 0; i < countShortcuts; i++) {
			const shortcutsTypeId: number = reader.readShort()
			const type: Shortcut = new types[shortcutsTypeId]() as Shortcut
			type.deserialize(reader)
			this.shortcuts.push(type)
		}
	}

	public hydrate(
		data: ShortcutBarContentMessage | Record<string, any>
	): ShortcutBarContentMessage {
		if (data instanceof ShortcutBarContentMessage) {
			return data
		}

		this.barType = data.barType
		this.shortcuts = data.shortcuts.map(
			(dataElement: Shortcut | Record<string, any>): Shortcut => {
				if (dataElement instanceof Shortcut) {
					return dataElement
				} else {
					return (new types[dataElement.id]() as Shortcut).hydrate(dataElement)
				}
			}
		)

		return this
	}
}

export interface RawObjectsAddedMessage {
	id: number
	object_: ObjectItem[]
}

export class ObjectsAddedMessage extends DofusMessage {
	public static id: number = 1391

	public object_: ObjectItem[] | undefined

	public constructor(object_?: ObjectItem[] | undefined) {
		super()
		this.object_ = object_
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeShort(this.object_!.length)
		this.object_!.forEach((current) => {
			current.serialize(writer)
		})
	}

	public deserialize(reader: BinaryReader): void {
		this.object_ = []
		const countObject_ = reader.readShort()
		for (let i: number = 0; i < countObject_; i++) {
			const type: ObjectItem = new ObjectItem()
			type.deserialize(reader)
			this.object_.push(type)
		}
	}

	public hydrate(
		data: ObjectsAddedMessage | Record<string, any>
	): ObjectsAddedMessage {
		if (data instanceof ObjectsAddedMessage) {
			return data
		}

		this.object_ = data.object_.map(
			(dataElement: ObjectItem | Record<string, any>): ObjectItem => {
				if (dataElement instanceof ObjectItem) {
					return dataElement
				} else {
					return new ObjectItem().hydrate(dataElement)
				}
			}
		)

		return this
	}
}

export interface RawCharacterSelectedSuccessMessage {
	id: number
	infos: CharacterBaseInformations
	isCollectingStats: boolean
}

export class CharacterSelectedSuccessMessage extends DofusMessage {
	public static id: number = 9868

	public infos: CharacterBaseInformations | undefined
	public isCollectingStats: boolean | undefined = false

	public constructor(
		infos?: CharacterBaseInformations | undefined,
		isCollectingStats?: boolean | undefined
	) {
		super()
		this.infos = infos
		this.isCollectingStats = isCollectingStats
	}

	public serialize(writer: BinaryWriter): void {
		this.infos!.serialize(writer)
		writer.writeBoolean(this.isCollectingStats!)
	}

	public deserialize(reader: BinaryReader): void {
		this.infos = new CharacterBaseInformations()
		this.infos!.deserialize(reader)
		this.isCollectingStats = reader.readBoolean()
	}

	public hydrate(
		data: CharacterSelectedSuccessMessage | Record<string, any>
	): CharacterSelectedSuccessMessage {
		if (data instanceof CharacterSelectedSuccessMessage) {
			return data
		}

		this.infos = new CharacterBaseInformations().hydrate(data.infos)
		this.isCollectingStats = data.isCollectingStats

		return this
	}
}

export interface RawExchangeCraftResultMessage {
	id: number
	craftResult: number
}

export class ExchangeCraftResultMessage extends DofusMessage {
	public static id: number = 7242

	public craftResult: number | undefined = 0

	public constructor(craftResult?: number | undefined) {
		super()
		this.craftResult = craftResult
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeByte(this.craftResult!)
	}

	public deserialize(reader: BinaryReader): void {
		this.craftResult = reader.readByte()
	}

	public hydrate(
		data: ExchangeCraftResultMessage | Record<string, any>
	): ExchangeCraftResultMessage {
		if (data instanceof ExchangeCraftResultMessage) {
			return data
		}

		this.craftResult = data.craftResult

		return this
	}
}

export interface RawExchangeCraftResultWithObjectDescMessage
	extends RawExchangeCraftResultMessage {
	id: number
	objectInfo: ObjectItemNotInContainer
}

export class ExchangeCraftResultWithObjectDescMessage extends ExchangeCraftResultMessage {
	public static id = 4589

	public objectInfo: ObjectItemNotInContainer | undefined

	public constructor(
		craftResult?: number | undefined,
		objectInfo?: ObjectItemNotInContainer | undefined
	) {
		super(craftResult)
		this.objectInfo = objectInfo
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		this.objectInfo!.serialize(writer)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.objectInfo = new ObjectItemNotInContainer()
		this.objectInfo!.deserialize(reader)
	}

	public hydrate(
		data: ExchangeCraftResultWithObjectDescMessage | Record<string, any>
	): ExchangeCraftResultWithObjectDescMessage {
		if (data instanceof ExchangeCraftResultWithObjectDescMessage) {
			return data
		}

		super.hydrate(data)

		this.objectInfo = new ObjectItemNotInContainer().hydrate(data.objectInfo)

		return this
	}
}

export interface RawAbstractPartyMessage {
	id: number
	partyId: number
}

export class AbstractPartyMessage extends DofusMessage {
	public static id: number = 995

	public partyId: number | undefined = 0

	public constructor(partyId?: number | undefined) {
		super()
		this.partyId = partyId
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarInt(this.partyId!)
	}

	public deserialize(reader: BinaryReader): void {
		this.partyId = reader.readVarInt()
	}

	public hydrate(
		data: AbstractPartyMessage | Record<string, any>
	): AbstractPartyMessage {
		if (data instanceof AbstractPartyMessage) {
			return data
		}

		this.partyId = data.partyId

		return this
	}
}

export interface RawAbstractPartyEventMessage extends RawAbstractPartyMessage {
	id: number
}

export class AbstractPartyEventMessage extends AbstractPartyMessage {
	public static id = 2338

	public constructor(partyId?: number | undefined) {
		super(partyId)
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
	}

	public hydrate(
		data: AbstractPartyEventMessage | Record<string, any>
	): AbstractPartyEventMessage {
		if (data instanceof AbstractPartyEventMessage) {
			return data
		}

		super.hydrate(data)

		return this
	}
}

export interface RawPartyMemberRemoveMessage
	extends RawAbstractPartyEventMessage {
	id: number
	leavingPlayerId: number
}

export class PartyMemberRemoveMessage extends AbstractPartyEventMessage {
	public static id = 5580

	public leavingPlayerId: number | undefined = 0

	public constructor(
		partyId?: number | undefined,
		leavingPlayerId?: number | undefined
	) {
		super(partyId)
		this.leavingPlayerId = leavingPlayerId
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeVarLong(this.leavingPlayerId!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.leavingPlayerId = reader.readVarLong()
	}

	public hydrate(
		data: PartyMemberRemoveMessage | Record<string, any>
	): PartyMemberRemoveMessage {
		if (data instanceof PartyMemberRemoveMessage) {
			return data
		}

		super.hydrate(data)

		this.leavingPlayerId = data.leavingPlayerId

		return this
	}
}

export interface RawGameRolePlayPlayerFightFriendlyAnsweredMessage {
	id: number
	fightId: number
	sourceId: number
	targetId: number
	accept: boolean
}

export class GameRolePlayPlayerFightFriendlyAnsweredMessage extends DofusMessage {
	public static id: number = 2891

	public fightId: number | undefined = 0
	public sourceId: number | undefined = 0
	public targetId: number | undefined = 0
	public accept: boolean | undefined = false

	public constructor(
		fightId?: number | undefined,
		sourceId?: number | undefined,
		targetId?: number | undefined,
		accept?: boolean | undefined
	) {
		super()
		this.fightId = fightId
		this.sourceId = sourceId
		this.targetId = targetId
		this.accept = accept
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarShort(this.fightId!)
		writer.writeVarLong(this.sourceId!)
		writer.writeVarLong(this.targetId!)
		writer.writeBoolean(this.accept!)
	}

	public deserialize(reader: BinaryReader): void {
		this.fightId = reader.readVarShort()
		this.sourceId = reader.readVarLong()
		this.targetId = reader.readVarLong()
		this.accept = reader.readBoolean()
	}

	public hydrate(
		data: GameRolePlayPlayerFightFriendlyAnsweredMessage | Record<string, any>
	): GameRolePlayPlayerFightFriendlyAnsweredMessage {
		if (data instanceof GameRolePlayPlayerFightFriendlyAnsweredMessage) {
			return data
		}

		this.fightId = data.fightId
		this.sourceId = data.sourceId
		this.targetId = data.targetId
		this.accept = data.accept

		return this
	}
}

export interface RawBasicWhoIsNoMatchMessage {
	id: number
	search: string
}

export class BasicWhoIsNoMatchMessage extends DofusMessage {
	public static id: number = 9329

	public search: string | undefined

	public constructor(search?: string | undefined) {
		super()
		this.search = search
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeUTF(this.search!)
	}

	public deserialize(reader: BinaryReader): void {
		this.search = reader.readUTF()
	}

	public hydrate(
		data: BasicWhoIsNoMatchMessage | Record<string, any>
	): BasicWhoIsNoMatchMessage {
		if (data instanceof BasicWhoIsNoMatchMessage) {
			return data
		}

		this.search = data.search

		return this
	}
}

export interface RawInteractiveUseErrorMessage {
	id: number
	elemId: number
	skillInstanceUid: number
}

export class InteractiveUseErrorMessage extends DofusMessage {
	public static id: number = 3657

	public elemId: number | undefined = 0
	public skillInstanceUid: number | undefined = 0

	public constructor(
		elemId?: number | undefined,
		skillInstanceUid?: number | undefined
	) {
		super()
		this.elemId = elemId
		this.skillInstanceUid = skillInstanceUid
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarInt(this.elemId!)
		writer.writeVarInt(this.skillInstanceUid!)
	}

	public deserialize(reader: BinaryReader): void {
		this.elemId = reader.readVarInt()
		this.skillInstanceUid = reader.readVarInt()
	}

	public hydrate(
		data: InteractiveUseErrorMessage | Record<string, any>
	): InteractiveUseErrorMessage {
		if (data instanceof InteractiveUseErrorMessage) {
			return data
		}

		this.elemId = data.elemId
		this.skillInstanceUid = data.skillInstanceUid

		return this
	}
}

export interface RawGameRolePlayGameOverMessage {
	id: number
}

export class GameRolePlayGameOverMessage extends DofusMessage {
	public static id: number = 7625

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public serialize(writer: BinaryWriter): void {}

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public deserialize(reader: BinaryReader): void {}

	public hydrate(
		data: GameRolePlayGameOverMessage | Record<string, any>
	): GameRolePlayGameOverMessage {
		if (data instanceof GameRolePlayGameOverMessage) {
			return data
		}

		return this
	}
}

export interface RawNotificationByServerMessage {
	id: number
	id_: number
	parameters: string[]
	forceOpen: boolean
}

export class NotificationByServerMessage extends DofusMessage {
	public static id: number = 1287

	public id_: number | undefined = 0
	public parameters: string[] | undefined
	public forceOpen: boolean | undefined = false

	public constructor(
		id_?: number | undefined,
		parameters?: string[] | undefined,
		forceOpen?: boolean | undefined
	) {
		super()
		this.id_ = id_
		this.parameters = parameters
		this.forceOpen = forceOpen
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarShort(this.id_!)
		writer.writeShort(this.parameters!.length)
		this.parameters!.forEach((current: string) => writer.writeUTF(current))
		writer.writeBoolean(this.forceOpen!)
	}

	public deserialize(reader: BinaryReader): void {
		this.id_ = reader.readVarShort()
		this.parameters = []
		const countParameters = reader.readShort()
		for (let i: number = 0; i < countParameters; i++) {
			this.parameters.push(reader.readUTF())
		}
		this.forceOpen = reader.readBoolean()
	}

	public hydrate(
		data: NotificationByServerMessage | Record<string, any>
	): NotificationByServerMessage {
		if (data instanceof NotificationByServerMessage) {
			return data
		}

		this.id_ = data.id_
		this.parameters = data.parameters
		this.forceOpen = data.forceOpen

		return this
	}
}

export interface RawGuildMemberOnlineStatusMessage {
	id: number
	memberId: number
	online: boolean
}

export class GuildMemberOnlineStatusMessage extends DofusMessage {
	public static id: number = 2910

	public memberId: number | undefined = 0
	public online: boolean | undefined = false

	public constructor(
		memberId?: number | undefined,
		online?: boolean | undefined
	) {
		super()
		this.memberId = memberId
		this.online = online
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarLong(this.memberId!)
		writer.writeBoolean(this.online!)
	}

	public deserialize(reader: BinaryReader): void {
		this.memberId = reader.readVarLong()
		this.online = reader.readBoolean()
	}

	public hydrate(
		data: GuildMemberOnlineStatusMessage | Record<string, any>
	): GuildMemberOnlineStatusMessage {
		if (data instanceof GuildMemberOnlineStatusMessage) {
			return data
		}

		this.memberId = data.memberId
		this.online = data.online

		return this
	}
}

export interface RawExchangeMountsPaddockRemoveMessage {
	id: number
	mountsId: number[]
}

export class ExchangeMountsPaddockRemoveMessage extends DofusMessage {
	public static id: number = 4871

	public mountsId: number[] | undefined

	public constructor(mountsId?: number[] | undefined) {
		super()
		this.mountsId = mountsId
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeShort(this.mountsId!.length)
		this.mountsId!.forEach((current: number) => writer.writeVarInt(current))
	}

	public deserialize(reader: BinaryReader): void {
		this.mountsId = []
		const countMountsId = reader.readShort()
		for (let i: number = 0; i < countMountsId; i++) {
			this.mountsId.push(reader.readVarInt())
		}
	}

	public hydrate(
		data: ExchangeMountsPaddockRemoveMessage | Record<string, any>
	): ExchangeMountsPaddockRemoveMessage {
		if (data instanceof ExchangeMountsPaddockRemoveMessage) {
			return data
		}

		this.mountsId = data.mountsId

		return this
	}
}

export interface RawSocialNoticeMessage {
	id: number
	content: string
	timestamp: number
	memberId: number
	memberName: string
}

export class SocialNoticeMessage extends DofusMessage {
	public static id: number = 1883

	public content: string | undefined
	public timestamp: number | undefined = 0
	public memberId: number | undefined = 0
	public memberName: string | undefined

	public constructor(
		content?: string | undefined,
		timestamp?: number | undefined,
		memberId?: number | undefined,
		memberName?: string | undefined
	) {
		super()
		this.content = content
		this.timestamp = timestamp
		this.memberId = memberId
		this.memberName = memberName
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeUTF(this.content!)
		writer.writeInt(this.timestamp!)
		writer.writeVarLong(this.memberId!)
		writer.writeUTF(this.memberName!)
	}

	public deserialize(reader: BinaryReader): void {
		this.content = reader.readUTF()
		this.timestamp = reader.readInt()
		this.memberId = reader.readVarLong()
		this.memberName = reader.readUTF()
	}

	public hydrate(
		data: SocialNoticeMessage | Record<string, any>
	): SocialNoticeMessage {
		if (data instanceof SocialNoticeMessage) {
			return data
		}

		this.content = data.content
		this.timestamp = data.timestamp
		this.memberId = data.memberId
		this.memberName = data.memberName

		return this
	}
}

export interface RawGameRolePlaySpellAnimMessage {
	id: number
	casterId: number
	targetCellId: number
	spellId: number
	spellLevel: number
}

export class GameRolePlaySpellAnimMessage extends DofusMessage {
	public static id: number = 3713

	public casterId: number | undefined = 0
	public targetCellId: number | undefined = 0
	public spellId: number | undefined = 0
	public spellLevel: number | undefined = 0

	public constructor(
		casterId?: number | undefined,
		targetCellId?: number | undefined,
		spellId?: number | undefined,
		spellLevel?: number | undefined
	) {
		super()
		this.casterId = casterId
		this.targetCellId = targetCellId
		this.spellId = spellId
		this.spellLevel = spellLevel
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarLong(this.casterId!)
		writer.writeVarShort(this.targetCellId!)
		writer.writeVarShort(this.spellId!)
		writer.writeShort(this.spellLevel!)
	}

	public deserialize(reader: BinaryReader): void {
		this.casterId = reader.readVarLong()
		this.targetCellId = reader.readVarShort()
		this.spellId = reader.readVarShort()
		this.spellLevel = reader.readShort()
	}

	public hydrate(
		data: GameRolePlaySpellAnimMessage | Record<string, any>
	): GameRolePlaySpellAnimMessage {
		if (data instanceof GameRolePlaySpellAnimMessage) {
			return data
		}

		this.casterId = data.casterId
		this.targetCellId = data.targetCellId
		this.spellId = data.spellId
		this.spellLevel = data.spellLevel

		return this
	}
}

export interface RawEmotePlayAbstractMessage {
	id: number
	emoteId: number
	emoteStartTime: number
}

export class EmotePlayAbstractMessage extends DofusMessage {
	public static id: number = 918

	public emoteId: number | undefined = 0
	public emoteStartTime: number | undefined = 0

	public constructor(
		emoteId?: number | undefined,
		emoteStartTime?: number | undefined
	) {
		super()
		this.emoteId = emoteId
		this.emoteStartTime = emoteStartTime
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeByte(this.emoteId!)
		writer.writeDouble(this.emoteStartTime!)
	}

	public deserialize(reader: BinaryReader): void {
		this.emoteId = reader.readByte()
		this.emoteStartTime = reader.readDouble()
	}

	public hydrate(
		data: EmotePlayAbstractMessage | Record<string, any>
	): EmotePlayAbstractMessage {
		if (data instanceof EmotePlayAbstractMessage) {
			return data
		}

		this.emoteId = data.emoteId
		this.emoteStartTime = data.emoteStartTime

		return this
	}
}

export interface RawOrnamentGainedMessage {
	id: number
	ornamentId: number
}

export class OrnamentGainedMessage extends DofusMessage {
	public static id: number = 3437

	public ornamentId: number | undefined = 0

	public constructor(ornamentId?: number | undefined) {
		super()
		this.ornamentId = ornamentId
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeShort(this.ornamentId!)
	}

	public deserialize(reader: BinaryReader): void {
		this.ornamentId = reader.readShort()
	}

	public hydrate(
		data: OrnamentGainedMessage | Record<string, any>
	): OrnamentGainedMessage {
		if (data instanceof OrnamentGainedMessage) {
			return data
		}

		this.ornamentId = data.ornamentId

		return this
	}
}

export interface RawExchangeBidHouseUnsoldItemsMessage {
	id: number
	items: ObjectItemGenericQuantity[]
}

export class ExchangeBidHouseUnsoldItemsMessage extends DofusMessage {
	public static id: number = 4688

	public items: ObjectItemGenericQuantity[] | undefined

	public constructor(items?: ObjectItemGenericQuantity[] | undefined) {
		super()
		this.items = items
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeShort(this.items!.length)
		this.items!.forEach((current) => {
			current.serialize(writer)
		})
	}

	public deserialize(reader: BinaryReader): void {
		this.items = []
		const countItems = reader.readShort()
		for (let i: number = 0; i < countItems; i++) {
			const type: ObjectItemGenericQuantity = new ObjectItemGenericQuantity()
			type.deserialize(reader)
			this.items.push(type)
		}
	}

	public hydrate(
		data: ExchangeBidHouseUnsoldItemsMessage | Record<string, any>
	): ExchangeBidHouseUnsoldItemsMessage {
		if (data instanceof ExchangeBidHouseUnsoldItemsMessage) {
			return data
		}

		this.items = data.items.map(
			(
				dataElement: ObjectItemGenericQuantity | Record<string, any>
			): ObjectItemGenericQuantity => {
				if (dataElement instanceof ObjectItemGenericQuantity) {
					return dataElement
				} else {
					return new ObjectItemGenericQuantity().hydrate(dataElement)
				}
			}
		)

		return this
	}
}

export interface RawExchangeShopStockMovementRemovedMessage {
	id: number
	objectId: number
}

export class ExchangeShopStockMovementRemovedMessage extends DofusMessage {
	public static id: number = 418

	public objectId: number | undefined = 0

	public constructor(objectId?: number | undefined) {
		super()
		this.objectId = objectId
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarInt(this.objectId!)
	}

	public deserialize(reader: BinaryReader): void {
		this.objectId = reader.readVarInt()
	}

	public hydrate(
		data: ExchangeShopStockMovementRemovedMessage | Record<string, any>
	): ExchangeShopStockMovementRemovedMessage {
		if (data instanceof ExchangeShopStockMovementRemovedMessage) {
			return data
		}

		this.objectId = data.objectId

		return this
	}
}

export interface RawIdolSelectErrorMessage {
	id: number
	activate: boolean
	party: boolean
	reason: number
	idolId: number
}

export class IdolSelectErrorMessage extends DofusMessage {
	public static id: number = 1593

	public activate: boolean | undefined = false
	public party: boolean | undefined = false
	public reason: number | undefined = 0
	public idolId: number | undefined = 0

	public constructor(
		activate?: boolean | undefined,
		party?: boolean | undefined,
		reason?: number | undefined,
		idolId?: number | undefined
	) {
		super()
		this.activate = activate
		this.party = party
		this.reason = reason
		this.idolId = idolId
	}

	public serialize(writer: BinaryWriter): void {
		let box0: number = 0
		box0 = setFlag(box0, 0, this.activate!)
		box0 = setFlag(box0, 1, this.party!)
		writer.writeByte(box0)
		writer.writeByte(this.reason!)
		writer.writeVarShort(this.idolId!)
	}

	public deserialize(reader: BinaryReader): void {
		const box0 = reader.readByte()
		this.activate = getFlag(box0, 0)
		this.party = getFlag(box0, 1)
		this.reason = reader.readByte()
		this.idolId = reader.readVarShort()
	}

	public hydrate(
		data: IdolSelectErrorMessage | Record<string, any>
	): IdolSelectErrorMessage {
		if (data instanceof IdolSelectErrorMessage) {
			return data
		}

		this.activate = data.activate
		this.party = data.party
		this.reason = data.reason
		this.idolId = data.idolId

		return this
	}
}

export interface RawSymbioticObjectAssociatedMessage {
	id: number
	hostUID: number
}

export class SymbioticObjectAssociatedMessage extends DofusMessage {
	public static id: number = 377

	public hostUID: number | undefined = 0

	public constructor(hostUID?: number | undefined) {
		super()
		this.hostUID = hostUID
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarInt(this.hostUID!)
	}

	public deserialize(reader: BinaryReader): void {
		this.hostUID = reader.readVarInt()
	}

	public hydrate(
		data: SymbioticObjectAssociatedMessage | Record<string, any>
	): SymbioticObjectAssociatedMessage {
		if (data instanceof SymbioticObjectAssociatedMessage) {
			return data
		}

		this.hostUID = data.hostUID

		return this
	}
}

export interface RawMimicryObjectAssociatedMessage
	extends RawSymbioticObjectAssociatedMessage {
	id: number
}

export class MimicryObjectAssociatedMessage extends SymbioticObjectAssociatedMessage {
	public static id = 288

	public constructor(hostUID?: number | undefined) {
		super(hostUID)
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
	}

	public hydrate(
		data: MimicryObjectAssociatedMessage | Record<string, any>
	): MimicryObjectAssociatedMessage {
		if (data instanceof MimicryObjectAssociatedMessage) {
			return data
		}

		super.hydrate(data)

		return this
	}
}

export interface RawBasicCharactersListMessage {
	id: number
	characters: CharacterBaseInformations[]
}

export class BasicCharactersListMessage extends DofusMessage {
	public static id: number = 7584

	public characters: CharacterBaseInformations[] | undefined

	public constructor(characters?: CharacterBaseInformations[] | undefined) {
		super()
		this.characters = characters
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeShort(this.characters!.length)
		this.characters!.forEach((current) => {
			writer.writeShort(current.id)
			current.serialize(writer)
		})
	}

	public deserialize(reader: BinaryReader): void {
		this.characters = []
		const countCharacters = reader.readShort()
		for (let i: number = 0; i < countCharacters; i++) {
			const charactersTypeId: number = reader.readShort()
			const type: CharacterBaseInformations = new types[
				charactersTypeId
			]() as CharacterBaseInformations
			type.deserialize(reader)
			this.characters.push(type)
		}
	}

	public hydrate(
		data: BasicCharactersListMessage | Record<string, any>
	): BasicCharactersListMessage {
		if (data instanceof BasicCharactersListMessage) {
			return data
		}

		this.characters = data.characters.map(
			(
				dataElement: CharacterBaseInformations | Record<string, any>
			): CharacterBaseInformations => {
				if (dataElement instanceof CharacterBaseInformations) {
					return dataElement
				} else {
					return (new types[
						dataElement.id
					]() as CharacterBaseInformations).hydrate(dataElement)
				}
			}
		)

		return this
	}
}

export interface RawTreasureHuntAvailableRetryCountUpdateMessage {
	id: number
	questType: number
	availableRetryCount: number
}

export class TreasureHuntAvailableRetryCountUpdateMessage extends DofusMessage {
	public static id: number = 1216

	public questType: number | undefined = 0
	public availableRetryCount: number | undefined = 0

	public constructor(
		questType?: number | undefined,
		availableRetryCount?: number | undefined
	) {
		super()
		this.questType = questType
		this.availableRetryCount = availableRetryCount
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeByte(this.questType!)
		writer.writeInt(this.availableRetryCount!)
	}

	public deserialize(reader: BinaryReader): void {
		this.questType = reader.readByte()
		this.availableRetryCount = reader.readInt()
	}

	public hydrate(
		data: TreasureHuntAvailableRetryCountUpdateMessage | Record<string, any>
	): TreasureHuntAvailableRetryCountUpdateMessage {
		if (data instanceof TreasureHuntAvailableRetryCountUpdateMessage) {
			return data
		}

		this.questType = data.questType
		this.availableRetryCount = data.availableRetryCount

		return this
	}
}

export interface RawLoginQueueStatusMessage {
	id: number
	position: number
	total: number
}

export class LoginQueueStatusMessage extends DofusMessage {
	public static id: number = 6831

	public position: number | undefined = 0
	public total: number | undefined = 0

	public constructor(
		position?: number | undefined,
		total?: number | undefined
	) {
		super()
		this.position = position
		this.total = total
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeShort(this.position!)
		writer.writeShort(this.total!)
	}

	public deserialize(reader: BinaryReader): void {
		this.position = reader.readShort()
		this.total = reader.readShort()
	}

	public hydrate(
		data: LoginQueueStatusMessage | Record<string, any>
	): LoginQueueStatusMessage {
		if (data instanceof LoginQueueStatusMessage) {
			return data
		}

		this.position = data.position
		this.total = data.total

		return this
	}
}

export interface RawPartyCancelInvitationNotificationMessage
	extends RawAbstractPartyEventMessage {
	id: number
	cancelerId: number
	guestId: number
}

export class PartyCancelInvitationNotificationMessage extends AbstractPartyEventMessage {
	public static id = 1837

	public cancelerId: number | undefined = 0
	public guestId: number | undefined = 0

	public constructor(
		partyId?: number | undefined,
		cancelerId?: number | undefined,
		guestId?: number | undefined
	) {
		super(partyId)
		this.cancelerId = cancelerId
		this.guestId = guestId
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeVarLong(this.cancelerId!)
		writer.writeVarLong(this.guestId!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.cancelerId = reader.readVarLong()
		this.guestId = reader.readVarLong()
	}

	public hydrate(
		data: PartyCancelInvitationNotificationMessage | Record<string, any>
	): PartyCancelInvitationNotificationMessage {
		if (data instanceof PartyCancelInvitationNotificationMessage) {
			return data
		}

		super.hydrate(data)

		this.cancelerId = data.cancelerId
		this.guestId = data.guestId

		return this
	}
}

export interface RawDungeonPartyFinderListenErrorMessage {
	id: number
	dungeonId: number
}

export class DungeonPartyFinderListenErrorMessage extends DofusMessage {
	public static id: number = 8025

	public dungeonId: number | undefined = 0

	public constructor(dungeonId?: number | undefined) {
		super()
		this.dungeonId = dungeonId
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarShort(this.dungeonId!)
	}

	public deserialize(reader: BinaryReader): void {
		this.dungeonId = reader.readVarShort()
	}

	public hydrate(
		data: DungeonPartyFinderListenErrorMessage | Record<string, any>
	): DungeonPartyFinderListenErrorMessage {
		if (data instanceof DungeonPartyFinderListenErrorMessage) {
			return data
		}

		this.dungeonId = data.dungeonId

		return this
	}
}

export interface RawExchangeObjectMessage {
	id: number
	remote: boolean
}

export class ExchangeObjectMessage extends DofusMessage {
	public static id: number = 3929

	public remote: boolean | undefined = false

	public constructor(remote?: boolean | undefined) {
		super()
		this.remote = remote
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeBoolean(this.remote!)
	}

	public deserialize(reader: BinaryReader): void {
		this.remote = reader.readBoolean()
	}

	public hydrate(
		data: ExchangeObjectMessage | Record<string, any>
	): ExchangeObjectMessage {
		if (data instanceof ExchangeObjectMessage) {
			return data
		}

		this.remote = data.remote

		return this
	}
}

export interface RawExchangeObjectsRemovedMessage
	extends RawExchangeObjectMessage {
	id: number
	objectUID: number[]
}

export class ExchangeObjectsRemovedMessage extends ExchangeObjectMessage {
	public static id = 5784

	public objectUID: number[] | undefined

	public constructor(
		remote?: boolean | undefined,
		objectUID?: number[] | undefined
	) {
		super(remote)
		this.objectUID = objectUID
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeShort(this.objectUID!.length)
		this.objectUID!.forEach((current: number) => writer.writeVarInt(current))
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.objectUID = []
		const countObjectUID = reader.readShort()
		for (let i: number = 0; i < countObjectUID; i++) {
			this.objectUID.push(reader.readVarInt())
		}
	}

	public hydrate(
		data: ExchangeObjectsRemovedMessage | Record<string, any>
	): ExchangeObjectsRemovedMessage {
		if (data instanceof ExchangeObjectsRemovedMessage) {
			return data
		}

		super.hydrate(data)

		this.objectUID = data.objectUID

		return this
	}
}

export interface RawTextInformationMessage {
	id: number
	msgType: number
	msgId: number
	parameters: string[]
}

export class TextInformationMessage extends DofusMessage {
	public static id: number = 8680

	public msgType: number | undefined = 0
	public msgId: number | undefined = 0
	public parameters: string[] | undefined

	public constructor(
		msgType?: number | undefined,
		msgId?: number | undefined,
		parameters?: string[] | undefined
	) {
		super()
		this.msgType = msgType
		this.msgId = msgId
		this.parameters = parameters
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeByte(this.msgType!)
		writer.writeVarShort(this.msgId!)
		writer.writeShort(this.parameters!.length)
		this.parameters!.forEach((current: string) => writer.writeUTF(current))
	}

	public deserialize(reader: BinaryReader): void {
		this.msgType = reader.readByte()
		this.msgId = reader.readVarShort()
		this.parameters = []
		const countParameters = reader.readShort()
		for (let i: number = 0; i < countParameters; i++) {
			this.parameters.push(reader.readUTF())
		}
	}

	public hydrate(
		data: TextInformationMessage | Record<string, any>
	): TextInformationMessage {
		if (data instanceof TextInformationMessage) {
			return data
		}

		this.msgType = data.msgType
		this.msgId = data.msgId
		this.parameters = data.parameters

		return this
	}
}

export interface RawWarnOnPermaDeathStateMessage {
	id: number
	enable: boolean
}

export class WarnOnPermaDeathStateMessage extends DofusMessage {
	public static id: number = 9296

	public enable: boolean | undefined = false

	public constructor(enable?: boolean | undefined) {
		super()
		this.enable = enable
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeBoolean(this.enable!)
	}

	public deserialize(reader: BinaryReader): void {
		this.enable = reader.readBoolean()
	}

	public hydrate(
		data: WarnOnPermaDeathStateMessage | Record<string, any>
	): WarnOnPermaDeathStateMessage {
		if (data instanceof WarnOnPermaDeathStateMessage) {
			return data
		}

		this.enable = data.enable

		return this
	}
}

export interface RawExchangeOfflineSoldItemsMessage {
	id: number
	bidHouseItems: ObjectItemQuantityPriceDateEffects[]
	merchantItems: ObjectItemQuantityPriceDateEffects[]
}

export class ExchangeOfflineSoldItemsMessage extends DofusMessage {
	public static id: number = 9786

	public bidHouseItems: ObjectItemQuantityPriceDateEffects[] | undefined
	public merchantItems: ObjectItemQuantityPriceDateEffects[] | undefined

	public constructor(
		bidHouseItems?: ObjectItemQuantityPriceDateEffects[] | undefined,
		merchantItems?: ObjectItemQuantityPriceDateEffects[] | undefined
	) {
		super()
		this.bidHouseItems = bidHouseItems
		this.merchantItems = merchantItems
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeShort(this.bidHouseItems!.length)
		this.bidHouseItems!.forEach((current) => {
			current.serialize(writer)
		})
		writer.writeShort(this.merchantItems!.length)
		this.merchantItems!.forEach((current) => {
			current.serialize(writer)
		})
	}

	public deserialize(reader: BinaryReader): void {
		this.bidHouseItems = []
		const countBidHouseItems = reader.readShort()
		for (let i: number = 0; i < countBidHouseItems; i++) {
			const type: ObjectItemQuantityPriceDateEffects = new ObjectItemQuantityPriceDateEffects()
			type.deserialize(reader)
			this.bidHouseItems.push(type)
		}
		this.merchantItems = []
		const countMerchantItems = reader.readShort()
		for (let i: number = 0; i < countMerchantItems; i++) {
			const type: ObjectItemQuantityPriceDateEffects = new ObjectItemQuantityPriceDateEffects()
			type.deserialize(reader)
			this.merchantItems.push(type)
		}
	}

	public hydrate(
		data: ExchangeOfflineSoldItemsMessage | Record<string, any>
	): ExchangeOfflineSoldItemsMessage {
		if (data instanceof ExchangeOfflineSoldItemsMessage) {
			return data
		}

		this.bidHouseItems = data.bidHouseItems.map(
			(
				dataElement: ObjectItemQuantityPriceDateEffects | Record<string, any>
			): ObjectItemQuantityPriceDateEffects => {
				if (dataElement instanceof ObjectItemQuantityPriceDateEffects) {
					return dataElement
				} else {
					return new ObjectItemQuantityPriceDateEffects().hydrate(dataElement)
				}
			}
		)
		this.merchantItems = data.merchantItems.map(
			(
				dataElement: ObjectItemQuantityPriceDateEffects | Record<string, any>
			): ObjectItemQuantityPriceDateEffects => {
				if (dataElement instanceof ObjectItemQuantityPriceDateEffects) {
					return dataElement
				} else {
					return new ObjectItemQuantityPriceDateEffects().hydrate(dataElement)
				}
			}
		)

		return this
	}
}

export interface RawPartyLeaveMessage extends RawAbstractPartyMessage {
	id: number
}

export class PartyLeaveMessage extends AbstractPartyMessage {
	public static id = 8726

	public constructor(partyId?: number | undefined) {
		super(partyId)
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
	}

	public hydrate(
		data: PartyLeaveMessage | Record<string, any>
	): PartyLeaveMessage {
		if (data instanceof PartyLeaveMessage) {
			return data
		}

		super.hydrate(data)

		return this
	}
}

export interface RawQueueStatusMessage {
	id: number
	position: number
	total: number
}

export class QueueStatusMessage extends DofusMessage {
	public static id: number = 3069

	public position: number | undefined = 0
	public total: number | undefined = 0

	public constructor(
		position?: number | undefined,
		total?: number | undefined
	) {
		super()
		this.position = position
		this.total = total
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeShort(this.position!)
		writer.writeShort(this.total!)
	}

	public deserialize(reader: BinaryReader): void {
		this.position = reader.readShort()
		this.total = reader.readShort()
	}

	public hydrate(
		data: QueueStatusMessage | Record<string, any>
	): QueueStatusMessage {
		if (data instanceof QueueStatusMessage) {
			return data
		}

		this.position = data.position
		this.total = data.total

		return this
	}
}

export interface RawExchangeObjectAddedMessage
	extends RawExchangeObjectMessage {
	id: number
	object_: ObjectItem
}

export class ExchangeObjectAddedMessage extends ExchangeObjectMessage {
	public static id = 5600

	public object_: ObjectItem | undefined

	public constructor(
		remote?: boolean | undefined,
		object_?: ObjectItem | undefined
	) {
		super(remote)
		this.object_ = object_
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		this.object_!.serialize(writer)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.object_ = new ObjectItem()
		this.object_!.deserialize(reader)
	}

	public hydrate(
		data: ExchangeObjectAddedMessage | Record<string, any>
	): ExchangeObjectAddedMessage {
		if (data instanceof ExchangeObjectAddedMessage) {
			return data
		}

		super.hydrate(data)

		this.object_ = new ObjectItem().hydrate(data.object_)

		return this
	}
}

export interface RawExchangeShopStockMovementUpdatedMessage {
	id: number
	objectInfo: ObjectItemToSell
}

export class ExchangeShopStockMovementUpdatedMessage extends DofusMessage {
	public static id: number = 5713

	public objectInfo: ObjectItemToSell | undefined

	public constructor(objectInfo?: ObjectItemToSell | undefined) {
		super()
		this.objectInfo = objectInfo
	}

	public serialize(writer: BinaryWriter): void {
		this.objectInfo!.serialize(writer)
	}

	public deserialize(reader: BinaryReader): void {
		this.objectInfo = new ObjectItemToSell()
		this.objectInfo!.deserialize(reader)
	}

	public hydrate(
		data: ExchangeShopStockMovementUpdatedMessage | Record<string, any>
	): ExchangeShopStockMovementUpdatedMessage {
		if (data instanceof ExchangeShopStockMovementUpdatedMessage) {
			return data
		}

		this.objectInfo = new ObjectItemToSell().hydrate(data.objectInfo)

		return this
	}
}

export interface RawAbstractTaxCollectorListMessage {
	id: number
	informations: TaxCollectorInformations[]
}

export class AbstractTaxCollectorListMessage extends DofusMessage {
	public static id: number = 1653

	public informations: TaxCollectorInformations[] | undefined

	public constructor(informations?: TaxCollectorInformations[] | undefined) {
		super()
		this.informations = informations
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeShort(this.informations!.length)
		this.informations!.forEach((current) => {
			writer.writeShort(current.id)
			current.serialize(writer)
		})
	}

	public deserialize(reader: BinaryReader): void {
		this.informations = []
		const countInformations = reader.readShort()
		for (let i: number = 0; i < countInformations; i++) {
			const informationsTypeId: number = reader.readShort()
			const type: TaxCollectorInformations = new types[
				informationsTypeId
			]() as TaxCollectorInformations
			type.deserialize(reader)
			this.informations.push(type)
		}
	}

	public hydrate(
		data: AbstractTaxCollectorListMessage | Record<string, any>
	): AbstractTaxCollectorListMessage {
		if (data instanceof AbstractTaxCollectorListMessage) {
			return data
		}

		this.informations = data.informations.map(
			(
				dataElement: TaxCollectorInformations | Record<string, any>
			): TaxCollectorInformations => {
				if (dataElement instanceof TaxCollectorInformations) {
					return dataElement
				} else {
					return (new types[
						dataElement.id
					]() as TaxCollectorInformations).hydrate(dataElement)
				}
			}
		)

		return this
	}
}

export interface RawTaxCollectorListMessage
	extends RawAbstractTaxCollectorListMessage {
	id: number
	nbcollectorMax: number
	fightersInformations: TaxCollectorFightersInformation[]
	infoType: number
}

export class TaxCollectorListMessage extends AbstractTaxCollectorListMessage {
	public static id = 6709

	public nbcollectorMax: number | undefined = 0
	public fightersInformations: TaxCollectorFightersInformation[] | undefined
	public infoType: number | undefined = 0

	public constructor(
		informations?: TaxCollectorInformations[] | undefined,
		nbcollectorMax?: number | undefined,
		fightersInformations?: TaxCollectorFightersInformation[] | undefined,
		infoType?: number | undefined
	) {
		super(informations)
		this.nbcollectorMax = nbcollectorMax
		this.fightersInformations = fightersInformations
		this.infoType = infoType
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeByte(this.nbcollectorMax!)
		writer.writeShort(this.fightersInformations!.length)
		this.fightersInformations!.forEach((current) => {
			current.serialize(writer)
		})
		writer.writeByte(this.infoType!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.nbcollectorMax = reader.readByte()
		this.fightersInformations = []
		const countFightersInformations = reader.readShort()
		for (let i: number = 0; i < countFightersInformations; i++) {
			const type: TaxCollectorFightersInformation = new TaxCollectorFightersInformation()
			type.deserialize(reader)
			this.fightersInformations.push(type)
		}
		this.infoType = reader.readByte()
	}

	public hydrate(
		data: TaxCollectorListMessage | Record<string, any>
	): TaxCollectorListMessage {
		if (data instanceof TaxCollectorListMessage) {
			return data
		}

		super.hydrate(data)

		this.nbcollectorMax = data.nbcollectorMax
		this.fightersInformations = data.fightersInformations.map(
			(
				dataElement: TaxCollectorFightersInformation | Record<string, any>
			): TaxCollectorFightersInformation => {
				if (dataElement instanceof TaxCollectorFightersInformation) {
					return dataElement
				} else {
					return new TaxCollectorFightersInformation().hydrate(dataElement)
				}
			}
		)
		this.infoType = data.infoType

		return this
	}
}

export interface RawGameRolePlayDelayedActionMessage {
	id: number
	delayedCharacterId: number
	delayTypeId: number
	delayEndTime: number
}

export class GameRolePlayDelayedActionMessage extends DofusMessage {
	public static id: number = 1671

	public delayedCharacterId: number | undefined = 0
	public delayTypeId: number | undefined = 0
	public delayEndTime: number | undefined = 0

	public constructor(
		delayedCharacterId?: number | undefined,
		delayTypeId?: number | undefined,
		delayEndTime?: number | undefined
	) {
		super()
		this.delayedCharacterId = delayedCharacterId
		this.delayTypeId = delayTypeId
		this.delayEndTime = delayEndTime
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeDouble(this.delayedCharacterId!)
		writer.writeByte(this.delayTypeId!)
		writer.writeDouble(this.delayEndTime!)
	}

	public deserialize(reader: BinaryReader): void {
		this.delayedCharacterId = reader.readDouble()
		this.delayTypeId = reader.readByte()
		this.delayEndTime = reader.readDouble()
	}

	public hydrate(
		data: GameRolePlayDelayedActionMessage | Record<string, any>
	): GameRolePlayDelayedActionMessage {
		if (data instanceof GameRolePlayDelayedActionMessage) {
			return data
		}

		this.delayedCharacterId = data.delayedCharacterId
		this.delayTypeId = data.delayTypeId
		this.delayEndTime = data.delayEndTime

		return this
	}
}

export interface RawPauseDialogMessage {
	id: number
	dialogType: number
}

export class PauseDialogMessage extends DofusMessage {
	public static id: number = 6445

	public dialogType: number | undefined = 0

	public constructor(dialogType?: number | undefined) {
		super()
		this.dialogType = dialogType
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeByte(this.dialogType!)
	}

	public deserialize(reader: BinaryReader): void {
		this.dialogType = reader.readByte()
	}

	public hydrate(
		data: PauseDialogMessage | Record<string, any>
	): PauseDialogMessage {
		if (data instanceof PauseDialogMessage) {
			return data
		}

		this.dialogType = data.dialogType

		return this
	}
}

export interface RawTeleportDestinationsMessage {
	id: number
	type: number
	destinations: TeleportDestination[]
}

export class TeleportDestinationsMessage extends DofusMessage {
	public static id: number = 5005

	public type: number | undefined = 0
	public destinations: TeleportDestination[] | undefined

	public constructor(
		type?: number | undefined,
		destinations?: TeleportDestination[] | undefined
	) {
		super()
		this.type = type
		this.destinations = destinations
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeByte(this.type!)
		writer.writeShort(this.destinations!.length)
		this.destinations!.forEach((current) => {
			current.serialize(writer)
		})
	}

	public deserialize(reader: BinaryReader): void {
		this.type = reader.readByte()
		this.destinations = []
		const countDestinations = reader.readShort()
		for (let i: number = 0; i < countDestinations; i++) {
			const type: TeleportDestination = new TeleportDestination()
			type.deserialize(reader)
			this.destinations.push(type)
		}
	}

	public hydrate(
		data: TeleportDestinationsMessage | Record<string, any>
	): TeleportDestinationsMessage {
		if (data instanceof TeleportDestinationsMessage) {
			return data
		}

		this.type = data.type
		this.destinations = data.destinations.map(
			(
				dataElement: TeleportDestination | Record<string, any>
			): TeleportDestination => {
				if (dataElement instanceof TeleportDestination) {
					return dataElement
				} else {
					return new TeleportDestination().hydrate(dataElement)
				}
			}
		)

		return this
	}
}

export interface RawLifePointsRegenBeginMessage {
	id: number
	regenRate: number
}

export class LifePointsRegenBeginMessage extends DofusMessage {
	public static id: number = 7338

	public regenRate: number | undefined = 0

	public constructor(regenRate?: number | undefined) {
		super()
		this.regenRate = regenRate
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeByte(this.regenRate!)
	}

	public deserialize(reader: BinaryReader): void {
		this.regenRate = reader.readByte()
	}

	public hydrate(
		data: LifePointsRegenBeginMessage | Record<string, any>
	): LifePointsRegenBeginMessage {
		if (data instanceof LifePointsRegenBeginMessage) {
			return data
		}

		this.regenRate = data.regenRate

		return this
	}
}

export interface RawBreachBranchesMessage {
	id: number
	branches: ExtendedBreachBranch[]
}

export class BreachBranchesMessage extends DofusMessage {
	public static id: number = 913

	public branches: ExtendedBreachBranch[] | undefined

	public constructor(branches?: ExtendedBreachBranch[] | undefined) {
		super()
		this.branches = branches
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeShort(this.branches!.length)
		this.branches!.forEach((current) => {
			writer.writeShort(current.id)
			current.serialize(writer)
		})
	}

	public deserialize(reader: BinaryReader): void {
		this.branches = []
		const countBranches = reader.readShort()
		for (let i: number = 0; i < countBranches; i++) {
			const branchesTypeId: number = reader.readShort()
			const type: ExtendedBreachBranch = new types[
				branchesTypeId
			]() as ExtendedBreachBranch
			type.deserialize(reader)
			this.branches.push(type)
		}
	}

	public hydrate(
		data: BreachBranchesMessage | Record<string, any>
	): BreachBranchesMessage {
		if (data instanceof BreachBranchesMessage) {
			return data
		}

		this.branches = data.branches.map(
			(
				dataElement: ExtendedBreachBranch | Record<string, any>
			): ExtendedBreachBranch => {
				if (dataElement instanceof ExtendedBreachBranch) {
					return dataElement
				} else {
					return (new types[dataElement.id]() as ExtendedBreachBranch).hydrate(
						dataElement
					)
				}
			}
		)

		return this
	}
}

export interface RawCheckFileRequestMessage {
	id: number
	filename: string
	type: number
}

export class CheckFileRequestMessage extends DofusMessage {
	public static id: number = 3787

	public filename: string | undefined
	public type: number | undefined = 0

	public constructor(filename?: string | undefined, type?: number | undefined) {
		super()
		this.filename = filename
		this.type = type
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeUTF(this.filename!)
		writer.writeByte(this.type!)
	}

	public deserialize(reader: BinaryReader): void {
		this.filename = reader.readUTF()
		this.type = reader.readByte()
	}

	public hydrate(
		data: CheckFileRequestMessage | Record<string, any>
	): CheckFileRequestMessage {
		if (data instanceof CheckFileRequestMessage) {
			return data
		}

		this.filename = data.filename
		this.type = data.type

		return this
	}
}

export interface RawForgettableSpellListUpdateMessage {
	id: number
	action: number
	spells: ForgettableSpellItem[]
}

export class ForgettableSpellListUpdateMessage extends DofusMessage {
	public static id: number = 3233

	public action: number | undefined = 0
	public spells: ForgettableSpellItem[] | undefined

	public constructor(
		action?: number | undefined,
		spells?: ForgettableSpellItem[] | undefined
	) {
		super()
		this.action = action
		this.spells = spells
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeByte(this.action!)
		writer.writeShort(this.spells!.length)
		this.spells!.forEach((current) => {
			current.serialize(writer)
		})
	}

	public deserialize(reader: BinaryReader): void {
		this.action = reader.readByte()
		this.spells = []
		const countSpells = reader.readShort()
		for (let i: number = 0; i < countSpells; i++) {
			const type: ForgettableSpellItem = new ForgettableSpellItem()
			type.deserialize(reader)
			this.spells.push(type)
		}
	}

	public hydrate(
		data: ForgettableSpellListUpdateMessage | Record<string, any>
	): ForgettableSpellListUpdateMessage {
		if (data instanceof ForgettableSpellListUpdateMessage) {
			return data
		}

		this.action = data.action
		this.spells = data.spells.map(
			(
				dataElement: ForgettableSpellItem | Record<string, any>
			): ForgettableSpellItem => {
				if (dataElement instanceof ForgettableSpellItem) {
					return dataElement
				} else {
					return new ForgettableSpellItem().hydrate(dataElement)
				}
			}
		)

		return this
	}
}

export interface RawChatAbstractServerMessage {
	id: number
	channel: number
	content: string
	timestamp: number
	fingerprint: string
}

export class ChatAbstractServerMessage extends DofusMessage {
	public static id: number = 6850

	public channel: number | undefined = 0
	public content: string | undefined
	public timestamp: number | undefined = 0
	public fingerprint: string | undefined

	public constructor(
		channel?: number | undefined,
		content?: string | undefined,
		timestamp?: number | undefined,
		fingerprint?: string | undefined
	) {
		super()
		this.channel = channel
		this.content = content
		this.timestamp = timestamp
		this.fingerprint = fingerprint
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeByte(this.channel!)
		writer.writeUTF(this.content!)
		writer.writeInt(this.timestamp!)
		writer.writeUTF(this.fingerprint!)
	}

	public deserialize(reader: BinaryReader): void {
		this.channel = reader.readByte()
		this.content = reader.readUTF()
		this.timestamp = reader.readInt()
		this.fingerprint = reader.readUTF()
	}

	public hydrate(
		data: ChatAbstractServerMessage | Record<string, any>
	): ChatAbstractServerMessage {
		if (data instanceof ChatAbstractServerMessage) {
			return data
		}

		this.channel = data.channel
		this.content = data.content
		this.timestamp = data.timestamp
		this.fingerprint = data.fingerprint

		return this
	}
}

export interface RawCharactersListMessage
	extends RawBasicCharactersListMessage {
	id: number
	hasStartupActions: boolean
}

export class CharactersListMessage extends DofusMessage {
	public static id = 1165

	public characters: CharacterBaseInformations[] | undefined

	public constructor(characters?: CharacterBaseInformations[] | undefined) {
		super()
		this.characters = characters
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeShort(this.characters!.length)
		this.characters!.forEach((current) => {
			writer.writeShort(current.id)
			current.serialize(writer)
		})
	}

	public deserialize(reader: BinaryReader): void {
		this.characters = []
		const countCharacters = reader.readShort()
		for (let i: number = 0; i < countCharacters; i++) {
			const charactersTypeId: number = reader.readShort()
			const type: CharacterBaseInformations = new types[
				charactersTypeId
			]() as CharacterBaseInformations
			type.deserialize(reader)
			this.characters.push(type)
		}
	}

	public hydrate(
		data: CharactersListMessage | Record<string, any>
	): CharactersListMessage {
		if (data instanceof CharactersListMessage) {
			return data
		}

		this.characters = data.characters.map(
			(
				dataElement: CharacterBaseInformations | Record<string, any>
			): CharacterBaseInformations => {
				if (dataElement instanceof CharacterBaseInformations) {
					return dataElement
				} else {
					return (new types[
						dataElement.id
					]() as CharacterBaseInformations).hydrate(dataElement)
				}
			}
		)

		return this
	}
}

export interface RawCharactersListWithRemodelingMessage
	extends RawCharactersListMessage {
	id: number
	charactersToRemodel: CharacterToRemodelInformations[]
}

export class CharactersListWithRemodelingMessage extends CharactersListMessage {
	public static id = 1171

	public charactersToRemodel: CharacterToRemodelInformations[] | undefined

	public constructor(
		characters?: CharacterBaseInformations[] | undefined,
		charactersToRemodel?: CharacterToRemodelInformations[] | undefined
	) {
		super(characters)
		this.charactersToRemodel = charactersToRemodel
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeShort(this.charactersToRemodel!.length)
		this.charactersToRemodel!.forEach((current) => {
			current.serialize(writer)
		})
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.charactersToRemodel = []
		const countCharactersToRemodel = reader.readShort()
		for (let i: number = 0; i < countCharactersToRemodel; i++) {
			const type: CharacterToRemodelInformations = new CharacterToRemodelInformations()
			type.deserialize(reader)
			this.charactersToRemodel.push(type)
		}
	}

	public hydrate(
		data: CharactersListWithRemodelingMessage | Record<string, any>
	): CharactersListWithRemodelingMessage {
		if (data instanceof CharactersListWithRemodelingMessage) {
			return data
		}

		super.hydrate(data)

		this.charactersToRemodel = data.charactersToRemodel.map(
			(
				dataElement: CharacterToRemodelInformations | Record<string, any>
			): CharacterToRemodelInformations => {
				if (dataElement instanceof CharacterToRemodelInformations) {
					return dataElement
				} else {
					return new CharacterToRemodelInformations().hydrate(dataElement)
				}
			}
		)

		return this
	}
}

export interface RawInteractiveElementUpdatedMessage {
	id: number
	interactiveElement: InteractiveElement
}

export class InteractiveElementUpdatedMessage extends DofusMessage {
	public static id: number = 6876

	public interactiveElement: InteractiveElement | undefined

	public constructor(interactiveElement?: InteractiveElement | undefined) {
		super()
		this.interactiveElement = interactiveElement
	}

	public serialize(writer: BinaryWriter): void {
		this.interactiveElement!.serialize(writer)
	}

	public deserialize(reader: BinaryReader): void {
		this.interactiveElement = new InteractiveElement()
		this.interactiveElement!.deserialize(reader)
	}

	public hydrate(
		data: InteractiveElementUpdatedMessage | Record<string, any>
	): InteractiveElementUpdatedMessage {
		if (data instanceof InteractiveElementUpdatedMessage) {
			return data
		}

		this.interactiveElement = new InteractiveElement().hydrate(
			data.interactiveElement
		)

		return this
	}
}

export interface RawGameRolePlayFightRequestCanceledMessage {
	id: number
	fightId: number
	sourceId: number
	targetId: number
}

export class GameRolePlayFightRequestCanceledMessage extends DofusMessage {
	public static id: number = 5454

	public fightId: number | undefined = 0
	public sourceId: number | undefined = 0
	public targetId: number | undefined = 0

	public constructor(
		fightId?: number | undefined,
		sourceId?: number | undefined,
		targetId?: number | undefined
	) {
		super()
		this.fightId = fightId
		this.sourceId = sourceId
		this.targetId = targetId
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarShort(this.fightId!)
		writer.writeDouble(this.sourceId!)
		writer.writeDouble(this.targetId!)
	}

	public deserialize(reader: BinaryReader): void {
		this.fightId = reader.readVarShort()
		this.sourceId = reader.readDouble()
		this.targetId = reader.readDouble()
	}

	public hydrate(
		data: GameRolePlayFightRequestCanceledMessage | Record<string, any>
	): GameRolePlayFightRequestCanceledMessage {
		if (data instanceof GameRolePlayFightRequestCanceledMessage) {
			return data
		}

		this.fightId = data.fightId
		this.sourceId = data.sourceId
		this.targetId = data.targetId

		return this
	}
}

export interface RawBreachSavedMessage {
	id: number
	saved: boolean
}

export class BreachSavedMessage extends DofusMessage {
	public static id: number = 8176

	public saved: boolean | undefined = false

	public constructor(saved?: boolean | undefined) {
		super()
		this.saved = saved
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeBoolean(this.saved!)
	}

	public deserialize(reader: BinaryReader): void {
		this.saved = reader.readBoolean()
	}

	public hydrate(
		data: BreachSavedMessage | Record<string, any>
	): BreachSavedMessage {
		if (data instanceof BreachSavedMessage) {
			return data
		}

		this.saved = data.saved

		return this
	}
}

export interface RawGuildFightPlayersHelpersLeaveMessage {
	id: number
	fightId: number
	playerId: number
}

export class GuildFightPlayersHelpersLeaveMessage extends DofusMessage {
	public static id: number = 6675

	public fightId: number | undefined = 0
	public playerId: number | undefined = 0

	public constructor(
		fightId?: number | undefined,
		playerId?: number | undefined
	) {
		super()
		this.fightId = fightId
		this.playerId = playerId
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeDouble(this.fightId!)
		writer.writeVarLong(this.playerId!)
	}

	public deserialize(reader: BinaryReader): void {
		this.fightId = reader.readDouble()
		this.playerId = reader.readVarLong()
	}

	public hydrate(
		data: GuildFightPlayersHelpersLeaveMessage | Record<string, any>
	): GuildFightPlayersHelpersLeaveMessage {
		if (data instanceof GuildFightPlayersHelpersLeaveMessage) {
			return data
		}

		this.fightId = data.fightId
		this.playerId = data.playerId

		return this
	}
}

export interface RawHaapiApiKeyMessage {
	id: number
	token: string
}

export class HaapiApiKeyMessage extends DofusMessage {
	public static id: number = 6974

	public token: string | undefined

	public constructor(token?: string | undefined) {
		super()
		this.token = token
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeUTF(this.token!)
	}

	public deserialize(reader: BinaryReader): void {
		this.token = reader.readUTF()
	}

	public hydrate(
		data: HaapiApiKeyMessage | Record<string, any>
	): HaapiApiKeyMessage {
		if (data instanceof HaapiApiKeyMessage) {
			return data
		}

		this.token = data.token

		return this
	}
}

export interface RawTopTaxCollectorListMessage
	extends RawAbstractTaxCollectorListMessage {
	id: number
	isDungeon: boolean
}

export class TopTaxCollectorListMessage extends AbstractTaxCollectorListMessage {
	public static id = 1779

	public isDungeon: boolean | undefined = false

	public constructor(
		informations?: TaxCollectorInformations[] | undefined,
		isDungeon?: boolean | undefined
	) {
		super(informations)
		this.isDungeon = isDungeon
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeBoolean(this.isDungeon!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.isDungeon = reader.readBoolean()
	}

	public hydrate(
		data: TopTaxCollectorListMessage | Record<string, any>
	): TopTaxCollectorListMessage {
		if (data instanceof TopTaxCollectorListMessage) {
			return data
		}

		super.hydrate(data)

		this.isDungeon = data.isDungeon

		return this
	}
}

export interface RawGameRolePlayArenaFighterStatusMessage {
	id: number
	fightId: number
	playerId: number
	accepted: boolean
}

export class GameRolePlayArenaFighterStatusMessage extends DofusMessage {
	public static id: number = 4175

	public fightId: number | undefined = 0
	public playerId: number | undefined = 0
	public accepted: boolean | undefined = false

	public constructor(
		fightId?: number | undefined,
		playerId?: number | undefined,
		accepted?: boolean | undefined
	) {
		super()
		this.fightId = fightId
		this.playerId = playerId
		this.accepted = accepted
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarShort(this.fightId!)
		writer.writeDouble(this.playerId!)
		writer.writeBoolean(this.accepted!)
	}

	public deserialize(reader: BinaryReader): void {
		this.fightId = reader.readVarShort()
		this.playerId = reader.readDouble()
		this.accepted = reader.readBoolean()
	}

	public hydrate(
		data: GameRolePlayArenaFighterStatusMessage | Record<string, any>
	): GameRolePlayArenaFighterStatusMessage {
		if (data instanceof GameRolePlayArenaFighterStatusMessage) {
			return data
		}

		this.fightId = data.fightId
		this.playerId = data.playerId
		this.accepted = data.accepted

		return this
	}
}

export interface RawChatServerCopyMessage extends RawChatAbstractServerMessage {
	id: number
	receiverId: number
	receiverName: string
}

export class ChatServerCopyMessage extends ChatAbstractServerMessage {
	public static id = 9502

	public receiverId: number | undefined = 0
	public receiverName: string | undefined

	public constructor(
		channel?: number | undefined,
		content?: string | undefined,
		timestamp?: number | undefined,
		fingerprint?: string | undefined,
		receiverId?: number | undefined,
		receiverName?: string | undefined
	) {
		super(channel, content, timestamp, fingerprint)
		this.receiverId = receiverId
		this.receiverName = receiverName
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeVarLong(this.receiverId!)
		writer.writeUTF(this.receiverName!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.receiverId = reader.readVarLong()
		this.receiverName = reader.readUTF()
	}

	public hydrate(
		data: ChatServerCopyMessage | Record<string, any>
	): ChatServerCopyMessage {
		if (data instanceof ChatServerCopyMessage) {
			return data
		}

		super.hydrate(data)

		this.receiverId = data.receiverId
		this.receiverName = data.receiverName

		return this
	}
}

export interface RawChatSmileyMessage {
	id: number
	entityId: number
	smileyId: number
	accountId: number
}

export class ChatSmileyMessage extends DofusMessage {
	public static id: number = 2736

	public entityId: number | undefined = 0
	public smileyId: number | undefined = 0
	public accountId: number | undefined = 0

	public constructor(
		entityId?: number | undefined,
		smileyId?: number | undefined,
		accountId?: number | undefined
	) {
		super()
		this.entityId = entityId
		this.smileyId = smileyId
		this.accountId = accountId
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeDouble(this.entityId!)
		writer.writeVarShort(this.smileyId!)
		writer.writeInt(this.accountId!)
	}

	public deserialize(reader: BinaryReader): void {
		this.entityId = reader.readDouble()
		this.smileyId = reader.readVarShort()
		this.accountId = reader.readInt()
	}

	public hydrate(
		data: ChatSmileyMessage | Record<string, any>
	): ChatSmileyMessage {
		if (data instanceof ChatSmileyMessage) {
			return data
		}

		this.entityId = data.entityId
		this.smileyId = data.smileyId
		this.accountId = data.accountId

		return this
	}
}

export interface RawLocalizedChatSmileyMessage extends RawChatSmileyMessage {
	id: number
	cellId: number
}

export class LocalizedChatSmileyMessage extends ChatSmileyMessage {
	public static id = 7234

	public cellId: number | undefined = 0

	public constructor(
		entityId?: number | undefined,
		smileyId?: number | undefined,
		accountId?: number | undefined,
		cellId?: number | undefined
	) {
		super(entityId, smileyId, accountId)
		this.cellId = cellId
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeVarShort(this.cellId!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.cellId = reader.readVarShort()
	}

	public hydrate(
		data: LocalizedChatSmileyMessage | Record<string, any>
	): LocalizedChatSmileyMessage {
		if (data instanceof LocalizedChatSmileyMessage) {
			return data
		}

		super.hydrate(data)

		this.cellId = data.cellId

		return this
	}
}

export interface RawGameRolePlayArenaSwitchToFightServerMessage {
	id: number
	address: string
	ports: number[]
	ticket: number[]
}

export class GameRolePlayArenaSwitchToFightServerMessage extends DofusMessage {
	public static id: number = 9126

	public address: string | undefined
	public ports: number[] | undefined
	public ticket: number[] | undefined

	public constructor(
		address?: string | undefined,
		ports?: number[] | undefined,
		ticket?: number[] | undefined
	) {
		super()
		this.address = address
		this.ports = ports
		this.ticket = ticket
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeUTF(this.address!)
		writer.writeShort(this.ports!.length)
		this.ports!.forEach((current: number) => writer.writeVarShort(current))
		writer.writeVarInt(this.ticket!.length)
		this.ticket!.forEach((current: number) => writer.writeByte(current))
	}

	public deserialize(reader: BinaryReader): void {
		this.address = reader.readUTF()
		this.ports = []
		const countPorts = reader.readShort()
		for (let i: number = 0; i < countPorts; i++) {
			this.ports.push(reader.readVarShort())
		}
		this.ticket = []
		const countTicket = reader.readVarInt()
		for (let i: number = 0; i < countTicket; i++) {
			this.ticket.push(reader.readByte())
		}
	}

	public hydrate(
		data: GameRolePlayArenaSwitchToFightServerMessage | Record<string, any>
	): GameRolePlayArenaSwitchToFightServerMessage {
		if (data instanceof GameRolePlayArenaSwitchToFightServerMessage) {
			return data
		}

		this.address = data.address
		this.ports = data.ports
		this.ticket = data.ticket

		return this
	}
}

export interface RawProtocolRequired {
	id: number
	version: string
}

export class ProtocolRequired extends DofusMessage {
	public static id: number = 6212

	public version: string | undefined

	public constructor(version?: string | undefined) {
		super()
		this.version = version
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeUTF(this.version!)
	}

	public deserialize(reader: BinaryReader): void {
		this.version = reader.readUTF()
	}

	public hydrate(
		data: ProtocolRequired | Record<string, any>
	): ProtocolRequired {
		if (data instanceof ProtocolRequired) {
			return data
		}

		this.version = data.version

		return this
	}
}

export interface RawCompassUpdateMessage {
	id: number
	type: number
	coords: MapCoordinates
}

export class CompassUpdateMessage extends DofusMessage {
	public static id: number = 476

	public type: number | undefined = 0
	public coords: MapCoordinates | undefined

	public constructor(
		type?: number | undefined,
		coords?: MapCoordinates | undefined
	) {
		super()
		this.type = type
		this.coords = coords
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeByte(this.type!)
		writer.writeShort(this.coords!.id)
		this.coords!.serialize(writer)
	}

	public deserialize(reader: BinaryReader): void {
		this.type = reader.readByte()
		const coordsTypeId: number = reader.readShort()
		this.coords = new types[coordsTypeId]() as MapCoordinates
		this.coords!.deserialize(reader)
	}

	public hydrate(
		data: CompassUpdateMessage | Record<string, any>
	): CompassUpdateMessage {
		if (data instanceof CompassUpdateMessage) {
			return data
		}

		this.type = data.type
		this.coords = (new types[data.coords.id]() as MapCoordinates).hydrate(
			data.coords
		)
		return this
	}
}

export interface RawGameRefreshMonsterBoostsMessage {
	id: number
	monsterBoosts: MonsterBoosts[]
	familyBoosts: MonsterBoosts[]
}

export class GameRefreshMonsterBoostsMessage extends DofusMessage {
	public static id: number = 979

	public monsterBoosts: MonsterBoosts[] | undefined
	public familyBoosts: MonsterBoosts[] | undefined

	public constructor(
		monsterBoosts?: MonsterBoosts[] | undefined,
		familyBoosts?: MonsterBoosts[] | undefined
	) {
		super()
		this.monsterBoosts = monsterBoosts
		this.familyBoosts = familyBoosts
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeShort(this.monsterBoosts!.length)
		this.monsterBoosts!.forEach((current) => {
			current.serialize(writer)
		})
		writer.writeShort(this.familyBoosts!.length)
		this.familyBoosts!.forEach((current) => {
			current.serialize(writer)
		})
	}

	public deserialize(reader: BinaryReader): void {
		this.monsterBoosts = []
		const countMonsterBoosts = reader.readShort()
		for (let i: number = 0; i < countMonsterBoosts; i++) {
			const type: MonsterBoosts = new MonsterBoosts()
			type.deserialize(reader)
			this.monsterBoosts.push(type)
		}
		this.familyBoosts = []
		const countFamilyBoosts = reader.readShort()
		for (let i: number = 0; i < countFamilyBoosts; i++) {
			const type: MonsterBoosts = new MonsterBoosts()
			type.deserialize(reader)
			this.familyBoosts.push(type)
		}
	}

	public hydrate(
		data: GameRefreshMonsterBoostsMessage | Record<string, any>
	): GameRefreshMonsterBoostsMessage {
		if (data instanceof GameRefreshMonsterBoostsMessage) {
			return data
		}

		this.monsterBoosts = data.monsterBoosts.map(
			(dataElement: MonsterBoosts | Record<string, any>): MonsterBoosts => {
				if (dataElement instanceof MonsterBoosts) {
					return dataElement
				} else {
					return new MonsterBoosts().hydrate(dataElement)
				}
			}
		)
		this.familyBoosts = data.familyBoosts.map(
			(dataElement: MonsterBoosts | Record<string, any>): MonsterBoosts => {
				if (dataElement instanceof MonsterBoosts) {
					return dataElement
				} else {
					return new MonsterBoosts().hydrate(dataElement)
				}
			}
		)

		return this
	}
}

export interface RawDungeonPartyFinderRegisterSuccessMessage {
	id: number
	dungeonIds: number[]
}

export class DungeonPartyFinderRegisterSuccessMessage extends DofusMessage {
	public static id: number = 971

	public dungeonIds: number[] | undefined

	public constructor(dungeonIds?: number[] | undefined) {
		super()
		this.dungeonIds = dungeonIds
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeShort(this.dungeonIds!.length)
		this.dungeonIds!.forEach((current: number) => writer.writeVarShort(current))
	}

	public deserialize(reader: BinaryReader): void {
		this.dungeonIds = []
		const countDungeonIds = reader.readShort()
		for (let i: number = 0; i < countDungeonIds; i++) {
			this.dungeonIds.push(reader.readVarShort())
		}
	}

	public hydrate(
		data: DungeonPartyFinderRegisterSuccessMessage | Record<string, any>
	): DungeonPartyFinderRegisterSuccessMessage {
		if (data instanceof DungeonPartyFinderRegisterSuccessMessage) {
			return data
		}

		this.dungeonIds = data.dungeonIds

		return this
	}
}

export interface RawSpellVariantActivationMessage {
	id: number
	spellId: number
	result: boolean
}

export class SpellVariantActivationMessage extends DofusMessage {
	public static id: number = 2623

	public spellId: number | undefined = 0
	public result: boolean | undefined = false

	public constructor(
		spellId?: number | undefined,
		result?: boolean | undefined
	) {
		super()
		this.spellId = spellId
		this.result = result
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarShort(this.spellId!)
		writer.writeBoolean(this.result!)
	}

	public deserialize(reader: BinaryReader): void {
		this.spellId = reader.readVarShort()
		this.result = reader.readBoolean()
	}

	public hydrate(
		data: SpellVariantActivationMessage | Record<string, any>
	): SpellVariantActivationMessage {
		if (data instanceof SpellVariantActivationMessage) {
			return data
		}

		this.spellId = data.spellId
		this.result = data.result

		return this
	}
}

export interface RawStorageObjectsRemoveMessage {
	id: number
	objectUIDList: number[]
}

export class StorageObjectsRemoveMessage extends DofusMessage {
	public static id: number = 3869

	public objectUIDList: number[] | undefined

	public constructor(objectUIDList?: number[] | undefined) {
		super()
		this.objectUIDList = objectUIDList
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeShort(this.objectUIDList!.length)
		this.objectUIDList!.forEach((current: number) =>
			writer.writeVarInt(current)
		)
	}

	public deserialize(reader: BinaryReader): void {
		this.objectUIDList = []
		const countObjectUIDList = reader.readShort()
		for (let i: number = 0; i < countObjectUIDList; i++) {
			this.objectUIDList.push(reader.readVarInt())
		}
	}

	public hydrate(
		data: StorageObjectsRemoveMessage | Record<string, any>
	): StorageObjectsRemoveMessage {
		if (data instanceof StorageObjectsRemoveMessage) {
			return data
		}

		this.objectUIDList = data.objectUIDList

		return this
	}
}

export interface RawMountReleasedMessage {
	id: number
	mountId: number
}

export class MountReleasedMessage extends DofusMessage {
	public static id: number = 6105

	public mountId: number | undefined = 0

	public constructor(mountId?: number | undefined) {
		super()
		this.mountId = mountId
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarInt(this.mountId!)
	}

	public deserialize(reader: BinaryReader): void {
		this.mountId = reader.readVarInt()
	}

	public hydrate(
		data: MountReleasedMessage | Record<string, any>
	): MountReleasedMessage {
		if (data instanceof MountReleasedMessage) {
			return data
		}

		this.mountId = data.mountId

		return this
	}
}

export interface RawDecraftResultMessage {
	id: number
	results: DecraftedItemStackInfo[]
}

export class DecraftResultMessage extends DofusMessage {
	public static id: number = 9469

	public results: DecraftedItemStackInfo[] | undefined

	public constructor(results?: DecraftedItemStackInfo[] | undefined) {
		super()
		this.results = results
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeShort(this.results!.length)
		this.results!.forEach((current) => {
			current.serialize(writer)
		})
	}

	public deserialize(reader: BinaryReader): void {
		this.results = []
		const countResults = reader.readShort()
		for (let i: number = 0; i < countResults; i++) {
			const type: DecraftedItemStackInfo = new DecraftedItemStackInfo()
			type.deserialize(reader)
			this.results.push(type)
		}
	}

	public hydrate(
		data: DecraftResultMessage | Record<string, any>
	): DecraftResultMessage {
		if (data instanceof DecraftResultMessage) {
			return data
		}

		this.results = data.results.map(
			(
				dataElement: DecraftedItemStackInfo | Record<string, any>
			): DecraftedItemStackInfo => {
				if (dataElement instanceof DecraftedItemStackInfo) {
					return dataElement
				} else {
					return new DecraftedItemStackInfo().hydrate(dataElement)
				}
			}
		)

		return this
	}
}

export interface RawMapFightStartPositionsUpdateMessage {
	id: number
	mapId: number
	fightStartPositions: FightStartingPositions
}

export class MapFightStartPositionsUpdateMessage extends DofusMessage {
	public static id: number = 7089

	public mapId: number | undefined = 0
	public fightStartPositions: FightStartingPositions | undefined

	public constructor(
		mapId?: number | undefined,
		fightStartPositions?: FightStartingPositions | undefined
	) {
		super()
		this.mapId = mapId
		this.fightStartPositions = fightStartPositions
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeDouble(this.mapId!)
		this.fightStartPositions!.serialize(writer)
	}

	public deserialize(reader: BinaryReader): void {
		this.mapId = reader.readDouble()
		this.fightStartPositions = new FightStartingPositions()
		this.fightStartPositions!.deserialize(reader)
	}

	public hydrate(
		data: MapFightStartPositionsUpdateMessage | Record<string, any>
	): MapFightStartPositionsUpdateMessage {
		if (data instanceof MapFightStartPositionsUpdateMessage) {
			return data
		}

		this.mapId = data.mapId
		this.fightStartPositions = new FightStartingPositions().hydrate(
			data.fightStartPositions
		)

		return this
	}
}

export interface RawOrnamentLostMessage {
	id: number
	ornamentId: number
}

export class OrnamentLostMessage extends DofusMessage {
	public static id: number = 8465

	public ornamentId: number | undefined = 0

	public constructor(ornamentId?: number | undefined) {
		super()
		this.ornamentId = ornamentId
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeShort(this.ornamentId!)
	}

	public deserialize(reader: BinaryReader): void {
		this.ornamentId = reader.readShort()
	}

	public hydrate(
		data: OrnamentLostMessage | Record<string, any>
	): OrnamentLostMessage {
		if (data instanceof OrnamentLostMessage) {
			return data
		}

		this.ornamentId = data.ornamentId

		return this
	}
}

export interface RawNetworkDataContainerMessage {
	id: number
}

export class NetworkDataContainerMessage extends DofusMessage {
	public static id: number = 2

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public serialize(writer: BinaryWriter): void {}

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public deserialize(reader: BinaryReader): void {}

	public hydrate(
		data: NetworkDataContainerMessage | Record<string, any>
	): NetworkDataContainerMessage {
		if (data instanceof NetworkDataContainerMessage) {
			return data
		}

		return this
	}
}

export interface RawGuildPaddockBoughtMessage {
	id: number
	paddockInfo: PaddockContentInformations
}

export class GuildPaddockBoughtMessage extends DofusMessage {
	public static id: number = 9221

	public paddockInfo: PaddockContentInformations | undefined

	public constructor(paddockInfo?: PaddockContentInformations | undefined) {
		super()
		this.paddockInfo = paddockInfo
	}

	public serialize(writer: BinaryWriter): void {
		this.paddockInfo!.serialize(writer)
	}

	public deserialize(reader: BinaryReader): void {
		this.paddockInfo = new PaddockContentInformations()
		this.paddockInfo!.deserialize(reader)
	}

	public hydrate(
		data: GuildPaddockBoughtMessage | Record<string, any>
	): GuildPaddockBoughtMessage {
		if (data instanceof GuildPaddockBoughtMessage) {
			return data
		}

		this.paddockInfo = new PaddockContentInformations().hydrate(
			data.paddockInfo
		)

		return this
	}
}

export interface RawAbstractPartyMemberInFightMessage
	extends RawAbstractPartyMessage {
	id: number
	reason: number
	memberId: number
	memberAccountId: number
	memberName: string
	fightId: number
	timeBeforeFightStart: number
}

export class AbstractPartyMemberInFightMessage extends AbstractPartyMessage {
	public static id = 5489

	public reason: number | undefined = 0
	public memberId: number | undefined = 0
	public memberAccountId: number | undefined = 0
	public memberName: string | undefined
	public fightId: number | undefined = 0
	public timeBeforeFightStart: number | undefined = 0

	public constructor(
		partyId?: number | undefined,
		reason?: number | undefined,
		memberId?: number | undefined,
		memberAccountId?: number | undefined,
		memberName?: string | undefined,
		fightId?: number | undefined,
		timeBeforeFightStart?: number | undefined
	) {
		super(partyId)
		this.reason = reason
		this.memberId = memberId
		this.memberAccountId = memberAccountId
		this.memberName = memberName
		this.fightId = fightId
		this.timeBeforeFightStart = timeBeforeFightStart
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeByte(this.reason!)
		writer.writeVarLong(this.memberId!)
		writer.writeInt(this.memberAccountId!)
		writer.writeUTF(this.memberName!)
		writer.writeVarShort(this.fightId!)
		writer.writeVarShort(this.timeBeforeFightStart!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.reason = reader.readByte()
		this.memberId = reader.readVarLong()
		this.memberAccountId = reader.readInt()
		this.memberName = reader.readUTF()
		this.fightId = reader.readVarShort()
		this.timeBeforeFightStart = reader.readVarShort()
	}

	public hydrate(
		data: AbstractPartyMemberInFightMessage | Record<string, any>
	): AbstractPartyMemberInFightMessage {
		if (data instanceof AbstractPartyMemberInFightMessage) {
			return data
		}

		super.hydrate(data)

		this.reason = data.reason
		this.memberId = data.memberId
		this.memberAccountId = data.memberAccountId
		this.memberName = data.memberName
		this.fightId = data.fightId
		this.timeBeforeFightStart = data.timeBeforeFightStart

		return this
	}
}

export interface RawPartyMemberInStandardFightMessage
	extends RawAbstractPartyMemberInFightMessage {
	id: number
	fightMap: MapCoordinatesExtended
}

export class PartyMemberInStandardFightMessage extends AbstractPartyMemberInFightMessage {
	public static id = 3432

	public fightMap: MapCoordinatesExtended | undefined

	public constructor(
		partyId?: number | undefined,
		reason?: number | undefined,
		memberId?: number | undefined,
		memberAccountId?: number | undefined,
		memberName?: string | undefined,
		fightId?: number | undefined,
		timeBeforeFightStart?: number | undefined,
		fightMap?: MapCoordinatesExtended | undefined
	) {
		super(
			partyId,
			reason,
			memberId,
			memberAccountId,
			memberName,
			fightId,
			timeBeforeFightStart
		)
		this.fightMap = fightMap
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		this.fightMap!.serialize(writer)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.fightMap = new MapCoordinatesExtended()
		this.fightMap!.deserialize(reader)
	}

	public hydrate(
		data: PartyMemberInStandardFightMessage | Record<string, any>
	): PartyMemberInStandardFightMessage {
		if (data instanceof PartyMemberInStandardFightMessage) {
			return data
		}

		super.hydrate(data)

		this.fightMap = new MapCoordinatesExtended().hydrate(data.fightMap)

		return this
	}
}

export interface RawExchangeStartedMessage {
	id: number
	exchangeType: number
}

export class ExchangeStartedMessage extends DofusMessage {
	public static id: number = 3035

	public exchangeType: number | undefined = 0

	public constructor(exchangeType?: number | undefined) {
		super()
		this.exchangeType = exchangeType
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeByte(this.exchangeType!)
	}

	public deserialize(reader: BinaryReader): void {
		this.exchangeType = reader.readByte()
	}

	public hydrate(
		data: ExchangeStartedMessage | Record<string, any>
	): ExchangeStartedMessage {
		if (data instanceof ExchangeStartedMessage) {
			return data
		}

		this.exchangeType = data.exchangeType

		return this
	}
}

export interface RawSpouseStatusMessage {
	id: number
	hasSpouse: boolean
}

export class SpouseStatusMessage extends DofusMessage {
	public static id: number = 8129

	public hasSpouse: boolean | undefined = false

	public constructor(hasSpouse?: boolean | undefined) {
		super()
		this.hasSpouse = hasSpouse
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeBoolean(this.hasSpouse!)
	}

	public deserialize(reader: BinaryReader): void {
		this.hasSpouse = reader.readBoolean()
	}

	public hydrate(
		data: SpouseStatusMessage | Record<string, any>
	): SpouseStatusMessage {
		if (data instanceof SpouseStatusMessage) {
			return data
		}

		this.hasSpouse = data.hasSpouse

		return this
	}
}

export interface RawSubscriptionLimitationMessage {
	id: number
	reason: number
}

export class SubscriptionLimitationMessage extends DofusMessage {
	public static id: number = 3344

	public reason: number | undefined = 0

	public constructor(reason?: number | undefined) {
		super()
		this.reason = reason
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeByte(this.reason!)
	}

	public deserialize(reader: BinaryReader): void {
		this.reason = reader.readByte()
	}

	public hydrate(
		data: SubscriptionLimitationMessage | Record<string, any>
	): SubscriptionLimitationMessage {
		if (data instanceof SubscriptionLimitationMessage) {
			return data
		}

		this.reason = data.reason

		return this
	}
}

export interface RawExchangeBidPriceMessage {
	id: number
	genericId: number
	averagePrice: number
}

export class ExchangeBidPriceMessage extends DofusMessage {
	public static id: number = 3774

	public genericId: number | undefined = 0
	public averagePrice: number | undefined = 0

	public constructor(
		genericId?: number | undefined,
		averagePrice?: number | undefined
	) {
		super()
		this.genericId = genericId
		this.averagePrice = averagePrice
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarShort(this.genericId!)
		writer.writeVarLong(this.averagePrice!)
	}

	public deserialize(reader: BinaryReader): void {
		this.genericId = reader.readVarShort()
		this.averagePrice = reader.readVarLong()
	}

	public hydrate(
		data: ExchangeBidPriceMessage | Record<string, any>
	): ExchangeBidPriceMessage {
		if (data instanceof ExchangeBidPriceMessage) {
			return data
		}

		this.genericId = data.genericId
		this.averagePrice = data.averagePrice

		return this
	}
}

export interface RawExchangeBidPriceForSellerMessage
	extends RawExchangeBidPriceMessage {
	id: number
	allIdentical: boolean
	minimalPrices: number[]
}

export class ExchangeBidPriceForSellerMessage extends ExchangeBidPriceMessage {
	public static id = 4716

	public allIdentical: boolean | undefined = false
	public minimalPrices: number[] | undefined

	public constructor(
		genericId?: number | undefined,
		averagePrice?: number | undefined,
		allIdentical?: boolean | undefined,
		minimalPrices?: number[] | undefined
	) {
		super(genericId, averagePrice)
		this.allIdentical = allIdentical
		this.minimalPrices = minimalPrices
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeBoolean(this.allIdentical!)
		writer.writeShort(this.minimalPrices!.length)
		this.minimalPrices!.forEach((current: number) =>
			writer.writeVarLong(current)
		)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.allIdentical = reader.readBoolean()
		this.minimalPrices = []
		const countMinimalPrices = reader.readShort()
		for (let i: number = 0; i < countMinimalPrices; i++) {
			this.minimalPrices.push(reader.readVarLong())
		}
	}

	public hydrate(
		data: ExchangeBidPriceForSellerMessage | Record<string, any>
	): ExchangeBidPriceForSellerMessage {
		if (data instanceof ExchangeBidPriceForSellerMessage) {
			return data
		}

		super.hydrate(data)

		this.allIdentical = data.allIdentical
		this.minimalPrices = data.minimalPrices

		return this
	}
}

export interface RawLockableShowCodeDialogMessage {
	id: number
	changeOrUse: boolean
	codeSize: number
}

export class LockableShowCodeDialogMessage extends DofusMessage {
	public static id: number = 2846

	public changeOrUse: boolean | undefined = false
	public codeSize: number | undefined = 0

	public constructor(
		changeOrUse?: boolean | undefined,
		codeSize?: number | undefined
	) {
		super()
		this.changeOrUse = changeOrUse
		this.codeSize = codeSize
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeBoolean(this.changeOrUse!)
		writer.writeByte(this.codeSize!)
	}

	public deserialize(reader: BinaryReader): void {
		this.changeOrUse = reader.readBoolean()
		this.codeSize = reader.readByte()
	}

	public hydrate(
		data: LockableShowCodeDialogMessage | Record<string, any>
	): LockableShowCodeDialogMessage {
		if (data instanceof LockableShowCodeDialogMessage) {
			return data
		}

		this.changeOrUse = data.changeOrUse
		this.codeSize = data.codeSize

		return this
	}
}

export interface RawGuildFightPlayersHelpersJoinMessage {
	id: number
	fightId: number
	playerInfo: CharacterMinimalPlusLookInformations
}

export class GuildFightPlayersHelpersJoinMessage extends DofusMessage {
	public static id: number = 5722

	public fightId: number | undefined = 0
	public playerInfo: CharacterMinimalPlusLookInformations | undefined

	public constructor(
		fightId?: number | undefined,
		playerInfo?: CharacterMinimalPlusLookInformations | undefined
	) {
		super()
		this.fightId = fightId
		this.playerInfo = playerInfo
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeDouble(this.fightId!)
		this.playerInfo!.serialize(writer)
	}

	public deserialize(reader: BinaryReader): void {
		this.fightId = reader.readDouble()
		this.playerInfo = new CharacterMinimalPlusLookInformations()
		this.playerInfo!.deserialize(reader)
	}

	public hydrate(
		data: GuildFightPlayersHelpersJoinMessage | Record<string, any>
	): GuildFightPlayersHelpersJoinMessage {
		if (data instanceof GuildFightPlayersHelpersJoinMessage) {
			return data
		}

		this.fightId = data.fightId
		this.playerInfo = new CharacterMinimalPlusLookInformations().hydrate(
			data.playerInfo
		)

		return this
	}
}

export interface RawTaxCollectorMovementsOfflineMessage {
	id: number
	movements: TaxCollectorMovement[]
}

export class TaxCollectorMovementsOfflineMessage extends DofusMessage {
	public static id: number = 3995

	public movements: TaxCollectorMovement[] | undefined

	public constructor(movements?: TaxCollectorMovement[] | undefined) {
		super()
		this.movements = movements
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeShort(this.movements!.length)
		this.movements!.forEach((current) => {
			current.serialize(writer)
		})
	}

	public deserialize(reader: BinaryReader): void {
		this.movements = []
		const countMovements = reader.readShort()
		for (let i: number = 0; i < countMovements; i++) {
			const type: TaxCollectorMovement = new TaxCollectorMovement()
			type.deserialize(reader)
			this.movements.push(type)
		}
	}

	public hydrate(
		data: TaxCollectorMovementsOfflineMessage | Record<string, any>
	): TaxCollectorMovementsOfflineMessage {
		if (data instanceof TaxCollectorMovementsOfflineMessage) {
			return data
		}

		this.movements = data.movements.map(
			(
				dataElement: TaxCollectorMovement | Record<string, any>
			): TaxCollectorMovement => {
				if (dataElement instanceof TaxCollectorMovement) {
					return dataElement
				} else {
					return new TaxCollectorMovement().hydrate(dataElement)
				}
			}
		)

		return this
	}
}

export interface RawUpdateLifePointsMessage {
	id: number
	lifePoints: number
	maxLifePoints: number
}

export class UpdateLifePointsMessage extends DofusMessage {
	public static id: number = 2752

	public lifePoints: number | undefined = 0
	public maxLifePoints: number | undefined = 0

	public constructor(
		lifePoints?: number | undefined,
		maxLifePoints?: number | undefined
	) {
		super()
		this.lifePoints = lifePoints
		this.maxLifePoints = maxLifePoints
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarInt(this.lifePoints!)
		writer.writeVarInt(this.maxLifePoints!)
	}

	public deserialize(reader: BinaryReader): void {
		this.lifePoints = reader.readVarInt()
		this.maxLifePoints = reader.readVarInt()
	}

	public hydrate(
		data: UpdateLifePointsMessage | Record<string, any>
	): UpdateLifePointsMessage {
		if (data instanceof UpdateLifePointsMessage) {
			return data
		}

		this.lifePoints = data.lifePoints
		this.maxLifePoints = data.maxLifePoints

		return this
	}
}

export interface RawReloginTokenStatusMessage {
	id: number
	validToken: boolean
	ticket: number[]
}

export class ReloginTokenStatusMessage extends DofusMessage {
	public static id: number = 3729

	public validToken: boolean | undefined = false
	public ticket: string | undefined = ""

	public constructor(
		validToken?: boolean | undefined,
		ticket?: string | undefined
	) {
		super()
		this.validToken = validToken
		this.ticket = ticket
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeBoolean(this.validToken!)
		writer.writeUTF(this.ticket!)
	}

	public deserialize(reader: BinaryReader): void {
		this.validToken = reader.readBoolean()
		this.ticket = reader.readUTF()
	}

	public hydrate(
		data: ReloginTokenStatusMessage | Record<string, any>
	): ReloginTokenStatusMessage {
		if (data instanceof ReloginTokenStatusMessage) {
			return data
		}

		this.validToken = data.validToken
		this.ticket = data.ticket

		return this
	}
}

export interface RawTitleGainedMessage {
	id: number
	titleId: number
}

export class TitleGainedMessage extends DofusMessage {
	public static id: number = 3189

	public titleId: number | undefined = 0

	public constructor(titleId?: number | undefined) {
		super()
		this.titleId = titleId
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarShort(this.titleId!)
	}

	public deserialize(reader: BinaryReader): void {
		this.titleId = reader.readVarShort()
	}

	public hydrate(
		data: TitleGainedMessage | Record<string, any>
	): TitleGainedMessage {
		if (data instanceof TitleGainedMessage) {
			return data
		}

		this.titleId = data.titleId

		return this
	}
}

export interface RawInventoryContentMessage {
	id: number
	objects: ObjectItem[]
	kamas: number
}

export class InventoryContentMessage extends DofusMessage {
	public static id: number = 6852

	public objects: ObjectItem[] | undefined
	public kamas: number | undefined = 0

	public constructor(
		objects?: ObjectItem[] | undefined,
		kamas?: number | undefined
	) {
		super()
		this.objects = objects
		this.kamas = kamas
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeShort(this.objects!.length)
		this.objects!.forEach((current) => {
			current.serialize(writer)
		})
		writer.writeVarLong(this.kamas!)
	}

	public deserialize(reader: BinaryReader): void {
		this.objects = []
		const countObjects = reader.readShort()
		for (let i: number = 0; i < countObjects; i++) {
			const type: ObjectItem = new ObjectItem()
			type.deserialize(reader)
			this.objects.push(type)
		}
		this.kamas = reader.readVarLong()
	}

	public hydrate(
		data: InventoryContentMessage | Record<string, any>
	): InventoryContentMessage {
		if (data instanceof InventoryContentMessage) {
			return data
		}

		this.objects = data.objects.map(
			(dataElement: ObjectItem | Record<string, any>): ObjectItem => {
				if (dataElement instanceof ObjectItem) {
					return dataElement
				} else {
					return new ObjectItem().hydrate(dataElement)
				}
			}
		)
		this.kamas = data.kamas

		return this
	}
}

export interface RawStorageInventoryContentMessage
	extends RawInventoryContentMessage {
	id: number
}

export class StorageInventoryContentMessage extends InventoryContentMessage {
	public static id = 714

	public constructor(
		objects?: ObjectItem[] | undefined,
		kamas?: number | undefined
	) {
		super(objects, kamas)
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
	}

	public hydrate(
		data: StorageInventoryContentMessage | Record<string, any>
	): StorageInventoryContentMessage {
		if (data instanceof StorageInventoryContentMessage) {
			return data
		}

		super.hydrate(data)

		return this
	}
}

export interface RawExchangeShopStockMultiMovementRemovedMessage {
	id: number
	objectIdList: number[]
}

export class ExchangeShopStockMultiMovementRemovedMessage extends DofusMessage {
	public static id: number = 1200

	public objectIdList: number[] | undefined

	public constructor(objectIdList?: number[] | undefined) {
		super()
		this.objectIdList = objectIdList
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeShort(this.objectIdList!.length)
		this.objectIdList!.forEach((current: number) => writer.writeVarInt(current))
	}

	public deserialize(reader: BinaryReader): void {
		this.objectIdList = []
		const countObjectIdList = reader.readShort()
		for (let i: number = 0; i < countObjectIdList; i++) {
			this.objectIdList.push(reader.readVarInt())
		}
	}

	public hydrate(
		data: ExchangeShopStockMultiMovementRemovedMessage | Record<string, any>
	): ExchangeShopStockMultiMovementRemovedMessage {
		if (data instanceof ExchangeShopStockMultiMovementRemovedMessage) {
			return data
		}

		this.objectIdList = data.objectIdList

		return this
	}
}

export interface RawTaxCollectorAttackedResultMessage {
	id: number
	deadOrAlive: boolean
	basicInfos: TaxCollectorBasicInformations
	guild: BasicGuildInformations
}

export class TaxCollectorAttackedResultMessage extends DofusMessage {
	public static id: number = 1261

	public deadOrAlive: boolean | undefined = false
	public basicInfos: TaxCollectorBasicInformations | undefined
	public guild: BasicGuildInformations | undefined

	public constructor(
		deadOrAlive?: boolean | undefined,
		basicInfos?: TaxCollectorBasicInformations | undefined,
		guild?: BasicGuildInformations | undefined
	) {
		super()
		this.deadOrAlive = deadOrAlive
		this.basicInfos = basicInfos
		this.guild = guild
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeBoolean(this.deadOrAlive!)
		this.basicInfos!.serialize(writer)
		this.guild!.serialize(writer)
	}

	public deserialize(reader: BinaryReader): void {
		this.deadOrAlive = reader.readBoolean()
		this.basicInfos = new TaxCollectorBasicInformations()
		this.basicInfos!.deserialize(reader)
		this.guild = new BasicGuildInformations()
		this.guild!.deserialize(reader)
	}

	public hydrate(
		data: TaxCollectorAttackedResultMessage | Record<string, any>
	): TaxCollectorAttackedResultMessage {
		if (data instanceof TaxCollectorAttackedResultMessage) {
			return data
		}

		this.deadOrAlive = data.deadOrAlive
		this.basicInfos = new TaxCollectorBasicInformations().hydrate(
			data.basicInfos
		)
		this.guild = new BasicGuildInformations().hydrate(data.guild)

		return this
	}
}

export interface RawExchangeObjectRemovedMessage
	extends RawExchangeObjectMessage {
	id: number
	objectUID: number
}

export class ExchangeObjectRemovedMessage extends ExchangeObjectMessage {
	public static id = 5047

	public objectUID: number | undefined = 0

	public constructor(
		remote?: boolean | undefined,
		objectUID?: number | undefined
	) {
		super(remote)
		this.objectUID = objectUID
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeVarInt(this.objectUID!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.objectUID = reader.readVarInt()
	}

	public hydrate(
		data: ExchangeObjectRemovedMessage | Record<string, any>
	): ExchangeObjectRemovedMessage {
		if (data instanceof ExchangeObjectRemovedMessage) {
			return data
		}

		super.hydrate(data)

		this.objectUID = data.objectUID

		return this
	}
}

export interface RawPrismFightAttackerAddMessage {
	id: number
	subAreaId: number
	fightId: number
	attacker: CharacterMinimalPlusLookInformations
}

export class PrismFightAttackerAddMessage extends DofusMessage {
	public static id: number = 1719

	public subAreaId: number | undefined = 0
	public fightId: number | undefined = 0
	public attacker: CharacterMinimalPlusLookInformations | undefined

	public constructor(
		subAreaId?: number | undefined,
		fightId?: number | undefined,
		attacker?: CharacterMinimalPlusLookInformations | undefined
	) {
		super()
		this.subAreaId = subAreaId
		this.fightId = fightId
		this.attacker = attacker
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarShort(this.subAreaId!)
		writer.writeVarShort(this.fightId!)
		writer.writeShort(this.attacker!.id)
		this.attacker!.serialize(writer)
	}

	public deserialize(reader: BinaryReader): void {
		this.subAreaId = reader.readVarShort()
		this.fightId = reader.readVarShort()
		const attackerTypeId: number = reader.readShort()
		this.attacker = new types[
			attackerTypeId
		]() as CharacterMinimalPlusLookInformations
		this.attacker!.deserialize(reader)
	}

	public hydrate(
		data: PrismFightAttackerAddMessage | Record<string, any>
	): PrismFightAttackerAddMessage {
		if (data instanceof PrismFightAttackerAddMessage) {
			return data
		}

		this.subAreaId = data.subAreaId
		this.fightId = data.fightId
		this.attacker = (new types[
			data.attacker.id
		]() as CharacterMinimalPlusLookInformations).hydrate(data.attacker)
		return this
	}
}

export interface RawLivingObjectMessageMessage {
	id: number
	msgId: number
	timeStamp: number
	owner: string
	objectGenericId: number
}

export class LivingObjectMessageMessage extends DofusMessage {
	public static id: number = 7628

	public msgId: number | undefined = 0
	public timeStamp: number | undefined = 0
	public owner: string | undefined
	public objectGenericId: number | undefined = 0

	public constructor(
		msgId?: number | undefined,
		timeStamp?: number | undefined,
		owner?: string | undefined,
		objectGenericId?: number | undefined
	) {
		super()
		this.msgId = msgId
		this.timeStamp = timeStamp
		this.owner = owner
		this.objectGenericId = objectGenericId
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarShort(this.msgId!)
		writer.writeInt(this.timeStamp!)
		writer.writeUTF(this.owner!)
		writer.writeVarShort(this.objectGenericId!)
	}

	public deserialize(reader: BinaryReader): void {
		this.msgId = reader.readVarShort()
		this.timeStamp = reader.readInt()
		this.owner = reader.readUTF()
		this.objectGenericId = reader.readVarShort()
	}

	public hydrate(
		data: LivingObjectMessageMessage | Record<string, any>
	): LivingObjectMessageMessage {
		if (data instanceof LivingObjectMessageMessage) {
			return data
		}

		this.msgId = data.msgId
		this.timeStamp = data.timeStamp
		this.owner = data.owner
		this.objectGenericId = data.objectGenericId

		return this
	}
}

export interface RawPartyInvitationMessage extends RawAbstractPartyMessage {
	id: number
	partyType: number
	partyName: string
	maxParticipants: number
	fromId: number
	fromName: string
	toId: number
}

export class PartyInvitationMessage extends AbstractPartyMessage {
	public static id = 1605

	public partyType: number | undefined = 0
	public partyName: string | undefined
	public maxParticipants: number | undefined = 0
	public fromId: number | undefined = 0
	public fromName: string | undefined
	public toId: number | undefined = 0

	public constructor(
		partyId?: number | undefined,
		partyType?: number | undefined,
		partyName?: string | undefined,
		maxParticipants?: number | undefined,
		fromId?: number | undefined,
		fromName?: string | undefined,
		toId?: number | undefined
	) {
		super(partyId)
		this.partyType = partyType
		this.partyName = partyName
		this.maxParticipants = maxParticipants
		this.fromId = fromId
		this.fromName = fromName
		this.toId = toId
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeByte(this.partyType!)
		writer.writeUTF(this.partyName!)
		writer.writeByte(this.maxParticipants!)
		writer.writeVarLong(this.fromId!)
		writer.writeUTF(this.fromName!)
		writer.writeVarLong(this.toId!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.partyType = reader.readByte()
		this.partyName = reader.readUTF()
		this.maxParticipants = reader.readByte()
		this.fromId = reader.readVarLong()
		this.fromName = reader.readUTF()
		this.toId = reader.readVarLong()
	}

	public hydrate(
		data: PartyInvitationMessage | Record<string, any>
	): PartyInvitationMessage {
		if (data instanceof PartyInvitationMessage) {
			return data
		}

		super.hydrate(data)

		this.partyType = data.partyType
		this.partyName = data.partyName
		this.maxParticipants = data.maxParticipants
		this.fromId = data.fromId
		this.fromName = data.fromName
		this.toId = data.toId

		return this
	}
}

export interface RawTreasureHuntRequestAnswerMessage {
	id: number
	questType: number
	result: number
}

export class TreasureHuntRequestAnswerMessage extends DofusMessage {
	public static id: number = 5673

	public questType: number | undefined = 0
	public result: number | undefined = 0

	public constructor(
		questType?: number | undefined,
		result?: number | undefined
	) {
		super()
		this.questType = questType
		this.result = result
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeByte(this.questType!)
		writer.writeByte(this.result!)
	}

	public deserialize(reader: BinaryReader): void {
		this.questType = reader.readByte()
		this.result = reader.readByte()
	}

	public hydrate(
		data: TreasureHuntRequestAnswerMessage | Record<string, any>
	): TreasureHuntRequestAnswerMessage {
		if (data instanceof TreasureHuntRequestAnswerMessage) {
			return data
		}

		this.questType = data.questType
		this.result = data.result

		return this
	}
}

export interface RawCharacterLoadingCompleteMessage {
	id: number
}

export class CharacterLoadingCompleteMessage extends DofusMessage {
	public static id: number = 7308

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public serialize(writer: BinaryWriter): void {}

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public deserialize(reader: BinaryReader): void {}

	public hydrate(
		data: CharacterLoadingCompleteMessage | Record<string, any>
	): CharacterLoadingCompleteMessage {
		if (data instanceof CharacterLoadingCompleteMessage) {
			return data
		}

		return this
	}
}

export interface RawTreasureHuntFlagRequestAnswerMessage {
	id: number
	questType: number
	result: number
	index: number
}

export class TreasureHuntFlagRequestAnswerMessage extends DofusMessage {
	public static id: number = 4075

	public questType: number | undefined = 0
	public result: number | undefined = 0
	public index: number | undefined = 0

	public constructor(
		questType?: number | undefined,
		result?: number | undefined,
		index?: number | undefined
	) {
		super()
		this.questType = questType
		this.result = result
		this.index = index
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeByte(this.questType!)
		writer.writeByte(this.result!)
		writer.writeByte(this.index!)
	}

	public deserialize(reader: BinaryReader): void {
		this.questType = reader.readByte()
		this.result = reader.readByte()
		this.index = reader.readByte()
	}

	public hydrate(
		data: TreasureHuntFlagRequestAnswerMessage | Record<string, any>
	): TreasureHuntFlagRequestAnswerMessage {
		if (data instanceof TreasureHuntFlagRequestAnswerMessage) {
			return data
		}

		this.questType = data.questType
		this.result = data.result
		this.index = data.index

		return this
	}
}

export interface RawExchangeIsReadyMessage {
	id: number
	id_: number
	ready: boolean
}

export class ExchangeIsReadyMessage extends DofusMessage {
	public static id: number = 8789

	public id_: number | undefined = 0
	public ready: boolean | undefined = false

	public constructor(id_?: number | undefined, ready?: boolean | undefined) {
		super()
		this.id_ = id_
		this.ready = ready
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeDouble(this.id_!)
		writer.writeBoolean(this.ready!)
	}

	public deserialize(reader: BinaryReader): void {
		this.id_ = reader.readDouble()
		this.ready = reader.readBoolean()
	}

	public hydrate(
		data: ExchangeIsReadyMessage | Record<string, any>
	): ExchangeIsReadyMessage {
		if (data instanceof ExchangeIsReadyMessage) {
			return data
		}

		this.id_ = data.id_
		this.ready = data.ready

		return this
	}
}

export interface RawAllianceFactsErrorMessage {
	id: number
	allianceId: number
}

export class AllianceFactsErrorMessage extends DofusMessage {
	public static id: number = 9299

	public allianceId: number | undefined = 0

	public constructor(allianceId?: number | undefined) {
		super()
		this.allianceId = allianceId
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarInt(this.allianceId!)
	}

	public deserialize(reader: BinaryReader): void {
		this.allianceId = reader.readVarInt()
	}

	public hydrate(
		data: AllianceFactsErrorMessage | Record<string, any>
	): AllianceFactsErrorMessage {
		if (data instanceof AllianceFactsErrorMessage) {
			return data
		}

		this.allianceId = data.allianceId

		return this
	}
}

export interface RawInteractiveUseEndedMessage {
	id: number
	elemId: number
	skillId: number
}

export class InteractiveUseEndedMessage extends DofusMessage {
	public static id: number = 5647

	public elemId: number | undefined = 0
	public skillId: number | undefined = 0

	public constructor(
		elemId?: number | undefined,
		skillId?: number | undefined
	) {
		super()
		this.elemId = elemId
		this.skillId = skillId
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarInt(this.elemId!)
		writer.writeVarShort(this.skillId!)
	}

	public deserialize(reader: BinaryReader): void {
		this.elemId = reader.readVarInt()
		this.skillId = reader.readVarShort()
	}

	public hydrate(
		data: InteractiveUseEndedMessage | Record<string, any>
	): InteractiveUseEndedMessage {
		if (data instanceof InteractiveUseEndedMessage) {
			return data
		}

		this.elemId = data.elemId
		this.skillId = data.skillId

		return this
	}
}

export interface RawAllianceInvitedMessage {
	id: number
	recruterId: number
	recruterName: string
	allianceInfo: BasicNamedAllianceInformations
}

export class AllianceInvitedMessage extends DofusMessage {
	public static id: number = 3392

	public recruterId: number | undefined = 0
	public recruterName: string | undefined
	public allianceInfo: BasicNamedAllianceInformations | undefined

	public constructor(
		recruterId?: number | undefined,
		recruterName?: string | undefined,
		allianceInfo?: BasicNamedAllianceInformations | undefined
	) {
		super()
		this.recruterId = recruterId
		this.recruterName = recruterName
		this.allianceInfo = allianceInfo
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarLong(this.recruterId!)
		writer.writeUTF(this.recruterName!)
		this.allianceInfo!.serialize(writer)
	}

	public deserialize(reader: BinaryReader): void {
		this.recruterId = reader.readVarLong()
		this.recruterName = reader.readUTF()
		this.allianceInfo = new BasicNamedAllianceInformations()
		this.allianceInfo!.deserialize(reader)
	}

	public hydrate(
		data: AllianceInvitedMessage | Record<string, any>
	): AllianceInvitedMessage {
		if (data instanceof AllianceInvitedMessage) {
			return data
		}

		this.recruterId = data.recruterId
		this.recruterName = data.recruterName
		this.allianceInfo = new BasicNamedAllianceInformations().hydrate(
			data.allianceInfo
		)

		return this
	}
}

export interface RawExchangeStartOkCraftMessage {
	id: number
}

export class ExchangeStartOkCraftMessage extends DofusMessage {
	public static id: number = 7527

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public serialize(writer: BinaryWriter): void {}

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public deserialize(reader: BinaryReader): void {}

	public hydrate(
		data: ExchangeStartOkCraftMessage | Record<string, any>
	): ExchangeStartOkCraftMessage {
		if (data instanceof ExchangeStartOkCraftMessage) {
			return data
		}

		return this
	}
}

export interface RawPartyLocateMembersMessage extends RawAbstractPartyMessage {
	id: number
	geopositions: PartyMemberGeoPosition[]
}

export class PartyLocateMembersMessage extends AbstractPartyMessage {
	public static id = 7607

	public geopositions: PartyMemberGeoPosition[] | undefined

	public constructor(
		partyId?: number | undefined,
		geopositions?: PartyMemberGeoPosition[] | undefined
	) {
		super(partyId)
		this.geopositions = geopositions
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeShort(this.geopositions!.length)
		this.geopositions!.forEach((current) => {
			current.serialize(writer)
		})
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.geopositions = []
		const countGeopositions = reader.readShort()
		for (let i: number = 0; i < countGeopositions; i++) {
			const type: PartyMemberGeoPosition = new PartyMemberGeoPosition()
			type.deserialize(reader)
			this.geopositions.push(type)
		}
	}

	public hydrate(
		data: PartyLocateMembersMessage | Record<string, any>
	): PartyLocateMembersMessage {
		if (data instanceof PartyLocateMembersMessage) {
			return data
		}

		super.hydrate(data)

		this.geopositions = data.geopositions.map(
			(
				dataElement: PartyMemberGeoPosition | Record<string, any>
			): PartyMemberGeoPosition => {
				if (dataElement instanceof PartyMemberGeoPosition) {
					return dataElement
				} else {
					return new PartyMemberGeoPosition().hydrate(dataElement)
				}
			}
		)

		return this
	}
}

export interface RawObjectsDeletedMessage {
	id: number
	objectUID: number[]
}

export class ObjectsDeletedMessage extends DofusMessage {
	public static id: number = 2210

	public objectUID: number[] | undefined

	public constructor(objectUID?: number[] | undefined) {
		super()
		this.objectUID = objectUID
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeShort(this.objectUID!.length)
		this.objectUID!.forEach((current: number) => writer.writeVarInt(current))
	}

	public deserialize(reader: BinaryReader): void {
		this.objectUID = []
		const countObjectUID = reader.readShort()
		for (let i: number = 0; i < countObjectUID; i++) {
			this.objectUID.push(reader.readVarInt())
		}
	}

	public hydrate(
		data: ObjectsDeletedMessage | Record<string, any>
	): ObjectsDeletedMessage {
		if (data instanceof ObjectsDeletedMessage) {
			return data
		}

		this.objectUID = data.objectUID

		return this
	}
}

export interface RawPaddockPropertiesMessage {
	id: number
	properties: PaddockInstancesInformations
}

export class PaddockPropertiesMessage extends DofusMessage {
	public static id: number = 2259

	public properties: PaddockInstancesInformations | undefined

	public constructor(properties?: PaddockInstancesInformations | undefined) {
		super()
		this.properties = properties
	}

	public serialize(writer: BinaryWriter): void {
		this.properties!.serialize(writer)
	}

	public deserialize(reader: BinaryReader): void {
		this.properties = new PaddockInstancesInformations()
		this.properties!.deserialize(reader)
	}

	public hydrate(
		data: PaddockPropertiesMessage | Record<string, any>
	): PaddockPropertiesMessage {
		if (data instanceof PaddockPropertiesMessage) {
			return data
		}

		this.properties = new PaddockInstancesInformations().hydrate(
			data.properties
		)

		return this
	}
}

export interface RawGameContextRemoveMultipleElementsWithEventsMessage
	extends RawGameContextRemoveMultipleElementsMessage {
	id: number
	elementEventIds: number[]
}

export class GameContextRemoveMultipleElementsWithEventsMessage extends GameContextRemoveMultipleElementsMessage {
	public static id = 9998

	public elementEventIds: number[] | undefined

	public constructor(
		elementsIds?: number[] | undefined,
		elementEventIds?: number[] | undefined
	) {
		super(elementsIds)
		this.elementEventIds = elementEventIds
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeShort(this.elementEventIds!.length)
		this.elementEventIds!.forEach((current: number) =>
			writer.writeByte(current)
		)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.elementEventIds = []
		const countElementEventIds = reader.readShort()
		for (let i: number = 0; i < countElementEventIds; i++) {
			this.elementEventIds.push(reader.readByte())
		}
	}

	public hydrate(
		data:
			| GameContextRemoveMultipleElementsWithEventsMessage
			| Record<string, any>
	): GameContextRemoveMultipleElementsWithEventsMessage {
		if (data instanceof GameContextRemoveMultipleElementsWithEventsMessage) {
			return data
		}

		super.hydrate(data)

		this.elementEventIds = data.elementEventIds

		return this
	}
}

export interface RawExchangeStartOkMulticraftCustomerMessage {
	id: number
	skillId: number
	crafterJobLevel: number
}

export class ExchangeStartOkMulticraftCustomerMessage extends DofusMessage {
	public static id: number = 5660

	public skillId: number | undefined = 0
	public crafterJobLevel: number | undefined = 0

	public constructor(
		skillId?: number | undefined,
		crafterJobLevel?: number | undefined
	) {
		super()
		this.skillId = skillId
		this.crafterJobLevel = crafterJobLevel
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarInt(this.skillId!)
		writer.writeByte(this.crafterJobLevel!)
	}

	public deserialize(reader: BinaryReader): void {
		this.skillId = reader.readVarInt()
		this.crafterJobLevel = reader.readByte()
	}

	public hydrate(
		data: ExchangeStartOkMulticraftCustomerMessage | Record<string, any>
	): ExchangeStartOkMulticraftCustomerMessage {
		if (data instanceof ExchangeStartOkMulticraftCustomerMessage) {
			return data
		}

		this.skillId = data.skillId
		this.crafterJobLevel = data.crafterJobLevel

		return this
	}
}

export interface RawSocialNoticeSetErrorMessage {
	id: number
	reason: number
}

export class SocialNoticeSetErrorMessage extends DofusMessage {
	public static id: number = 9965

	public reason: number | undefined = 0

	public constructor(reason?: number | undefined) {
		super()
		this.reason = reason
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeByte(this.reason!)
	}

	public deserialize(reader: BinaryReader): void {
		this.reason = reader.readByte()
	}

	public hydrate(
		data: SocialNoticeSetErrorMessage | Record<string, any>
	): SocialNoticeSetErrorMessage {
		if (data instanceof SocialNoticeSetErrorMessage) {
			return data
		}

		this.reason = data.reason

		return this
	}
}

export interface RawGuildBulletinSetErrorMessage
	extends RawSocialNoticeSetErrorMessage {
	id: number
}

export class GuildBulletinSetErrorMessage extends SocialNoticeSetErrorMessage {
	public static id = 7608

	public constructor(reason?: number | undefined) {
		super(reason)
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
	}

	public hydrate(
		data: GuildBulletinSetErrorMessage | Record<string, any>
	): GuildBulletinSetErrorMessage {
		if (data instanceof GuildBulletinSetErrorMessage) {
			return data
		}

		super.hydrate(data)

		return this
	}
}

export interface RawAccessoryPreviewMessage {
	id: number
	look: EntityLook
}

export class AccessoryPreviewMessage extends DofusMessage {
	public static id: number = 1972

	public look: EntityLook | undefined

	public constructor(look?: EntityLook | undefined) {
		super()
		this.look = look
	}

	public serialize(writer: BinaryWriter): void {
		this.look!.serialize(writer)
	}

	public deserialize(reader: BinaryReader): void {
		this.look = new EntityLook()
		this.look!.deserialize(reader)
	}

	public hydrate(
		data: AccessoryPreviewMessage | Record<string, any>
	): AccessoryPreviewMessage {
		if (data instanceof AccessoryPreviewMessage) {
			return data
		}

		this.look = new EntityLook().hydrate(data.look)

		return this
	}
}

export interface RawExchangeStartOkNpcShopMessage {
	id: number
	npcSellerId: number
	tokenId: number
	objectsInfos: ObjectItemToSellInNpcShop[]
}

export class ExchangeStartOkNpcShopMessage extends DofusMessage {
	public static id: number = 6110

	public npcSellerId: number | undefined = 0
	public tokenId: number | undefined = 0
	public objectsInfos: ObjectItemToSellInNpcShop[] | undefined

	public constructor(
		npcSellerId?: number | undefined,
		tokenId?: number | undefined,
		objectsInfos?: ObjectItemToSellInNpcShop[] | undefined
	) {
		super()
		this.npcSellerId = npcSellerId
		this.tokenId = tokenId
		this.objectsInfos = objectsInfos
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeDouble(this.npcSellerId!)
		writer.writeVarShort(this.tokenId!)
		writer.writeShort(this.objectsInfos!.length)
		this.objectsInfos!.forEach((current) => {
			current.serialize(writer)
		})
	}

	public deserialize(reader: BinaryReader): void {
		this.npcSellerId = reader.readDouble()
		this.tokenId = reader.readVarShort()
		this.objectsInfos = []
		const countObjectsInfos = reader.readShort()
		for (let i: number = 0; i < countObjectsInfos; i++) {
			const type: ObjectItemToSellInNpcShop = new ObjectItemToSellInNpcShop()
			type.deserialize(reader)
			this.objectsInfos.push(type)
		}
	}

	public hydrate(
		data: ExchangeStartOkNpcShopMessage | Record<string, any>
	): ExchangeStartOkNpcShopMessage {
		if (data instanceof ExchangeStartOkNpcShopMessage) {
			return data
		}

		this.npcSellerId = data.npcSellerId
		this.tokenId = data.tokenId
		this.objectsInfos = data.objectsInfos.map(
			(
				dataElement: ObjectItemToSellInNpcShop | Record<string, any>
			): ObjectItemToSellInNpcShop => {
				if (dataElement instanceof ObjectItemToSellInNpcShop) {
					return dataElement
				} else {
					return new ObjectItemToSellInNpcShop().hydrate(dataElement)
				}
			}
		)

		return this
	}
}

export interface RawPartyUpdateMessage extends RawAbstractPartyEventMessage {
	id: number
	memberInformations: PartyMemberInformations
}

export class PartyUpdateMessage extends AbstractPartyEventMessage {
	public static id = 5568

	public memberInformations: PartyMemberInformations | undefined

	public constructor(
		partyId?: number | undefined,
		memberInformations?: PartyMemberInformations | undefined
	) {
		super(partyId)
		this.memberInformations = memberInformations
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeShort(this.memberInformations!.id)
		this.memberInformations!.serialize(writer)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		const memberInformationsTypeId: number = reader.readShort()
		this.memberInformations = new types[
			memberInformationsTypeId
		]() as PartyMemberInformations
		this.memberInformations!.deserialize(reader)
	}

	public hydrate(
		data: PartyUpdateMessage | Record<string, any>
	): PartyUpdateMessage {
		if (data instanceof PartyUpdateMessage) {
			return data
		}

		super.hydrate(data)

		this.memberInformations = (new types[
			data.memberInformations.id
		]() as PartyMemberInformations).hydrate(data.memberInformations)
		return this
	}
}

export interface RawPartyNewMemberMessage extends RawPartyUpdateMessage {
	id: number
}

export class PartyNewMemberMessage extends PartyUpdateMessage {
	public static id = 2422

	public constructor(
		partyId?: number | undefined,
		memberInformations?: PartyMemberInformations | undefined
	) {
		super(partyId, memberInformations)
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
	}

	public hydrate(
		data: PartyNewMemberMessage | Record<string, any>
	): PartyNewMemberMessage {
		if (data instanceof PartyNewMemberMessage) {
			return data
		}

		super.hydrate(data)

		return this
	}
}

export interface RawInviteInHavenBagMessage {
	id: number
	guestInformations: CharacterMinimalInformations
	accept: boolean
}

export class InviteInHavenBagMessage extends DofusMessage {
	public static id: number = 5627

	public guestInformations: CharacterMinimalInformations | undefined
	public accept: boolean | undefined = false

	public constructor(
		guestInformations?: CharacterMinimalInformations | undefined,
		accept?: boolean | undefined
	) {
		super()
		this.guestInformations = guestInformations
		this.accept = accept
	}

	public serialize(writer: BinaryWriter): void {
		this.guestInformations!.serialize(writer)
		writer.writeBoolean(this.accept!)
	}

	public deserialize(reader: BinaryReader): void {
		this.guestInformations = new CharacterMinimalInformations()
		this.guestInformations!.deserialize(reader)
		this.accept = reader.readBoolean()
	}

	public hydrate(
		data: InviteInHavenBagMessage | Record<string, any>
	): InviteInHavenBagMessage {
		if (data instanceof InviteInHavenBagMessage) {
			return data
		}

		this.guestInformations = new CharacterMinimalInformations().hydrate(
			data.guestInformations
		)
		this.accept = data.accept

		return this
	}
}

export interface RawAllianceInvitationStateRecruterMessage {
	id: number
	recrutedName: string
	invitationState: number
}

export class AllianceInvitationStateRecruterMessage extends DofusMessage {
	public static id: number = 3584

	public recrutedName: string | undefined
	public invitationState: number | undefined = 0

	public constructor(
		recrutedName?: string | undefined,
		invitationState?: number | undefined
	) {
		super()
		this.recrutedName = recrutedName
		this.invitationState = invitationState
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeUTF(this.recrutedName!)
		writer.writeByte(this.invitationState!)
	}

	public deserialize(reader: BinaryReader): void {
		this.recrutedName = reader.readUTF()
		this.invitationState = reader.readByte()
	}

	public hydrate(
		data: AllianceInvitationStateRecruterMessage | Record<string, any>
	): AllianceInvitationStateRecruterMessage {
		if (data instanceof AllianceInvitationStateRecruterMessage) {
			return data
		}

		this.recrutedName = data.recrutedName
		this.invitationState = data.invitationState

		return this
	}
}

export interface RawExchangeCrafterJobLevelupMessage {
	id: number
	crafterJobLevel: number
}

export class ExchangeCrafterJobLevelupMessage extends DofusMessage {
	public static id: number = 6788

	public crafterJobLevel: number | undefined = 0

	public constructor(crafterJobLevel?: number | undefined) {
		super()
		this.crafterJobLevel = crafterJobLevel
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeByte(this.crafterJobLevel!)
	}

	public deserialize(reader: BinaryReader): void {
		this.crafterJobLevel = reader.readByte()
	}

	public hydrate(
		data: ExchangeCrafterJobLevelupMessage | Record<string, any>
	): ExchangeCrafterJobLevelupMessage {
		if (data instanceof ExchangeCrafterJobLevelupMessage) {
			return data
		}

		this.crafterJobLevel = data.crafterJobLevel

		return this
	}
}

export interface RawIgnoredAddFailureMessage {
	id: number
	reason: number
}

export class IgnoredAddFailureMessage extends DofusMessage {
	public static id: number = 3617

	public reason: number | undefined = 0

	public constructor(reason?: number | undefined) {
		super()
		this.reason = reason
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeByte(this.reason!)
	}

	public deserialize(reader: BinaryReader): void {
		this.reason = reader.readByte()
	}

	public hydrate(
		data: IgnoredAddFailureMessage | Record<string, any>
	): IgnoredAddFailureMessage {
		if (data instanceof IgnoredAddFailureMessage) {
			return data
		}

		this.reason = data.reason

		return this
	}
}

export interface RawExchangeStartedBidSellerMessage {
	id: number
	sellerDescriptor: SellerBuyerDescriptor
	objectsInfos: ObjectItemToSellInBid[]
}

export class ExchangeStartedBidSellerMessage extends DofusMessage {
	public static id: number = 1385

	public sellerDescriptor: SellerBuyerDescriptor | undefined
	public objectsInfos: ObjectItemToSellInBid[] | undefined

	public constructor(
		sellerDescriptor?: SellerBuyerDescriptor | undefined,
		objectsInfos?: ObjectItemToSellInBid[] | undefined
	) {
		super()
		this.sellerDescriptor = sellerDescriptor
		this.objectsInfos = objectsInfos
	}

	public serialize(writer: BinaryWriter): void {
		this.sellerDescriptor!.serialize(writer)
		writer.writeShort(this.objectsInfos!.length)
		this.objectsInfos!.forEach((current) => {
			current.serialize(writer)
		})
	}

	public deserialize(reader: BinaryReader): void {
		this.sellerDescriptor = new SellerBuyerDescriptor()
		this.sellerDescriptor!.deserialize(reader)
		this.objectsInfos = []
		const countObjectsInfos = reader.readShort()
		for (let i: number = 0; i < countObjectsInfos; i++) {
			const type: ObjectItemToSellInBid = new ObjectItemToSellInBid()
			type.deserialize(reader)
			this.objectsInfos.push(type)
		}
	}

	public hydrate(
		data: ExchangeStartedBidSellerMessage | Record<string, any>
	): ExchangeStartedBidSellerMessage {
		if (data instanceof ExchangeStartedBidSellerMessage) {
			return data
		}

		this.sellerDescriptor = new SellerBuyerDescriptor().hydrate(
			data.sellerDescriptor
		)
		this.objectsInfos = data.objectsInfos.map(
			(
				dataElement: ObjectItemToSellInBid | Record<string, any>
			): ObjectItemToSellInBid => {
				if (dataElement instanceof ObjectItemToSellInBid) {
					return dataElement
				} else {
					return new ObjectItemToSellInBid().hydrate(dataElement)
				}
			}
		)

		return this
	}
}

export interface RawEmotePlayMassiveMessage
	extends RawEmotePlayAbstractMessage {
	id: number
	actorIds: number[]
}

export class EmotePlayMassiveMessage extends EmotePlayAbstractMessage {
	public static id = 2881

	public actorIds: number[] | undefined

	public constructor(
		emoteId?: number | undefined,
		emoteStartTime?: number | undefined,
		actorIds?: number[] | undefined
	) {
		super(emoteId, emoteStartTime)
		this.actorIds = actorIds
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeShort(this.actorIds!.length)
		this.actorIds!.forEach((current: number) => writer.writeDouble(current))
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.actorIds = []
		const countActorIds = reader.readShort()
		for (let i: number = 0; i < countActorIds; i++) {
			this.actorIds.push(reader.readDouble())
		}
	}

	public hydrate(
		data: EmotePlayMassiveMessage | Record<string, any>
	): EmotePlayMassiveMessage {
		if (data instanceof EmotePlayMassiveMessage) {
			return data
		}

		super.hydrate(data)

		this.actorIds = data.actorIds

		return this
	}
}

export interface RawHaapiValidationMessage {
	id: number
	action: number
	code: number
}

export class HaapiValidationMessage extends DofusMessage {
	public static id: number = 8381

	public action: number | undefined = 0
	public code: number | undefined = 0

	public constructor(action?: number | undefined, code?: number | undefined) {
		super()
		this.action = action
		this.code = code
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeByte(this.action!)
		writer.writeByte(this.code!)
	}

	public deserialize(reader: BinaryReader): void {
		this.action = reader.readByte()
		this.code = reader.readByte()
	}

	public hydrate(
		data: HaapiValidationMessage | Record<string, any>
	): HaapiValidationMessage {
		if (data instanceof HaapiValidationMessage) {
			return data
		}

		this.action = data.action
		this.code = data.code

		return this
	}
}

export interface RawIgnoredDeleteResultMessage {
	id: number
	success: boolean
	session: boolean
	name: string
}

export class IgnoredDeleteResultMessage extends DofusMessage {
	public static id: number = 4091

	public success: boolean | undefined = false
	public session: boolean | undefined = false
	public name: string | undefined

	public constructor(
		success?: boolean | undefined,
		session?: boolean | undefined,
		name?: string | undefined
	) {
		super()
		this.success = success
		this.session = session
		this.name = name
	}

	public serialize(writer: BinaryWriter): void {
		let box0: number = 0
		box0 = setFlag(box0, 0, this.success!)
		box0 = setFlag(box0, 1, this.session!)
		writer.writeByte(box0)
		writer.writeUTF(this.name!)
	}

	public deserialize(reader: BinaryReader): void {
		const box0 = reader.readByte()
		this.success = getFlag(box0, 0)
		this.session = getFlag(box0, 1)
		this.name = reader.readUTF()
	}

	public hydrate(
		data: IgnoredDeleteResultMessage | Record<string, any>
	): IgnoredDeleteResultMessage {
		if (data instanceof IgnoredDeleteResultMessage) {
			return data
		}

		this.success = data.success
		this.session = data.session
		this.name = data.name

		return this
	}
}

export interface RawCompassUpdatePartyMemberMessage
	extends RawCompassUpdateMessage {
	id: number
	memberId: number
	active: boolean
}

export class CompassUpdatePartyMemberMessage extends CompassUpdateMessage {
	public static id = 5594

	public memberId: number | undefined = 0
	public active: boolean | undefined = false

	public constructor(
		type?: number | undefined,
		coords?: MapCoordinates | undefined,
		memberId?: number | undefined,
		active?: boolean | undefined
	) {
		super(type, coords)
		this.memberId = memberId
		this.active = active
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeVarLong(this.memberId!)
		writer.writeBoolean(this.active!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.memberId = reader.readVarLong()
		this.active = reader.readBoolean()
	}

	public hydrate(
		data: CompassUpdatePartyMemberMessage | Record<string, any>
	): CompassUpdatePartyMemberMessage {
		if (data instanceof CompassUpdatePartyMemberMessage) {
			return data
		}

		super.hydrate(data)

		this.memberId = data.memberId
		this.active = data.active

		return this
	}
}

export interface RawExchangeObjectPutInBagMessage
	extends RawExchangeObjectMessage {
	id: number
	object_: ObjectItem
}

export class ExchangeObjectPutInBagMessage extends ExchangeObjectMessage {
	public static id = 8650

	public object_: ObjectItem | undefined

	public constructor(
		remote?: boolean | undefined,
		object_?: ObjectItem | undefined
	) {
		super(remote)
		this.object_ = object_
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		this.object_!.serialize(writer)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.object_ = new ObjectItem()
		this.object_!.deserialize(reader)
	}

	public hydrate(
		data: ExchangeObjectPutInBagMessage | Record<string, any>
	): ExchangeObjectPutInBagMessage {
		if (data instanceof ExchangeObjectPutInBagMessage) {
			return data
		}

		super.hydrate(data)

		this.object_ = new ObjectItem().hydrate(data.object_)

		return this
	}
}

export interface RawGuildFightPlayersEnemiesListMessage {
	id: number
	fightId: number
	playerInfo: CharacterMinimalPlusLookInformations[]
}

export class GuildFightPlayersEnemiesListMessage extends DofusMessage {
	public static id: number = 2079

	public fightId: number | undefined = 0
	public playerInfo: CharacterMinimalPlusLookInformations[] | undefined

	public constructor(
		fightId?: number | undefined,
		playerInfo?: CharacterMinimalPlusLookInformations[] | undefined
	) {
		super()
		this.fightId = fightId
		this.playerInfo = playerInfo
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeDouble(this.fightId!)
		writer.writeShort(this.playerInfo!.length)
		this.playerInfo!.forEach((current) => {
			current.serialize(writer)
		})
	}

	public deserialize(reader: BinaryReader): void {
		this.fightId = reader.readDouble()
		this.playerInfo = []
		const countPlayerInfo = reader.readShort()
		for (let i: number = 0; i < countPlayerInfo; i++) {
			const type: CharacterMinimalPlusLookInformations = new CharacterMinimalPlusLookInformations()
			type.deserialize(reader)
			this.playerInfo.push(type)
		}
	}

	public hydrate(
		data: GuildFightPlayersEnemiesListMessage | Record<string, any>
	): GuildFightPlayersEnemiesListMessage {
		if (data instanceof GuildFightPlayersEnemiesListMessage) {
			return data
		}

		this.fightId = data.fightId
		this.playerInfo = data.playerInfo.map(
			(
				dataElement: CharacterMinimalPlusLookInformations | Record<string, any>
			): CharacterMinimalPlusLookInformations => {
				if (dataElement instanceof CharacterMinimalPlusLookInformations) {
					return dataElement
				} else {
					return new CharacterMinimalPlusLookInformations().hydrate(dataElement)
				}
			}
		)

		return this
	}
}

export class AllianceRanksRequestMessage extends DofusMessage {
	public static id = 8627

	constructor() {
		super()
	}

	public serialize(writer: BinaryWriter): void {}

	public deserialize(reader: BinaryReader): void {}
}

export class AllianceRanksMessage extends DofusMessage {
	public static id = 9967

	public ranks: RankInformation[] | undefined

	constructor(ranks?: RankInformation[]) {
		super()
		this.ranks = ranks
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeShort(this.ranks!.length)
		this.ranks!.forEach((current) => {
			current.serialize(writer)
		})
	}

	public deserialize(reader: BinaryReader): void {
		this.ranks = []
		const countRanks = reader.readShort()
		for (let i: number = 0; i < countRanks; i++) {
			const type: RankInformation = new RankInformation()
			type.deserialize(reader)
			this.ranks.push(type)
		}
	}
}

export class RankMinimalInformation extends DofusMessage {
	public static id: number = 6102

	public _id: number | undefined = 0

	public name: string | undefined = ""

	constructor(id?: number, name?: string) {
		super()
		;(this._id = id), (this.name = name)
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarInt(this.id!)
		writer.writeUTF(this.name!)
	}

	public deserialize(reader: BinaryReader): void {
		this._id = reader.readVarUInt()
		this.name = reader.readUTF()
	}
}

export class RankInformation extends RankMinimalInformation {
	public static id: number = 15

	public order: number | undefined = 0

	public gfxId: number | undefined = 0

	public modifiable: boolean | undefined = false

	public rights: number[] | undefined

	constructor(
		id?: number,
		name?: string,
		order?: number,
		gfxId?: number,
		modifiable?: boolean,
		rights?: number[]
	) {
		super(id, name)
		this.order = order
		this.gfxId = gfxId
		this.modifiable = modifiable
		this.rights = rights
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeVarInt(this.order!)
		writer.writeVarInt(this.gfxId!)
		writer.writeBoolean(this.modifiable!)
		writer.writeShort(this.rights!.length)
		this.rights!.forEach((current) => {
			writer.writeVarInt(current)
		})
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.order = reader.readVarUInt()
		this.gfxId = reader.readVarUInt()
		this.modifiable = reader.readBoolean()
		this.rights = []
		const countRights = reader.readShort()
		for (let i: number = 0; i < countRights; i++) {
			const val = reader.readVarUInt()
			this.rights.push(val)
		}
	}
}

export interface RawGameCautiousMapMovementMessage
	extends RawGameMapMovementMessage {
	id: number
}

export class GameCautiousMapMovementMessage extends GameMapMovementMessage {
	public static id = 3954

	public constructor(
		keyMovements?: number[] | undefined,
		forcedDirection?: number | undefined,
		actorId?: number | undefined
	) {
		super(keyMovements, forcedDirection, actorId)
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
	}

	public hydrate(
		data: GameCautiousMapMovementMessage | Record<string, any>
	): GameCautiousMapMovementMessage {
		if (data instanceof GameCautiousMapMovementMessage) {
			return data
		}

		super.hydrate(data)

		return this
	}
}

export interface RawAchievementFinishedMessage {
	id: number
	achievement: AchievementAchievedRewardable
}

export class AchievementFinishedMessage extends DofusMessage {
	public static id: number = 9364

	public achievement: AchievementAchievedRewardable | undefined

	public constructor(achievement?: AchievementAchievedRewardable | undefined) {
		super()
		this.achievement = achievement
	}

	public serialize(writer: BinaryWriter): void {
		this.achievement!.serialize(writer)
	}

	public deserialize(reader: BinaryReader): void {
		this.achievement = new AchievementAchievedRewardable()
		this.achievement!.deserialize(reader)
	}

	public hydrate(
		data: AchievementFinishedMessage | Record<string, any>
	): AchievementFinishedMessage {
		if (data instanceof AchievementFinishedMessage) {
			return data
		}

		this.achievement = new AchievementAchievedRewardable().hydrate(
			data.achievement
		)

		return this
	}
}

export interface RawAchievementFinishedInformationMessage
	extends RawAchievementFinishedMessage {
	id: number
	name: string
	playerId: number
}

export class AchievementFinishedInformationMessage extends AchievementFinishedMessage {
	public static id = 1659

	public name: string | undefined
	public playerId: number | undefined = 0

	public constructor(
		achievement?: AchievementAchievedRewardable | undefined,
		name?: string | undefined,
		playerId?: number | undefined
	) {
		super(achievement)
		this.name = name
		this.playerId = playerId
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeUTF(this.name!)
		writer.writeVarLong(this.playerId!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.name = reader.readUTF()
		this.playerId = reader.readVarLong()
	}

	public hydrate(
		data: AchievementFinishedInformationMessage | Record<string, any>
	): AchievementFinishedInformationMessage {
		if (data instanceof AchievementFinishedInformationMessage) {
			return data
		}

		super.hydrate(data)

		this.name = data.name
		this.playerId = data.playerId

		return this
	}
}

export interface RawEntityTalkMessage {
	id: number
	entityId: number
	textId: number
	parameters: string[]
}

export class EntityTalkMessage extends DofusMessage {
	public static id: number = 6863

	public entityId: number | undefined = 0
	public textId: number | undefined = 0
	public parameters: string[] | undefined

	public constructor(
		entityId?: number | undefined,
		textId?: number | undefined,
		parameters?: string[] | undefined
	) {
		super()
		this.entityId = entityId
		this.textId = textId
		this.parameters = parameters
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeDouble(this.entityId!)
		writer.writeVarShort(this.textId!)
		writer.writeShort(this.parameters!.length)
		this.parameters!.forEach((current: string) => writer.writeUTF(current))
	}

	public deserialize(reader: BinaryReader): void {
		this.entityId = reader.readDouble()
		this.textId = reader.readVarShort()
		this.parameters = []
		const countParameters = reader.readShort()
		for (let i: number = 0; i < countParameters; i++) {
			this.parameters.push(reader.readUTF())
		}
	}

	public hydrate(
		data: EntityTalkMessage | Record<string, any>
	): EntityTalkMessage {
		if (data instanceof EntityTalkMessage) {
			return data
		}

		this.entityId = data.entityId
		this.textId = data.textId
		this.parameters = data.parameters

		return this
	}
}

export interface RawLockableStateUpdateAbstractMessage {
	id: number
	locked: boolean
}

export class LockableStateUpdateAbstractMessage extends DofusMessage {
	public static id: number = 4109

	public locked: boolean | undefined = false

	public constructor(locked?: boolean | undefined) {
		super()
		this.locked = locked
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeBoolean(this.locked!)
	}

	public deserialize(reader: BinaryReader): void {
		this.locked = reader.readBoolean()
	}

	public hydrate(
		data: LockableStateUpdateAbstractMessage | Record<string, any>
	): LockableStateUpdateAbstractMessage {
		if (data instanceof LockableStateUpdateAbstractMessage) {
			return data
		}

		this.locked = data.locked

		return this
	}
}

export interface RawLockableStateUpdateStorageMessage
	extends RawLockableStateUpdateAbstractMessage {
	id: number
	mapId: number
	elementId: number
}

export class LockableStateUpdateStorageMessage extends LockableStateUpdateAbstractMessage {
	public static id = 6717

	public mapId: number | undefined = 0
	public elementId: number | undefined = 0

	public constructor(
		locked?: boolean | undefined,
		mapId?: number | undefined,
		elementId?: number | undefined
	) {
		super(locked)
		this.mapId = mapId
		this.elementId = elementId
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeDouble(this.mapId!)
		writer.writeVarInt(this.elementId!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.mapId = reader.readDouble()
		this.elementId = reader.readVarInt()
	}

	public hydrate(
		data: LockableStateUpdateStorageMessage | Record<string, any>
	): LockableStateUpdateStorageMessage {
		if (data instanceof LockableStateUpdateStorageMessage) {
			return data
		}

		super.hydrate(data)

		this.mapId = data.mapId
		this.elementId = data.elementId

		return this
	}
}

export interface RawExchangeStartedBidBuyerMessage {
	id: number
	buyerDescriptor: SellerBuyerDescriptor
}

export class ExchangeStartedBidBuyerMessage extends DofusMessage {
	public static id: number = 6940

	public buyerDescriptor: SellerBuyerDescriptor | undefined

	public constructor(buyerDescriptor?: SellerBuyerDescriptor | undefined) {
		super()
		this.buyerDescriptor = buyerDescriptor
	}

	public serialize(writer: BinaryWriter): void {
		this.buyerDescriptor!.serialize(writer)
	}

	public deserialize(reader: BinaryReader): void {
		this.buyerDescriptor = new SellerBuyerDescriptor()
		this.buyerDescriptor!.deserialize(reader)
	}

	public hydrate(
		data: ExchangeStartedBidBuyerMessage | Record<string, any>
	): ExchangeStartedBidBuyerMessage {
		if (data instanceof ExchangeStartedBidBuyerMessage) {
			return data
		}

		this.buyerDescriptor = new SellerBuyerDescriptor().hydrate(
			data.buyerDescriptor
		)

		return this
	}
}

export interface RawAllianceListMessage {
	id: number
	alliances: AllianceFactSheetInformations[]
}

export class AllianceListMessage extends DofusMessage {
	public static id: number = 5865

	public alliances: AllianceFactSheetInformations[] | undefined

	public constructor(alliances?: AllianceFactSheetInformations[] | undefined) {
		super()
		this.alliances = alliances
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeShort(this.alliances!.length)
		this.alliances!.forEach((current) => {
			current.serialize(writer)
		})
	}

	public deserialize(reader: BinaryReader): void {
		this.alliances = []
		const countAlliances = reader.readShort()
		for (let i: number = 0; i < countAlliances; i++) {
			const type: AllianceFactSheetInformations = new AllianceFactSheetInformations()
			type.deserialize(reader)
			this.alliances.push(type)
		}
	}

	public hydrate(
		data: AllianceListMessage | Record<string, any>
	): AllianceListMessage {
		if (data instanceof AllianceListMessage) {
			return data
		}

		this.alliances = data.alliances.map(
			(
				dataElement: AllianceFactSheetInformations | Record<string, any>
			): AllianceFactSheetInformations => {
				if (dataElement instanceof AllianceFactSheetInformations) {
					return dataElement
				} else {
					return new AllianceFactSheetInformations().hydrate(dataElement)
				}
			}
		)

		return this
	}
}

export interface RawJobCrafterDirectoryEntryMessage {
	id: number
	playerInfo: JobCrafterDirectoryEntryPlayerInfo
	jobInfoList: JobCrafterDirectoryEntryJobInfo[]
	playerLook: EntityLook
}

export class JobCrafterDirectoryEntryMessage extends DofusMessage {
	public static id: number = 3830

	public playerInfo: JobCrafterDirectoryEntryPlayerInfo | undefined
	public jobInfoList: JobCrafterDirectoryEntryJobInfo[] | undefined
	public playerLook: EntityLook | undefined

	public constructor(
		playerInfo?: JobCrafterDirectoryEntryPlayerInfo | undefined,
		jobInfoList?: JobCrafterDirectoryEntryJobInfo[] | undefined,
		playerLook?: EntityLook | undefined
	) {
		super()
		this.playerInfo = playerInfo
		this.jobInfoList = jobInfoList
		this.playerLook = playerLook
	}

	public serialize(writer: BinaryWriter): void {
		this.playerInfo!.serialize(writer)
		writer.writeShort(this.jobInfoList!.length)
		this.jobInfoList!.forEach((current) => {
			current.serialize(writer)
		})
		this.playerLook!.serialize(writer)
	}

	public deserialize(reader: BinaryReader): void {
		this.playerInfo = new JobCrafterDirectoryEntryPlayerInfo()
		this.playerInfo!.deserialize(reader)
		this.jobInfoList = []
		const countJobInfoList = reader.readShort()
		for (let i: number = 0; i < countJobInfoList; i++) {
			const type: JobCrafterDirectoryEntryJobInfo = new JobCrafterDirectoryEntryJobInfo()
			type.deserialize(reader)
			this.jobInfoList.push(type)
		}
		this.playerLook = new EntityLook()
		this.playerLook!.deserialize(reader)
	}

	public hydrate(
		data: JobCrafterDirectoryEntryMessage | Record<string, any>
	): JobCrafterDirectoryEntryMessage {
		if (data instanceof JobCrafterDirectoryEntryMessage) {
			return data
		}

		this.playerInfo = new JobCrafterDirectoryEntryPlayerInfo().hydrate(
			data.playerInfo
		)
		this.jobInfoList = data.jobInfoList.map(
			(
				dataElement: JobCrafterDirectoryEntryJobInfo | Record<string, any>
			): JobCrafterDirectoryEntryJobInfo => {
				if (dataElement instanceof JobCrafterDirectoryEntryJobInfo) {
					return dataElement
				} else {
					return new JobCrafterDirectoryEntryJobInfo().hydrate(dataElement)
				}
			}
		)
		this.playerLook = new EntityLook().hydrate(data.playerLook)

		return this
	}
}

export interface RawObtainedItemMessage {
	id: number
	genericId: number
	baseQuantity: number
}

export class ObtainedItemMessage extends DofusMessage {
	public static id: number = 7458

	public genericId: number | undefined = 0
	public baseQuantity: number | undefined = 0

	public constructor(
		genericId?: number | undefined,
		baseQuantity?: number | undefined
	) {
		super()
		this.genericId = genericId
		this.baseQuantity = baseQuantity
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarShort(this.genericId!)
		writer.writeVarInt(this.baseQuantity!)
	}

	public deserialize(reader: BinaryReader): void {
		this.genericId = reader.readVarShort()
		this.baseQuantity = reader.readVarInt()
	}

	public hydrate(
		data: ObtainedItemMessage | Record<string, any>
	): ObtainedItemMessage {
		if (data instanceof ObtainedItemMessage) {
			return data
		}

		this.genericId = data.genericId
		this.baseQuantity = data.baseQuantity

		return this
	}
}

export interface RawObtainedItemWithBonusMessage
	extends RawObtainedItemMessage {
	id: number
	bonusQuantity: number
}

export class ObtainedItemWithBonusMessage extends ObtainedItemMessage {
	public static id = 5610

	public bonusQuantity: number | undefined = 0

	public constructor(
		genericId?: number | undefined,
		baseQuantity?: number | undefined,
		bonusQuantity?: number | undefined
	) {
		super(genericId, baseQuantity)
		this.bonusQuantity = bonusQuantity
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeVarInt(this.bonusQuantity!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.bonusQuantity = reader.readVarInt()
	}

	public hydrate(
		data: ObtainedItemWithBonusMessage | Record<string, any>
	): ObtainedItemWithBonusMessage {
		if (data instanceof ObtainedItemWithBonusMessage) {
			return data
		}

		super.hydrate(data)

		this.bonusQuantity = data.bonusQuantity

		return this
	}
}

export interface RawSpellListMessage {
	id: number
	spellPrevisualization: boolean
	spells: SpellItem[]
}

export class SpellListMessage extends DofusMessage {
	public static id: number = 7309

	public spellPrevisualization: boolean | undefined = false
	public spells: SpellItem[] | undefined

	public constructor(
		spellPrevisualization?: boolean | undefined,
		spells?: SpellItem[] | undefined
	) {
		super()
		this.spellPrevisualization = spellPrevisualization
		this.spells = spells
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeBoolean(this.spellPrevisualization!)
		writer.writeShort(this.spells!.length)
		this.spells!.forEach((current) => {
			current.serialize(writer)
		})
	}

	public deserialize(reader: BinaryReader): void {
		this.spellPrevisualization = reader.readBoolean()
		this.spells = []
		const countSpells = reader.readShort()
		for (let i: number = 0; i < countSpells; i++) {
			const type: SpellItem = new SpellItem()
			type.deserialize(reader)
			this.spells.push(type)
		}
	}

	public hydrate(
		data: SpellListMessage | Record<string, any>
	): SpellListMessage {
		if (data instanceof SpellListMessage) {
			return data
		}

		this.spellPrevisualization = data.spellPrevisualization
		this.spells = data.spells.map(
			(dataElement: SpellItem | Record<string, any>): SpellItem => {
				if (dataElement instanceof SpellItem) {
					return dataElement
				} else {
					return new SpellItem().hydrate(dataElement)
				}
			}
		)

		return this
	}
}

export interface RawGuildPaddockRemovedMessage {
	id: number
	paddockId: number
}

export class GuildPaddockRemovedMessage extends DofusMessage {
	public static id: number = 369

	public paddockId: number | undefined = 0

	public constructor(paddockId?: number | undefined) {
		super()
		this.paddockId = paddockId
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeDouble(this.paddockId!)
	}

	public deserialize(reader: BinaryReader): void {
		this.paddockId = reader.readDouble()
	}

	public hydrate(
		data: GuildPaddockRemovedMessage | Record<string, any>
	): GuildPaddockRemovedMessage {
		if (data instanceof GuildPaddockRemovedMessage) {
			return data
		}

		this.paddockId = data.paddockId

		return this
	}
}

export interface RawBreachInvitationResponseMessage {
	id: number
	guest: CharacterMinimalInformations
	accept: boolean
}

export class BreachInvitationResponseMessage extends DofusMessage {
	public static id: number = 6740

	public guest: CharacterMinimalInformations | undefined
	public accept: boolean | undefined = false

	public constructor(
		guest?: CharacterMinimalInformations | undefined,
		accept?: boolean | undefined
	) {
		super()
		this.guest = guest
		this.accept = accept
	}

	public serialize(writer: BinaryWriter): void {
		this.guest!.serialize(writer)
		writer.writeBoolean(this.accept!)
	}

	public deserialize(reader: BinaryReader): void {
		this.guest = new CharacterMinimalInformations()
		this.guest!.deserialize(reader)
		this.accept = reader.readBoolean()
	}

	public hydrate(
		data: BreachInvitationResponseMessage | Record<string, any>
	): BreachInvitationResponseMessage {
		if (data instanceof BreachInvitationResponseMessage) {
			return data
		}

		this.guest = new CharacterMinimalInformations().hydrate(data.guest)
		this.accept = data.accept

		return this
	}
}

export interface RawGuildLeftMessage {
	id: number
}

export class GuildLeftMessage extends DofusMessage {
	public static id: number = 105

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public serialize(writer: BinaryWriter): void {}

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public deserialize(reader: BinaryReader): void {}

	public hydrate(
		data: GuildLeftMessage | Record<string, any>
	): GuildLeftMessage {
		if (data instanceof GuildLeftMessage) {
			return data
		}

		return this
	}
}

export interface RawEditHavenBagStartMessage {
	id: number
}

export class EditHavenBagStartMessage extends DofusMessage {
	public static id: number = 6189

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public serialize(writer: BinaryWriter): void {}

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public deserialize(reader: BinaryReader): void {}

	public hydrate(
		data: EditHavenBagStartMessage | Record<string, any>
	): EditHavenBagStartMessage {
		if (data instanceof EditHavenBagStartMessage) {
			return data
		}

		return this
	}
}

export interface RawPartyRefuseInvitationNotificationMessage
	extends RawAbstractPartyEventMessage {
	id: number
	guestId: number
}

export class PartyRefuseInvitationNotificationMessage extends AbstractPartyEventMessage {
	public static id = 4578

	public guestId: number | undefined = 0

	public constructor(
		partyId?: number | undefined,
		guestId?: number | undefined
	) {
		super(partyId)
		this.guestId = guestId
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeVarLong(this.guestId!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.guestId = reader.readVarLong()
	}

	public hydrate(
		data: PartyRefuseInvitationNotificationMessage | Record<string, any>
	): PartyRefuseInvitationNotificationMessage {
		if (data instanceof PartyRefuseInvitationNotificationMessage) {
			return data
		}

		super.hydrate(data)

		this.guestId = data.guestId

		return this
	}
}

export interface RawCharacterNameSuggestionFailureMessage {
	id: number
	reason: number
}

export class CharacterNameSuggestionFailureMessage extends DofusMessage {
	public static id: number = 5079

	public reason: number | undefined = 1

	public constructor(reason?: number | undefined) {
		super()
		this.reason = reason
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeByte(this.reason!)
	}

	public deserialize(reader: BinaryReader): void {
		this.reason = reader.readByte()
	}

	public hydrate(
		data: CharacterNameSuggestionFailureMessage | Record<string, any>
	): CharacterNameSuggestionFailureMessage {
		if (data instanceof CharacterNameSuggestionFailureMessage) {
			return data
		}

		this.reason = data.reason

		return this
	}
}

export interface RawSelectedServerRefusedMessage {
	id: number
	serverId: number
	error: number
	serverStatus: number
}

export class SelectedServerRefusedMessage extends DofusMessage {
	public static id: number = 95

	public serverId: number | undefined = 0
	public error: number | undefined = 1
	public serverStatus: number | undefined = 1

	public constructor(
		serverId?: number | undefined,
		error?: number | undefined,
		serverStatus?: number | undefined
	) {
		super()
		this.serverId = serverId
		this.error = error
		this.serverStatus = serverStatus
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarShort(this.serverId!)
		writer.writeByte(this.error!)
		writer.writeByte(this.serverStatus!)
	}

	public deserialize(reader: BinaryReader): void {
		this.serverId = reader.readVarShort()
		this.error = reader.readByte()
		this.serverStatus = reader.readByte()
	}

	public hydrate(
		data: SelectedServerRefusedMessage | Record<string, any>
	): SelectedServerRefusedMessage {
		if (data instanceof SelectedServerRefusedMessage) {
			return data
		}

		this.serverId = data.serverId
		this.error = data.error
		this.serverStatus = data.serverStatus

		return this
	}
}

export interface RawPrismInfoInValidMessage {
	id: number
	reason: number
}

export class PrismInfoInValidMessage extends DofusMessage {
	public static id: number = 2678

	public reason: number | undefined = 0

	public constructor(reason?: number | undefined) {
		super()
		this.reason = reason
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeByte(this.reason!)
	}

	public deserialize(reader: BinaryReader): void {
		this.reason = reader.readByte()
	}

	public hydrate(
		data: PrismInfoInValidMessage | Record<string, any>
	): PrismInfoInValidMessage {
		if (data instanceof PrismInfoInValidMessage) {
			return data
		}

		this.reason = data.reason

		return this
	}
}

export interface RawExchangeBidHouseBuyResultMessage {
	id: number
	uid: number
	bought: boolean
}

export class ExchangeBidHouseBuyResultMessage extends DofusMessage {
	public static id: number = 9696

	public uid: number | undefined = 0
	public bought: boolean | undefined = false

	public constructor(uid?: number | undefined, bought?: boolean | undefined) {
		super()
		this.uid = uid
		this.bought = bought
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarInt(this.uid!)
		writer.writeBoolean(this.bought!)
	}

	public deserialize(reader: BinaryReader): void {
		this.uid = reader.readVarInt()
		this.bought = reader.readBoolean()
	}

	public hydrate(
		data: ExchangeBidHouseBuyResultMessage | Record<string, any>
	): ExchangeBidHouseBuyResultMessage {
		if (data instanceof ExchangeBidHouseBuyResultMessage) {
			return data
		}

		this.uid = data.uid
		this.bought = data.bought

		return this
	}
}

export interface RawChatCommunityChannelCommunityMessage {
	id: number
	communityId: number
}

export class ChatCommunityChannelCommunityMessage extends DofusMessage {
	public static id: number = 5438

	public communityId: number | undefined = 0

	public constructor(communityId?: number | undefined) {
		super()
		this.communityId = communityId
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeShort(this.communityId!)
	}

	public deserialize(reader: BinaryReader): void {
		this.communityId = reader.readShort()
	}

	public hydrate(
		data: ChatCommunityChannelCommunityMessage | Record<string, any>
	): ChatCommunityChannelCommunityMessage {
		if (data instanceof ChatCommunityChannelCommunityMessage) {
			return data
		}

		this.communityId = data.communityId

		return this
	}
}

export interface RawIdolPartyLostMessage {
	id: number
	idolId: number
}

export class IdolPartyLostMessage extends DofusMessage {
	public static id: number = 9953

	public idolId: number | undefined = 0

	public constructor(idolId?: number | undefined) {
		super()
		this.idolId = idolId
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarShort(this.idolId!)
	}

	public deserialize(reader: BinaryReader): void {
		this.idolId = reader.readVarShort()
	}

	public hydrate(
		data: IdolPartyLostMessage | Record<string, any>
	): IdolPartyLostMessage {
		if (data instanceof IdolPartyLostMessage) {
			return data
		}

		this.idolId = data.idolId

		return this
	}
}

export interface RawExchangePodsModifiedMessage
	extends RawExchangeObjectMessage {
	id: number
	currentWeight: number
	maxWeight: number
}

export class ExchangePodsModifiedMessage extends ExchangeObjectMessage {
	public static id = 8494

	public currentWeight: number | undefined = 0
	public maxWeight: number | undefined = 0

	public constructor(
		remote?: boolean | undefined,
		currentWeight?: number | undefined,
		maxWeight?: number | undefined
	) {
		super(remote)
		this.currentWeight = currentWeight
		this.maxWeight = maxWeight
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeVarInt(this.currentWeight!)
		writer.writeVarInt(this.maxWeight!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.currentWeight = reader.readVarInt()
		this.maxWeight = reader.readVarInt()
	}

	public hydrate(
		data: ExchangePodsModifiedMessage | Record<string, any>
	): ExchangePodsModifiedMessage {
		if (data instanceof ExchangePodsModifiedMessage) {
			return data
		}

		super.hydrate(data)

		this.currentWeight = data.currentWeight
		this.maxWeight = data.maxWeight

		return this
	}
}

export interface RawTaxCollectorDialogQuestionBasicMessage {
	id: number
	guildInfo: BasicGuildInformations
}

export class TaxCollectorDialogQuestionBasicMessage extends DofusMessage {
	public static id: number = 6664

	public guildInfo: BasicGuildInformations | undefined

	public constructor(guildInfo?: BasicGuildInformations | undefined) {
		super()
		this.guildInfo = guildInfo
	}

	public serialize(writer: BinaryWriter): void {
		this.guildInfo!.serialize(writer)
	}

	public deserialize(reader: BinaryReader): void {
		this.guildInfo = new BasicGuildInformations()
		this.guildInfo!.deserialize(reader)
	}

	public hydrate(
		data: TaxCollectorDialogQuestionBasicMessage | Record<string, any>
	): TaxCollectorDialogQuestionBasicMessage {
		if (data instanceof TaxCollectorDialogQuestionBasicMessage) {
			return data
		}

		this.guildInfo = new BasicGuildInformations().hydrate(data.guildInfo)

		return this
	}
}

export interface RawTaxCollectorDialogQuestionExtendedMessage
	extends RawTaxCollectorDialogQuestionBasicMessage {
	id: number
	maxPods: number
	prospecting: number
	wisdom: number
	taxCollectorsCount: number
	taxCollectorAttack: number
	kamas: number
	experience: number
	pods: number
	itemsValue: number
}

export class TaxCollectorDialogQuestionExtendedMessage extends TaxCollectorDialogQuestionBasicMessage {
	public static id = 9199

	public maxPods: number | undefined = 0
	public prospecting: number | undefined = 0
	public wisdom: number | undefined = 0
	public taxCollectorsCount: number | undefined = 0
	public taxCollectorAttack: number | undefined = 0
	public kamas: number | undefined = 0
	public experience: number | undefined = 0
	public pods: number | undefined = 0
	public itemsValue: number | undefined = 0

	public constructor(
		guildInfo?: BasicGuildInformations | undefined,
		maxPods?: number | undefined,
		prospecting?: number | undefined,
		wisdom?: number | undefined,
		taxCollectorsCount?: number | undefined,
		taxCollectorAttack?: number | undefined,
		kamas?: number | undefined,
		experience?: number | undefined,
		pods?: number | undefined,
		itemsValue?: number | undefined
	) {
		super(guildInfo)
		this.maxPods = maxPods
		this.prospecting = prospecting
		this.wisdom = wisdom
		this.taxCollectorsCount = taxCollectorsCount
		this.taxCollectorAttack = taxCollectorAttack
		this.kamas = kamas
		this.experience = experience
		this.pods = pods
		this.itemsValue = itemsValue
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeVarShort(this.maxPods!)
		writer.writeVarShort(this.prospecting!)
		writer.writeVarShort(this.wisdom!)
		writer.writeByte(this.taxCollectorsCount!)
		writer.writeInt(this.taxCollectorAttack!)
		writer.writeVarLong(this.kamas!)
		writer.writeVarLong(this.experience!)
		writer.writeVarInt(this.pods!)
		writer.writeVarLong(this.itemsValue!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.maxPods = reader.readVarShort()
		this.prospecting = reader.readVarShort()
		this.wisdom = reader.readVarShort()
		this.taxCollectorsCount = reader.readByte()
		this.taxCollectorAttack = reader.readInt()
		this.kamas = reader.readVarLong()
		this.experience = reader.readVarLong()
		this.pods = reader.readVarInt()
		this.itemsValue = reader.readVarLong()
	}

	public hydrate(
		data: TaxCollectorDialogQuestionExtendedMessage | Record<string, any>
	): TaxCollectorDialogQuestionExtendedMessage {
		if (data instanceof TaxCollectorDialogQuestionExtendedMessage) {
			return data
		}

		super.hydrate(data)

		this.maxPods = data.maxPods
		this.prospecting = data.prospecting
		this.wisdom = data.wisdom
		this.taxCollectorsCount = data.taxCollectorsCount
		this.taxCollectorAttack = data.taxCollectorAttack
		this.kamas = data.kamas
		this.experience = data.experience
		this.pods = data.pods
		this.itemsValue = data.itemsValue

		return this
	}
}

export interface RawAllianceTaxCollectorDialogQuestionExtendedMessage
	extends RawTaxCollectorDialogQuestionExtendedMessage {
	id: number
	alliance: BasicNamedAllianceInformations
}

export class AllianceTaxCollectorDialogQuestionExtendedMessage extends TaxCollectorDialogQuestionExtendedMessage {
	public static id = 1736

	public alliance: BasicNamedAllianceInformations | undefined

	public constructor(
		guildInfo?: BasicGuildInformations | undefined,
		maxPods?: number | undefined,
		prospecting?: number | undefined,
		wisdom?: number | undefined,
		taxCollectorsCount?: number | undefined,
		taxCollectorAttack?: number | undefined,
		kamas?: number | undefined,
		experience?: number | undefined,
		pods?: number | undefined,
		itemsValue?: number | undefined,
		alliance?: BasicNamedAllianceInformations | undefined
	) {
		super(
			guildInfo,
			maxPods,
			prospecting,
			wisdom,
			taxCollectorsCount,
			taxCollectorAttack,
			kamas,
			experience,
			pods,
			itemsValue
		)
		this.alliance = alliance
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		this.alliance!.serialize(writer)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.alliance = new BasicNamedAllianceInformations()
		this.alliance!.deserialize(reader)
	}

	public hydrate(
		data:
			| AllianceTaxCollectorDialogQuestionExtendedMessage
			| Record<string, any>
	): AllianceTaxCollectorDialogQuestionExtendedMessage {
		if (data instanceof AllianceTaxCollectorDialogQuestionExtendedMessage) {
			return data
		}

		super.hydrate(data)

		this.alliance = new BasicNamedAllianceInformations().hydrate(data.alliance)

		return this
	}
}

export interface RawTaxCollectorStateUpdateMessage {
	id: number
	uniqueId: number
	state: number
}

export class TaxCollectorStateUpdateMessage extends DofusMessage {
	public static id: number = 8589

	public uniqueId: number | undefined = 0
	public state: number | undefined = 0

	public constructor(
		uniqueId?: number | undefined,
		state?: number | undefined
	) {
		super()
		this.uniqueId = uniqueId
		this.state = state
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeDouble(this.uniqueId!)
		writer.writeByte(this.state!)
	}

	public deserialize(reader: BinaryReader): void {
		this.uniqueId = reader.readDouble()
		this.state = reader.readByte()
	}

	public hydrate(
		data: TaxCollectorStateUpdateMessage | Record<string, any>
	): TaxCollectorStateUpdateMessage {
		if (data instanceof TaxCollectorStateUpdateMessage) {
			return data
		}

		this.uniqueId = data.uniqueId
		this.state = data.state

		return this
	}
}

export interface RawExchangeBidHouseGenericItemRemovedMessage {
	id: number
	objGenericId: number
}

export class ExchangeBidHouseGenericItemRemovedMessage extends DofusMessage {
	public static id: number = 636

	public objGenericId: number | undefined = 0

	public constructor(objGenericId?: number | undefined) {
		super()
		this.objGenericId = objGenericId
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarShort(this.objGenericId!)
	}

	public deserialize(reader: BinaryReader): void {
		this.objGenericId = reader.readVarShort()
	}

	public hydrate(
		data: ExchangeBidHouseGenericItemRemovedMessage | Record<string, any>
	): ExchangeBidHouseGenericItemRemovedMessage {
		if (data instanceof ExchangeBidHouseGenericItemRemovedMessage) {
			return data
		}

		this.objGenericId = data.objGenericId

		return this
	}
}

export interface RawQuestStepInfoMessage {
	id: number
	infos: QuestActiveInformations
}

export class QuestStepInfoMessage extends DofusMessage {
	public static id: number = 2660

	public infos: QuestActiveInformations | undefined

	public constructor(infos?: QuestActiveInformations | undefined) {
		super()
		this.infos = infos
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeShort(this.infos!.id)
		this.infos!.serialize(writer)
	}

	public deserialize(reader: BinaryReader): void {
		const infosTypeId: number = reader.readShort()
		this.infos = new types[infosTypeId]() as QuestActiveInformations
		this.infos!.deserialize(reader)
	}

	public hydrate(
		data: QuestStepInfoMessage | Record<string, any>
	): QuestStepInfoMessage {
		if (data instanceof QuestStepInfoMessage) {
			return data
		}

		this.infos = (new types[
			data.infos.id
		]() as QuestActiveInformations).hydrate(data.infos)
		return this
	}
}

export interface RawServerOptionalFeaturesMessage {
	id: number
	features: number[]
}

export class ServerOptionalFeaturesMessage extends DofusMessage {
	public static id: number = 5407

	public features: number[] | undefined

	public constructor(features?: number[] | undefined) {
		super()
		this.features = features
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeShort(this.features!.length)
		this.features!.forEach((current: number) => writer.writeInt(current))
	}

	public deserialize(reader: BinaryReader): void {
		this.features = []
		const countFeatures = reader.readShort()
		for (let i: number = 0; i < countFeatures; i++) {
			this.features.push(reader.readInt())
		}
	}

	public hydrate(
		data: ServerOptionalFeaturesMessage | Record<string, any>
	): ServerOptionalFeaturesMessage {
		if (data instanceof ServerOptionalFeaturesMessage) {
			return data
		}

		this.features = data.features

		return this
	}
}

export interface RawBreachRoomUnlockResultMessage {
	id: number
	roomId: number
	result: number
}

export class BreachRoomUnlockResultMessage extends DofusMessage {
	public static id: number = 884

	public roomId: number | undefined = 0
	public result: number | undefined = 0

	public constructor(roomId?: number | undefined, result?: number | undefined) {
		super()
		this.roomId = roomId
		this.result = result
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeByte(this.roomId!)
		writer.writeByte(this.result!)
	}

	public deserialize(reader: BinaryReader): void {
		this.roomId = reader.readByte()
		this.result = reader.readByte()
	}

	public hydrate(
		data: BreachRoomUnlockResultMessage | Record<string, any>
	): BreachRoomUnlockResultMessage {
		if (data instanceof BreachRoomUnlockResultMessage) {
			return data
		}

		this.roomId = data.roomId
		this.result = data.result

		return this
	}
}

export interface RawDungeonPartyFinderRoomContentUpdateMessage {
	id: number
	dungeonId: number
	addedPlayers: DungeonPartyFinderPlayer[]
	removedPlayersIds: number[]
}

export class DungeonPartyFinderRoomContentUpdateMessage extends DofusMessage {
	public static id: number = 9690

	public dungeonId: number | undefined = 0
	public addedPlayers: DungeonPartyFinderPlayer[] | undefined
	public removedPlayersIds: number[] | undefined

	public constructor(
		dungeonId?: number | undefined,
		addedPlayers?: DungeonPartyFinderPlayer[] | undefined,
		removedPlayersIds?: number[] | undefined
	) {
		super()
		this.dungeonId = dungeonId
		this.addedPlayers = addedPlayers
		this.removedPlayersIds = removedPlayersIds
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarShort(this.dungeonId!)
		writer.writeShort(this.addedPlayers!.length)
		this.addedPlayers!.forEach((current) => {
			current.serialize(writer)
		})
		writer.writeShort(this.removedPlayersIds!.length)
		this.removedPlayersIds!.forEach((current: number) =>
			writer.writeVarLong(current)
		)
	}

	public deserialize(reader: BinaryReader): void {
		this.dungeonId = reader.readVarShort()
		this.addedPlayers = []
		const countAddedPlayers = reader.readShort()
		for (let i: number = 0; i < countAddedPlayers; i++) {
			const type: DungeonPartyFinderPlayer = new DungeonPartyFinderPlayer()
			type.deserialize(reader)
			this.addedPlayers.push(type)
		}
		this.removedPlayersIds = []
		const countRemovedPlayersIds = reader.readShort()
		for (let i: number = 0; i < countRemovedPlayersIds; i++) {
			this.removedPlayersIds.push(reader.readVarLong())
		}
	}

	public hydrate(
		data: DungeonPartyFinderRoomContentUpdateMessage | Record<string, any>
	): DungeonPartyFinderRoomContentUpdateMessage {
		if (data instanceof DungeonPartyFinderRoomContentUpdateMessage) {
			return data
		}

		this.dungeonId = data.dungeonId
		this.addedPlayers = data.addedPlayers.map(
			(
				dataElement: DungeonPartyFinderPlayer | Record<string, any>
			): DungeonPartyFinderPlayer => {
				if (dataElement instanceof DungeonPartyFinderPlayer) {
					return dataElement
				} else {
					return new DungeonPartyFinderPlayer().hydrate(dataElement)
				}
			}
		)
		this.removedPlayersIds = data.removedPlayersIds

		return this
	}
}

export interface RawQuestStepValidatedMessage {
	id: number
	questId: number
	stepId: number
}

export class QuestStepValidatedMessage extends DofusMessage {
	public static id: number = 5890

	public questId: number | undefined = 0
	public stepId: number | undefined = 0

	public constructor(
		questId?: number | undefined,
		stepId?: number | undefined
	) {
		super()
		this.questId = questId
		this.stepId = stepId
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarShort(this.questId!)
		writer.writeVarShort(this.stepId!)
	}

	public deserialize(reader: BinaryReader): void {
		this.questId = reader.readVarShort()
		this.stepId = reader.readVarShort()
	}

	public hydrate(
		data: QuestStepValidatedMessage | Record<string, any>
	): QuestStepValidatedMessage {
		if (data instanceof QuestStepValidatedMessage) {
			return data
		}

		this.questId = data.questId
		this.stepId = data.stepId

		return this
	}
}

export interface RawCompassUpdatePvpSeekMessage
	extends RawCompassUpdateMessage {
	id: number
	memberId: number
	memberName: string
}

export class CompassUpdatePvpSeekMessage extends CompassUpdateMessage {
	public static id = 4417

	public memberId: number | undefined = 0
	public memberName: string | undefined

	public constructor(
		type?: number | undefined,
		coords?: MapCoordinates | undefined,
		memberId?: number | undefined,
		memberName?: string | undefined
	) {
		super(type, coords)
		this.memberId = memberId
		this.memberName = memberName
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeVarLong(this.memberId!)
		writer.writeUTF(this.memberName!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.memberId = reader.readVarLong()
		this.memberName = reader.readUTF()
	}

	public hydrate(
		data: CompassUpdatePvpSeekMessage | Record<string, any>
	): CompassUpdatePvpSeekMessage {
		if (data instanceof CompassUpdatePvpSeekMessage) {
			return data
		}

		super.hydrate(data)

		this.memberId = data.memberId
		this.memberName = data.memberName

		return this
	}
}

export interface RawAllianceFactsMessage {
	id: number
	infos: AllianceFactSheetInformations
	guilds: GuildInAllianceInformations[]
	controlledSubareaIds: number[]
	leaderCharacterId: number
	leaderCharacterName: string
}

export class AllianceFactsMessage extends DofusMessage {
	public static id: number = 6638

	public infos: AllianceFactSheetInformations | undefined
	public guilds: GuildInAllianceInformations[] | undefined
	public controlledSubareaIds: number[] | undefined
	public leaderCharacterId: number | undefined = 0
	public leaderCharacterName: string | undefined

	public constructor(
		infos?: AllianceFactSheetInformations | undefined,
		guilds?: GuildInAllianceInformations[] | undefined,
		controlledSubareaIds?: number[] | undefined,
		leaderCharacterId?: number | undefined,
		leaderCharacterName?: string | undefined
	) {
		super()
		this.infos = infos
		this.guilds = guilds
		this.controlledSubareaIds = controlledSubareaIds
		this.leaderCharacterId = leaderCharacterId
		this.leaderCharacterName = leaderCharacterName
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeShort(this.infos!.id)
		this.infos!.serialize(writer)
		writer.writeShort(this.guilds!.length)
		this.guilds!.forEach((current) => {
			current.serialize(writer)
		})
		writer.writeShort(this.controlledSubareaIds!.length)
		this.controlledSubareaIds!.forEach((current: number) =>
			writer.writeVarShort(current)
		)
		writer.writeVarLong(this.leaderCharacterId!)
		writer.writeUTF(this.leaderCharacterName!)
	}

	public deserialize(reader: BinaryReader): void {
		const infosTypeId: number = reader.readShort()
		this.infos = new types[infosTypeId]() as AllianceFactSheetInformations
		this.infos!.deserialize(reader)
		this.guilds = []
		const countGuilds = reader.readShort()
		for (let i: number = 0; i < countGuilds; i++) {
			const type: GuildInAllianceInformations = new GuildInAllianceInformations()
			type.deserialize(reader)
			this.guilds.push(type)
		}
		this.controlledSubareaIds = []
		const countControlledSubareaIds = reader.readShort()
		for (let i: number = 0; i < countControlledSubareaIds; i++) {
			this.controlledSubareaIds.push(reader.readVarShort())
		}
		this.leaderCharacterId = reader.readVarLong()
		this.leaderCharacterName = reader.readUTF()
	}

	public hydrate(
		data: AllianceFactsMessage | Record<string, any>
	): AllianceFactsMessage {
		if (data instanceof AllianceFactsMessage) {
			return data
		}

		this.infos = (new types[
			data.infos.id
		]() as AllianceFactSheetInformations).hydrate(data.infos)
		this.guilds = data.guilds.map(
			(
				dataElement: GuildInAllianceInformations | Record<string, any>
			): GuildInAllianceInformations => {
				if (dataElement instanceof GuildInAllianceInformations) {
					return dataElement
				} else {
					return new GuildInAllianceInformations().hydrate(dataElement)
				}
			}
		)
		this.controlledSubareaIds = data.controlledSubareaIds
		this.leaderCharacterId = data.leaderCharacterId
		this.leaderCharacterName = data.leaderCharacterName

		return this
	}
}

export interface RawPrismFightDefenderAddMessage {
	id: number
	subAreaId: number
	fightId: number
	defender: CharacterMinimalPlusLookInformations
}

export class PrismFightDefenderAddMessage extends DofusMessage {
	public static id: number = 873

	public subAreaId: number | undefined = 0
	public fightId: number | undefined = 0
	public defender: CharacterMinimalPlusLookInformations | undefined

	public constructor(
		subAreaId?: number | undefined,
		fightId?: number | undefined,
		defender?: CharacterMinimalPlusLookInformations | undefined
	) {
		super()
		this.subAreaId = subAreaId
		this.fightId = fightId
		this.defender = defender
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarShort(this.subAreaId!)
		writer.writeVarShort(this.fightId!)
		writer.writeShort(this.defender!.id)
		this.defender!.serialize(writer)
	}

	public deserialize(reader: BinaryReader): void {
		this.subAreaId = reader.readVarShort()
		this.fightId = reader.readVarShort()
		const defenderTypeId: number = reader.readShort()
		this.defender = new types[
			defenderTypeId
		]() as CharacterMinimalPlusLookInformations
		this.defender!.deserialize(reader)
	}

	public hydrate(
		data: PrismFightDefenderAddMessage | Record<string, any>
	): PrismFightDefenderAddMessage {
		if (data instanceof PrismFightDefenderAddMessage) {
			return data
		}

		this.subAreaId = data.subAreaId
		this.fightId = data.fightId
		this.defender = (new types[
			data.defender.id
		]() as CharacterMinimalPlusLookInformations).hydrate(data.defender)
		return this
	}
}

export interface RawJobCrafterDirectoryAddMessage {
	id: number
	listEntry: JobCrafterDirectoryListEntry
}

export class JobCrafterDirectoryAddMessage extends DofusMessage {
	public static id: number = 1484

	public listEntry: JobCrafterDirectoryListEntry | undefined

	public constructor(listEntry?: JobCrafterDirectoryListEntry | undefined) {
		super()
		this.listEntry = listEntry
	}

	public serialize(writer: BinaryWriter): void {
		this.listEntry!.serialize(writer)
	}

	public deserialize(reader: BinaryReader): void {
		this.listEntry = new JobCrafterDirectoryListEntry()
		this.listEntry!.deserialize(reader)
	}

	public hydrate(
		data: JobCrafterDirectoryAddMessage | Record<string, any>
	): JobCrafterDirectoryAddMessage {
		if (data instanceof JobCrafterDirectoryAddMessage) {
			return data
		}

		this.listEntry = new JobCrafterDirectoryListEntry().hydrate(data.listEntry)

		return this
	}
}

export interface RawShortcutBarSwapErrorMessage {
	id: number
	error: number
}

export class ShortcutBarSwapErrorMessage extends DofusMessage {
	public static id: number = 4478

	public error: number | undefined = 0

	public constructor(error?: number | undefined) {
		super()
		this.error = error
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeByte(this.error!)
	}

	public deserialize(reader: BinaryReader): void {
		this.error = reader.readByte()
	}

	public hydrate(
		data: ShortcutBarSwapErrorMessage | Record<string, any>
	): ShortcutBarSwapErrorMessage {
		if (data instanceof ShortcutBarSwapErrorMessage) {
			return data
		}

		this.error = data.error

		return this
	}
}

export interface RawPartyInvitationDungeonMessage
	extends RawPartyInvitationMessage {
	id: number
	dungeonId: number
}

export class PartyInvitationDungeonMessage extends PartyInvitationMessage {
	public static id = 744

	public dungeonId: number | undefined = 0

	public constructor(
		partyId?: number | undefined,
		partyType?: number | undefined,
		partyName?: string | undefined,
		maxParticipants?: number | undefined,
		fromId?: number | undefined,
		fromName?: string | undefined,
		toId?: number | undefined,
		dungeonId?: number | undefined
	) {
		super(
			partyId,
			partyType,
			partyName,
			maxParticipants,
			fromId,
			fromName,
			toId
		)
		this.dungeonId = dungeonId
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeVarShort(this.dungeonId!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.dungeonId = reader.readVarShort()
	}

	public hydrate(
		data: PartyInvitationDungeonMessage | Record<string, any>
	): PartyInvitationDungeonMessage {
		if (data instanceof PartyInvitationDungeonMessage) {
			return data
		}

		super.hydrate(data)

		this.dungeonId = data.dungeonId

		return this
	}
}

export interface RawBreachBudgetMessage {
	id: number
	bugdet: number
}

export class BreachBudgetMessage extends DofusMessage {
	public static id: number = 2375

	public bugdet: number | undefined = 0

	public constructor(bugdet?: number | undefined) {
		super()
		this.bugdet = bugdet
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarInt(this.bugdet!)
	}

	public deserialize(reader: BinaryReader): void {
		this.bugdet = reader.readVarInt()
	}

	public hydrate(
		data: BreachBudgetMessage | Record<string, any>
	): BreachBudgetMessage {
		if (data instanceof BreachBudgetMessage) {
			return data
		}

		this.bugdet = data.bugdet

		return this
	}
}

export interface RawJobAllowMultiCraftRequestMessage {
	id: number
	enabled: boolean
}

export class JobAllowMultiCraftRequestMessage extends DofusMessage {
	public static id: number = 6296

	public enabled: boolean | undefined = false

	public constructor(enabled?: boolean | undefined) {
		super()
		this.enabled = enabled
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeBoolean(this.enabled!)
	}

	public deserialize(reader: BinaryReader): void {
		this.enabled = reader.readBoolean()
	}

	public hydrate(
		data: JobAllowMultiCraftRequestMessage | Record<string, any>
	): JobAllowMultiCraftRequestMessage {
		if (data instanceof JobAllowMultiCraftRequestMessage) {
			return data
		}

		this.enabled = data.enabled

		return this
	}
}

export interface RawJobMultiCraftAvailableSkillsMessage
	extends RawJobAllowMultiCraftRequestMessage {
	id: number
	playerId: number
	skills: number[]
}

export class JobMultiCraftAvailableSkillsMessage extends JobAllowMultiCraftRequestMessage {
	public static id = 5801

	public playerId: number | undefined = 0
	public skills: number[] | undefined

	public constructor(
		enabled?: boolean | undefined,
		playerId?: number | undefined,
		skills?: number[] | undefined
	) {
		super(enabled)
		this.playerId = playerId
		this.skills = skills
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeVarLong(this.playerId!)
		writer.writeShort(this.skills!.length)
		this.skills!.forEach((current: number) => writer.writeVarShort(current))
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.playerId = reader.readVarLong()
		this.skills = []
		const countSkills = reader.readShort()
		for (let i: number = 0; i < countSkills; i++) {
			this.skills.push(reader.readVarShort())
		}
	}

	public hydrate(
		data: JobMultiCraftAvailableSkillsMessage | Record<string, any>
	): JobMultiCraftAvailableSkillsMessage {
		if (data instanceof JobMultiCraftAvailableSkillsMessage) {
			return data
		}

		super.hydrate(data)

		this.playerId = data.playerId
		this.skills = data.skills

		return this
	}
}

export interface RawExchangeMountsStableAddMessage {
	id: number
	mountDescription: MountClientData[]
}

export class ExchangeMountsStableAddMessage extends DofusMessage {
	public static id: number = 1752

	public mountDescription: MountClientData[] | undefined

	public constructor(mountDescription?: MountClientData[] | undefined) {
		super()
		this.mountDescription = mountDescription
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeShort(this.mountDescription!.length)
		this.mountDescription!.forEach((current) => {
			current.serialize(writer)
		})
	}

	public deserialize(reader: BinaryReader): void {
		this.mountDescription = []
		const countMountDescription = reader.readShort()
		for (let i: number = 0; i < countMountDescription; i++) {
			const type: MountClientData = new MountClientData()
			type.deserialize(reader)
			this.mountDescription.push(type)
		}
	}

	public hydrate(
		data: ExchangeMountsStableAddMessage | Record<string, any>
	): ExchangeMountsStableAddMessage {
		if (data instanceof ExchangeMountsStableAddMessage) {
			return data
		}

		this.mountDescription = data.mountDescription.map(
			(dataElement: MountClientData | Record<string, any>): MountClientData => {
				if (dataElement instanceof MountClientData) {
					return dataElement
				} else {
					return new MountClientData().hydrate(dataElement)
				}
			}
		)

		return this
	}
}

export interface RawFriendAddedMessage {
	id: number
	friendAdded: FriendInformations
}

export class FriendAddedMessage extends DofusMessage {
	public static id: number = 2999

	public friendAdded: FriendInformations | undefined

	public constructor(friendAdded?: FriendInformations | undefined) {
		super()
		this.friendAdded = friendAdded
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeShort(this.friendAdded!.id)
		this.friendAdded!.serialize(writer)
	}

	public deserialize(reader: BinaryReader): void {
		const friendAddedTypeId: number = reader.readShort()
		this.friendAdded = new types[friendAddedTypeId]() as FriendInformations
		this.friendAdded!.deserialize(reader)
	}

	public hydrate(
		data: FriendAddedMessage | Record<string, any>
	): FriendAddedMessage {
		if (data instanceof FriendAddedMessage) {
			return data
		}

		this.friendAdded = (new types[
			data.friendAdded.id
		]() as FriendInformations).hydrate(data.friendAdded)
		return this
	}
}

export interface RawCharacterCanBeCreatedResultMessage {
	id: number
	yesYouCan: boolean
}

export class CharacterCanBeCreatedResultMessage extends DofusMessage {
	public static id: number = 3594

	public yesYouCan: boolean | undefined = false

	public constructor(yesYouCan?: boolean | undefined) {
		super()
		this.yesYouCan = yesYouCan
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeBoolean(this.yesYouCan!)
	}

	public deserialize(reader: BinaryReader): void {
		this.yesYouCan = reader.readBoolean()
	}

	public hydrate(
		data: CharacterCanBeCreatedResultMessage | Record<string, any>
	): CharacterCanBeCreatedResultMessage {
		if (data instanceof CharacterCanBeCreatedResultMessage) {
			return data
		}

		this.yesYouCan = data.yesYouCan

		return this
	}
}

export interface RawNpcGenericActionFailureMessage {
	id: number
}

export class NpcGenericActionFailureMessage extends DofusMessage {
	public static id: number = 1685

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public serialize(writer: BinaryWriter): void {}

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public deserialize(reader: BinaryReader): void {}

	public hydrate(
		data: NpcGenericActionFailureMessage | Record<string, any>
	): NpcGenericActionFailureMessage {
		if (data instanceof NpcGenericActionFailureMessage) {
			return data
		}

		return this
	}
}

export interface RawAccountHouseMessage {
	id: number
	houses: AccountHouseInformations[]
}

export class AccountHouseMessage extends DofusMessage {
	public static id: number = 6480

	public houses: AccountHouseInformations[] | undefined

	public constructor(houses?: AccountHouseInformations[] | undefined) {
		super()
		this.houses = houses
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeShort(this.houses!.length)
		this.houses!.forEach((current) => {
			current.serialize(writer)
		})
	}

	public deserialize(reader: BinaryReader): void {
		this.houses = []
		const countHouses = reader.readShort()
		for (let i: number = 0; i < countHouses; i++) {
			const type: AccountHouseInformations = new AccountHouseInformations()
			type.deserialize(reader)
			this.houses.push(type)
		}
	}

	public hydrate(
		data: AccountHouseMessage | Record<string, any>
	): AccountHouseMessage {
		if (data instanceof AccountHouseMessage) {
			return data
		}

		this.houses = data.houses.map(
			(
				dataElement: AccountHouseInformations | Record<string, any>
			): AccountHouseInformations => {
				if (dataElement instanceof AccountHouseInformations) {
					return dataElement
				} else {
					return new AccountHouseInformations().hydrate(dataElement)
				}
			}
		)

		return this
	}
}

export interface RawAcquaintanceSearchErrorMessage {
	id: number
	reason: number
}

export class GuildRanksRequestMessage extends DofusMessage {
	public static id: number = 4543

	public constructor() {
		super()
	}

	public serialize(writer: BinaryWriter): void {}

	public deserialize(reader: BinaryReader): void {}
}

export class AcquaintanceSearchErrorMessage extends DofusMessage {
	public static id: number = 2175

	public reason: number | undefined = 0

	public constructor(reason?: number | undefined) {
		super()
		this.reason = reason
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeByte(this.reason!)
	}

	public deserialize(reader: BinaryReader): void {
		this.reason = reader.readByte()
	}

	public hydrate(
		data: AcquaintanceSearchErrorMessage | Record<string, any>
	): AcquaintanceSearchErrorMessage {
		if (data instanceof AcquaintanceSearchErrorMessage) {
			return data
		}

		this.reason = data.reason

		return this
	}
}

export interface RawExchangeStartOkRecycleTradeMessage {
	id: number
	percentToPrism: number
	percentToPlayer: number
}

export class ExchangeStartOkRecycleTradeMessage extends DofusMessage {
	public static id: number = 255

	public percentToPrism: number | undefined = 0
	public percentToPlayer: number | undefined = 0

	public constructor(
		percentToPrism?: number | undefined,
		percentToPlayer?: number | undefined
	) {
		super()
		this.percentToPrism = percentToPrism
		this.percentToPlayer = percentToPlayer
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeShort(this.percentToPrism!)
		writer.writeShort(this.percentToPlayer!)
	}

	public deserialize(reader: BinaryReader): void {
		this.percentToPrism = reader.readShort()
		this.percentToPlayer = reader.readShort()
	}

	public hydrate(
		data: ExchangeStartOkRecycleTradeMessage | Record<string, any>
	): ExchangeStartOkRecycleTradeMessage {
		if (data instanceof ExchangeStartOkRecycleTradeMessage) {
			return data
		}

		this.percentToPrism = data.percentToPrism
		this.percentToPlayer = data.percentToPlayer

		return this
	}
}

export interface RawStatsUpgradeResultMessage {
	id: number
	result: number
	nbCharacBoost: number
}

export class StatsUpgradeResultMessage extends DofusMessage {
	public static id: number = 5392

	public result: number | undefined = 0
	public nbCharacBoost: number | undefined = 0

	public constructor(
		result?: number | undefined,
		nbCharacBoost?: number | undefined
	) {
		super()
		this.result = result
		this.nbCharacBoost = nbCharacBoost
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeByte(this.result!)
		writer.writeVarShort(this.nbCharacBoost!)
	}

	public deserialize(reader: BinaryReader): void {
		this.result = reader.readByte()
		this.nbCharacBoost = reader.readVarShort()
	}

	public hydrate(
		data: StatsUpgradeResultMessage | Record<string, any>
	): StatsUpgradeResultMessage {
		if (data instanceof StatsUpgradeResultMessage) {
			return data
		}

		this.result = data.result
		this.nbCharacBoost = data.nbCharacBoost

		return this
	}
}

export interface RawMapRunningFightListMessage {
	id: number
	fights: FightExternalInformations[]
}

export class MapRunningFightListMessage extends DofusMessage {
	public static id: number = 2666

	public fights: FightExternalInformations[] | undefined

	public constructor(fights?: FightExternalInformations[] | undefined) {
		super()
		this.fights = fights
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeShort(this.fights!.length)
		this.fights!.forEach((current) => {
			current.serialize(writer)
		})
	}

	public deserialize(reader: BinaryReader): void {
		this.fights = []
		const countFights = reader.readShort()
		for (let i: number = 0; i < countFights; i++) {
			const type: FightExternalInformations = new FightExternalInformations()
			type.deserialize(reader)
			this.fights.push(type)
		}
	}

	public hydrate(
		data: MapRunningFightListMessage | Record<string, any>
	): MapRunningFightListMessage {
		if (data instanceof MapRunningFightListMessage) {
			return data
		}

		this.fights = data.fights.map(
			(
				dataElement: FightExternalInformations | Record<string, any>
			): FightExternalInformations => {
				if (dataElement instanceof FightExternalInformations) {
					return dataElement
				} else {
					return new FightExternalInformations().hydrate(dataElement)
				}
			}
		)

		return this
	}
}

export interface RawSequenceNumberRequestMessage {
	id: number
}

export class SequenceNumberRequestMessage extends DofusMessage {
	public static id: number = 1620

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public serialize(writer: BinaryWriter): void {}

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public deserialize(reader: BinaryReader): void {}

	public hydrate(
		data: SequenceNumberRequestMessage | Record<string, any>
	): SequenceNumberRequestMessage {
		if (data instanceof SequenceNumberRequestMessage) {
			return data
		}

		return this
	}
}

export interface RawPartyInvitationDetailsMessage
	extends RawAbstractPartyMessage {
	id: number
	partyType: number
	partyName: string
	fromId: number
	fromName: string
	leaderId: number
	members: PartyInvitationMemberInformations[]
	guests: PartyGuestInformations[]
}

export class PartyInvitationDetailsMessage extends AbstractPartyMessage {
	public static id = 3818

	public partyType: number | undefined = 0
	public partyName: string | undefined
	public fromId: number | undefined = 0
	public fromName: string | undefined
	public leaderId: number | undefined = 0
	public members: PartyInvitationMemberInformations[] | undefined
	public guests: PartyGuestInformations[] | undefined

	public constructor(
		partyId?: number | undefined,
		partyType?: number | undefined,
		partyName?: string | undefined,
		fromId?: number | undefined,
		fromName?: string | undefined,
		leaderId?: number | undefined,
		members?: PartyInvitationMemberInformations[] | undefined,
		guests?: PartyGuestInformations[] | undefined
	) {
		super(partyId)
		this.partyType = partyType
		this.partyName = partyName
		this.fromId = fromId
		this.fromName = fromName
		this.leaderId = leaderId
		this.members = members
		this.guests = guests
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeByte(this.partyType!)
		writer.writeUTF(this.partyName!)
		writer.writeVarLong(this.fromId!)
		writer.writeUTF(this.fromName!)
		writer.writeVarLong(this.leaderId!)
		writer.writeShort(this.members!.length)
		this.members!.forEach((current) => {
			writer.writeShort(current.id)
			current.serialize(writer)
		})
		writer.writeShort(this.guests!.length)
		this.guests!.forEach((current) => {
			current.serialize(writer)
		})
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.partyType = reader.readByte()
		this.partyName = reader.readUTF()
		this.fromId = reader.readVarLong()
		this.fromName = reader.readUTF()
		this.leaderId = reader.readVarLong()
		this.members = []
		const countMembers = reader.readShort()
		for (let i: number = 0; i < countMembers; i++) {
			const membersTypeId: number = reader.readShort()
			const type: PartyInvitationMemberInformations = new types[
				membersTypeId
			]() as PartyInvitationMemberInformations
			type.deserialize(reader)
			this.members.push(type)
		}
		this.guests = []
		const countGuests = reader.readShort()
		for (let i: number = 0; i < countGuests; i++) {
			const type: PartyGuestInformations = new PartyGuestInformations()
			type.deserialize(reader)
			this.guests.push(type)
		}
	}

	public hydrate(
		data: PartyInvitationDetailsMessage | Record<string, any>
	): PartyInvitationDetailsMessage {
		if (data instanceof PartyInvitationDetailsMessage) {
			return data
		}

		super.hydrate(data)

		this.partyType = data.partyType
		this.partyName = data.partyName
		this.fromId = data.fromId
		this.fromName = data.fromName
		this.leaderId = data.leaderId
		this.members = data.members.map(
			(
				dataElement: PartyInvitationMemberInformations | Record<string, any>
			): PartyInvitationMemberInformations => {
				if (dataElement instanceof PartyInvitationMemberInformations) {
					return dataElement
				} else {
					return (new types[
						dataElement.id
					]() as PartyInvitationMemberInformations).hydrate(dataElement)
				}
			}
		)
		this.guests = data.guests.map(
			(
				dataElement: PartyGuestInformations | Record<string, any>
			): PartyGuestInformations => {
				if (dataElement instanceof PartyGuestInformations) {
					return dataElement
				} else {
					return new PartyGuestInformations().hydrate(dataElement)
				}
			}
		)

		return this
	}
}

export interface RawPartyInvitationDungeonDetailsMessage
	extends RawPartyInvitationDetailsMessage {
	id: number
	dungeonId: number
	playersDungeonReady: boolean[]
}

export class PartyInvitationDungeonDetailsMessage extends PartyInvitationDetailsMessage {
	public static id = 1024

	public dungeonId: number | undefined = 0
	public playersDungeonReady: boolean[] | undefined

	public constructor(
		partyId?: number | undefined,
		partyType?: number | undefined,
		partyName?: string | undefined,
		fromId?: number | undefined,
		fromName?: string | undefined,
		leaderId?: number | undefined,
		members?: PartyInvitationMemberInformations[] | undefined,
		guests?: PartyGuestInformations[] | undefined,
		dungeonId?: number | undefined,
		playersDungeonReady?: boolean[] | undefined
	) {
		super(
			partyId,
			partyType,
			partyName,
			fromId,
			fromName,
			leaderId,
			members,
			guests
		)
		this.dungeonId = dungeonId
		this.playersDungeonReady = playersDungeonReady
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeVarShort(this.dungeonId!)
		writer.writeShort(this.playersDungeonReady!.length)
		this.playersDungeonReady!.forEach((current: boolean) =>
			writer.writeBoolean(current)
		)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.dungeonId = reader.readVarShort()
		this.playersDungeonReady = []
		const countPlayersDungeonReady = reader.readShort()
		for (let i: number = 0; i < countPlayersDungeonReady; i++) {
			this.playersDungeonReady.push(reader.readBoolean())
		}
	}

	public hydrate(
		data: PartyInvitationDungeonDetailsMessage | Record<string, any>
	): PartyInvitationDungeonDetailsMessage {
		if (data instanceof PartyInvitationDungeonDetailsMessage) {
			return data
		}

		super.hydrate(data)

		this.dungeonId = data.dungeonId
		this.playersDungeonReady = data.playersDungeonReady

		return this
	}
}

export interface RawExchangeTypesExchangerDescriptionForUserMessage {
	id: number
	objectType: number
	typeDescription: number[]
}

export class ExchangeTypesExchangerDescriptionForUserMessage extends DofusMessage {
	public static id: number = 2868

	public objectType: number | undefined = 0
	public typeDescription: number[] | undefined

	public constructor(
		objectType?: number | undefined,
		typeDescription?: number[] | undefined
	) {
		super()
		this.objectType = objectType
		this.typeDescription = typeDescription
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeInt(this.objectType!)
		writer.writeShort(this.typeDescription!.length)
		this.typeDescription!.forEach((current: number) =>
			writer.writeVarInt(current)
		)
	}

	public deserialize(reader: BinaryReader): void {
		this.objectType = reader.readInt()
		this.typeDescription = []
		const countTypeDescription = reader.readShort()
		for (let i: number = 0; i < countTypeDescription; i++) {
			this.typeDescription.push(reader.readVarInt())
		}
	}

	public hydrate(
		data: ExchangeTypesExchangerDescriptionForUserMessage | Record<string, any>
	): ExchangeTypesExchangerDescriptionForUserMessage {
		if (data instanceof ExchangeTypesExchangerDescriptionForUserMessage) {
			return data
		}

		this.objectType = data.objectType
		this.typeDescription = data.typeDescription

		return this
	}
}

export interface RawJobCrafterDirectorySettingsMessage {
	id: number
	craftersSettings: JobCrafterDirectorySettings[]
}

export class JobCrafterDirectorySettingsMessage extends DofusMessage {
	public static id: number = 809

	public craftersSettings: JobCrafterDirectorySettings[] | undefined

	public constructor(
		craftersSettings?: JobCrafterDirectorySettings[] | undefined
	) {
		super()
		this.craftersSettings = craftersSettings
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeShort(this.craftersSettings!.length)
		this.craftersSettings!.forEach((current) => {
			current.serialize(writer)
		})
	}

	public deserialize(reader: BinaryReader): void {
		this.craftersSettings = []
		const countCraftersSettings = reader.readShort()
		for (let i: number = 0; i < countCraftersSettings; i++) {
			const type: JobCrafterDirectorySettings = new JobCrafterDirectorySettings()
			type.deserialize(reader)
			this.craftersSettings.push(type)
		}
	}

	public hydrate(
		data: JobCrafterDirectorySettingsMessage | Record<string, any>
	): JobCrafterDirectorySettingsMessage {
		if (data instanceof JobCrafterDirectorySettingsMessage) {
			return data
		}

		this.craftersSettings = data.craftersSettings.map(
			(
				dataElement: JobCrafterDirectorySettings | Record<string, any>
			): JobCrafterDirectorySettings => {
				if (dataElement instanceof JobCrafterDirectorySettings) {
					return dataElement
				} else {
					return new JobCrafterDirectorySettings().hydrate(dataElement)
				}
			}
		)

		return this
	}
}

export interface RawMoodSmileyUpdateMessage {
	id: number
	accountId: number
	playerId: number
	smileyId: number
}

export class MoodSmileyUpdateMessage extends DofusMessage {
	public static id: number = 4794

	public accountId: number | undefined = 0
	public playerId: number | undefined = 0
	public smileyId: number | undefined = 0

	public constructor(
		accountId?: number | undefined,
		playerId?: number | undefined,
		smileyId?: number | undefined
	) {
		super()
		this.accountId = accountId
		this.playerId = playerId
		this.smileyId = smileyId
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeInt(this.accountId!)
		writer.writeVarLong(this.playerId!)
		writer.writeVarShort(this.smileyId!)
	}

	public deserialize(reader: BinaryReader): void {
		this.accountId = reader.readInt()
		this.playerId = reader.readVarLong()
		this.smileyId = reader.readVarShort()
	}

	public hydrate(
		data: MoodSmileyUpdateMessage | Record<string, any>
	): MoodSmileyUpdateMessage {
		if (data instanceof MoodSmileyUpdateMessage) {
			return data
		}

		this.accountId = data.accountId
		this.playerId = data.playerId
		this.smileyId = data.smileyId

		return this
	}
}

export interface RawEmotePlayMessage extends RawEmotePlayAbstractMessage {
	id: number
	actorId: number
	accountId: number
}

export class EmotePlayMessage extends EmotePlayAbstractMessage {
	public static id = 6496

	public actorId: number | undefined = 0
	public accountId: number | undefined = 0

	public constructor(
		emoteId?: number | undefined,
		emoteStartTime?: number | undefined,
		actorId?: number | undefined,
		accountId?: number | undefined
	) {
		super(emoteId, emoteStartTime)
		this.actorId = actorId
		this.accountId = accountId
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeDouble(this.actorId!)
		writer.writeInt(this.accountId!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.actorId = reader.readDouble()
		this.accountId = reader.readInt()
	}

	public hydrate(
		data: EmotePlayMessage | Record<string, any>
	): EmotePlayMessage {
		if (data instanceof EmotePlayMessage) {
			return data
		}

		super.hydrate(data)

		this.actorId = data.actorId
		this.accountId = data.accountId

		return this
	}
}

export interface RawSelectedServerDataMessage {
	id: number
	serverId: number
	address: string
	ports: number[]
	canCreateNewCharacter: boolean
	ticket: number[]
}

export class SelectedServerDataMessage extends DofusMessage {
	public static id: number = 2882

	public serverId: number | undefined = 0
	public address: string | undefined
	public ports: number[] | undefined
	public canCreateNewCharacter: boolean | undefined = false
	public ticket: number[] | undefined

	public constructor(
		serverId?: number | undefined,
		address?: string | undefined,
		ports?: number[] | undefined,
		canCreateNewCharacter?: boolean | undefined,
		ticket?: number[] | undefined
	) {
		super()
		this.serverId = serverId
		this.address = address
		this.ports = ports
		this.canCreateNewCharacter = canCreateNewCharacter
		this.ticket = ticket
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarShort(this.serverId!)
		writer.writeUTF(this.address!)
		writer.writeShort(this.ports!.length)
		this.ports!.forEach((current: number) => writer.writeVarShort(current))
		writer.writeBoolean(this.canCreateNewCharacter!)
		writer.writeVarInt(this.ticket!.length)
		this.ticket!.forEach((current: number) => writer.writeByte(current))
	}

	public deserialize(reader: BinaryReader): void {
		this.serverId = reader.readVarShort()
		this.address = reader.readUTF()
		this.ports = []
		const countPorts = reader.readShort()
		for (let i: number = 0; i < countPorts; i++) {
			this.ports.push(reader.readVarShort())
		}
		this.canCreateNewCharacter = reader.readBoolean()
		this.ticket = []
		const countTicket = reader.readVarInt()
		for (let i: number = 0; i < countTicket; i++) {
			this.ticket.push(reader.readByte())
		}
	}

	public hydrate(
		data: SelectedServerDataMessage | Record<string, any>
	): SelectedServerDataMessage {
		if (data instanceof SelectedServerDataMessage) {
			return data
		}

		this.serverId = data.serverId
		this.address = data.address
		this.ports = data.ports
		this.canCreateNewCharacter = data.canCreateNewCharacter
		this.ticket = data.ticket

		return this
	}
}

export interface RawSelectedServerDataExtendedMessage
	extends RawSelectedServerDataMessage {
	id: number
	servers: GameServerInformations[]
}

export class SelectedServerDataExtendedMessage extends SelectedServerDataMessage {
	public static id = 7321

	public servers: GameServerInformations[] | undefined

	public constructor(
		serverId?: number | undefined,
		address?: string | undefined,
		ports?: number[] | undefined,
		canCreateNewCharacter?: boolean | undefined,
		ticket?: number[] | undefined,
		servers?: GameServerInformations[] | undefined
	) {
		super(serverId, address, ports, canCreateNewCharacter, ticket)
		this.servers = servers
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeShort(this.servers!.length)
		this.servers!.forEach((current) => {
			current.serialize(writer)
		})
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.servers = []
		const countServers = reader.readShort()
		for (let i: number = 0; i < countServers; i++) {
			const type: GameServerInformations = new GameServerInformations()
			type.deserialize(reader)
			this.servers.push(type)
		}
	}

	public hydrate(
		data: SelectedServerDataExtendedMessage | Record<string, any>
	): SelectedServerDataExtendedMessage {
		if (data instanceof SelectedServerDataExtendedMessage) {
			return data
		}

		super.hydrate(data)

		this.servers = data.servers.map(
			(
				dataElement: GameServerInformations | Record<string, any>
			): GameServerInformations => {
				if (dataElement instanceof GameServerInformations) {
					return dataElement
				} else {
					return new GameServerInformations().hydrate(dataElement)
				}
			}
		)

		return this
	}
}

export interface RawFriendWarnOnConnectionStateMessage {
	id: number
	enable: boolean
}

export class FriendWarnOnConnectionStateMessage extends DofusMessage {
	public static id: number = 6364

	public enable: boolean | undefined = false

	public constructor(enable?: boolean | undefined) {
		super()
		this.enable = enable
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeBoolean(this.enable!)
	}

	public deserialize(reader: BinaryReader): void {
		this.enable = reader.readBoolean()
	}

	public hydrate(
		data: FriendWarnOnConnectionStateMessage | Record<string, any>
	): FriendWarnOnConnectionStateMessage {
		if (data instanceof FriendWarnOnConnectionStateMessage) {
			return data
		}

		this.enable = data.enable

		return this
	}
}

export interface RawDungeonPartyFinderRoomContentMessage {
	id: number
	dungeonId: number
	players: DungeonPartyFinderPlayer[]
}

export class DungeonPartyFinderRoomContentMessage extends DofusMessage {
	public static id: number = 3771

	public dungeonId: number | undefined = 0
	public players: DungeonPartyFinderPlayer[] | undefined

	public constructor(
		dungeonId?: number | undefined,
		players?: DungeonPartyFinderPlayer[] | undefined
	) {
		super()
		this.dungeonId = dungeonId
		this.players = players
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarShort(this.dungeonId!)
		writer.writeShort(this.players!.length)
		this.players!.forEach((current) => {
			current.serialize(writer)
		})
	}

	public deserialize(reader: BinaryReader): void {
		this.dungeonId = reader.readVarShort()
		this.players = []
		const countPlayers = reader.readShort()
		for (let i: number = 0; i < countPlayers; i++) {
			const type: DungeonPartyFinderPlayer = new DungeonPartyFinderPlayer()
			type.deserialize(reader)
			this.players.push(type)
		}
	}

	public hydrate(
		data: DungeonPartyFinderRoomContentMessage | Record<string, any>
	): DungeonPartyFinderRoomContentMessage {
		if (data instanceof DungeonPartyFinderRoomContentMessage) {
			return data
		}

		this.dungeonId = data.dungeonId
		this.players = data.players.map(
			(
				dataElement: DungeonPartyFinderPlayer | Record<string, any>
			): DungeonPartyFinderPlayer => {
				if (dataElement instanceof DungeonPartyFinderPlayer) {
					return dataElement
				} else {
					return new DungeonPartyFinderPlayer().hydrate(dataElement)
				}
			}
		)

		return this
	}
}

export interface RawBasicDateMessage {
	id: number
	day: number
	month: number
	year: number
}

export class BasicDateMessage extends DofusMessage {
	public static id: number = 7123

	public day: number | undefined = 0
	public month: number | undefined = 0
	public year: number | undefined = 0

	public constructor(
		day?: number | undefined,
		month?: number | undefined,
		year?: number | undefined
	) {
		super()
		this.day = day
		this.month = month
		this.year = year
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeByte(this.day!)
		writer.writeByte(this.month!)
		writer.writeShort(this.year!)
	}

	public deserialize(reader: BinaryReader): void {
		this.day = reader.readByte()
		this.month = reader.readByte()
		this.year = reader.readShort()
	}

	public hydrate(
		data: BasicDateMessage | Record<string, any>
	): BasicDateMessage {
		if (data instanceof BasicDateMessage) {
			return data
		}

		this.day = data.day
		this.month = data.month
		this.year = data.year

		return this
	}
}

export interface RawExchangeMountsStableBornAddMessage
	extends RawExchangeMountsStableAddMessage {
	id: number
}

export class ExchangeMountsStableBornAddMessage extends ExchangeMountsStableAddMessage {
	public static id = 839

	public constructor(mountDescription?: MountClientData[] | undefined) {
		super(mountDescription)
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
	}

	public hydrate(
		data: ExchangeMountsStableBornAddMessage | Record<string, any>
	): ExchangeMountsStableBornAddMessage {
		if (data instanceof ExchangeMountsStableBornAddMessage) {
			return data
		}

		super.hydrate(data)

		return this
	}
}

export interface RawJobDescriptionMessage {
	id: number
	jobsDescription: JobDescription[]
}

export class JobDescriptionMessage extends DofusMessage {
	public static id: number = 3482

	public jobsDescription: JobDescription[] | undefined

	public constructor(jobsDescription?: JobDescription[] | undefined) {
		super()
		this.jobsDescription = jobsDescription
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeShort(this.jobsDescription!.length)
		this.jobsDescription!.forEach((current) => {
			current.serialize(writer)
		})
	}

	public deserialize(reader: BinaryReader): void {
		this.jobsDescription = []
		const countJobsDescription = reader.readShort()
		for (let i: number = 0; i < countJobsDescription; i++) {
			const type: JobDescription = new JobDescription()
			type.deserialize(reader)
			this.jobsDescription.push(type)
		}
	}

	public hydrate(
		data: JobDescriptionMessage | Record<string, any>
	): JobDescriptionMessage {
		if (data instanceof JobDescriptionMessage) {
			return data
		}

		this.jobsDescription = data.jobsDescription.map(
			(dataElement: JobDescription | Record<string, any>): JobDescription => {
				if (dataElement instanceof JobDescription) {
					return dataElement
				} else {
					return new JobDescription().hydrate(dataElement)
				}
			}
		)

		return this
	}
}

export interface RawAccountLoggingKickedMessage {
	id: number
	days: number
	hours: number
	minutes: number
}

export class AccountLoggingKickedMessage extends DofusMessage {
	public static id: number = 2150

	public days: number | undefined = 0
	public hours: number | undefined = 0
	public minutes: number | undefined = 0

	public constructor(
		days?: number | undefined,
		hours?: number | undefined,
		minutes?: number | undefined
	) {
		super()
		this.days = days
		this.hours = hours
		this.minutes = minutes
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarShort(this.days!)
		writer.writeByte(this.hours!)
		writer.writeByte(this.minutes!)
	}

	public deserialize(reader: BinaryReader): void {
		this.days = reader.readVarShort()
		this.hours = reader.readByte()
		this.minutes = reader.readByte()
	}

	public hydrate(
		data: AccountLoggingKickedMessage | Record<string, any>
	): AccountLoggingKickedMessage {
		if (data instanceof AccountLoggingKickedMessage) {
			return data
		}

		this.days = data.days
		this.hours = data.hours
		this.minutes = data.minutes

		return this
	}
}

export interface RawExchangeObjectModifiedInBagMessage
	extends RawExchangeObjectMessage {
	id: number
	object_: ObjectItem
}

export class ExchangeObjectModifiedInBagMessage extends ExchangeObjectMessage {
	public static id = 1372

	public object_: ObjectItem | undefined

	public constructor(
		remote?: boolean | undefined,
		object_?: ObjectItem | undefined
	) {
		super(remote)
		this.object_ = object_
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		this.object_!.serialize(writer)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.object_ = new ObjectItem()
		this.object_!.deserialize(reader)
	}

	public hydrate(
		data: ExchangeObjectModifiedInBagMessage | Record<string, any>
	): ExchangeObjectModifiedInBagMessage {
		if (data instanceof ExchangeObjectModifiedInBagMessage) {
			return data
		}

		super.hydrate(data)

		this.object_ = new ObjectItem().hydrate(data.object_)

		return this
	}
}

export interface RawDebtsUpdateMessage {
	id: number
	action: number
	debts: DebtInformation[]
}

export class DebtsUpdateMessage extends DofusMessage {
	public static id: number = 9975

	public action: number | undefined = 0
	public debts: DebtInformation[] | undefined

	public constructor(
		action?: number | undefined,
		debts?: DebtInformation[] | undefined
	) {
		super()
		this.action = action
		this.debts = debts
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeByte(this.action!)
		writer.writeShort(this.debts!.length)
		this.debts!.forEach((current) => {
			writer.writeShort(current.id)
			current.serialize(writer)
		})
	}

	public deserialize(reader: BinaryReader): void {
		this.action = reader.readByte()
		this.debts = []
		const countDebts = reader.readShort()
		for (let i: number = 0; i < countDebts; i++) {
			const debtsTypeId: number = reader.readShort()
			const type: DebtInformation = new types[debtsTypeId]() as DebtInformation
			type.deserialize(reader)
			this.debts.push(type)
		}
	}

	public hydrate(
		data: DebtsUpdateMessage | Record<string, any>
	): DebtsUpdateMessage {
		if (data instanceof DebtsUpdateMessage) {
			return data
		}

		this.action = data.action
		this.debts = data.debts.map(
			(dataElement: DebtInformation | Record<string, any>): DebtInformation => {
				if (dataElement instanceof DebtInformation) {
					return dataElement
				} else {
					return (new types[dataElement.id]() as DebtInformation).hydrate(
						dataElement
					)
				}
			}
		)

		return this
	}
}

export interface RawGameRolePlayArenaUpdatePlayerInfosMessage {
	id: number
	solo: ArenaRankInfos
}

export class GameRolePlayArenaUpdatePlayerInfosMessage extends DofusMessage {
	public static id: number = 2247

	public solo: ArenaRankInfos | undefined

	public constructor(solo?: ArenaRankInfos | undefined) {
		super()
		this.solo = solo
	}

	public serialize(writer: BinaryWriter): void {
		this.solo!.serialize(writer)
	}

	public deserialize(reader: BinaryReader): void {
		this.solo = new ArenaRankInfos()
		this.solo!.deserialize(reader)
	}

	public hydrate(
		data: GameRolePlayArenaUpdatePlayerInfosMessage | Record<string, any>
	): GameRolePlayArenaUpdatePlayerInfosMessage {
		if (data instanceof GameRolePlayArenaUpdatePlayerInfosMessage) {
			return data
		}

		this.solo = new ArenaRankInfos().hydrate(data.solo)

		return this
	}
}

export interface RawGameRolePlayArenaUpdatePlayerInfosAllQueuesMessage
	extends RawGameRolePlayArenaUpdatePlayerInfosMessage {
	id: number
	team: ArenaRankInfos
	duel: ArenaRankInfos
}

export class GameRolePlayArenaUpdatePlayerInfosAllQueuesMessage extends GameRolePlayArenaUpdatePlayerInfosMessage {
	public static id = 451

	public team: ArenaRankInfos | undefined
	public duel: ArenaRankInfos | undefined

	public constructor(
		solo?: ArenaRankInfos | undefined,
		team?: ArenaRankInfos | undefined,
		duel?: ArenaRankInfos | undefined
	) {
		super(solo)
		this.team = team
		this.duel = duel
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		this.team!.serialize(writer)
		this.duel!.serialize(writer)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.team = new ArenaRankInfos()
		this.team!.deserialize(reader)
		this.duel = new ArenaRankInfos()
		this.duel!.deserialize(reader)
	}

	public hydrate(
		data:
			| GameRolePlayArenaUpdatePlayerInfosAllQueuesMessage
			| Record<string, any>
	): GameRolePlayArenaUpdatePlayerInfosAllQueuesMessage {
		if (data instanceof GameRolePlayArenaUpdatePlayerInfosAllQueuesMessage) {
			return data
		}

		super.hydrate(data)

		this.team = new ArenaRankInfos().hydrate(data.team)
		this.duel = new ArenaRankInfos().hydrate(data.duel)

		return this
	}
}

export interface RawGuildCreationResultMessage {
	id: number
	result: number
}

export class GuildCreationResultMessage extends DofusMessage {
	public static id: number = 6753

	public result: number | undefined = 0

	public constructor(result?: number | undefined) {
		super()
		this.result = result
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeByte(this.result!)
	}

	public deserialize(reader: BinaryReader): void {
		this.result = reader.readByte()
	}

	public hydrate(
		data: GuildCreationResultMessage | Record<string, any>
	): GuildCreationResultMessage {
		if (data instanceof GuildCreationResultMessage) {
			return data
		}

		this.result = data.result

		return this
	}
}

export interface RawExchangeStoppedMessage {
	id: number
	id_: number
}

export class ExchangeStoppedMessage extends DofusMessage {
	public static id: number = 5468

	public id_: number | undefined = 0

	public constructor(id_?: number | undefined) {
		super()
		this.id_ = id_
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarLong(this.id_!)
	}

	public deserialize(reader: BinaryReader): void {
		this.id_ = reader.readVarLong()
	}

	public hydrate(
		data: ExchangeStoppedMessage | Record<string, any>
	): ExchangeStoppedMessage {
		if (data instanceof ExchangeStoppedMessage) {
			return data
		}

		this.id_ = data.id_

		return this
	}
}

export interface RawExchangeShopStockMultiMovementUpdatedMessage {
	id: number
	objectInfoList: ObjectItemToSell[]
}

export class ExchangeShopStockMultiMovementUpdatedMessage extends DofusMessage {
	public static id: number = 230

	public objectInfoList: ObjectItemToSell[] | undefined

	public constructor(objectInfoList?: ObjectItemToSell[] | undefined) {
		super()
		this.objectInfoList = objectInfoList
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeShort(this.objectInfoList!.length)
		this.objectInfoList!.forEach((current) => {
			current.serialize(writer)
		})
	}

	public deserialize(reader: BinaryReader): void {
		this.objectInfoList = []
		const countObjectInfoList = reader.readShort()
		for (let i: number = 0; i < countObjectInfoList; i++) {
			const type: ObjectItemToSell = new ObjectItemToSell()
			type.deserialize(reader)
			this.objectInfoList.push(type)
		}
	}

	public hydrate(
		data: ExchangeShopStockMultiMovementUpdatedMessage | Record<string, any>
	): ExchangeShopStockMultiMovementUpdatedMessage {
		if (data instanceof ExchangeShopStockMultiMovementUpdatedMessage) {
			return data
		}

		this.objectInfoList = data.objectInfoList.map(
			(
				dataElement: ObjectItemToSell | Record<string, any>
			): ObjectItemToSell => {
				if (dataElement instanceof ObjectItemToSell) {
					return dataElement
				} else {
					return new ObjectItemToSell().hydrate(dataElement)
				}
			}
		)

		return this
	}
}

export interface RawAccountInformationsUpdateMessage {
	id: number
	subscriptionEndDate: number
}

export class AccountInformationsUpdateMessage extends DofusMessage {
	public static id: number = 3493

	public subscriptionEndDate: number | undefined = 0

	public constructor(subscriptionEndDate?: number | undefined) {
		super()
		this.subscriptionEndDate = subscriptionEndDate
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeDouble(this.subscriptionEndDate!)
	}

	public deserialize(reader: BinaryReader): void {
		this.subscriptionEndDate = reader.readDouble()
	}

	public hydrate(
		data: AccountInformationsUpdateMessage | Record<string, any>
	): AccountInformationsUpdateMessage {
		if (data instanceof AccountInformationsUpdateMessage) {
			return data
		}

		this.subscriptionEndDate = data.subscriptionEndDate

		return this
	}
}

export interface RawTitleSelectErrorMessage {
	id: number
	reason: number
}

export class TitleSelectErrorMessage extends DofusMessage {
	public static id: number = 7106

	public reason: number | undefined = 0

	public constructor(reason?: number | undefined) {
		super()
		this.reason = reason
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeByte(this.reason!)
	}

	public deserialize(reader: BinaryReader): void {
		this.reason = reader.readByte()
	}

	public hydrate(
		data: TitleSelectErrorMessage | Record<string, any>
	): TitleSelectErrorMessage {
		if (data instanceof TitleSelectErrorMessage) {
			return data
		}

		this.reason = data.reason

		return this
	}
}

export interface RawAccountCapabilitiesMessage {
	id: number
	tutorialAvailable: boolean
	canCreateNewCharacter: boolean
	accountId: number
	breedsVisible: number
	breedsAvailable: number
	status: number
}

export class AccountCapabilitiesMessage extends DofusMessage {
	public static id: number = 7413

	public tutorialAvailable: boolean | undefined = false
	public canCreateNewCharacter: boolean | undefined = false
	public accountId: number | undefined = 0
	public status: number | undefined = -1

	public constructor(
		tutorialAvailable?: boolean | undefined,
		canCreateNewCharacter?: boolean | undefined,
		accountId?: number | undefined,
		status?: number | undefined
	) {
		super()
		this.tutorialAvailable = tutorialAvailable
		this.canCreateNewCharacter = canCreateNewCharacter
		this.accountId = accountId
		this.status = status
	}

	public serialize(writer: BinaryWriter): void {
		let box0: number = 0
		box0 = setFlag(box0, 0, this.tutorialAvailable!)
		box0 = setFlag(box0, 1, this.canCreateNewCharacter!)
		writer.writeByte(box0)
		writer.writeInt(this.accountId!)
		writer.writeByte(this.status!)
	}

	public deserialize(reader: BinaryReader): void {
		const box0 = reader.readByte()
		this.tutorialAvailable = getFlag(box0, 0)
		this.canCreateNewCharacter = getFlag(box0, 1)
		this.accountId = reader.readInt()
		this.status = reader.readByte()
	}

	public hydrate(
		data: AccountCapabilitiesMessage | Record<string, any>
	): AccountCapabilitiesMessage {
		if (data instanceof AccountCapabilitiesMessage) {
			return data
		}

		this.tutorialAvailable = data.tutorialAvailable
		this.canCreateNewCharacter = data.canCreateNewCharacter
		this.accountId = data.accountId
		this.status = data.status

		return this
	}
}

export interface RawTreasureHuntDigRequestAnswerMessage {
	id: number
	questType: number
	result: number
}

export class TreasureHuntDigRequestAnswerMessage extends DofusMessage {
	public static id: number = 1475

	public questType: number | undefined = 0
	public result: number | undefined = 0

	public constructor(
		questType?: number | undefined,
		result?: number | undefined
	) {
		super()
		this.questType = questType
		this.result = result
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeByte(this.questType!)
		writer.writeByte(this.result!)
	}

	public deserialize(reader: BinaryReader): void {
		this.questType = reader.readByte()
		this.result = reader.readByte()
	}

	public hydrate(
		data: TreasureHuntDigRequestAnswerMessage | Record<string, any>
	): TreasureHuntDigRequestAnswerMessage {
		if (data instanceof TreasureHuntDigRequestAnswerMessage) {
			return data
		}

		this.questType = data.questType
		this.result = data.result

		return this
	}
}

export interface RawTreasureHuntDigRequestAnswerFailedMessage
	extends RawTreasureHuntDigRequestAnswerMessage {
	id: number
	wrongFlagCount: number
}

export class TreasureHuntDigRequestAnswerFailedMessage extends TreasureHuntDigRequestAnswerMessage {
	public static id = 9892

	public wrongFlagCount: number | undefined = 0

	public constructor(
		questType?: number | undefined,
		result?: number | undefined,
		wrongFlagCount?: number | undefined
	) {
		super(questType, result)
		this.wrongFlagCount = wrongFlagCount
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeByte(this.wrongFlagCount!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.wrongFlagCount = reader.readByte()
	}

	public hydrate(
		data: TreasureHuntDigRequestAnswerFailedMessage | Record<string, any>
	): TreasureHuntDigRequestAnswerFailedMessage {
		if (data instanceof TreasureHuntDigRequestAnswerFailedMessage) {
			return data
		}

		super.hydrate(data)

		this.wrongFlagCount = data.wrongFlagCount

		return this
	}
}

export interface RawGameEntityDispositionErrorMessage {
	id: number
}

export class GameEntityDispositionErrorMessage extends DofusMessage {
	public static id: number = 7003

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public serialize(writer: BinaryWriter): void {}

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public deserialize(reader: BinaryReader): void {}

	public hydrate(
		data: GameEntityDispositionErrorMessage | Record<string, any>
	): GameEntityDispositionErrorMessage {
		if (data instanceof GameEntityDispositionErrorMessage) {
			return data
		}

		return this
	}
}

export interface RawEmoteAddMessage {
	id: number
	emoteId: number
}

export class EmoteAddMessage extends DofusMessage {
	public static id: number = 5327

	public emoteId: number | undefined = 0

	public constructor(emoteId?: number | undefined) {
		super()
		this.emoteId = emoteId
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeByte(this.emoteId!)
	}

	public deserialize(reader: BinaryReader): void {
		this.emoteId = reader.readByte()
	}

	public hydrate(data: EmoteAddMessage | Record<string, any>): EmoteAddMessage {
		if (data instanceof EmoteAddMessage) {
			return data
		}

		this.emoteId = data.emoteId

		return this
	}
}

export interface RawGuildMotdMessage extends RawSocialNoticeMessage {
	id: number
}

export class GuildMotdMessage extends SocialNoticeMessage {
	public static id = 3362

	public constructor(
		content?: string | undefined,
		timestamp?: number | undefined,
		memberId?: number | undefined,
		memberName?: string | undefined
	) {
		super(content, timestamp, memberId, memberName)
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
	}

	public hydrate(
		data: GuildMotdMessage | Record<string, any>
	): GuildMotdMessage {
		if (data instanceof GuildMotdMessage) {
			return data
		}

		super.hydrate(data)

		return this
	}
}

export interface RawPartyLeaderUpdateMessage
	extends RawAbstractPartyEventMessage {
	id: number
	partyLeaderId: number
}

export class PartyLeaderUpdateMessage extends AbstractPartyEventMessage {
	public static id = 3269

	public partyLeaderId: number | undefined = 0

	public constructor(
		partyId?: number | undefined,
		partyLeaderId?: number | undefined
	) {
		super(partyId)
		this.partyLeaderId = partyLeaderId
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeVarLong(this.partyLeaderId!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.partyLeaderId = reader.readVarLong()
	}

	public hydrate(
		data: PartyLeaderUpdateMessage | Record<string, any>
	): PartyLeaderUpdateMessage {
		if (data instanceof PartyLeaderUpdateMessage) {
			return data
		}

		super.hydrate(data)

		this.partyLeaderId = data.partyLeaderId

		return this
	}
}

export interface RawChatServerMessage extends RawChatAbstractServerMessage {
	id: number
	senderId: number
	senderName: string
	prefix: string
	senderAccountId: number
}

export class ChatServerMessage extends ChatAbstractServerMessage {
	public static id = 5509

	public senderId: number | undefined = 0
	public senderName: string | undefined
	public prefix: string | undefined
	public senderAccountId: number | undefined = 0

	public constructor(
		channel?: number | undefined,
		content?: string | undefined,
		timestamp?: number | undefined,
		fingerprint?: string | undefined,
		senderId?: number | undefined,
		senderName?: string | undefined,
		prefix?: string | undefined,
		senderAccountId?: number | undefined
	) {
		super(channel, content, timestamp, fingerprint)
		this.senderId = senderId
		this.senderName = senderName
		this.prefix = prefix
		this.senderAccountId = senderAccountId
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeDouble(this.senderId!)
		writer.writeUTF(this.senderName!)
		writer.writeUTF(this.prefix!)
		writer.writeInt(this.senderAccountId!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.senderId = reader.readDouble()
		this.senderName = reader.readUTF()
		this.prefix = reader.readUTF()
		this.senderAccountId = reader.readInt()
	}

	public hydrate(
		data: ChatServerMessage | Record<string, any>
	): ChatServerMessage {
		if (data instanceof ChatServerMessage) {
			return data
		}

		super.hydrate(data)

		this.senderId = data.senderId
		this.senderName = data.senderName
		this.prefix = data.prefix
		this.senderAccountId = data.senderAccountId

		return this
	}
}

export interface RawChatAdminServerMessage extends RawChatServerMessage {
	id: number
}

export class ChatAdminServerMessage extends ChatServerMessage {
	public static id = 5240

	public constructor(
		channel?: number | undefined,
		content?: string | undefined,
		timestamp?: number | undefined,
		fingerprint?: string | undefined,
		senderId?: number | undefined,
		senderName?: string | undefined,
		prefix?: string | undefined,
		senderAccountId?: number | undefined
	) {
		super(
			channel,
			content,
			timestamp,
			fingerprint,
			senderId,
			senderName,
			prefix,
			senderAccountId
		)
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
	}

	public hydrate(
		data: ChatAdminServerMessage | Record<string, any>
	): ChatAdminServerMessage {
		if (data instanceof ChatAdminServerMessage) {
			return data
		}

		super.hydrate(data)

		return this
	}
}

export interface RawMountSterilizedMessage {
	id: number
	mountId: number
}

export class MountSterilizedMessage extends DofusMessage {
	public static id: number = 1248

	public mountId: number | undefined = 0

	public constructor(mountId?: number | undefined) {
		super()
		this.mountId = mountId
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarInt(this.mountId!)
	}

	public deserialize(reader: BinaryReader): void {
		this.mountId = reader.readVarInt()
	}

	public hydrate(
		data: MountSterilizedMessage | Record<string, any>
	): MountSterilizedMessage {
		if (data instanceof MountSterilizedMessage) {
			return data
		}

		this.mountId = data.mountId

		return this
	}
}

export interface RawBasicWhoIsMessage {
	id: number
	self: boolean
	verbose: boolean
	position: number
	accountNickname: string
	accountId: number
	playerName: string
	playerId: number
	areaId: number
	serverId: number
	originServerId: number
	socialGroups: AbstractSocialGroupInfos[]
	playerState: number
}

export class BasicWhoIsMessage extends DofusMessage {
	public static id: number = 4158

	public self: boolean | undefined = false
	public verbose: boolean | undefined = false
	public position: number | undefined = -1
	public accountNickname: string | undefined
	public accountId: number | undefined = 0
	public playerName: string | undefined
	public playerId: number | undefined = 0
	public areaId: number | undefined = 0
	public serverId: number | undefined = 0
	public originServerId: number | undefined = 0
	public socialGroups: AbstractSocialGroupInfos[] | undefined
	public playerState: number | undefined = 99

	public constructor(
		self?: boolean | undefined,
		verbose?: boolean | undefined,
		position?: number | undefined,
		accountNickname?: string | undefined,
		accountId?: number | undefined,
		playerName?: string | undefined,
		playerId?: number | undefined,
		areaId?: number | undefined,
		serverId?: number | undefined,
		originServerId?: number | undefined,
		socialGroups?: AbstractSocialGroupInfos[] | undefined,
		playerState?: number | undefined
	) {
		super()
		this.self = self
		this.verbose = verbose
		this.position = position
		this.accountNickname = accountNickname
		this.accountId = accountId
		this.playerName = playerName
		this.playerId = playerId
		this.areaId = areaId
		this.serverId = serverId
		this.originServerId = originServerId
		this.socialGroups = socialGroups
		this.playerState = playerState
	}

	public serialize(writer: BinaryWriter): void {
		let box0: number = 0
		box0 = setFlag(box0, 0, this.self!)
		box0 = setFlag(box0, 1, this.verbose!)
		writer.writeByte(box0)
		writer.writeByte(this.position!)
		writer.writeUTF(this.accountNickname!)
		writer.writeInt(this.accountId!)
		writer.writeUTF(this.playerName!)
		writer.writeVarLong(this.playerId!)
		writer.writeShort(this.areaId!)
		writer.writeShort(this.serverId!)
		writer.writeShort(this.originServerId!)
		writer.writeShort(this.socialGroups!.length)
		this.socialGroups!.forEach((current) => {
			writer.writeShort(current.id)
			current.serialize(writer)
		})
		writer.writeByte(this.playerState!)
	}

	public deserialize(reader: BinaryReader): void {
		const box0 = reader.readByte()
		this.self = getFlag(box0, 0)
		this.verbose = getFlag(box0, 1)
		this.position = reader.readByte()
		this.accountNickname = reader.readUTF()
		this.accountId = reader.readInt()
		this.playerName = reader.readUTF()
		this.playerId = reader.readVarLong()
		this.areaId = reader.readShort()
		this.serverId = reader.readShort()
		this.originServerId = reader.readShort()
		this.socialGroups = []
		const countSocialGroups = reader.readShort()
		for (let i: number = 0; i < countSocialGroups; i++) {
			const socialGroupsTypeId: number = reader.readShort()
			const type: AbstractSocialGroupInfos = new types[
				socialGroupsTypeId
			]() as AbstractSocialGroupInfos
			type.deserialize(reader)
			this.socialGroups.push(type)
		}
		this.playerState = reader.readByte()
	}

	public hydrate(
		data: BasicWhoIsMessage | Record<string, any>
	): BasicWhoIsMessage {
		if (data instanceof BasicWhoIsMessage) {
			return data
		}

		this.self = data.self
		this.verbose = data.verbose
		this.position = data.position
		this.accountNickname = data.accountNickname
		this.accountId = data.accountId
		this.playerName = data.playerName
		this.playerId = data.playerId
		this.areaId = data.areaId
		this.serverId = data.serverId
		this.originServerId = data.originServerId
		this.socialGroups = data.socialGroups.map(
			(
				dataElement: AbstractSocialGroupInfos | Record<string, any>
			): AbstractSocialGroupInfos => {
				if (dataElement instanceof AbstractSocialGroupInfos) {
					return dataElement
				} else {
					return (new types[
						dataElement.id
					]() as AbstractSocialGroupInfos).hydrate(dataElement)
				}
			}
		)
		this.playerState = data.playerState

		return this
	}
}

export interface RawObjectAddedMessage {
	id: number
	object_: ObjectItem
	origin: number
}

export class ObjectAddedMessage extends DofusMessage {
	public static id: number = 1715

	public object_: ObjectItem | undefined
	public origin: number | undefined = 0

	public constructor(
		object_?: ObjectItem | undefined,
		origin?: number | undefined
	) {
		super()
		this.object_ = object_
		this.origin = origin
	}

	public serialize(writer: BinaryWriter): void {
		this.object_!.serialize(writer)
		writer.writeByte(this.origin!)
	}

	public deserialize(reader: BinaryReader): void {
		this.object_ = new ObjectItem()
		this.object_!.deserialize(reader)
		this.origin = reader.readByte()
	}

	public hydrate(
		data: ObjectAddedMessage | Record<string, any>
	): ObjectAddedMessage {
		if (data instanceof ObjectAddedMessage) {
			return data
		}

		this.object_ = new ObjectItem().hydrate(data.object_)
		this.origin = data.origin

		return this
	}
}

export interface RawGameActionNoopMessage {
	id: number
}

export class GameActionNoopMessage extends DofusMessage {
	public static id: number = 3464

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public serialize(writer: BinaryWriter): void {}

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public deserialize(reader: BinaryReader): void {}

	public hydrate(
		data: GameActionNoopMessage | Record<string, any>
	): GameActionNoopMessage {
		if (data instanceof GameActionNoopMessage) {
			return data
		}

		return this
	}
}

export interface RawPopupWarningMessage {
	id: number
	lockDuration: number
	author: string
	content: string
}

export class PopupWarningMessage extends DofusMessage {
	public static id: number = 4006

	public lockDuration: number | undefined = 0
	public author: string | undefined
	public content: string | undefined

	public constructor(
		lockDuration?: number | undefined,
		author?: string | undefined,
		content?: string | undefined
	) {
		super()
		this.lockDuration = lockDuration
		this.author = author
		this.content = content
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeByte(this.lockDuration!)
		writer.writeUTF(this.author!)
		writer.writeUTF(this.content!)
	}

	public deserialize(reader: BinaryReader): void {
		this.lockDuration = reader.readByte()
		this.author = reader.readUTF()
		this.content = reader.readUTF()
	}

	public hydrate(
		data: PopupWarningMessage | Record<string, any>
	): PopupWarningMessage {
		if (data instanceof PopupWarningMessage) {
			return data
		}

		this.lockDuration = data.lockDuration
		this.author = data.author
		this.content = data.content

		return this
	}
}

export interface RawJobExperienceUpdateMessage {
	id: number
	experiencesUpdate: JobExperience
}

export class JobExperienceUpdateMessage extends DofusMessage {
	public static id: number = 4823

	public experiencesUpdate: JobExperience | undefined

	public constructor(experiencesUpdate?: JobExperience | undefined) {
		super()
		this.experiencesUpdate = experiencesUpdate
	}

	public serialize(writer: BinaryWriter): void {
		this.experiencesUpdate!.serialize(writer)
	}

	public deserialize(reader: BinaryReader): void {
		this.experiencesUpdate = new JobExperience()
		this.experiencesUpdate!.deserialize(reader)
	}

	public hydrate(
		data: JobExperienceUpdateMessage | Record<string, any>
	): JobExperienceUpdateMessage {
		if (data instanceof JobExperienceUpdateMessage) {
			return data
		}

		this.experiencesUpdate = new JobExperience().hydrate(data.experiencesUpdate)

		return this
	}
}

export interface RawGuildInformationsPaddocksMessage {
	id: number
	nbPaddockMax: number
	paddocksInformations: PaddockContentInformations[]
}

export class GuildInformationsPaddocksMessage extends DofusMessage {
	public static id: number = 8683

	public nbPaddockMax: number | undefined = 0
	public paddocksInformations: PaddockContentInformations[] | undefined

	public constructor(
		nbPaddockMax?: number | undefined,
		paddocksInformations?: PaddockContentInformations[] | undefined
	) {
		super()
		this.nbPaddockMax = nbPaddockMax
		this.paddocksInformations = paddocksInformations
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeByte(this.nbPaddockMax!)
		writer.writeShort(this.paddocksInformations!.length)
		this.paddocksInformations!.forEach((current) => {
			current.serialize(writer)
		})
	}

	public deserialize(reader: BinaryReader): void {
		this.nbPaddockMax = reader.readByte()
		this.paddocksInformations = []
		const countPaddocksInformations = reader.readShort()
		for (let i: number = 0; i < countPaddocksInformations; i++) {
			const type: PaddockContentInformations = new PaddockContentInformations()
			type.deserialize(reader)
			this.paddocksInformations.push(type)
		}
	}

	public hydrate(
		data: GuildInformationsPaddocksMessage | Record<string, any>
	): GuildInformationsPaddocksMessage {
		if (data instanceof GuildInformationsPaddocksMessage) {
			return data
		}

		this.nbPaddockMax = data.nbPaddockMax
		this.paddocksInformations = data.paddocksInformations.map(
			(
				dataElement: PaddockContentInformations | Record<string, any>
			): PaddockContentInformations => {
				if (dataElement instanceof PaddockContentInformations) {
					return dataElement
				} else {
					return new PaddockContentInformations().hydrate(dataElement)
				}
			}
		)

		return this
	}
}

export interface RawGuildVersatileInfoListMessage {
	id: number
	guilds: GuildVersatileInformations[]
}

export class GuildVersatileInfoListMessage extends DofusMessage {
	public static id: number = 7241

	public guilds: GuildVersatileInformations[] | undefined

	public constructor(guilds?: GuildVersatileInformations[] | undefined) {
		super()
		this.guilds = guilds
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeShort(this.guilds!.length)
		this.guilds!.forEach((current) => {
			writer.writeShort(current.id)
			current.serialize(writer)
		})
	}

	public deserialize(reader: BinaryReader): void {
		this.guilds = []
		const countGuilds = reader.readShort()
		for (let i: number = 0; i < countGuilds; i++) {
			const guildsTypeId: number = reader.readShort()
			const type: GuildVersatileInformations = new types[
				guildsTypeId
			]() as GuildVersatileInformations
			type.deserialize(reader)
			this.guilds.push(type)
		}
	}

	public hydrate(
		data: GuildVersatileInfoListMessage | Record<string, any>
	): GuildVersatileInfoListMessage {
		if (data instanceof GuildVersatileInfoListMessage) {
			return data
		}

		this.guilds = data.guilds.map(
			(
				dataElement: GuildVersatileInformations | Record<string, any>
			): GuildVersatileInformations => {
				if (dataElement instanceof GuildVersatileInformations) {
					return dataElement
				} else {
					return (new types[
						dataElement.id
					]() as GuildVersatileInformations).hydrate(dataElement)
				}
			}
		)

		return this
	}
}

export interface RawIdentificationFailedMessage {
	id: number
	reason: number
}

export class IdentificationFailedMessage extends DofusMessage {
	public static id: number = 4905

	public reason: number | undefined = 99

	public constructor(reason?: number | undefined) {
		super()
		this.reason = reason
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeByte(this.reason!)
	}

	public deserialize(reader: BinaryReader): void {
		this.reason = reader.readByte()
	}

	public hydrate(
		data: IdentificationFailedMessage | Record<string, any>
	): IdentificationFailedMessage {
		if (data instanceof IdentificationFailedMessage) {
			return data
		}

		this.reason = data.reason

		return this
	}
}

export interface RawIdentificationFailedForBadVersionMessage
	extends RawIdentificationFailedMessage {
	id: number
	requiredVersion: Version
}

export class IdentificationFailedForBadVersionMessage extends IdentificationFailedMessage {
	public static id = 8907

	public requiredVersion: Version | undefined

	public constructor(
		reason?: number | undefined,
		requiredVersion?: Version | undefined
	) {
		super(reason)
		this.requiredVersion = requiredVersion
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		this.requiredVersion!.serialize(writer)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.requiredVersion = new Version()
		this.requiredVersion!.deserialize(reader)
	}

	public hydrate(
		data: IdentificationFailedForBadVersionMessage | Record<string, any>
	): IdentificationFailedForBadVersionMessage {
		if (data instanceof IdentificationFailedForBadVersionMessage) {
			return data
		}

		super.hydrate(data)

		this.requiredVersion = new Version().hydrate(data.requiredVersion)

		return this
	}
}

export interface RawJobLevelUpMessage {
	id: number
	newLevel: number
	jobsDescription: JobDescription
}

export class JobLevelUpMessage extends DofusMessage {
	public static id: number = 2061

	public newLevel: number | undefined = 0
	public jobsDescription: JobDescription | undefined

	public constructor(
		newLevel?: number | undefined,
		jobsDescription?: JobDescription | undefined
	) {
		super()
		this.newLevel = newLevel
		this.jobsDescription = jobsDescription
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeByte(this.newLevel!)
		this.jobsDescription!.serialize(writer)
	}

	public deserialize(reader: BinaryReader): void {
		this.newLevel = reader.readByte()
		this.jobsDescription = new JobDescription()
		this.jobsDescription!.deserialize(reader)
	}

	public hydrate(
		data: JobLevelUpMessage | Record<string, any>
	): JobLevelUpMessage {
		if (data instanceof JobLevelUpMessage) {
			return data
		}

		this.newLevel = data.newLevel
		this.jobsDescription = new JobDescription().hydrate(data.jobsDescription)

		return this
	}
}

export interface RawExchangeBidHouseInListAddedMessage {
	id: number
	itemUID: number
	objectGID: number
	objectType: number
	effects: ObjectEffect[]
	prices: number[]
}

export class ExchangeBidHouseInListAddedMessage extends DofusMessage {
	public static id: number = 1407

	public itemUID: number | undefined = 0
	public objectGID: number | undefined = 0
	public objectType: number | undefined = 0
	public effects: ObjectEffect[] | undefined
	public prices: number[] | undefined

	public constructor(
		itemUID?: number | undefined,
		objectGID?: number | undefined,
		objectType?: number | undefined,
		effects?: ObjectEffect[] | undefined,
		prices?: number[] | undefined
	) {
		super()
		this.itemUID = itemUID
		this.objectGID = objectGID
		this.objectType = objectType
		this.effects = effects
		this.prices = prices
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeInt(this.itemUID!)
		writer.writeVarShort(this.objectGID!)
		writer.writeInt(this.objectType!)
		writer.writeShort(this.effects!.length)
		this.effects!.forEach((current) => {
			writer.writeShort(current.id)
			current.serialize(writer)
		})
		writer.writeShort(this.prices!.length)
		this.prices!.forEach((current: number) => writer.writeVarLong(current))
	}

	public deserialize(reader: BinaryReader): void {
		this.itemUID = reader.readInt()
		this.objectGID = reader.readVarShort()
		this.objectType = reader.readInt()
		this.effects = []
		const countEffects = reader.readShort()
		for (let i: number = 0; i < countEffects; i++) {
			const effectsTypeId: number = reader.readShort()
			const type: ObjectEffect = new types[effectsTypeId]() as ObjectEffect
			type.deserialize(reader)
			this.effects.push(type)
		}
		this.prices = []
		const countPrices = reader.readShort()
		for (let i: number = 0; i < countPrices; i++) {
			this.prices.push(reader.readVarLong())
		}
	}

	public hydrate(
		data: ExchangeBidHouseInListAddedMessage | Record<string, any>
	): ExchangeBidHouseInListAddedMessage {
		if (data instanceof ExchangeBidHouseInListAddedMessage) {
			return data
		}

		this.itemUID = data.itemUID
		this.objectGID = data.objectGID
		this.objectType = data.objectType
		this.effects = data.effects.map(
			(dataElement: ObjectEffect | Record<string, any>): ObjectEffect => {
				if (dataElement instanceof ObjectEffect) {
					return dataElement
				} else {
					return (new types[dataElement.id]() as ObjectEffect).hydrate(
						dataElement
					)
				}
			}
		)
		this.prices = data.prices

		return this
	}
}

export interface RawExchangeStartedMountStockMessage {
	id: number
	objectsInfos: ObjectItem[]
}

export class ExchangeStartedMountStockMessage extends DofusMessage {
	public static id: number = 8074

	public objectsInfos: ObjectItem[] | undefined

	public constructor(objectsInfos?: ObjectItem[] | undefined) {
		super()
		this.objectsInfos = objectsInfos
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeShort(this.objectsInfos!.length)
		this.objectsInfos!.forEach((current) => {
			current.serialize(writer)
		})
	}

	public deserialize(reader: BinaryReader): void {
		this.objectsInfos = []
		const countObjectsInfos = reader.readShort()
		for (let i: number = 0; i < countObjectsInfos; i++) {
			const type: ObjectItem = new ObjectItem()
			type.deserialize(reader)
			this.objectsInfos.push(type)
		}
	}

	public hydrate(
		data: ExchangeStartedMountStockMessage | Record<string, any>
	): ExchangeStartedMountStockMessage {
		if (data instanceof ExchangeStartedMountStockMessage) {
			return data
		}

		this.objectsInfos = data.objectsInfos.map(
			(dataElement: ObjectItem | Record<string, any>): ObjectItem => {
				if (dataElement instanceof ObjectItem) {
					return dataElement
				} else {
					return new ObjectItem().hydrate(dataElement)
				}
			}
		)

		return this
	}
}

export interface RawBreachCharactersMessage {
	id: number
	characters: number[]
}

export class BreachCharactersMessage extends DofusMessage {
	public static id: number = 6961

	public characters: number[] | undefined

	public constructor(characters?: number[] | undefined) {
		super()
		this.characters = characters
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeShort(this.characters!.length)
		this.characters!.forEach((current: number) => writer.writeVarLong(current))
	}

	public deserialize(reader: BinaryReader): void {
		this.characters = []
		const countCharacters = reader.readShort()
		for (let i: number = 0; i < countCharacters; i++) {
			this.characters.push(reader.readVarLong())
		}
	}

	public hydrate(
		data: BreachCharactersMessage | Record<string, any>
	): BreachCharactersMessage {
		if (data instanceof BreachCharactersMessage) {
			return data
		}

		this.characters = data.characters

		return this
	}
}

export interface RawAllianceVersatileInfoListMessage {
	id: number
	alliances: AllianceVersatileInformations[]
}

export class AllianceVersatileInfoListMessage extends DofusMessage {
	public static id: number = 815

	public alliances: AllianceVersatileInformations[] | undefined

	public constructor(alliances?: AllianceVersatileInformations[] | undefined) {
		super()
		this.alliances = alliances
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeShort(this.alliances!.length)
		this.alliances!.forEach((current) => {
			current.serialize(writer)
		})
	}

	public deserialize(reader: BinaryReader): void {
		this.alliances = []
		const countAlliances = reader.readShort()
		for (let i: number = 0; i < countAlliances; i++) {
			const type: AllianceVersatileInformations = new AllianceVersatileInformations()
			type.deserialize(reader)
			this.alliances.push(type)
		}
	}

	public hydrate(
		data: AllianceVersatileInfoListMessage | Record<string, any>
	): AllianceVersatileInfoListMessage {
		if (data instanceof AllianceVersatileInfoListMessage) {
			return data
		}

		this.alliances = data.alliances.map(
			(
				dataElement: AllianceVersatileInformations | Record<string, any>
			): AllianceVersatileInformations => {
				if (dataElement instanceof AllianceVersatileInformations) {
					return dataElement
				} else {
					return new AllianceVersatileInformations().hydrate(dataElement)
				}
			}
		)

		return this
	}
}

export interface RawHaapiShopApiKeyMessage {
	id: number
	token: string
}

export class HaapiShopApiKeyMessage extends DofusMessage {
	public static id: number = 2762

	public token: string | undefined

	public constructor(token?: string | undefined) {
		super()
		this.token = token
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeUTF(this.token!)
	}

	public deserialize(reader: BinaryReader): void {
		this.token = reader.readUTF()
	}

	public hydrate(
		data: HaapiShopApiKeyMessage | Record<string, any>
	): HaapiShopApiKeyMessage {
		if (data instanceof HaapiShopApiKeyMessage) {
			return data
		}

		this.token = data.token

		return this
	}
}

export interface RawObjectErrorMessage {
	id: number
	reason: number
}

export class ObjectErrorMessage extends DofusMessage {
	public static id: number = 9812

	public reason: number | undefined = 0

	public constructor(reason?: number | undefined) {
		super()
		this.reason = reason
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeByte(this.reason!)
	}

	public deserialize(reader: BinaryReader): void {
		this.reason = reader.readByte()
	}

	public hydrate(
		data: ObjectErrorMessage | Record<string, any>
	): ObjectErrorMessage {
		if (data instanceof ObjectErrorMessage) {
			return data
		}

		this.reason = data.reason

		return this
	}
}

export interface RawSymbioticObjectErrorMessage extends RawObjectErrorMessage {
	id: number
	errorCode: number
}

export class SymbioticObjectErrorMessage extends ObjectErrorMessage {
	public static id = 5316

	public errorCode: number | undefined = 0

	public constructor(
		reason?: number | undefined,
		errorCode?: number | undefined
	) {
		super(reason)
		this.errorCode = errorCode
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeByte(this.errorCode!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.errorCode = reader.readByte()
	}

	public hydrate(
		data: SymbioticObjectErrorMessage | Record<string, any>
	): SymbioticObjectErrorMessage {
		if (data instanceof SymbioticObjectErrorMessage) {
			return data
		}

		super.hydrate(data)

		this.errorCode = data.errorCode

		return this
	}
}

export interface RawMimicryObjectErrorMessage
	extends RawSymbioticObjectErrorMessage {
	id: number
	preview: boolean
}

export class MimicryObjectErrorMessage extends SymbioticObjectErrorMessage {
	public static id = 6833

	public preview: boolean | undefined = false

	public constructor(
		reason?: number | undefined,
		errorCode?: number | undefined,
		preview?: boolean | undefined
	) {
		super(reason, errorCode)
		this.preview = preview
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeBoolean(this.preview!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.preview = reader.readBoolean()
	}

	public hydrate(
		data: MimicryObjectErrorMessage | Record<string, any>
	): MimicryObjectErrorMessage {
		if (data instanceof MimicryObjectErrorMessage) {
			return data
		}

		super.hydrate(data)

		this.preview = data.preview

		return this
	}
}

export interface RawKohUpdateMessage {
	id: number
	alliances: AllianceInformations[]
	allianceNbMembers: number[]
	allianceRoundWeigth: number[]
	allianceMatchScore: number[]
	allianceMapWinners: BasicAllianceInformations[]
	allianceMapWinnerScore: number
	allianceMapMyAllianceScore: number
	nextTickTime: number
}

export class KohUpdateMessage extends DofusMessage {
	public static id: number = 5197

	public alliances: AllianceInformations[] | undefined
	public allianceNbMembers: number[] | undefined
	public allianceRoundWeigth: number[] | undefined
	public allianceMatchScore: number[] | undefined
	public allianceMapWinners: BasicAllianceInformations[] | undefined
	public allianceMapWinnerScore: number | undefined = 0
	public allianceMapMyAllianceScore: number | undefined = 0
	public nextTickTime: number | undefined = 0

	public constructor(
		alliances?: AllianceInformations[] | undefined,
		allianceNbMembers?: number[] | undefined,
		allianceRoundWeigth?: number[] | undefined,
		allianceMatchScore?: number[] | undefined,
		allianceMapWinners?: BasicAllianceInformations[] | undefined,
		allianceMapWinnerScore?: number | undefined,
		allianceMapMyAllianceScore?: number | undefined,
		nextTickTime?: number | undefined
	) {
		super()
		this.alliances = alliances
		this.allianceNbMembers = allianceNbMembers
		this.allianceRoundWeigth = allianceRoundWeigth
		this.allianceMatchScore = allianceMatchScore
		this.allianceMapWinners = allianceMapWinners
		this.allianceMapWinnerScore = allianceMapWinnerScore
		this.allianceMapMyAllianceScore = allianceMapMyAllianceScore
		this.nextTickTime = nextTickTime
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeShort(this.alliances!.length)
		this.alliances!.forEach((current) => {
			current.serialize(writer)
		})
		writer.writeShort(this.allianceNbMembers!.length)
		this.allianceNbMembers!.forEach((current: number) =>
			writer.writeVarShort(current)
		)
		writer.writeShort(this.allianceRoundWeigth!.length)
		this.allianceRoundWeigth!.forEach((current: number) =>
			writer.writeVarInt(current)
		)
		writer.writeShort(this.allianceMatchScore!.length)
		this.allianceMatchScore!.forEach((current: number) =>
			writer.writeByte(current)
		)
		writer.writeShort(this.allianceMapWinners!.length)
		this.allianceMapWinners!.forEach((current) => {
			current.serialize(writer)
		})
		writer.writeVarInt(this.allianceMapWinnerScore!)
		writer.writeVarInt(this.allianceMapMyAllianceScore!)
		writer.writeDouble(this.nextTickTime!)
	}

	public deserialize(reader: BinaryReader): void {
		this.alliances = []
		const countAlliances = reader.readShort()
		for (let i: number = 0; i < countAlliances; i++) {
			const type: AllianceInformations = new AllianceInformations()
			type.deserialize(reader)
			this.alliances.push(type)
		}
		this.allianceNbMembers = []
		const countAllianceNbMembers = reader.readShort()
		for (let i: number = 0; i < countAllianceNbMembers; i++) {
			this.allianceNbMembers.push(reader.readVarShort())
		}
		this.allianceRoundWeigth = []
		const countAllianceRoundWeigth = reader.readShort()
		for (let i: number = 0; i < countAllianceRoundWeigth; i++) {
			this.allianceRoundWeigth.push(reader.readVarInt())
		}
		this.allianceMatchScore = []
		const countAllianceMatchScore = reader.readShort()
		for (let i: number = 0; i < countAllianceMatchScore; i++) {
			this.allianceMatchScore.push(reader.readByte())
		}
		this.allianceMapWinners = []
		const countAllianceMapWinners = reader.readShort()
		for (let i: number = 0; i < countAllianceMapWinners; i++) {
			const type: BasicAllianceInformations = new BasicAllianceInformations()
			type.deserialize(reader)
			this.allianceMapWinners.push(type)
		}
		this.allianceMapWinnerScore = reader.readVarInt()
		this.allianceMapMyAllianceScore = reader.readVarInt()
		this.nextTickTime = reader.readDouble()
	}

	public hydrate(
		data: KohUpdateMessage | Record<string, any>
	): KohUpdateMessage {
		if (data instanceof KohUpdateMessage) {
			return data
		}

		this.alliances = data.alliances.map(
			(
				dataElement: AllianceInformations | Record<string, any>
			): AllianceInformations => {
				if (dataElement instanceof AllianceInformations) {
					return dataElement
				} else {
					return new AllianceInformations().hydrate(dataElement)
				}
			}
		)
		this.allianceNbMembers = data.allianceNbMembers
		this.allianceRoundWeigth = data.allianceRoundWeigth
		this.allianceMatchScore = data.allianceMatchScore
		this.allianceMapWinners = data.allianceMapWinners.map(
			(
				dataElement: BasicAllianceInformations | Record<string, any>
			): BasicAllianceInformations => {
				if (dataElement instanceof BasicAllianceInformations) {
					return dataElement
				} else {
					return new BasicAllianceInformations().hydrate(dataElement)
				}
			}
		)
		this.allianceMapWinnerScore = data.allianceMapWinnerScore
		this.allianceMapMyAllianceScore = data.allianceMapMyAllianceScore
		this.nextTickTime = data.nextTickTime

		return this
	}
}

export interface RawClientUIOpenedMessage {
	id: number
	type: number
}

export class ClientUIOpenedMessage extends DofusMessage {
	public static id: number = 4819

	public type: number | undefined = 0

	public constructor(type?: number | undefined) {
		super()
		this.type = type
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeByte(this.type!)
	}

	public deserialize(reader: BinaryReader): void {
		this.type = reader.readByte()
	}

	public hydrate(
		data: ClientUIOpenedMessage | Record<string, any>
	): ClientUIOpenedMessage {
		if (data instanceof ClientUIOpenedMessage) {
			return data
		}

		this.type = data.type

		return this
	}
}

export interface RawClientUIOpenedByObjectMessage
	extends RawClientUIOpenedMessage {
	id: number
	uid: number
}

export class ClientUIOpenedByObjectMessage extends ClientUIOpenedMessage {
	public static id = 4274

	public uid: number | undefined = 0

	public constructor(type?: number | undefined, uid?: number | undefined) {
		super(type)
		this.uid = uid
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeVarInt(this.uid!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.uid = reader.readVarInt()
	}

	public hydrate(
		data: ClientUIOpenedByObjectMessage | Record<string, any>
	): ClientUIOpenedByObjectMessage {
		if (data instanceof ClientUIOpenedByObjectMessage) {
			return data
		}

		super.hydrate(data)

		this.uid = data.uid

		return this
	}
}

export interface RawTeleportBuddiesRequestedMessage {
	id: number
	dungeonId: number
	inviterId: number
	invalidBuddiesIds: number[]
}

export class TeleportBuddiesRequestedMessage extends DofusMessage {
	public static id: number = 2270

	public dungeonId: number | undefined = 0
	public inviterId: number | undefined = 0
	public invalidBuddiesIds: number[] | undefined

	public constructor(
		dungeonId?: number | undefined,
		inviterId?: number | undefined,
		invalidBuddiesIds?: number[] | undefined
	) {
		super()
		this.dungeonId = dungeonId
		this.inviterId = inviterId
		this.invalidBuddiesIds = invalidBuddiesIds
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarShort(this.dungeonId!)
		writer.writeVarLong(this.inviterId!)
		writer.writeShort(this.invalidBuddiesIds!.length)
		this.invalidBuddiesIds!.forEach((current: number) =>
			writer.writeVarLong(current)
		)
	}

	public deserialize(reader: BinaryReader): void {
		this.dungeonId = reader.readVarShort()
		this.inviterId = reader.readVarLong()
		this.invalidBuddiesIds = []
		const countInvalidBuddiesIds = reader.readShort()
		for (let i: number = 0; i < countInvalidBuddiesIds; i++) {
			this.invalidBuddiesIds.push(reader.readVarLong())
		}
	}

	public hydrate(
		data: TeleportBuddiesRequestedMessage | Record<string, any>
	): TeleportBuddiesRequestedMessage {
		if (data instanceof TeleportBuddiesRequestedMessage) {
			return data
		}

		this.dungeonId = data.dungeonId
		this.inviterId = data.inviterId
		this.invalidBuddiesIds = data.invalidBuddiesIds

		return this
	}
}

export interface RawExchangeStartOkEvolutiveObjectRecycleTradeMessage {
	id: number
}

export class ExchangeStartOkEvolutiveObjectRecycleTradeMessage extends DofusMessage {
	public static id: number = 9997

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public serialize(writer: BinaryWriter): void {}

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public deserialize(reader: BinaryReader): void {}

	public hydrate(
		data:
			| ExchangeStartOkEvolutiveObjectRecycleTradeMessage
			| Record<string, any>
	): ExchangeStartOkEvolutiveObjectRecycleTradeMessage {
		if (data instanceof ExchangeStartOkEvolutiveObjectRecycleTradeMessage) {
			return data
		}

		return this
	}
}

export interface RawExchangeCraftPaymentModifiedMessage {
	id: number
	goldSum: number
}

export class ExchangeCraftPaymentModifiedMessage extends DofusMessage {
	public static id: number = 8994

	public goldSum: number | undefined = 0

	public constructor(goldSum?: number | undefined) {
		super()
		this.goldSum = goldSum
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarLong(this.goldSum!)
	}

	public deserialize(reader: BinaryReader): void {
		this.goldSum = reader.readVarLong()
	}

	public hydrate(
		data: ExchangeCraftPaymentModifiedMessage | Record<string, any>
	): ExchangeCraftPaymentModifiedMessage {
		if (data instanceof ExchangeCraftPaymentModifiedMessage) {
			return data
		}

		this.goldSum = data.goldSum

		return this
	}
}

export interface RawAllianceMotdSetErrorMessage
	extends RawSocialNoticeSetErrorMessage {
	id: number
}

export class AllianceMotdSetErrorMessage extends SocialNoticeSetErrorMessage {
	public static id = 2111

	public constructor(reason?: number | undefined) {
		super(reason)
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
	}

	public hydrate(
		data: AllianceMotdSetErrorMessage | Record<string, any>
	): AllianceMotdSetErrorMessage {
		if (data instanceof AllianceMotdSetErrorMessage) {
			return data
		}

		super.hydrate(data)

		return this
	}
}

export interface RawLeaveDialogMessage {
	id: number
	dialogType: number
}

export class LeaveDialogMessage extends DofusMessage {
	public static id: number = 2479

	public dialogType: number | undefined = 0

	public constructor(dialogType?: number | undefined) {
		super()
		this.dialogType = dialogType
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeByte(this.dialogType!)
	}

	public deserialize(reader: BinaryReader): void {
		this.dialogType = reader.readByte()
	}

	public hydrate(
		data: LeaveDialogMessage | Record<string, any>
	): LeaveDialogMessage {
		if (data instanceof LeaveDialogMessage) {
			return data
		}

		this.dialogType = data.dialogType

		return this
	}
}

export interface RawExchangeLeaveMessage extends RawLeaveDialogMessage {
	id: number
	success: boolean
}

export class ExchangeLeaveMessage extends LeaveDialogMessage {
	public static id = 4632

	public success: boolean | undefined = false

	public constructor(
		dialogType?: number | undefined,
		success?: boolean | undefined
	) {
		super(dialogType)
		this.success = success
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeBoolean(this.success!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.success = reader.readBoolean()
	}

	public hydrate(
		data: ExchangeLeaveMessage | Record<string, any>
	): ExchangeLeaveMessage {
		if (data instanceof ExchangeLeaveMessage) {
			return data
		}

		super.hydrate(data)

		this.success = data.success

		return this
	}
}

export interface RawTaxCollectorErrorMessage {
	id: number
	reason: number
}

export class TaxCollectorErrorMessage extends DofusMessage {
	public static id: number = 8117

	public reason: number | undefined = 0

	public constructor(reason?: number | undefined) {
		super()
		this.reason = reason
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeByte(this.reason!)
	}

	public deserialize(reader: BinaryReader): void {
		this.reason = reader.readByte()
	}

	public hydrate(
		data: TaxCollectorErrorMessage | Record<string, any>
	): TaxCollectorErrorMessage {
		if (data instanceof TaxCollectorErrorMessage) {
			return data
		}

		this.reason = data.reason

		return this
	}
}

export interface RawBreachRoomLockedMessage {
	id: number
}

export class BreachRoomLockedMessage extends DofusMessage {
	public static id: number = 6303

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public serialize(writer: BinaryWriter): void {}

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public deserialize(reader: BinaryReader): void {}

	public hydrate(
		data: BreachRoomLockedMessage | Record<string, any>
	): BreachRoomLockedMessage {
		if (data instanceof BreachRoomLockedMessage) {
			return data
		}

		return this
	}
}

export interface RawIdolListMessage {
	id: number
	chosenIdols: number[]
	partyChosenIdols: number[]
	partyIdols: PartyIdol[]
}

export class IdolListMessage extends DofusMessage {
	public static id: number = 6079

	public chosenIdols: number[] | undefined
	public partyChosenIdols: number[] | undefined
	public partyIdols: PartyIdol[] | undefined

	public constructor(
		chosenIdols?: number[] | undefined,
		partyChosenIdols?: number[] | undefined,
		partyIdols?: PartyIdol[] | undefined
	) {
		super()
		this.chosenIdols = chosenIdols
		this.partyChosenIdols = partyChosenIdols
		this.partyIdols = partyIdols
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeShort(this.chosenIdols!.length)
		this.chosenIdols!.forEach((current: number) =>
			writer.writeVarShort(current)
		)
		writer.writeShort(this.partyChosenIdols!.length)
		this.partyChosenIdols!.forEach((current: number) =>
			writer.writeVarShort(current)
		)
		writer.writeShort(this.partyIdols!.length)
		this.partyIdols!.forEach((current) => {
			writer.writeShort(current.id)
			current.serialize(writer)
		})
	}

	public deserialize(reader: BinaryReader): void {
		this.chosenIdols = []
		const countChosenIdols = reader.readShort()
		for (let i: number = 0; i < countChosenIdols; i++) {
			this.chosenIdols.push(reader.readVarShort())
		}
		this.partyChosenIdols = []
		const countPartyChosenIdols = reader.readShort()
		for (let i: number = 0; i < countPartyChosenIdols; i++) {
			this.partyChosenIdols.push(reader.readVarShort())
		}
		this.partyIdols = []
		const countPartyIdols = reader.readShort()
		for (let i: number = 0; i < countPartyIdols; i++) {
			const partyIdolsTypeId: number = reader.readShort()
			const type: PartyIdol = new types[partyIdolsTypeId]() as PartyIdol
			type.deserialize(reader)
			this.partyIdols.push(type)
		}
	}

	public hydrate(data: IdolListMessage | Record<string, any>): IdolListMessage {
		if (data instanceof IdolListMessage) {
			return data
		}

		this.chosenIdols = data.chosenIdols
		this.partyChosenIdols = data.partyChosenIdols
		this.partyIdols = data.partyIdols.map(
			(dataElement: PartyIdol | Record<string, any>): PartyIdol => {
				if (dataElement instanceof PartyIdol) {
					return dataElement
				} else {
					return (new types[dataElement.id]() as PartyIdol).hydrate(dataElement)
				}
			}
		)

		return this
	}
}

export interface RawEmoteRemoveMessage {
	id: number
	emoteId: number
}

export class EmoteRemoveMessage extends DofusMessage {
	public static id: number = 3309

	public emoteId: number | undefined = 0

	public constructor(emoteId?: number | undefined) {
		super()
		this.emoteId = emoteId
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeByte(this.emoteId!)
	}

	public deserialize(reader: BinaryReader): void {
		this.emoteId = reader.readByte()
	}

	public hydrate(
		data: EmoteRemoveMessage | Record<string, any>
	): EmoteRemoveMessage {
		if (data instanceof EmoteRemoveMessage) {
			return data
		}

		this.emoteId = data.emoteId

		return this
	}
}

export interface RawExchangeGuildTaxCollectorGetMessage {
	id: number
	collectorName: string
	worldX: number
	worldY: number
	mapId: number
	subAreaId: number
	userName: string
	callerId: number
	callerName: string
	experience: number
	pods: number
	objectsInfos: ObjectItemGenericQuantity[]
}

export class ExchangeGuildTaxCollectorGetMessage extends DofusMessage {
	public static id: number = 2268

	public collectorName: string | undefined
	public worldX: number | undefined = 0
	public worldY: number | undefined = 0
	public mapId: number | undefined = 0
	public subAreaId: number | undefined = 0
	public userName: string | undefined
	public callerId: number | undefined = 0
	public callerName: string | undefined
	public experience: number | undefined = 0
	public pods: number | undefined = 0
	public objectsInfos: ObjectItemGenericQuantity[] | undefined

	public constructor(
		collectorName?: string | undefined,
		worldX?: number | undefined,
		worldY?: number | undefined,
		mapId?: number | undefined,
		subAreaId?: number | undefined,
		userName?: string | undefined,
		callerId?: number | undefined,
		callerName?: string | undefined,
		experience?: number | undefined,
		pods?: number | undefined,
		objectsInfos?: ObjectItemGenericQuantity[] | undefined
	) {
		super()
		this.collectorName = collectorName
		this.worldX = worldX
		this.worldY = worldY
		this.mapId = mapId
		this.subAreaId = subAreaId
		this.userName = userName
		this.callerId = callerId
		this.callerName = callerName
		this.experience = experience
		this.pods = pods
		this.objectsInfos = objectsInfos
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeUTF(this.collectorName!)
		writer.writeShort(this.worldX!)
		writer.writeShort(this.worldY!)
		writer.writeDouble(this.mapId!)
		writer.writeVarShort(this.subAreaId!)
		writer.writeUTF(this.userName!)
		writer.writeVarLong(this.callerId!)
		writer.writeUTF(this.callerName!)
		writer.writeDouble(this.experience!)
		writer.writeVarShort(this.pods!)
		writer.writeShort(this.objectsInfos!.length)
		this.objectsInfos!.forEach((current) => {
			current.serialize(writer)
		})
	}

	public deserialize(reader: BinaryReader): void {
		this.collectorName = reader.readUTF()
		this.worldX = reader.readShort()
		this.worldY = reader.readShort()
		this.mapId = reader.readDouble()
		this.subAreaId = reader.readVarShort()
		this.userName = reader.readUTF()
		this.callerId = reader.readVarLong()
		this.callerName = reader.readUTF()
		this.experience = reader.readDouble()
		this.pods = reader.readVarShort()
		this.objectsInfos = []
		const countObjectsInfos = reader.readShort()
		for (let i: number = 0; i < countObjectsInfos; i++) {
			const type: ObjectItemGenericQuantity = new ObjectItemGenericQuantity()
			type.deserialize(reader)
			this.objectsInfos.push(type)
		}
	}

	public hydrate(
		data: ExchangeGuildTaxCollectorGetMessage | Record<string, any>
	): ExchangeGuildTaxCollectorGetMessage {
		if (data instanceof ExchangeGuildTaxCollectorGetMessage) {
			return data
		}

		this.collectorName = data.collectorName
		this.worldX = data.worldX
		this.worldY = data.worldY
		this.mapId = data.mapId
		this.subAreaId = data.subAreaId
		this.userName = data.userName
		this.callerId = data.callerId
		this.callerName = data.callerName
		this.experience = data.experience
		this.pods = data.pods
		this.objectsInfos = data.objectsInfos.map(
			(
				dataElement: ObjectItemGenericQuantity | Record<string, any>
			): ObjectItemGenericQuantity => {
				if (dataElement instanceof ObjectItemGenericQuantity) {
					return dataElement
				} else {
					return new ObjectItemGenericQuantity().hydrate(dataElement)
				}
			}
		)

		return this
	}
}

export interface RawGuildMotdSetErrorMessage
	extends RawSocialNoticeSetErrorMessage {
	id: number
}

export class GuildMotdSetErrorMessage extends SocialNoticeSetErrorMessage {
	public static id = 338

	public constructor(reason?: number | undefined) {
		super(reason)
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
	}

	public hydrate(
		data: GuildMotdSetErrorMessage | Record<string, any>
	): GuildMotdSetErrorMessage {
		if (data instanceof GuildMotdSetErrorMessage) {
			return data
		}

		super.hydrate(data)

		return this
	}
}

export interface RawGameRolePlayArenaSwitchToGameServerMessage {
	id: number
	validToken: boolean
	ticket: number[]
	homeServerId: number
}

export class GameRolePlayArenaSwitchToGameServerMessage extends DofusMessage {
	public static id: number = 6943

	public validToken: boolean | undefined = false
	public ticket: number[] | undefined
	public homeServerId: number | undefined = 0

	public constructor(
		validToken?: boolean | undefined,
		ticket?: number[] | undefined,
		homeServerId?: number | undefined
	) {
		super()
		this.validToken = validToken
		this.ticket = ticket
		this.homeServerId = homeServerId
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeBoolean(this.validToken!)
		writer.writeVarInt(this.ticket!.length)
		this.ticket!.forEach((current: number) => writer.writeByte(current))
		writer.writeShort(this.homeServerId!)
	}

	public deserialize(reader: BinaryReader): void {
		this.validToken = reader.readBoolean()
		this.ticket = []
		const countTicket = reader.readVarInt()
		for (let i: number = 0; i < countTicket; i++) {
			this.ticket.push(reader.readByte())
		}
		this.homeServerId = reader.readShort()
	}

	public hydrate(
		data: GameRolePlayArenaSwitchToGameServerMessage | Record<string, any>
	): GameRolePlayArenaSwitchToGameServerMessage {
		if (data instanceof GameRolePlayArenaSwitchToGameServerMessage) {
			return data
		}

		this.validToken = data.validToken
		this.ticket = data.ticket
		this.homeServerId = data.homeServerId

		return this
	}
}

export interface RawContactLookMessage {
	id: number
	requestId: number
	playerName: string
	playerId: number
	look: EntityLook
}

export class ContactLookMessage extends DofusMessage {
	public static id: number = 4440

	public requestId: number | undefined = 0
	public playerName: string | undefined
	public playerId: number | undefined = 0
	public look: EntityLook | undefined

	public constructor(
		requestId?: number | undefined,
		playerName?: string | undefined,
		playerId?: number | undefined,
		look?: EntityLook | undefined
	) {
		super()
		this.requestId = requestId
		this.playerName = playerName
		this.playerId = playerId
		this.look = look
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarInt(this.requestId!)
		writer.writeUTF(this.playerName!)
		writer.writeVarLong(this.playerId!)
		this.look!.serialize(writer)
	}

	public deserialize(reader: BinaryReader): void {
		this.requestId = reader.readVarInt()
		this.playerName = reader.readUTF()
		this.playerId = reader.readVarLong()
		this.look = new EntityLook()
		this.look!.deserialize(reader)
	}

	public hydrate(
		data: ContactLookMessage | Record<string, any>
	): ContactLookMessage {
		if (data instanceof ContactLookMessage) {
			return data
		}

		this.requestId = data.requestId
		this.playerName = data.playerName
		this.playerId = data.playerId
		this.look = new EntityLook().hydrate(data.look)

		return this
	}
}

export interface RawAlliancePartialListMessage extends RawAllianceListMessage {
	id: number
}

export class AlliancePartialListMessage extends AllianceListMessage {
	public static id = 4368

	public constructor(alliances?: AllianceFactSheetInformations[] | undefined) {
		super(alliances)
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
	}

	public hydrate(
		data: AlliancePartialListMessage | Record<string, any>
	): AlliancePartialListMessage {
		if (data instanceof AlliancePartialListMessage) {
			return data
		}

		super.hydrate(data)

		return this
	}
}

export interface RawMapRunningFightDetailsMessage {
	id: number
	fightId: number
	attackers: GameFightFighterLightInformations[]
	defenders: GameFightFighterLightInformations[]
}

export class MapRunningFightDetailsMessage extends DofusMessage {
	public static id: number = 8222

	public fightId: number | undefined = 0
	public attackers: GameFightFighterLightInformations[] | undefined
	public defenders: GameFightFighterLightInformations[] | undefined

	public constructor(
		fightId?: number | undefined,
		attackers?: GameFightFighterLightInformations[] | undefined,
		defenders?: GameFightFighterLightInformations[] | undefined
	) {
		super()
		this.fightId = fightId
		this.attackers = attackers
		this.defenders = defenders
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarShort(this.fightId!)
		writer.writeShort(this.attackers!.length)
		this.attackers!.forEach((current) => {
			writer.writeShort(current.id)
			current.serialize(writer)
		})
		writer.writeShort(this.defenders!.length)
		this.defenders!.forEach((current) => {
			writer.writeShort(current.id)
			current.serialize(writer)
		})
	}

	public deserialize(reader: BinaryReader): void {
		this.fightId = reader.readVarShort()
		this.attackers = []
		const countAttackers = reader.readShort()
		for (let i: number = 0; i < countAttackers; i++) {
			const attackersTypeId: number = reader.readShort()
			const type: GameFightFighterLightInformations = new types[
				attackersTypeId
			]() as GameFightFighterLightInformations
			type.deserialize(reader)
			this.attackers.push(type)
		}
		this.defenders = []
		const countDefenders = reader.readShort()
		for (let i: number = 0; i < countDefenders; i++) {
			const defendersTypeId: number = reader.readShort()
			const type: GameFightFighterLightInformations = new types[
				defendersTypeId
			]() as GameFightFighterLightInformations
			type.deserialize(reader)
			this.defenders.push(type)
		}
	}

	public hydrate(
		data: MapRunningFightDetailsMessage | Record<string, any>
	): MapRunningFightDetailsMessage {
		if (data instanceof MapRunningFightDetailsMessage) {
			return data
		}

		this.fightId = data.fightId
		this.attackers = data.attackers.map(
			(
				dataElement: GameFightFighterLightInformations | Record<string, any>
			): GameFightFighterLightInformations => {
				if (dataElement instanceof GameFightFighterLightInformations) {
					return dataElement
				} else {
					return (new types[
						dataElement.id
					]() as GameFightFighterLightInformations).hydrate(dataElement)
				}
			}
		)
		this.defenders = data.defenders.map(
			(
				dataElement: GameFightFighterLightInformations | Record<string, any>
			): GameFightFighterLightInformations => {
				if (dataElement instanceof GameFightFighterLightInformations) {
					return dataElement
				} else {
					return (new types[
						dataElement.id
					]() as GameFightFighterLightInformations).hydrate(dataElement)
				}
			}
		)

		return this
	}
}

export interface RawMapRunningFightDetailsExtendedMessage
	extends RawMapRunningFightDetailsMessage {
	id: number
	namedPartyTeams: NamedPartyTeam[]
}

export class MapRunningFightDetailsExtendedMessage extends MapRunningFightDetailsMessage {
	public static id = 3172

	public namedPartyTeams: NamedPartyTeam[] | undefined

	public constructor(
		fightId?: number | undefined,
		attackers?: GameFightFighterLightInformations[] | undefined,
		defenders?: GameFightFighterLightInformations[] | undefined,
		namedPartyTeams?: NamedPartyTeam[] | undefined
	) {
		super(fightId, attackers, defenders)
		this.namedPartyTeams = namedPartyTeams
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeShort(this.namedPartyTeams!.length)
		this.namedPartyTeams!.forEach((current) => {
			current.serialize(writer)
		})
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.namedPartyTeams = []
		const countNamedPartyTeams = reader.readShort()
		for (let i: number = 0; i < countNamedPartyTeams; i++) {
			const type: NamedPartyTeam = new NamedPartyTeam()
			type.deserialize(reader)
			this.namedPartyTeams.push(type)
		}
	}

	public hydrate(
		data: MapRunningFightDetailsExtendedMessage | Record<string, any>
	): MapRunningFightDetailsExtendedMessage {
		if (data instanceof MapRunningFightDetailsExtendedMessage) {
			return data
		}

		super.hydrate(data)

		this.namedPartyTeams = data.namedPartyTeams.map(
			(dataElement: NamedPartyTeam | Record<string, any>): NamedPartyTeam => {
				if (dataElement instanceof NamedPartyTeam) {
					return dataElement
				} else {
					return new NamedPartyTeam().hydrate(dataElement)
				}
			}
		)

		return this
	}
}

export interface RawAcquaintanceServerListMessage {
	id: number
	servers: number[]
}

export class AcquaintanceServerListMessage extends DofusMessage {
	public static id: number = 1800

	public servers: number[] | undefined

	public constructor(servers?: number[] | undefined) {
		super()
		this.servers = servers
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeShort(this.servers!.length)
		this.servers!.forEach((current: number) => writer.writeVarShort(current))
	}

	public deserialize(reader: BinaryReader): void {
		this.servers = []
		const countServers = reader.readShort()
		for (let i: number = 0; i < countServers; i++) {
			this.servers.push(reader.readVarShort())
		}
	}

	public hydrate(
		data: AcquaintanceServerListMessage | Record<string, any>
	): AcquaintanceServerListMessage {
		if (data instanceof AcquaintanceServerListMessage) {
			return data
		}

		this.servers = data.servers

		return this
	}
}

export interface RawDungeonPartyFinderRegisterErrorMessage {
	id: number
}

export class DungeonPartyFinderRegisterErrorMessage extends DofusMessage {
	public static id: number = 8304

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public serialize(writer: BinaryWriter): void {}

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public deserialize(reader: BinaryReader): void {}

	public hydrate(
		data: DungeonPartyFinderRegisterErrorMessage | Record<string, any>
	): DungeonPartyFinderRegisterErrorMessage {
		if (data instanceof DungeonPartyFinderRegisterErrorMessage) {
			return data
		}

		return this
	}
}

export interface RawEmoteListMessage {
	id: number
	emoteIds: number[]
}

export class EmoteListMessage extends DofusMessage {
	public static id: number = 8072

	public emoteIds: number[] | undefined

	public constructor(emoteIds?: number[] | undefined) {
		super()
		this.emoteIds = emoteIds
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeShort(this.emoteIds!.length)
		this.emoteIds!.forEach((current: number) => writer.writeByte(current))
	}

	public deserialize(reader: BinaryReader): void {
		this.emoteIds = []
		const countEmoteIds = reader.readShort()
		for (let i: number = 0; i < countEmoteIds; i++) {
			this.emoteIds.push(reader.readByte())
		}
	}

	public hydrate(
		data: EmoteListMessage | Record<string, any>
	): EmoteListMessage {
		if (data instanceof EmoteListMessage) {
			return data
		}

		this.emoteIds = data.emoteIds

		return this
	}
}

export interface RawTitlesAndOrnamentsListMessage {
	id: number
	titles: number[]
	ornaments: number[]
	activeTitle: number
	activeOrnament: number
}

export class TitlesAndOrnamentsListMessage extends DofusMessage {
	public static id: number = 4737

	public titles: number[] | undefined
	public ornaments: number[] | undefined
	public activeTitle: number | undefined = 0
	public activeOrnament: number | undefined = 0

	public constructor(
		titles?: number[] | undefined,
		ornaments?: number[] | undefined,
		activeTitle?: number | undefined,
		activeOrnament?: number | undefined
	) {
		super()
		this.titles = titles
		this.ornaments = ornaments
		this.activeTitle = activeTitle
		this.activeOrnament = activeOrnament
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeShort(this.titles!.length)
		this.titles!.forEach((current: number) => writer.writeVarShort(current))
		writer.writeShort(this.ornaments!.length)
		this.ornaments!.forEach((current: number) => writer.writeVarShort(current))
		writer.writeVarShort(this.activeTitle!)
		writer.writeVarShort(this.activeOrnament!)
	}

	public deserialize(reader: BinaryReader): void {
		this.titles = []
		const countTitles = reader.readShort()
		for (let i: number = 0; i < countTitles; i++) {
			this.titles.push(reader.readVarShort())
		}
		this.ornaments = []
		const countOrnaments = reader.readShort()
		for (let i: number = 0; i < countOrnaments; i++) {
			this.ornaments.push(reader.readVarShort())
		}
		this.activeTitle = reader.readVarShort()
		this.activeOrnament = reader.readVarShort()
	}

	public hydrate(
		data: TitlesAndOrnamentsListMessage | Record<string, any>
	): TitlesAndOrnamentsListMessage {
		if (data instanceof TitlesAndOrnamentsListMessage) {
			return data
		}

		this.titles = data.titles
		this.ornaments = data.ornaments
		this.activeTitle = data.activeTitle
		this.activeOrnament = data.activeOrnament

		return this
	}
}

export interface RawHaapiConfirmationMessage {
	id: number
	kamas: number
	amount: number
	rate: number
	action: number
	transaction: string
}

export class HaapiConfirmationMessage extends DofusMessage {
	public static id: number = 2667

	public kamas: number | undefined = 0
	public amount: number | undefined = 0
	public rate: number | undefined = 0
	public action: number | undefined = 0
	public transaction: string | undefined

	public constructor(
		kamas?: number | undefined,
		amount?: number | undefined,
		rate?: number | undefined,
		action?: number | undefined,
		transaction?: string | undefined
	) {
		super()
		this.kamas = kamas
		this.amount = amount
		this.rate = rate
		this.action = action
		this.transaction = transaction
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarLong(this.kamas!)
		writer.writeVarLong(this.amount!)
		writer.writeVarShort(this.rate!)
		writer.writeByte(this.action!)
		writer.writeUTF(this.transaction!)
	}

	public deserialize(reader: BinaryReader): void {
		this.kamas = reader.readVarLong()
		this.amount = reader.readVarLong()
		this.rate = reader.readVarShort()
		this.action = reader.readByte()
		this.transaction = reader.readUTF()
	}

	public hydrate(
		data: HaapiConfirmationMessage | Record<string, any>
	): HaapiConfirmationMessage {
		if (data instanceof HaapiConfirmationMessage) {
			return data
		}

		this.kamas = data.kamas
		this.amount = data.amount
		this.rate = data.rate
		this.action = data.action
		this.transaction = data.transaction

		return this
	}
}

export interface RawPrismsInfoValidMessage {
	id: number
	fights: PrismFightersInformation[]
}

export class PrismsInfoValidMessage extends DofusMessage {
	public static id: number = 4624

	public fights: PrismFightersInformation[] | undefined

	public constructor(fights?: PrismFightersInformation[] | undefined) {
		super()
		this.fights = fights
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeShort(this.fights!.length)
		this.fights!.forEach((current) => {
			current.serialize(writer)
		})
	}

	public deserialize(reader: BinaryReader): void {
		this.fights = []
		const countFights = reader.readShort()
		for (let i: number = 0; i < countFights; i++) {
			const type: PrismFightersInformation = new PrismFightersInformation()
			type.deserialize(reader)
			this.fights.push(type)
		}
	}

	public hydrate(
		data: PrismsInfoValidMessage | Record<string, any>
	): PrismsInfoValidMessage {
		if (data instanceof PrismsInfoValidMessage) {
			return data
		}

		this.fights = data.fights.map(
			(
				dataElement: PrismFightersInformation | Record<string, any>
			): PrismFightersInformation => {
				if (dataElement instanceof PrismFightersInformation) {
					return dataElement
				} else {
					return new PrismFightersInformation().hydrate(dataElement)
				}
			}
		)

		return this
	}
}

export interface RawInviteInHavenBagOfferMessage {
	id: number
	hostInformations: CharacterMinimalInformations
	timeLeftBeforeCancel: number
}

export class InviteInHavenBagOfferMessage extends DofusMessage {
	public static id: number = 2889

	public hostInformations: CharacterMinimalInformations | undefined
	public timeLeftBeforeCancel: number | undefined = 0

	public constructor(
		hostInformations?: CharacterMinimalInformations | undefined,
		timeLeftBeforeCancel?: number | undefined
	) {
		super()
		this.hostInformations = hostInformations
		this.timeLeftBeforeCancel = timeLeftBeforeCancel
	}

	public serialize(writer: BinaryWriter): void {
		this.hostInformations!.serialize(writer)
		writer.writeVarInt(this.timeLeftBeforeCancel!)
	}

	public deserialize(reader: BinaryReader): void {
		this.hostInformations = new CharacterMinimalInformations()
		this.hostInformations!.deserialize(reader)
		this.timeLeftBeforeCancel = reader.readVarInt()
	}

	public hydrate(
		data: InviteInHavenBagOfferMessage | Record<string, any>
	): InviteInHavenBagOfferMessage {
		if (data instanceof InviteInHavenBagOfferMessage) {
			return data
		}

		this.hostInformations = new CharacterMinimalInformations().hydrate(
			data.hostInformations
		)
		this.timeLeftBeforeCancel = data.timeLeftBeforeCancel

		return this
	}
}

export interface RawHavenBagPackListMessage {
	id: number
	packIds: number[]
}

export class HavenBagPackListMessage extends DofusMessage {
	public static id: number = 7074

	public packIds: number[] | undefined

	public constructor(packIds?: number[] | undefined) {
		super()
		this.packIds = packIds
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeShort(this.packIds!.length)
		this.packIds!.forEach((current: number) => writer.writeByte(current))
	}

	public deserialize(reader: BinaryReader): void {
		this.packIds = []
		const countPackIds = reader.readShort()
		for (let i: number = 0; i < countPackIds; i++) {
			this.packIds.push(reader.readByte())
		}
	}

	public hydrate(
		data: HavenBagPackListMessage | Record<string, any>
	): HavenBagPackListMessage {
		if (data instanceof HavenBagPackListMessage) {
			return data
		}

		this.packIds = data.packIds

		return this
	}
}

export interface RawCharacterDeletionErrorMessage {
	id: number
	reason: number
}

export class CharacterDeletionErrorMessage extends DofusMessage {
	public static id: number = 9555

	public reason: number | undefined = 1

	public constructor(reason?: number | undefined) {
		super()
		this.reason = reason
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeByte(this.reason!)
	}

	public deserialize(reader: BinaryReader): void {
		this.reason = reader.readByte()
	}

	public hydrate(
		data: CharacterDeletionErrorMessage | Record<string, any>
	): CharacterDeletionErrorMessage {
		if (data instanceof CharacterDeletionErrorMessage) {
			return data
		}

		this.reason = data.reason

		return this
	}
}

export interface RawHavenBagFurnituresMessage {
	id: number
	furnituresInfos: HavenBagFurnitureInformation[]
}

export class HavenBagFurnituresMessage extends DofusMessage {
	public static id: number = 162

	public furnituresInfos: HavenBagFurnitureInformation[] | undefined

	public constructor(
		furnituresInfos?: HavenBagFurnitureInformation[] | undefined
	) {
		super()
		this.furnituresInfos = furnituresInfos
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeShort(this.furnituresInfos!.length)
		this.furnituresInfos!.forEach((current) => {
			current.serialize(writer)
		})
	}

	public deserialize(reader: BinaryReader): void {
		this.furnituresInfos = []
		const countFurnituresInfos = reader.readShort()
		for (let i: number = 0; i < countFurnituresInfos; i++) {
			const type: HavenBagFurnitureInformation = new HavenBagFurnitureInformation()
			type.deserialize(reader)
			this.furnituresInfos.push(type)
		}
	}

	public hydrate(
		data: HavenBagFurnituresMessage | Record<string, any>
	): HavenBagFurnituresMessage {
		if (data instanceof HavenBagFurnituresMessage) {
			return data
		}

		this.furnituresInfos = data.furnituresInfos.map(
			(
				dataElement: HavenBagFurnitureInformation | Record<string, any>
			): HavenBagFurnitureInformation => {
				if (dataElement instanceof HavenBagFurnitureInformation) {
					return dataElement
				} else {
					return new HavenBagFurnitureInformation().hydrate(dataElement)
				}
			}
		)

		return this
	}
}

export interface RawAcquaintancesListMessage {
	id: number
	acquaintanceList: AcquaintanceInformation[]
}

export class AcquaintancesListMessage extends DofusMessage {
	public static id: number = 1493

	public acquaintanceList: AcquaintanceInformation[] | undefined

	public constructor(acquaintanceList?: AcquaintanceInformation[] | undefined) {
		super()
		this.acquaintanceList = acquaintanceList
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeShort(this.acquaintanceList!.length)
		this.acquaintanceList!.forEach((current) => {
			writer.writeShort(current.id)
			current.serialize(writer)
		})
	}

	public deserialize(reader: BinaryReader): void {
		this.acquaintanceList = []
		const countAcquaintanceList = reader.readShort()
		for (let i: number = 0; i < countAcquaintanceList; i++) {
			const acquaintanceListTypeId: number = reader.readShort()
			const type: AcquaintanceInformation = new types[
				acquaintanceListTypeId
			]() as AcquaintanceInformation
			type.deserialize(reader)
			this.acquaintanceList.push(type)
		}
	}

	public hydrate(
		data: AcquaintancesListMessage | Record<string, any>
	): AcquaintancesListMessage {
		if (data instanceof AcquaintancesListMessage) {
			return data
		}

		this.acquaintanceList = data.acquaintanceList.map(
			(
				dataElement: AcquaintanceInformation | Record<string, any>
			): AcquaintanceInformation => {
				if (dataElement instanceof AcquaintanceInformation) {
					return dataElement
				} else {
					return (new types[
						dataElement.id
					]() as AcquaintanceInformation).hydrate(dataElement)
				}
			}
		)

		return this
	}
}

export interface RawExchangeStartedTaxCollectorShopMessage {
	id: number
	objects: ObjectItem[]
	kamas: number
}

export class ExchangeStartedTaxCollectorShopMessage extends DofusMessage {
	public static id: number = 2431

	public objects: ObjectItem[] | undefined
	public kamas: number | undefined = 0

	public constructor(
		objects?: ObjectItem[] | undefined,
		kamas?: number | undefined
	) {
		super()
		this.objects = objects
		this.kamas = kamas
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeShort(this.objects!.length)
		this.objects!.forEach((current) => {
			current.serialize(writer)
		})
		writer.writeVarLong(this.kamas!)
	}

	public deserialize(reader: BinaryReader): void {
		this.objects = []
		const countObjects = reader.readShort()
		for (let i: number = 0; i < countObjects; i++) {
			const type: ObjectItem = new ObjectItem()
			type.deserialize(reader)
			this.objects.push(type)
		}
		this.kamas = reader.readVarLong()
	}

	public hydrate(
		data: ExchangeStartedTaxCollectorShopMessage | Record<string, any>
	): ExchangeStartedTaxCollectorShopMessage {
		if (data instanceof ExchangeStartedTaxCollectorShopMessage) {
			return data
		}

		this.objects = data.objects.map(
			(dataElement: ObjectItem | Record<string, any>): ObjectItem => {
				if (dataElement instanceof ObjectItem) {
					return dataElement
				} else {
					return new ObjectItem().hydrate(dataElement)
				}
			}
		)
		this.kamas = data.kamas

		return this
	}
}

export interface RawGuildHouseRemoveMessage {
	id: number
	houseId: number
	instanceId: number
	secondHand: boolean
}

export class GuildHouseRemoveMessage extends DofusMessage {
	public static id: number = 8731

	public houseId: number | undefined = 0
	public instanceId: number | undefined = 0
	public secondHand: boolean | undefined = false

	public constructor(
		houseId?: number | undefined,
		instanceId?: number | undefined,
		secondHand?: boolean | undefined
	) {
		super()
		this.houseId = houseId
		this.instanceId = instanceId
		this.secondHand = secondHand
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarInt(this.houseId!)
		writer.writeInt(this.instanceId!)
		writer.writeBoolean(this.secondHand!)
	}

	public deserialize(reader: BinaryReader): void {
		this.houseId = reader.readVarInt()
		this.instanceId = reader.readInt()
		this.secondHand = reader.readBoolean()
	}

	public hydrate(
		data: GuildHouseRemoveMessage | Record<string, any>
	): GuildHouseRemoveMessage {
		if (data instanceof GuildHouseRemoveMessage) {
			return data
		}

		this.houseId = data.houseId
		this.instanceId = data.instanceId
		this.secondHand = data.secondHand

		return this
	}
}

export interface RawTreasureHuntFinishedMessage {
	id: number
	questType: number
}

export class TreasureHuntFinishedMessage extends DofusMessage {
	public static id: number = 2759

	public questType: number | undefined = 0

	public constructor(questType?: number | undefined) {
		super()
		this.questType = questType
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeByte(this.questType!)
	}

	public deserialize(reader: BinaryReader): void {
		this.questType = reader.readByte()
	}

	public hydrate(
		data: TreasureHuntFinishedMessage | Record<string, any>
	): TreasureHuntFinishedMessage {
		if (data instanceof TreasureHuntFinishedMessage) {
			return data
		}

		this.questType = data.questType

		return this
	}
}

export interface RawHaapiBufferListMessage {
	id: number
	buffers: BufferInformation[]
}

export class HaapiBufferListMessage extends DofusMessage {
	public static id: number = 875

	public buffers: BufferInformation[] | undefined

	public constructor(buffers?: BufferInformation[] | undefined) {
		super()
		this.buffers = buffers
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeShort(this.buffers!.length)
		this.buffers!.forEach((current) => {
			current.serialize(writer)
		})
	}

	public deserialize(reader: BinaryReader): void {
		this.buffers = []
		const countBuffers = reader.readShort()
		for (let i: number = 0; i < countBuffers; i++) {
			const type: BufferInformation = new BufferInformation()
			type.deserialize(reader)
			this.buffers.push(type)
		}
	}

	public hydrate(
		data: HaapiBufferListMessage | Record<string, any>
	): HaapiBufferListMessage {
		if (data instanceof HaapiBufferListMessage) {
			return data
		}

		this.buffers = data.buffers.map(
			(
				dataElement: BufferInformation | Record<string, any>
			): BufferInformation => {
				if (dataElement instanceof BufferInformation) {
					return dataElement
				} else {
					return new BufferInformation().hydrate(dataElement)
				}
			}
		)

		return this
	}
}

export interface RawWrapperObjectAssociatedMessage
	extends RawSymbioticObjectAssociatedMessage {
	id: number
}

export class WrapperObjectAssociatedMessage extends SymbioticObjectAssociatedMessage {
	public static id = 134

	public constructor(hostUID?: number | undefined) {
		super(hostUID)
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
	}

	public hydrate(
		data: WrapperObjectAssociatedMessage | Record<string, any>
	): WrapperObjectAssociatedMessage {
		if (data instanceof WrapperObjectAssociatedMessage) {
			return data
		}

		super.hydrate(data)

		return this
	}
}

export interface RawObjectDeletedMessage {
	id: number
	objectUID: number
}

export class ObjectDeletedMessage extends DofusMessage {
	public static id: number = 8730

	public objectUID: number | undefined = 0

	public constructor(objectUID?: number | undefined) {
		super()
		this.objectUID = objectUID
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarInt(this.objectUID!)
	}

	public deserialize(reader: BinaryReader): void {
		this.objectUID = reader.readVarInt()
	}

	public hydrate(
		data: ObjectDeletedMessage | Record<string, any>
	): ObjectDeletedMessage {
		if (data instanceof ObjectDeletedMessage) {
			return data
		}

		this.objectUID = data.objectUID

		return this
	}
}

export interface RawPartyMemberEjectedMessage
	extends RawPartyMemberRemoveMessage {
	id: number
	kickerId: number
}

export class PartyMemberEjectedMessage extends PartyMemberRemoveMessage {
	public static id = 7887

	public kickerId: number | undefined = 0

	public constructor(
		partyId?: number | undefined,
		leavingPlayerId?: number | undefined,
		kickerId?: number | undefined
	) {
		super(partyId, leavingPlayerId)
		this.kickerId = kickerId
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeVarLong(this.kickerId!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.kickerId = reader.readVarLong()
	}

	public hydrate(
		data: PartyMemberEjectedMessage | Record<string, any>
	): PartyMemberEjectedMessage {
		if (data instanceof PartyMemberEjectedMessage) {
			return data
		}

		super.hydrate(data)

		this.kickerId = data.kickerId

		return this
	}
}

export interface RawExchangeMountsStableRemoveMessage {
	id: number
	mountsId: number[]
}

export class ExchangeMountsStableRemoveMessage extends DofusMessage {
	public static id: number = 2552

	public mountsId: number[] | undefined

	public constructor(mountsId?: number[] | undefined) {
		super()
		this.mountsId = mountsId
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeShort(this.mountsId!.length)
		this.mountsId!.forEach((current: number) => writer.writeVarInt(current))
	}

	public deserialize(reader: BinaryReader): void {
		this.mountsId = []
		const countMountsId = reader.readShort()
		for (let i: number = 0; i < countMountsId; i++) {
			this.mountsId.push(reader.readVarInt())
		}
	}

	public hydrate(
		data: ExchangeMountsStableRemoveMessage | Record<string, any>
	): ExchangeMountsStableRemoveMessage {
		if (data instanceof ExchangeMountsStableRemoveMessage) {
			return data
		}

		this.mountsId = data.mountsId

		return this
	}
}

export interface RawAllianceCreationStartedMessage {
	id: number
}

export class AllianceCreationStartedMessage extends DofusMessage {
	public static id: number = 4020

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public serialize(writer: BinaryWriter): void {}

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public deserialize(reader: BinaryReader): void {}

	public hydrate(
		data: AllianceCreationStartedMessage | Record<string, any>
	): AllianceCreationStartedMessage {
		if (data instanceof AllianceCreationStartedMessage) {
			return data
		}

		return this
	}
}

export interface RawInventoryWeightMessage {
	id: number
	inventoryWeight: number
	shopWeight: number
	weightMax: number
}

export class InventoryWeightMessage extends DofusMessage {
	public static id: number = 1264

	public inventoryWeight: number | undefined = 0
	public weightMax: number | undefined = 0

	public constructor(
		inventoryWeight?: number | undefined,
		weightMax?: number | undefined
	) {
		super()
		this.inventoryWeight = inventoryWeight
		this.weightMax = weightMax
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarInt(this.inventoryWeight!)
		writer.writeVarInt(this.weightMax!)
	}

	public deserialize(reader: BinaryReader): void {
		this.inventoryWeight = reader.readVarInt()
		this.weightMax = reader.readVarInt()
	}

	public hydrate(
		data: InventoryWeightMessage | Record<string, any>
	): InventoryWeightMessage {
		if (data instanceof InventoryWeightMessage) {
			return data
		}

		this.inventoryWeight = data.inventoryWeight
		this.weightMax = data.weightMax

		return this
	}
}

export interface RawMountDataErrorMessage {
	id: number
	reason: number
}

export class MountDataErrorMessage extends DofusMessage {
	public static id: number = 5783

	public reason: number | undefined = 0

	public constructor(reason?: number | undefined) {
		super()
		this.reason = reason
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeByte(this.reason!)
	}

	public deserialize(reader: BinaryReader): void {
		this.reason = reader.readByte()
	}

	public hydrate(
		data: MountDataErrorMessage | Record<string, any>
	): MountDataErrorMessage {
		if (data instanceof MountDataErrorMessage) {
			return data
		}

		this.reason = data.reason

		return this
	}
}

export interface RawExchangeMoneyMovementInformationMessage {
	id: number
	limit: number
}

export class ExchangeMoneyMovementInformationMessage extends DofusMessage {
	public static id: number = 4402

	public limit: number | undefined = 0

	public constructor(limit?: number | undefined) {
		super()
		this.limit = limit
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarLong(this.limit!)
	}

	public deserialize(reader: BinaryReader): void {
		this.limit = reader.readVarLong()
	}

	public hydrate(
		data: ExchangeMoneyMovementInformationMessage | Record<string, any>
	): ExchangeMoneyMovementInformationMessage {
		if (data instanceof ExchangeMoneyMovementInformationMessage) {
			return data
		}

		this.limit = data.limit

		return this
	}
}

export interface RawZaapRespawnUpdatedMessage {
	id: number
	mapId: number
}

export class ZaapRespawnUpdatedMessage extends DofusMessage {
	public static id: number = 6953

	public mapId: number | undefined = 0

	public constructor(mapId?: number | undefined) {
		super()
		this.mapId = mapId
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeDouble(this.mapId!)
	}

	public deserialize(reader: BinaryReader): void {
		this.mapId = reader.readDouble()
	}

	public hydrate(
		data: ZaapRespawnUpdatedMessage | Record<string, any>
	): ZaapRespawnUpdatedMessage {
		if (data instanceof ZaapRespawnUpdatedMessage) {
			return data
		}

		this.mapId = data.mapId

		return this
	}
}

export interface RawExchangeMultiCraftCrafterCanUseHisRessourcesMessage {
	id: number
	allowed: boolean
}

export class ExchangeMultiCraftCrafterCanUseHisRessourcesMessage extends DofusMessage {
	public static id: number = 7247

	public allowed: boolean | undefined = false

	public constructor(allowed?: boolean | undefined) {
		super()
		this.allowed = allowed
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeBoolean(this.allowed!)
	}

	public deserialize(reader: BinaryReader): void {
		this.allowed = reader.readBoolean()
	}

	public hydrate(
		data:
			| ExchangeMultiCraftCrafterCanUseHisRessourcesMessage
			| Record<string, any>
	): ExchangeMultiCraftCrafterCanUseHisRessourcesMessage {
		if (data instanceof ExchangeMultiCraftCrafterCanUseHisRessourcesMessage) {
			return data
		}

		this.allowed = data.allowed

		return this
	}
}

export interface RawInvalidPresetsMessage {
	id: number
	presetIds: number[]
}

export class InvalidPresetsMessage extends DofusMessage {
	public static id: number = 4221

	public presetIds: number[] | undefined

	public constructor(presetIds?: number[] | undefined) {
		super()
		this.presetIds = presetIds
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeShort(this.presetIds!.length)
		this.presetIds!.forEach((current: number) => writer.writeShort(current))
	}

	public deserialize(reader: BinaryReader): void {
		this.presetIds = []
		const countPresetIds = reader.readShort()
		for (let i: number = 0; i < countPresetIds; i++) {
			this.presetIds.push(reader.readShort())
		}
	}

	public hydrate(
		data: InvalidPresetsMessage | Record<string, any>
	): InvalidPresetsMessage {
		if (data instanceof InvalidPresetsMessage) {
			return data
		}

		this.presetIds = data.presetIds

		return this
	}
}

export interface RawPresetSaveErrorMessage {
	id: number
	presetId: number
	code: number
}

export class PresetSaveErrorMessage extends DofusMessage {
	public static id: number = 810

	public presetId: number | undefined = 0
	public code: number | undefined = 2

	public constructor(presetId?: number | undefined, code?: number | undefined) {
		super()
		this.presetId = presetId
		this.code = code
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeShort(this.presetId!)
		writer.writeByte(this.code!)
	}

	public deserialize(reader: BinaryReader): void {
		this.presetId = reader.readShort()
		this.code = reader.readByte()
	}

	public hydrate(
		data: PresetSaveErrorMessage | Record<string, any>
	): PresetSaveErrorMessage {
		if (data instanceof PresetSaveErrorMessage) {
			return data
		}

		this.presetId = data.presetId
		this.code = data.code

		return this
	}
}

export interface RawGuildInformationsMemberUpdateMessage {
	id: number
	member: GuildMember
}

export class GuildInformationsMemberUpdateMessage extends DofusMessage {
	public static id: number = 7131

	public member: GuildMember | undefined

	public constructor(member?: GuildMember | undefined) {
		super()
		this.member = member
	}

	public serialize(writer: BinaryWriter): void {
		this.member!.serialize(writer)
	}

	public deserialize(reader: BinaryReader): void {
		this.member = new GuildMember()
		this.member!.deserialize(reader)
	}

	public hydrate(
		data: GuildInformationsMemberUpdateMessage | Record<string, any>
	): GuildInformationsMemberUpdateMessage {
		if (data instanceof GuildInformationsMemberUpdateMessage) {
			return data
		}

		this.member = new GuildMember().hydrate(data.member)

		return this
	}
}

export interface RawExchangeStartedWithStorageMessage
	extends RawExchangeStartedMessage {
	id: number
	storageMaxSlot: number
}

export class ExchangeStartedWithStorageMessage extends ExchangeStartedMessage {
	public static id = 5381

	public storageMaxSlot: number | undefined = 0

	public constructor(
		exchangeType?: number | undefined,
		storageMaxSlot?: number | undefined
	) {
		super(exchangeType)
		this.storageMaxSlot = storageMaxSlot
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeVarInt(this.storageMaxSlot!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.storageMaxSlot = reader.readVarInt()
	}

	public hydrate(
		data: ExchangeStartedWithStorageMessage | Record<string, any>
	): ExchangeStartedWithStorageMessage {
		if (data instanceof ExchangeStartedWithStorageMessage) {
			return data
		}

		super.hydrate(data)

		this.storageMaxSlot = data.storageMaxSlot

		return this
	}
}

export interface RawTeleportToBuddyOfferMessage {
	id: number
	dungeonId: number
	buddyId: number
	timeLeft: number
}

export class TeleportToBuddyOfferMessage extends DofusMessage {
	public static id: number = 5505

	public dungeonId: number | undefined = 0
	public buddyId: number | undefined = 0
	public timeLeft: number | undefined = 0

	public constructor(
		dungeonId?: number | undefined,
		buddyId?: number | undefined,
		timeLeft?: number | undefined
	) {
		super()
		this.dungeonId = dungeonId
		this.buddyId = buddyId
		this.timeLeft = timeLeft
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarShort(this.dungeonId!)
		writer.writeVarLong(this.buddyId!)
		writer.writeVarInt(this.timeLeft!)
	}

	public deserialize(reader: BinaryReader): void {
		this.dungeonId = reader.readVarShort()
		this.buddyId = reader.readVarLong()
		this.timeLeft = reader.readVarInt()
	}

	public hydrate(
		data: TeleportToBuddyOfferMessage | Record<string, any>
	): TeleportToBuddyOfferMessage {
		if (data instanceof TeleportToBuddyOfferMessage) {
			return data
		}

		this.dungeonId = data.dungeonId
		this.buddyId = data.buddyId
		this.timeLeft = data.timeLeft

		return this
	}
}

export interface RawExchangeCraftResultWithObjectIdMessage
	extends RawExchangeCraftResultMessage {
	id: number
	objectGenericId: number
}

export class ExchangeCraftResultWithObjectIdMessage extends ExchangeCraftResultMessage {
	public static id = 1951

	public objectGenericId: number | undefined = 0

	public constructor(
		craftResult?: number | undefined,
		objectGenericId?: number | undefined
	) {
		super(craftResult)
		this.objectGenericId = objectGenericId
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeVarShort(this.objectGenericId!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.objectGenericId = reader.readVarShort()
	}

	public hydrate(
		data: ExchangeCraftResultWithObjectIdMessage | Record<string, any>
	): ExchangeCraftResultWithObjectIdMessage {
		if (data instanceof ExchangeCraftResultWithObjectIdMessage) {
			return data
		}

		super.hydrate(data)

		this.objectGenericId = data.objectGenericId

		return this
	}
}

export interface RawExchangeCraftInformationObjectMessage
	extends RawExchangeCraftResultWithObjectIdMessage {
	id: number
	playerId: number
}

export class ExchangeCraftInformationObjectMessage extends ExchangeCraftResultWithObjectIdMessage {
	public static id = 819

	public playerId: number | undefined = 0

	public constructor(
		craftResult?: number | undefined,
		objectGenericId?: number | undefined,
		playerId?: number | undefined
	) {
		super(craftResult, objectGenericId)
		this.playerId = playerId
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeVarLong(this.playerId!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.playerId = reader.readVarLong()
	}

	public hydrate(
		data: ExchangeCraftInformationObjectMessage | Record<string, any>
	): ExchangeCraftInformationObjectMessage {
		if (data instanceof ExchangeCraftInformationObjectMessage) {
			return data
		}

		super.hydrate(data)

		this.playerId = data.playerId

		return this
	}
}

export interface RawPartyLoyaltyStatusMessage extends RawAbstractPartyMessage {
	id: number
	loyal: boolean
}

export class PartyLoyaltyStatusMessage extends AbstractPartyMessage {
	public static id = 7075

	public loyal: boolean | undefined = false

	public constructor(
		partyId?: number | undefined,
		loyal?: boolean | undefined
	) {
		super(partyId)
		this.loyal = loyal
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeBoolean(this.loyal!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.loyal = reader.readBoolean()
	}

	public hydrate(
		data: PartyLoyaltyStatusMessage | Record<string, any>
	): PartyLoyaltyStatusMessage {
		if (data instanceof PartyLoyaltyStatusMessage) {
			return data
		}

		super.hydrate(data)

		this.loyal = data.loyal

		return this
	}
}

export interface RawJobCrafterDirectoryRemoveMessage {
	id: number
	jobId: number
	playerId: number
}

export class JobCrafterDirectoryRemoveMessage extends DofusMessage {
	public static id: number = 7514

	public jobId: number | undefined = 0
	public playerId: number | undefined = 0

	public constructor(
		jobId?: number | undefined,
		playerId?: number | undefined
	) {
		super()
		this.jobId = jobId
		this.playerId = playerId
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeByte(this.jobId!)
		writer.writeVarLong(this.playerId!)
	}

	public deserialize(reader: BinaryReader): void {
		this.jobId = reader.readByte()
		this.playerId = reader.readVarLong()
	}

	public hydrate(
		data: JobCrafterDirectoryRemoveMessage | Record<string, any>
	): JobCrafterDirectoryRemoveMessage {
		if (data instanceof JobCrafterDirectoryRemoveMessage) {
			return data
		}

		this.jobId = data.jobId
		this.playerId = data.playerId

		return this
	}
}

export interface RawExchangeObjectModifiedMessage
	extends RawExchangeObjectMessage {
	id: number
	object_: ObjectItem
}

export class ExchangeObjectModifiedMessage extends ExchangeObjectMessage {
	public static id = 1595

	public object_: ObjectItem | undefined

	public constructor(
		remote?: boolean | undefined,
		object_?: ObjectItem | undefined
	) {
		super(remote)
		this.object_ = object_
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		this.object_!.serialize(writer)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.object_ = new ObjectItem()
		this.object_!.deserialize(reader)
	}

	public hydrate(
		data: ExchangeObjectModifiedMessage | Record<string, any>
	): ExchangeObjectModifiedMessage {
		if (data instanceof ExchangeObjectModifiedMessage) {
			return data
		}

		super.hydrate(data)

		this.object_ = new ObjectItem().hydrate(data.object_)

		return this
	}
}

export interface RawAnomalySubareaInformationResponseMessage {
	id: number
	subareas: AnomalySubareaInformation[]
}

export class AnomalySubareaInformationResponseMessage extends DofusMessage {
	public static id: number = 9391

	public subareas: AnomalySubareaInformation[] | undefined

	public constructor(subareas?: AnomalySubareaInformation[] | undefined) {
		super()
		this.subareas = subareas
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeShort(this.subareas!.length)
		this.subareas!.forEach((current) => {
			current.serialize(writer)
		})
	}

	public deserialize(reader: BinaryReader): void {
		this.subareas = []
		const countSubareas = reader.readShort()
		for (let i: number = 0; i < countSubareas; i++) {
			const type: AnomalySubareaInformation = new AnomalySubareaInformation()
			type.deserialize(reader)
			this.subareas.push(type)
		}
	}

	public hydrate(
		data: AnomalySubareaInformationResponseMessage | Record<string, any>
	): AnomalySubareaInformationResponseMessage {
		if (data instanceof AnomalySubareaInformationResponseMessage) {
			return data
		}

		this.subareas = data.subareas.map(
			(
				dataElement: AnomalySubareaInformation | Record<string, any>
			): AnomalySubareaInformation => {
				if (dataElement instanceof AnomalySubareaInformation) {
					return dataElement
				} else {
					return new AnomalySubareaInformation().hydrate(dataElement)
				}
			}
		)

		return this
	}
}

export interface RawFriendAddFailureMessage {
	id: number
	reason: number
}

export class FriendAddFailureMessage extends DofusMessage {
	public static id: number = 9558

	public reason: number | undefined = 0

	public constructor(reason?: number | undefined) {
		super()
		this.reason = reason
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeByte(this.reason!)
	}

	public deserialize(reader: BinaryReader): void {
		this.reason = reader.readByte()
	}

	public hydrate(
		data: FriendAddFailureMessage | Record<string, any>
	): FriendAddFailureMessage {
		if (data instanceof FriendAddFailureMessage) {
			return data
		}

		this.reason = data.reason

		return this
	}
}

export interface RawHavenBagRoomUpdateMessage {
	id: number
	action: number
	roomsPreview: HavenBagRoomPreviewInformation[]
}

export class HavenBagRoomUpdateMessage extends DofusMessage {
	public static id: number = 2501

	public action: number | undefined = 0
	public roomsPreview: HavenBagRoomPreviewInformation[] | undefined

	public constructor(
		action?: number | undefined,
		roomsPreview?: HavenBagRoomPreviewInformation[] | undefined
	) {
		super()
		this.action = action
		this.roomsPreview = roomsPreview
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeByte(this.action!)
		writer.writeShort(this.roomsPreview!.length)
		this.roomsPreview!.forEach((current) => {
			current.serialize(writer)
		})
	}

	public deserialize(reader: BinaryReader): void {
		this.action = reader.readByte()
		this.roomsPreview = []
		const countRoomsPreview = reader.readShort()
		for (let i: number = 0; i < countRoomsPreview; i++) {
			const type: HavenBagRoomPreviewInformation = new HavenBagRoomPreviewInformation()
			type.deserialize(reader)
			this.roomsPreview.push(type)
		}
	}

	public hydrate(
		data: HavenBagRoomUpdateMessage | Record<string, any>
	): HavenBagRoomUpdateMessage {
		if (data instanceof HavenBagRoomUpdateMessage) {
			return data
		}

		this.action = data.action
		this.roomsPreview = data.roomsPreview.map(
			(
				dataElement: HavenBagRoomPreviewInformation | Record<string, any>
			): HavenBagRoomPreviewInformation => {
				if (dataElement instanceof HavenBagRoomPreviewInformation) {
					return dataElement
				} else {
					return new HavenBagRoomPreviewInformation().hydrate(dataElement)
				}
			}
		)

		return this
	}
}

export interface RawBulletinMessage extends RawSocialNoticeMessage {
	id: number
	lastNotifiedTimestamp: number
}

export class BulletinMessage extends SocialNoticeMessage {
	public static id = 6070

	public lastNotifiedTimestamp: number | undefined = 0

	public constructor(
		content?: string | undefined,
		timestamp?: number | undefined,
		memberId?: number | undefined,
		memberName?: string | undefined,
		lastNotifiedTimestamp?: number | undefined
	) {
		super(content, timestamp, memberId, memberName)
		this.lastNotifiedTimestamp = lastNotifiedTimestamp
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeInt(this.lastNotifiedTimestamp!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.lastNotifiedTimestamp = reader.readInt()
	}

	public hydrate(data: BulletinMessage | Record<string, any>): BulletinMessage {
		if (data instanceof BulletinMessage) {
			return data
		}

		super.hydrate(data)

		this.lastNotifiedTimestamp = data.lastNotifiedTimestamp

		return this
	}
}

export interface RawGuildBulletinMessage extends RawBulletinMessage {
	id: number
}

export class GuildBulletinMessage extends BulletinMessage {
	public static id = 7441

	public constructor(
		content?: string | undefined,
		timestamp?: number | undefined,
		memberId?: number | undefined,
		memberName?: string | undefined,
		lastNotifiedTimestamp?: number | undefined
	) {
		super(content, timestamp, memberId, memberName, lastNotifiedTimestamp)
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
	}

	public hydrate(
		data: GuildBulletinMessage | Record<string, any>
	): GuildBulletinMessage {
		if (data instanceof GuildBulletinMessage) {
			return data
		}

		super.hydrate(data)

		return this
	}
}

export interface RawPartyUpdateLightMessage
	extends RawAbstractPartyEventMessage {
	id: number
	id_: number
	lifePoints: number
	maxLifePoints: number
	prospecting: number
	regenRate: number
}

export class PartyUpdateLightMessage extends AbstractPartyEventMessage {
	public static id = 3044

	public id_: number | undefined = 0
	public lifePoints: number | undefined = 0
	public maxLifePoints: number | undefined = 0
	public prospecting: number | undefined = 0
	public regenRate: number | undefined = 0

	public constructor(
		partyId?: number | undefined,
		id_?: number | undefined,
		lifePoints?: number | undefined,
		maxLifePoints?: number | undefined,
		prospecting?: number | undefined,
		regenRate?: number | undefined
	) {
		super(partyId)
		this.id_ = id_
		this.lifePoints = lifePoints
		this.maxLifePoints = maxLifePoints
		this.prospecting = prospecting
		this.regenRate = regenRate
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeVarLong(this.id_!)
		writer.writeVarInt(this.lifePoints!)
		writer.writeVarInt(this.maxLifePoints!)
		writer.writeVarShort(this.prospecting!)
		writer.writeByte(this.regenRate!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.id_ = reader.readVarLong()
		this.lifePoints = reader.readVarInt()
		this.maxLifePoints = reader.readVarInt()
		this.prospecting = reader.readVarShort()
		this.regenRate = reader.readByte()
	}

	public hydrate(
		data: PartyUpdateLightMessage | Record<string, any>
	): PartyUpdateLightMessage {
		if (data instanceof PartyUpdateLightMessage) {
			return data
		}

		super.hydrate(data)

		this.id_ = data.id_
		this.lifePoints = data.lifePoints
		this.maxLifePoints = data.maxLifePoints
		this.prospecting = data.prospecting
		this.regenRate = data.regenRate

		return this
	}
}

export interface RawBreachInvitationOfferMessage {
	id: number
	host: CharacterMinimalInformations
	timeLeftBeforeCancel: number
}

export class BreachInvitationOfferMessage extends DofusMessage {
	public static id: number = 3906

	public host: CharacterMinimalInformations | undefined
	public timeLeftBeforeCancel: number | undefined = 0

	public constructor(
		host?: CharacterMinimalInformations | undefined,
		timeLeftBeforeCancel?: number | undefined
	) {
		super()
		this.host = host
		this.timeLeftBeforeCancel = timeLeftBeforeCancel
	}

	public serialize(writer: BinaryWriter): void {
		this.host!.serialize(writer)
		writer.writeVarInt(this.timeLeftBeforeCancel!)
	}

	public deserialize(reader: BinaryReader): void {
		this.host = new CharacterMinimalInformations()
		this.host!.deserialize(reader)
		this.timeLeftBeforeCancel = reader.readVarInt()
	}

	public hydrate(
		data: BreachInvitationOfferMessage | Record<string, any>
	): BreachInvitationOfferMessage {
		if (data instanceof BreachInvitationOfferMessage) {
			return data
		}

		this.host = new CharacterMinimalInformations().hydrate(data.host)
		this.timeLeftBeforeCancel = data.timeLeftBeforeCancel

		return this
	}
}

export interface RawGuildJoinedMessage {
	id: number
	guildInfo: GuildInformations
	memberRights: number
}

export class GuildJoinedMessage extends DofusMessage {
	public static id: number = 8729

	public guildInfo: GuildInformations | undefined
	public memberRights: number | undefined = 0

	public constructor(
		guildInfo?: GuildInformations | undefined,
		memberRights?: number | undefined
	) {
		super()
		this.guildInfo = guildInfo
		this.memberRights = memberRights
	}

	public serialize(writer: BinaryWriter): void {
		this.guildInfo!.serialize(writer)
		writer.writeVarInt(this.memberRights!)
	}

	public deserialize(reader: BinaryReader): void {
		this.guildInfo = new GuildInformations()
		this.guildInfo!.deserialize(reader)
		this.memberRights = reader.readVarInt()
	}

	public hydrate(
		data: GuildJoinedMessage | Record<string, any>
	): GuildJoinedMessage {
		if (data instanceof GuildJoinedMessage) {
			return data
		}

		this.guildInfo = new GuildInformations().hydrate(data.guildInfo)
		this.memberRights = data.memberRights

		return this
	}
}

export interface RawGuildMembershipMessage extends RawGuildJoinedMessage {
	id: number
}

export class GuildMembershipMessage extends GuildJoinedMessage {
	public static id = 2509

	public constructor(
		guildInfo?: GuildInformations | undefined,
		memberRights?: number | undefined
	) {
		super(guildInfo, memberRights)
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
	}

	public hydrate(
		data: GuildMembershipMessage | Record<string, any>
	): GuildMembershipMessage {
		if (data instanceof GuildMembershipMessage) {
			return data
		}

		super.hydrate(data)

		return this
	}
}

export interface RawSubscriptionZoneMessage {
	id: number
	active: boolean
}

export class SubscriptionZoneMessage extends DofusMessage {
	public static id: number = 5540

	public active: boolean | undefined = false

	public constructor(active?: boolean | undefined) {
		super()
		this.active = active
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeBoolean(this.active!)
	}

	public deserialize(reader: BinaryReader): void {
		this.active = reader.readBoolean()
	}

	public hydrate(
		data: SubscriptionZoneMessage | Record<string, any>
	): SubscriptionZoneMessage {
		if (data instanceof SubscriptionZoneMessage) {
			return data
		}

		this.active = data.active

		return this
	}
}

export interface RawGameFightPlacementSwapPositionsErrorMessage {
	id: number
}

export class GameFightPlacementSwapPositionsErrorMessage extends DofusMessage {
	public static id: number = 139

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public serialize(writer: BinaryWriter): void {}

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public deserialize(reader: BinaryReader): void {}

	public hydrate(
		data: GameFightPlacementSwapPositionsErrorMessage | Record<string, any>
	): GameFightPlacementSwapPositionsErrorMessage {
		if (data instanceof GameFightPlacementSwapPositionsErrorMessage) {
			return data
		}

		return this
	}
}

export interface RawExchangeReplyTaxVendorMessage {
	id: number
	objectValue: number
	totalTaxValue: number
}

export class ExchangeReplyTaxVendorMessage extends DofusMessage {
	public static id: number = 5902

	public objectValue: number | undefined = 0
	public totalTaxValue: number | undefined = 0

	public constructor(
		objectValue?: number | undefined,
		totalTaxValue?: number | undefined
	) {
		super()
		this.objectValue = objectValue
		this.totalTaxValue = totalTaxValue
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarLong(this.objectValue!)
		writer.writeVarLong(this.totalTaxValue!)
	}

	public deserialize(reader: BinaryReader): void {
		this.objectValue = reader.readVarLong()
		this.totalTaxValue = reader.readVarLong()
	}

	public hydrate(
		data: ExchangeReplyTaxVendorMessage | Record<string, any>
	): ExchangeReplyTaxVendorMessage {
		if (data instanceof ExchangeReplyTaxVendorMessage) {
			return data
		}

		this.objectValue = data.objectValue
		this.totalTaxValue = data.totalTaxValue

		return this
	}
}

export interface RawPresetUseResultMessage {
	id: number
	presetId: number
	code: number
}

export class PresetUseResultMessage extends DofusMessage {
	public static id: number = 2621

	public presetId: number | undefined = 0
	public code: number | undefined = 3

	public constructor(presetId?: number | undefined, code?: number | undefined) {
		super()
		this.presetId = presetId
		this.code = code
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeShort(this.presetId!)
		writer.writeByte(this.code!)
	}

	public deserialize(reader: BinaryReader): void {
		this.presetId = reader.readShort()
		this.code = reader.readByte()
	}

	public hydrate(
		data: PresetUseResultMessage | Record<string, any>
	): PresetUseResultMessage {
		if (data instanceof PresetUseResultMessage) {
			return data
		}

		this.presetId = data.presetId
		this.code = data.code

		return this
	}
}

export interface RawIdentificationFailedBannedMessage
	extends RawIdentificationFailedMessage {
	id: number
	banEndDate: number
}

export class IdentificationFailedBannedMessage extends IdentificationFailedMessage {
	public static id = 5027

	public banEndDate: number | undefined = 0

	public constructor(
		reason?: number | undefined,
		banEndDate?: number | undefined
	) {
		super(reason)
		this.banEndDate = banEndDate
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeDouble(this.banEndDate!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.banEndDate = reader.readDouble()
	}

	public hydrate(
		data: IdentificationFailedBannedMessage | Record<string, any>
	): IdentificationFailedBannedMessage {
		if (data instanceof IdentificationFailedBannedMessage) {
			return data
		}

		super.hydrate(data)

		this.banEndDate = data.banEndDate

		return this
	}
}

export interface RawBreachRewardsMessage {
	id: number
	rewards: BreachReward[]
}

export class BreachRewardsMessage extends DofusMessage {
	public static id: number = 5563

	public rewards: BreachReward[] | undefined

	public constructor(rewards?: BreachReward[] | undefined) {
		super()
		this.rewards = rewards
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeShort(this.rewards!.length)
		this.rewards!.forEach((current) => {
			current.serialize(writer)
		})
	}

	public deserialize(reader: BinaryReader): void {
		this.rewards = []
		const countRewards = reader.readShort()
		for (let i: number = 0; i < countRewards; i++) {
			const type: BreachReward = new BreachReward()
			type.deserialize(reader)
			this.rewards.push(type)
		}
	}

	public hydrate(
		data: BreachRewardsMessage | Record<string, any>
	): BreachRewardsMessage {
		if (data instanceof BreachRewardsMessage) {
			return data
		}

		this.rewards = data.rewards.map(
			(dataElement: BreachReward | Record<string, any>): BreachReward => {
				if (dataElement instanceof BreachReward) {
					return dataElement
				} else {
					return new BreachReward().hydrate(dataElement)
				}
			}
		)

		return this
	}
}

export interface RawObjectAveragePricesMessage {
	id: number
	ids: number[]
	avgPrices: number[]
}

export class ObjectAveragePricesMessage extends DofusMessage {
	public static id: number = 5500

	public ids: number[] | undefined
	public avgPrices: number[] | undefined

	public constructor(
		ids?: number[] | undefined,
		avgPrices?: number[] | undefined
	) {
		super()
		this.ids = ids
		this.avgPrices = avgPrices
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeShort(this.ids!.length)
		this.ids!.forEach((current: number) => writer.writeVarShort(current))
		writer.writeShort(this.avgPrices!.length)
		this.avgPrices!.forEach((current: number) => writer.writeVarLong(current))
	}

	public deserialize(reader: BinaryReader): void {
		this.ids = []
		const countIds = reader.readShort()
		for (let i: number = 0; i < countIds; i++) {
			this.ids.push(reader.readVarShort())
		}
		this.avgPrices = []
		const countAvgPrices = reader.readShort()
		for (let i: number = 0; i < countAvgPrices; i++) {
			this.avgPrices.push(reader.readVarLong())
		}
	}

	public hydrate(
		data: ObjectAveragePricesMessage | Record<string, any>
	): ObjectAveragePricesMessage {
		if (data instanceof ObjectAveragePricesMessage) {
			return data
		}

		this.ids = data.ids
		this.avgPrices = data.avgPrices

		return this
	}
}

export interface RawGuildHousesInformationMessage {
	id: number
	housesInformations: HouseInformationsForGuild[]
}

export class GuildHousesInformationMessage extends DofusMessage {
	public static id: number = 1180

	public housesInformations: HouseInformationsForGuild[] | undefined

	public constructor(
		housesInformations?: HouseInformationsForGuild[] | undefined
	) {
		super()
		this.housesInformations = housesInformations
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeShort(this.housesInformations!.length)
		this.housesInformations!.forEach((current) => {
			current.serialize(writer)
		})
	}

	public deserialize(reader: BinaryReader): void {
		this.housesInformations = []
		const countHousesInformations = reader.readShort()
		for (let i: number = 0; i < countHousesInformations; i++) {
			const type: HouseInformationsForGuild = new HouseInformationsForGuild()
			type.deserialize(reader)
			this.housesInformations.push(type)
		}
	}

	public hydrate(
		data: GuildHousesInformationMessage | Record<string, any>
	): GuildHousesInformationMessage {
		if (data instanceof GuildHousesInformationMessage) {
			return data
		}

		this.housesInformations = data.housesInformations.map(
			(
				dataElement: HouseInformationsForGuild | Record<string, any>
			): HouseInformationsForGuild => {
				if (dataElement instanceof HouseInformationsForGuild) {
					return dataElement
				} else {
					return new HouseInformationsForGuild().hydrate(dataElement)
				}
			}
		)

		return this
	}
}

export interface RawDisplayNumericalValuePaddockMessage {
	id: number
	rideId: number
	value: number
	type: number
}

export class DisplayNumericalValuePaddockMessage extends DofusMessage {
	public static id: number = 5004

	public rideId: number | undefined = 0
	public value: number | undefined = 0
	public type: number | undefined = 0

	public constructor(
		rideId?: number | undefined,
		value?: number | undefined,
		type?: number | undefined
	) {
		super()
		this.rideId = rideId
		this.value = value
		this.type = type
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeInt(this.rideId!)
		writer.writeInt(this.value!)
		writer.writeByte(this.type!)
	}

	public deserialize(reader: BinaryReader): void {
		this.rideId = reader.readInt()
		this.value = reader.readInt()
		this.type = reader.readByte()
	}

	public hydrate(
		data: DisplayNumericalValuePaddockMessage | Record<string, any>
	): DisplayNumericalValuePaddockMessage {
		if (data instanceof DisplayNumericalValuePaddockMessage) {
			return data
		}

		this.rideId = data.rideId
		this.value = data.value
		this.type = data.type

		return this
	}
}

export interface RawMailStatusMessage {
	id: number
	unread: number
	total: number
}

export class MailStatusMessage extends DofusMessage {
	public static id: number = 9985

	public unread: number | undefined = 0
	public total: number | undefined = 0

	public constructor(unread?: number | undefined, total?: number | undefined) {
		super()
		this.unread = unread
		this.total = total
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarShort(this.unread!)
		writer.writeVarShort(this.total!)
	}

	public deserialize(reader: BinaryReader): void {
		this.unread = reader.readVarShort()
		this.total = reader.readVarShort()
	}

	public hydrate(
		data: MailStatusMessage | Record<string, any>
	): MailStatusMessage {
		if (data instanceof MailStatusMessage) {
			return data
		}

		this.unread = data.unread
		this.total = data.total

		return this
	}
}

export interface RawNewMailMessage extends RawMailStatusMessage {
	id: number
	sendersAccountId: number[]
}

export class NewMailMessage extends MailStatusMessage {
	public static id = 2732

	public sendersAccountId: number[] | undefined

	public constructor(
		unread?: number | undefined,
		total?: number | undefined,
		sendersAccountId?: number[] | undefined
	) {
		super(unread, total)
		this.sendersAccountId = sendersAccountId
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeShort(this.sendersAccountId!.length)
		this.sendersAccountId!.forEach((current: number) =>
			writer.writeInt(current)
		)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.sendersAccountId = []
		const countSendersAccountId = reader.readShort()
		for (let i: number = 0; i < countSendersAccountId; i++) {
			this.sendersAccountId.push(reader.readInt())
		}
	}

	public hydrate(data: NewMailMessage | Record<string, any>): NewMailMessage {
		if (data instanceof NewMailMessage) {
			return data
		}

		super.hydrate(data)

		this.sendersAccountId = data.sendersAccountId

		return this
	}
}

export interface RawMountEquipedErrorMessage {
	id: number
	errorType: number
}

export class MountEquipedErrorMessage extends DofusMessage {
	public static id: number = 9127

	public errorType: number | undefined = 0

	public constructor(errorType?: number | undefined) {
		super()
		this.errorType = errorType
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeByte(this.errorType!)
	}

	public deserialize(reader: BinaryReader): void {
		this.errorType = reader.readByte()
	}

	public hydrate(
		data: MountEquipedErrorMessage | Record<string, any>
	): MountEquipedErrorMessage {
		if (data instanceof MountEquipedErrorMessage) {
			return data
		}

		this.errorType = data.errorType

		return this
	}
}

export interface RawAchievementRewardErrorMessage {
	id: number
	achievementId: number
}

export class AchievementRewardErrorMessage extends DofusMessage {
	public static id: number = 8876

	public achievementId: number | undefined = 0

	public constructor(achievementId?: number | undefined) {
		super()
		this.achievementId = achievementId
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeShort(this.achievementId!)
	}

	public deserialize(reader: BinaryReader): void {
		this.achievementId = reader.readShort()
	}

	public hydrate(
		data: AchievementRewardErrorMessage | Record<string, any>
	): AchievementRewardErrorMessage {
		if (data instanceof AchievementRewardErrorMessage) {
			return data
		}

		this.achievementId = data.achievementId

		return this
	}
}

export interface RawChallengeFightJoinRefusedMessage {
	id: number
	playerId: number
	reason: number
}

export class ChallengeFightJoinRefusedMessage extends DofusMessage {
	public static id: number = 3637

	public playerId: number | undefined = 0
	public reason: number | undefined = 0

	public constructor(
		playerId?: number | undefined,
		reason?: number | undefined
	) {
		super()
		this.playerId = playerId
		this.reason = reason
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarLong(this.playerId!)
		writer.writeByte(this.reason!)
	}

	public deserialize(reader: BinaryReader): void {
		this.playerId = reader.readVarLong()
		this.reason = reader.readByte()
	}

	public hydrate(
		data: ChallengeFightJoinRefusedMessage | Record<string, any>
	): ChallengeFightJoinRefusedMessage {
		if (data instanceof ChallengeFightJoinRefusedMessage) {
			return data
		}

		this.playerId = data.playerId
		this.reason = data.reason

		return this
	}
}

export interface RawGuildMemberLeavingMessage {
	id: number
	kicked: boolean
	memberId: number
}

export class GuildMemberLeavingMessage extends DofusMessage {
	public static id: number = 7590

	public kicked: boolean | undefined = false
	public memberId: number | undefined = 0

	public constructor(
		kicked?: boolean | undefined,
		memberId?: number | undefined
	) {
		super()
		this.kicked = kicked
		this.memberId = memberId
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeBoolean(this.kicked!)
		writer.writeVarLong(this.memberId!)
	}

	public deserialize(reader: BinaryReader): void {
		this.kicked = reader.readBoolean()
		this.memberId = reader.readVarLong()
	}

	public hydrate(
		data: GuildMemberLeavingMessage | Record<string, any>
	): GuildMemberLeavingMessage {
		if (data instanceof GuildMemberLeavingMessage) {
			return data
		}

		this.kicked = data.kicked
		this.memberId = data.memberId

		return this
	}
}

export interface RawForgettableSpellEquipmentSlotsMessage {
	id: number
	quantity: number
}

export class ForgettableSpellEquipmentSlotsMessage extends DofusMessage {
	public static id: number = 1271

	public quantity: number | undefined = 0

	public constructor(quantity?: number | undefined) {
		super()
		this.quantity = quantity
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarShort(this.quantity!)
	}

	public deserialize(reader: BinaryReader): void {
		this.quantity = reader.readVarShort()
	}

	public hydrate(
		data: ForgettableSpellEquipmentSlotsMessage | Record<string, any>
	): ForgettableSpellEquipmentSlotsMessage {
		if (data instanceof ForgettableSpellEquipmentSlotsMessage) {
			return data
		}

		this.quantity = data.quantity

		return this
	}
}

export interface RawGameActionSpamMessage {
	id: number
	cells: number[]
}

export class GameActionSpamMessage extends DofusMessage {
	public static id: number = 5912

	public cells: number[] | undefined

	public constructor(cells?: number[] | undefined) {
		super()
		this.cells = cells
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeShort(this.cells!.length)
		this.cells!.forEach((current: number) => writer.writeShort(current))
	}

	public deserialize(reader: BinaryReader): void {
		this.cells = []
		const countCells = reader.readShort()
		for (let i: number = 0; i < countCells; i++) {
			this.cells.push(reader.readShort())
		}
	}

	public hydrate(
		data: GameActionSpamMessage | Record<string, any>
	): GameActionSpamMessage {
		if (data instanceof GameActionSpamMessage) {
			return data
		}

		this.cells = data.cells

		return this
	}
}

export interface RawGuildLevelUpMessage {
	id: number
	newLevel: number
}

export class GuildLevelUpMessage extends DofusMessage {
	public static id: number = 963

	public newLevel: number | undefined = 0

	public constructor(newLevel?: number | undefined) {
		super()
		this.newLevel = newLevel
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeByte(this.newLevel!)
	}

	public deserialize(reader: BinaryReader): void {
		this.newLevel = reader.readByte()
	}

	public hydrate(
		data: GuildLevelUpMessage | Record<string, any>
	): GuildLevelUpMessage {
		if (data instanceof GuildLevelUpMessage) {
			return data
		}

		this.newLevel = data.newLevel

		return this
	}
}

export interface RawAllianceJoinedMessage {
	id: number
	allianceInfo: AllianceInformations
	enabled: boolean
	leadingGuildId: number
}

export class AllianceJoinedMessage extends DofusMessage {
	public static id: number = 1115

	public allianceInfo: AllianceInformations | undefined
	public enabled: boolean | undefined = false
	public leadingGuildId: number | undefined = 0

	public constructor(
		allianceInfo?: AllianceInformations | undefined,
		enabled?: boolean | undefined,
		leadingGuildId?: number | undefined
	) {
		super()
		this.allianceInfo = allianceInfo
		this.enabled = enabled
		this.leadingGuildId = leadingGuildId
	}

	public serialize(writer: BinaryWriter): void {
		this.allianceInfo!.serialize(writer)
		writer.writeBoolean(this.enabled!)
		writer.writeVarInt(this.leadingGuildId!)
	}

	public deserialize(reader: BinaryReader): void {
		this.allianceInfo = new AllianceInformations()
		this.allianceInfo!.deserialize(reader)
		this.enabled = reader.readBoolean()
		this.leadingGuildId = reader.readVarInt()
	}

	public hydrate(
		data: AllianceJoinedMessage | Record<string, any>
	): AllianceJoinedMessage {
		if (data instanceof AllianceJoinedMessage) {
			return data
		}

		this.allianceInfo = new AllianceInformations().hydrate(data.allianceInfo)
		this.enabled = data.enabled
		this.leadingGuildId = data.leadingGuildId

		return this
	}
}

export interface RawNumericWhoIsMessage {
	id: number
	playerId: number
	accountId: number
}

export class NumericWhoIsMessage extends DofusMessage {
	public static id: number = 5521

	public playerId: number | undefined = 0
	public accountId: number | undefined = 0

	public constructor(
		playerId?: number | undefined,
		accountId?: number | undefined
	) {
		super()
		this.playerId = playerId
		this.accountId = accountId
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarLong(this.playerId!)
		writer.writeInt(this.accountId!)
	}

	public deserialize(reader: BinaryReader): void {
		this.playerId = reader.readVarLong()
		this.accountId = reader.readInt()
	}

	public hydrate(
		data: NumericWhoIsMessage | Record<string, any>
	): NumericWhoIsMessage {
		if (data instanceof NumericWhoIsMessage) {
			return data
		}

		this.playerId = data.playerId
		this.accountId = data.accountId

		return this
	}
}

export interface RawExchangeBidSearchOkMessage {
	id: number
}

export class ExchangeBidSearchOkMessage extends DofusMessage {
	public static id: number = 8600

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public serialize(writer: BinaryWriter): void {}

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public deserialize(reader: BinaryReader): void {}

	public hydrate(
		data: ExchangeBidSearchOkMessage | Record<string, any>
	): ExchangeBidSearchOkMessage {
		if (data instanceof ExchangeBidSearchOkMessage) {
			return data
		}

		return this
	}
}

export interface RawPaddockToSellListMessage {
	id: number
	pageIndex: number
	totalPage: number
	paddockList: PaddockInformationsForSell[]
}

export class PaddockToSellListMessage extends DofusMessage {
	public static id: number = 2971

	public pageIndex: number | undefined = 0
	public totalPage: number | undefined = 0
	public paddockList: PaddockInformationsForSell[] | undefined

	public constructor(
		pageIndex?: number | undefined,
		totalPage?: number | undefined,
		paddockList?: PaddockInformationsForSell[] | undefined
	) {
		super()
		this.pageIndex = pageIndex
		this.totalPage = totalPage
		this.paddockList = paddockList
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarShort(this.pageIndex!)
		writer.writeVarShort(this.totalPage!)
		writer.writeShort(this.paddockList!.length)
		this.paddockList!.forEach((current) => {
			current.serialize(writer)
		})
	}

	public deserialize(reader: BinaryReader): void {
		this.pageIndex = reader.readVarShort()
		this.totalPage = reader.readVarShort()
		this.paddockList = []
		const countPaddockList = reader.readShort()
		for (let i: number = 0; i < countPaddockList; i++) {
			const type: PaddockInformationsForSell = new PaddockInformationsForSell()
			type.deserialize(reader)
			this.paddockList.push(type)
		}
	}

	public hydrate(
		data: PaddockToSellListMessage | Record<string, any>
	): PaddockToSellListMessage {
		if (data instanceof PaddockToSellListMessage) {
			return data
		}

		this.pageIndex = data.pageIndex
		this.totalPage = data.totalPage
		this.paddockList = data.paddockList.map(
			(
				dataElement: PaddockInformationsForSell | Record<string, any>
			): PaddockInformationsForSell => {
				if (dataElement instanceof PaddockInformationsForSell) {
					return dataElement
				} else {
					return new PaddockInformationsForSell().hydrate(dataElement)
				}
			}
		)

		return this
	}
}

export interface RawHavenBagDailyLoteryMessage {
	id: number
	returnType: number
	gameActionId: string
}

export class HavenBagDailyLoteryMessage extends DofusMessage {
	public static id: number = 7129

	public returnType: number | undefined = 0
	public gameActionId: string | undefined

	public constructor(
		returnType?: number | undefined,
		gameActionId?: string | undefined
	) {
		super()
		this.returnType = returnType
		this.gameActionId = gameActionId
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeByte(this.returnType!)
		writer.writeUTF(this.gameActionId!)
	}

	public deserialize(reader: BinaryReader): void {
		this.returnType = reader.readByte()
		this.gameActionId = reader.readUTF()
	}

	public hydrate(
		data: HavenBagDailyLoteryMessage | Record<string, any>
	): HavenBagDailyLoteryMessage {
		if (data instanceof HavenBagDailyLoteryMessage) {
			return data
		}

		this.returnType = data.returnType
		this.gameActionId = data.gameActionId

		return this
	}
}

export interface RawPurchasableDialogMessage {
	id: number
	buyOrSell: boolean
	secondHand: boolean
	purchasableId: number
	purchasableInstanceId: number
	price: number
}

export class PurchasableDialogMessage extends DofusMessage {
	public static id: number = 3240

	public buyOrSell: boolean | undefined = false
	public secondHand: boolean | undefined = false
	public purchasableId: number | undefined = 0
	public purchasableInstanceId: number | undefined = 0
	public price: number | undefined = 0

	public constructor(
		buyOrSell?: boolean | undefined,
		secondHand?: boolean | undefined,
		purchasableId?: number | undefined,
		purchasableInstanceId?: number | undefined,
		price?: number | undefined
	) {
		super()
		this.buyOrSell = buyOrSell
		this.secondHand = secondHand
		this.purchasableId = purchasableId
		this.purchasableInstanceId = purchasableInstanceId
		this.price = price
	}

	public serialize(writer: BinaryWriter): void {
		let box0: number = 0
		box0 = setFlag(box0, 0, this.buyOrSell!)
		box0 = setFlag(box0, 1, this.secondHand!)
		writer.writeByte(box0)
		writer.writeDouble(this.purchasableId!)
		writer.writeInt(this.purchasableInstanceId!)
		writer.writeVarLong(this.price!)
	}

	public deserialize(reader: BinaryReader): void {
		const box0 = reader.readByte()
		this.buyOrSell = getFlag(box0, 0)
		this.secondHand = getFlag(box0, 1)
		this.purchasableId = reader.readDouble()
		this.purchasableInstanceId = reader.readInt()
		this.price = reader.readVarLong()
	}

	public hydrate(
		data: PurchasableDialogMessage | Record<string, any>
	): PurchasableDialogMessage {
		if (data instanceof PurchasableDialogMessage) {
			return data
		}

		this.buyOrSell = data.buyOrSell
		this.secondHand = data.secondHand
		this.purchasableId = data.purchasableId
		this.purchasableInstanceId = data.purchasableInstanceId
		this.price = data.price

		return this
	}
}

export interface RawAlignmentWarEffortDonationResultMessage {
	id: number
	result: number
}

export class AlignmentWarEffortDonationResultMessage extends DofusMessage {
	public static id: number = 3258

	public result: number | undefined = 4

	public constructor(result?: number | undefined) {
		super()
		this.result = result
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeByte(this.result!)
	}

	public deserialize(reader: BinaryReader): void {
		this.result = reader.readByte()
	}

	public hydrate(
		data: AlignmentWarEffortDonationResultMessage | Record<string, any>
	): AlignmentWarEffortDonationResultMessage {
		if (data instanceof AlignmentWarEffortDonationResultMessage) {
			return data
		}

		this.result = data.result

		return this
	}
}

export interface RawAllianceMotdMessage extends RawSocialNoticeMessage {
	id: number
}

export class AllianceMotdMessage extends SocialNoticeMessage {
	public static id = 6551

	public constructor(
		content?: string | undefined,
		timestamp?: number | undefined,
		memberId?: number | undefined,
		memberName?: string | undefined
	) {
		super(content, timestamp, memberId, memberName)
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
	}

	public hydrate(
		data: AllianceMotdMessage | Record<string, any>
	): AllianceMotdMessage {
		if (data instanceof AllianceMotdMessage) {
			return data
		}

		super.hydrate(data)

		return this
	}
}

export interface RawGameRolePlayArenaLeagueRewardsMessage {
	id: number
	seasonId: number
	leagueId: number
	ladderPosition: number
	endSeasonReward: boolean
}

export class GameRolePlayArenaLeagueRewardsMessage extends DofusMessage {
	public static id: number = 8309

	public seasonId: number | undefined = 0
	public leagueId: number | undefined = 0
	public ladderPosition: number | undefined = 0
	public endSeasonReward: boolean | undefined = false

	public constructor(
		seasonId?: number | undefined,
		leagueId?: number | undefined,
		ladderPosition?: number | undefined,
		endSeasonReward?: boolean | undefined
	) {
		super()
		this.seasonId = seasonId
		this.leagueId = leagueId
		this.ladderPosition = ladderPosition
		this.endSeasonReward = endSeasonReward
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarShort(this.seasonId!)
		writer.writeVarShort(this.leagueId!)
		writer.writeInt(this.ladderPosition!)
		writer.writeBoolean(this.endSeasonReward!)
	}

	public deserialize(reader: BinaryReader): void {
		this.seasonId = reader.readVarShort()
		this.leagueId = reader.readVarShort()
		this.ladderPosition = reader.readInt()
		this.endSeasonReward = reader.readBoolean()
	}

	public hydrate(
		data: GameRolePlayArenaLeagueRewardsMessage | Record<string, any>
	): GameRolePlayArenaLeagueRewardsMessage {
		if (data instanceof GameRolePlayArenaLeagueRewardsMessage) {
			return data
		}

		this.seasonId = data.seasonId
		this.leagueId = data.leagueId
		this.ladderPosition = data.ladderPosition
		this.endSeasonReward = data.endSeasonReward

		return this
	}
}

export interface RawGameRolePlayShowActorWithEventMessage
	extends RawGameRolePlayShowActorMessage {
	id: number
	actorEventId: number
}

export class GameRolePlayShowActorWithEventMessage extends GameRolePlayShowActorMessage {
	public static id = 6726

	public actorEventId: number | undefined = 0

	public constructor(
		informations?: GameRolePlayActorInformations | undefined,
		actorEventId?: number | undefined
	) {
		super(informations)
		this.actorEventId = actorEventId
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeByte(this.actorEventId!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.actorEventId = reader.readByte()
	}

	public hydrate(
		data: GameRolePlayShowActorWithEventMessage | Record<string, any>
	): GameRolePlayShowActorWithEventMessage {
		if (data instanceof GameRolePlayShowActorWithEventMessage) {
			return data
		}

		super.hydrate(data)

		this.actorEventId = data.actorEventId

		return this
	}
}

export interface RawHaapiAuthErrorMessage {
	id: number
	type: number
}

export class HaapiAuthErrorMessage extends DofusMessage {
	public static id: number = 4210

	public type: number | undefined = 0

	public constructor(type?: number | undefined) {
		super()
		this.type = type
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeByte(this.type!)
	}

	public deserialize(reader: BinaryReader): void {
		this.type = reader.readByte()
	}

	public hydrate(
		data: HaapiAuthErrorMessage | Record<string, any>
	): HaapiAuthErrorMessage {
		if (data instanceof HaapiAuthErrorMessage) {
			return data
		}

		this.type = data.type

		return this
	}
}

export interface RawPartyDeletedMessage extends RawAbstractPartyMessage {
	id: number
}

export class PartyDeletedMessage extends AbstractPartyMessage {
	public static id = 360

	public constructor(partyId?: number | undefined) {
		super(partyId)
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
	}

	public hydrate(
		data: PartyDeletedMessage | Record<string, any>
	): PartyDeletedMessage {
		if (data instanceof PartyDeletedMessage) {
			return data
		}

		super.hydrate(data)

		return this
	}
}

export interface RawGuildFactsMessage {
	id: number
	infos: GuildFactSheetInformations
	creationDate: number
	nbTaxCollectors: number
	members: CharacterMinimalGuildPublicInformations[]
}

export class GuildFactsMessage extends DofusMessage {
	public static id: number = 6491

	public infos: GuildFactSheetInformations | undefined
	public creationDate: number | undefined = 0
	public nbTaxCollectors: number | undefined = 0
	public members: CharacterMinimalGuildPublicInformations[] | undefined

	public constructor(
		infos?: GuildFactSheetInformations | undefined,
		creationDate?: number | undefined,
		nbTaxCollectors?: number | undefined,
		members?: CharacterMinimalGuildPublicInformations[] | undefined
	) {
		super()
		this.infos = infos
		this.creationDate = creationDate
		this.nbTaxCollectors = nbTaxCollectors
		this.members = members
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeShort(this.infos!.id)
		this.infos!.serialize(writer)
		writer.writeInt(this.creationDate!)
		writer.writeVarShort(this.nbTaxCollectors!)
		writer.writeShort(this.members!.length)
		this.members!.forEach((current) => {
			current.serialize(writer)
		})
	}

	public deserialize(reader: BinaryReader): void {
		const infosTypeId: number = reader.readShort()
		this.infos = new types[infosTypeId]() as GuildFactSheetInformations
		this.infos!.deserialize(reader)
		this.creationDate = reader.readInt()
		this.nbTaxCollectors = reader.readVarShort()
		this.members = []
		const countMembers = reader.readShort()
		for (let i: number = 0; i < countMembers; i++) {
			const type: CharacterMinimalGuildPublicInformations = new CharacterMinimalGuildPublicInformations()
			type.deserialize(reader)
			this.members.push(type)
		}
	}

	public hydrate(
		data: GuildFactsMessage | Record<string, any>
	): GuildFactsMessage {
		if (data instanceof GuildFactsMessage) {
			return data
		}

		this.infos = (new types[
			data.infos.id
		]() as GuildFactSheetInformations).hydrate(data.infos)
		this.creationDate = data.creationDate
		this.nbTaxCollectors = data.nbTaxCollectors
		this.members = data.members.map(
			(
				dataElement:
					| CharacterMinimalGuildPublicInformations
					| Record<string, any>
			): CharacterMinimalGuildPublicInformations => {
				if (dataElement instanceof CharacterMinimalGuildPublicInformations) {
					return dataElement
				} else {
					return new CharacterMinimalGuildPublicInformations().hydrate(
						dataElement
					)
				}
			}
		)

		return this
	}
}

export interface RawGuildInAllianceFactsMessage extends RawGuildFactsMessage {
	id: number
	allianceInfos: BasicNamedAllianceInformations
}

export class GuildInAllianceFactsMessage extends GuildFactsMessage {
	public static id = 6411

	public allianceInfos: BasicNamedAllianceInformations | undefined

	public constructor(
		infos?: GuildFactSheetInformations | undefined,
		creationDate?: number | undefined,
		nbTaxCollectors?: number | undefined,
		members?: CharacterMinimalGuildPublicInformations[] | undefined,
		allianceInfos?: BasicNamedAllianceInformations | undefined
	) {
		super(infos, creationDate, nbTaxCollectors, members)
		this.allianceInfos = allianceInfos
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		this.allianceInfos!.serialize(writer)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.allianceInfos = new BasicNamedAllianceInformations()
		this.allianceInfos!.deserialize(reader)
	}

	public hydrate(
		data: GuildInAllianceFactsMessage | Record<string, any>
	): GuildInAllianceFactsMessage {
		if (data instanceof GuildInAllianceFactsMessage) {
			return data
		}

		super.hydrate(data)

		this.allianceInfos = new BasicNamedAllianceInformations().hydrate(
			data.allianceInfos
		)

		return this
	}
}

export interface RawHouseBuyResultMessage {
	id: number
	secondHand: boolean
	bought: boolean
	houseId: number
	instanceId: number
	realPrice: number
}

export class HouseBuyResultMessage extends DofusMessage {
	public static id: number = 7313

	public secondHand: boolean | undefined = false
	public bought: boolean | undefined = false
	public houseId: number | undefined = 0
	public instanceId: number | undefined = 0
	public realPrice: number | undefined = 0

	public constructor(
		secondHand?: boolean | undefined,
		bought?: boolean | undefined,
		houseId?: number | undefined,
		instanceId?: number | undefined,
		realPrice?: number | undefined
	) {
		super()
		this.secondHand = secondHand
		this.bought = bought
		this.houseId = houseId
		this.instanceId = instanceId
		this.realPrice = realPrice
	}

	public serialize(writer: BinaryWriter): void {
		let box0: number = 0
		box0 = setFlag(box0, 0, this.secondHand!)
		box0 = setFlag(box0, 1, this.bought!)
		writer.writeByte(box0)
		writer.writeVarInt(this.houseId!)
		writer.writeInt(this.instanceId!)
		writer.writeVarLong(this.realPrice!)
	}

	public deserialize(reader: BinaryReader): void {
		const box0 = reader.readByte()
		this.secondHand = getFlag(box0, 0)
		this.bought = getFlag(box0, 1)
		this.houseId = reader.readVarInt()
		this.instanceId = reader.readInt()
		this.realPrice = reader.readVarLong()
	}

	public hydrate(
		data: HouseBuyResultMessage | Record<string, any>
	): HouseBuyResultMessage {
		if (data instanceof HouseBuyResultMessage) {
			return data
		}

		this.secondHand = data.secondHand
		this.bought = data.bought
		this.houseId = data.houseId
		this.instanceId = data.instanceId
		this.realPrice = data.realPrice

		return this
	}
}

export interface RawSystemMessageDisplayMessage {
	id: number
	hangUp: boolean
	msgId: number
	parameters: string[]
}

export class SystemMessageDisplayMessage extends DofusMessage {
	public static id: number = 6724

	public hangUp: boolean | undefined = false
	public msgId: number | undefined = 0
	public parameters: string[] | undefined

	public constructor(
		hangUp?: boolean | undefined,
		msgId?: number | undefined,
		parameters?: string[] | undefined
	) {
		super()
		this.hangUp = hangUp
		this.msgId = msgId
		this.parameters = parameters
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeBoolean(this.hangUp!)
		writer.writeVarShort(this.msgId!)
		writer.writeShort(this.parameters!.length)
		this.parameters!.forEach((current: string) => writer.writeUTF(current))
	}

	public deserialize(reader: BinaryReader): void {
		this.hangUp = reader.readBoolean()
		this.msgId = reader.readVarShort()
		this.parameters = []
		const countParameters = reader.readShort()
		for (let i: number = 0; i < countParameters; i++) {
			this.parameters.push(reader.readUTF())
		}
	}

	public hydrate(
		data: SystemMessageDisplayMessage | Record<string, any>
	): SystemMessageDisplayMessage {
		if (data instanceof SystemMessageDisplayMessage) {
			return data
		}

		this.hangUp = data.hangUp
		this.msgId = data.msgId
		this.parameters = data.parameters

		return this
	}
}

export interface RawExchangeBidHouseInListUpdatedMessage
	extends RawExchangeBidHouseInListAddedMessage {
	id: number
}

export class ExchangeBidHouseInListUpdatedMessage extends ExchangeBidHouseInListAddedMessage {
	public static id = 2741

	public constructor(
		itemUID?: number | undefined,
		objectGID?: number | undefined,
		objectType?: number | undefined,
		effects?: ObjectEffect[] | undefined,
		prices?: number[] | undefined
	) {
		super(itemUID, objectGID, objectType, effects, prices)
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
	}

	public hydrate(
		data: ExchangeBidHouseInListUpdatedMessage | Record<string, any>
	): ExchangeBidHouseInListUpdatedMessage {
		if (data instanceof ExchangeBidHouseInListUpdatedMessage) {
			return data
		}

		super.hydrate(data)

		return this
	}
}

export interface RawAllianceModificationStartedMessage {
	id: number
	canChangeName: boolean
	canChangeTag: boolean
	canChangeEmblem: boolean
}

export class AllianceModificationStartedMessage extends DofusMessage {
	public static id: number = 6628

	public canChangeName: boolean | undefined = false
	public canChangeTag: boolean | undefined = false
	public canChangeEmblem: boolean | undefined = false

	public constructor(
		canChangeName?: boolean | undefined,
		canChangeTag?: boolean | undefined,
		canChangeEmblem?: boolean | undefined
	) {
		super()
		this.canChangeName = canChangeName
		this.canChangeTag = canChangeTag
		this.canChangeEmblem = canChangeEmblem
	}

	public serialize(writer: BinaryWriter): void {
		let box0: number = 0
		box0 = setFlag(box0, 0, this.canChangeName!)
		box0 = setFlag(box0, 1, this.canChangeTag!)
		box0 = setFlag(box0, 2, this.canChangeEmblem!)
		writer.writeByte(box0)
	}

	public deserialize(reader: BinaryReader): void {
		const box0 = reader.readByte()
		this.canChangeName = getFlag(box0, 0)
		this.canChangeTag = getFlag(box0, 1)
		this.canChangeEmblem = getFlag(box0, 2)
	}

	public hydrate(
		data: AllianceModificationStartedMessage | Record<string, any>
	): AllianceModificationStartedMessage {
		if (data instanceof AllianceModificationStartedMessage) {
			return data
		}

		this.canChangeName = data.canChangeName
		this.canChangeTag = data.canChangeTag
		this.canChangeEmblem = data.canChangeEmblem

		return this
	}
}

export interface RawExchangeMountsTakenFromPaddockMessage {
	id: number
	name: string
	worldX: number
	worldY: number
	ownername: string
}

export class ExchangeMountsTakenFromPaddockMessage extends DofusMessage {
	public static id: number = 2583

	public name: string | undefined
	public worldX: number | undefined = 0
	public worldY: number | undefined = 0
	public ownername: string | undefined

	public constructor(
		name?: string | undefined,
		worldX?: number | undefined,
		worldY?: number | undefined,
		ownername?: string | undefined
	) {
		super()
		this.name = name
		this.worldX = worldX
		this.worldY = worldY
		this.ownername = ownername
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeUTF(this.name!)
		writer.writeShort(this.worldX!)
		writer.writeShort(this.worldY!)
		writer.writeUTF(this.ownername!)
	}

	public deserialize(reader: BinaryReader): void {
		this.name = reader.readUTF()
		this.worldX = reader.readShort()
		this.worldY = reader.readShort()
		this.ownername = reader.readUTF()
	}

	public hydrate(
		data: ExchangeMountsTakenFromPaddockMessage | Record<string, any>
	): ExchangeMountsTakenFromPaddockMessage {
		if (data instanceof ExchangeMountsTakenFromPaddockMessage) {
			return data
		}

		this.name = data.name
		this.worldX = data.worldX
		this.worldY = data.worldY
		this.ownername = data.ownername

		return this
	}
}

export interface RawRecycleResultMessage {
	id: number
	nuggetsForPrism: number
	nuggetsForPlayer: number
}

export class RecycleResultMessage extends DofusMessage {
	public static id: number = 2403

	public nuggetsForPrism: number | undefined = 0
	public nuggetsForPlayer: number | undefined = 0

	public constructor(
		nuggetsForPrism?: number | undefined,
		nuggetsForPlayer?: number | undefined
	) {
		super()
		this.nuggetsForPrism = nuggetsForPrism
		this.nuggetsForPlayer = nuggetsForPlayer
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarInt(this.nuggetsForPrism!)
		writer.writeVarInt(this.nuggetsForPlayer!)
	}

	public deserialize(reader: BinaryReader): void {
		this.nuggetsForPrism = reader.readVarInt()
		this.nuggetsForPlayer = reader.readVarInt()
	}

	public hydrate(
		data: RecycleResultMessage | Record<string, any>
	): RecycleResultMessage {
		if (data instanceof RecycleResultMessage) {
			return data
		}

		this.nuggetsForPrism = data.nuggetsForPrism
		this.nuggetsForPlayer = data.nuggetsForPlayer

		return this
	}
}

export interface RawHaapiTokenMessage {
	id: number
	token: string
}

export class HaapiTokenMessage extends DofusMessage {
	public static id: number = 3058

	public token: string | undefined

	public constructor(token?: string | undefined) {
		super()
		this.token = token
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeUTF(this.token!)
	}

	public deserialize(reader: BinaryReader): void {
		this.token = reader.readUTF()
	}

	public hydrate(
		data: HaapiTokenMessage | Record<string, any>
	): HaapiTokenMessage {
		if (data instanceof HaapiTokenMessage) {
			return data
		}

		this.token = data.token

		return this
	}
}

export interface RawCurrentServerStatusUpdateMessage {
	id: number
	status: number
}

export class CurrentServerStatusUpdateMessage extends DofusMessage {
	public static id: number = 1218

	public status: number | undefined = 1

	public constructor(status?: number | undefined) {
		super()
		this.status = status
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeByte(this.status!)
	}

	public deserialize(reader: BinaryReader): void {
		this.status = reader.readByte()
	}

	public hydrate(
		data: CurrentServerStatusUpdateMessage | Record<string, any>
	): CurrentServerStatusUpdateMessage {
		if (data instanceof CurrentServerStatusUpdateMessage) {
			return data
		}

		this.status = data.status

		return this
	}
}

export interface RawPartyCannotJoinErrorMessage
	extends RawAbstractPartyMessage {
	id: number
	reason: number
}

export class PartyCannotJoinErrorMessage extends AbstractPartyMessage {
	public static id = 842

	public reason: number | undefined = 0

	public constructor(
		partyId?: number | undefined,
		reason?: number | undefined
	) {
		super(partyId)
		this.reason = reason
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeByte(this.reason!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.reason = reader.readByte()
	}

	public hydrate(
		data: PartyCannotJoinErrorMessage | Record<string, any>
	): PartyCannotJoinErrorMessage {
		if (data instanceof PartyCannotJoinErrorMessage) {
			return data
		}

		super.hydrate(data)

		this.reason = data.reason

		return this
	}
}

export interface RawAllianceGuildLeavingMessage {
	id: number
	kicked: boolean
	guildId: number
}

export class AllianceGuildLeavingMessage extends DofusMessage {
	public static id: number = 2353

	public kicked: boolean | undefined = false
	public guildId: number | undefined = 0

	public constructor(
		kicked?: boolean | undefined,
		guildId?: number | undefined
	) {
		super()
		this.kicked = kicked
		this.guildId = guildId
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeBoolean(this.kicked!)
		writer.writeVarInt(this.guildId!)
	}

	public deserialize(reader: BinaryReader): void {
		this.kicked = reader.readBoolean()
		this.guildId = reader.readVarInt()
	}

	public hydrate(
		data: AllianceGuildLeavingMessage | Record<string, any>
	): AllianceGuildLeavingMessage {
		if (data instanceof AllianceGuildLeavingMessage) {
			return data
		}

		this.kicked = data.kicked
		this.guildId = data.guildId

		return this
	}
}

export interface RawGuildInvitationStateRecruterMessage {
	id: number
	recrutedName: string
	invitationState: number
}

export class GuildInvitationStateRecruterMessage extends DofusMessage {
	public static id: number = 7258

	public recrutedName: string | undefined
	public invitationState: number | undefined = 0

	public constructor(
		recrutedName?: string | undefined,
		invitationState?: number | undefined
	) {
		super()
		this.recrutedName = recrutedName
		this.invitationState = invitationState
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeUTF(this.recrutedName!)
		writer.writeByte(this.invitationState!)
	}

	public deserialize(reader: BinaryReader): void {
		this.recrutedName = reader.readUTF()
		this.invitationState = reader.readByte()
	}

	public hydrate(
		data: GuildInvitationStateRecruterMessage | Record<string, any>
	): GuildInvitationStateRecruterMessage {
		if (data instanceof GuildInvitationStateRecruterMessage) {
			return data
		}

		this.recrutedName = data.recrutedName
		this.invitationState = data.invitationState

		return this
	}
}

export interface RawIgnoredListMessage {
	id: number
	ignoredList: IgnoredInformations[]
}

export class IgnoredListMessage extends DofusMessage {
	public static id: number = 4244

	public ignoredList: IgnoredInformations[] | undefined

	public constructor(ignoredList?: IgnoredInformations[] | undefined) {
		super()
		this.ignoredList = ignoredList
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeShort(this.ignoredList!.length)
		this.ignoredList!.forEach((current) => {
			writer.writeShort(current.id)
			current.serialize(writer)
		})
	}

	public deserialize(reader: BinaryReader): void {
		this.ignoredList = []
		const countIgnoredList = reader.readShort()
		for (let i: number = 0; i < countIgnoredList; i++) {
			const ignoredListTypeId: number = reader.readShort()
			const type: IgnoredInformations = new types[
				ignoredListTypeId
			]() as IgnoredInformations
			type.deserialize(reader)
			this.ignoredList.push(type)
		}
	}

	public hydrate(
		data: IgnoredListMessage | Record<string, any>
	): IgnoredListMessage {
		if (data instanceof IgnoredListMessage) {
			return data
		}

		this.ignoredList = data.ignoredList.map(
			(
				dataElement: IgnoredInformations | Record<string, any>
			): IgnoredInformations => {
				if (dataElement instanceof IgnoredInformations) {
					return dataElement
				} else {
					return (new types[dataElement.id]() as IgnoredInformations).hydrate(
						dataElement
					)
				}
			}
		)

		return this
	}
}

export interface RawIgnoredAddedMessage {
	id: number
	ignoreAdded: IgnoredInformations
	session: boolean
}

export class IgnoredAddedMessage extends DofusMessage {
	public static id: number = 1152

	public ignoreAdded: IgnoredInformations | undefined
	public session: boolean | undefined = false

	public constructor(
		ignoreAdded?: IgnoredInformations | undefined,
		session?: boolean | undefined
	) {
		super()
		this.ignoreAdded = ignoreAdded
		this.session = session
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeShort(this.ignoreAdded!.id)
		this.ignoreAdded!.serialize(writer)
		writer.writeBoolean(this.session!)
	}

	public deserialize(reader: BinaryReader): void {
		const ignoreAddedTypeId: number = reader.readShort()
		this.ignoreAdded = new types[ignoreAddedTypeId]() as IgnoredInformations
		this.ignoreAdded!.deserialize(reader)
		this.session = reader.readBoolean()
	}

	public hydrate(
		data: IgnoredAddedMessage | Record<string, any>
	): IgnoredAddedMessage {
		if (data instanceof IgnoredAddedMessage) {
			return data
		}

		this.ignoreAdded = (new types[
			data.ignoreAdded.id
		]() as IgnoredInformations).hydrate(data.ignoreAdded)
		this.session = data.session

		return this
	}
}

export interface RawEntityInformationMessage {
	id: number
	entity: EntityInformation
}

export class EntityInformationMessage extends DofusMessage {
	public static id: number = 325

	public entity: EntityInformation | undefined

	public constructor(entity?: EntityInformation | undefined) {
		super()
		this.entity = entity
	}

	public serialize(writer: BinaryWriter): void {
		this.entity!.serialize(writer)
	}

	public deserialize(reader: BinaryReader): void {
		this.entity = new EntityInformation()
		this.entity!.deserialize(reader)
	}

	public hydrate(
		data: EntityInformationMessage | Record<string, any>
	): EntityInformationMessage {
		if (data instanceof EntityInformationMessage) {
			return data
		}

		this.entity = new EntityInformation().hydrate(data.entity)

		return this
	}
}

export interface RawAlignmentWarEffortProgressionMessage {
	id: number
	effortProgressions: AlignmentWarEffortInformation[]
}

export class AlignmentWarEffortProgressionMessage extends DofusMessage {
	public static id: number = 1424

	public effortProgressions: AlignmentWarEffortInformation[] | undefined

	public constructor(
		effortProgressions?: AlignmentWarEffortInformation[] | undefined
	) {
		super()
		this.effortProgressions = effortProgressions
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeShort(this.effortProgressions!.length)
		this.effortProgressions!.forEach((current) => {
			current.serialize(writer)
		})
	}

	public deserialize(reader: BinaryReader): void {
		this.effortProgressions = []
		const countEffortProgressions = reader.readShort()
		for (let i: number = 0; i < countEffortProgressions; i++) {
			const type: AlignmentWarEffortInformation = new AlignmentWarEffortInformation()
			type.deserialize(reader)
			this.effortProgressions.push(type)
		}
	}

	public hydrate(
		data: AlignmentWarEffortProgressionMessage | Record<string, any>
	): AlignmentWarEffortProgressionMessage {
		if (data instanceof AlignmentWarEffortProgressionMessage) {
			return data
		}

		this.effortProgressions = data.effortProgressions.map(
			(
				dataElement: AlignmentWarEffortInformation | Record<string, any>
			): AlignmentWarEffortInformation => {
				if (dataElement instanceof AlignmentWarEffortInformation) {
					return dataElement
				} else {
					return new AlignmentWarEffortInformation().hydrate(dataElement)
				}
			}
		)

		return this
	}
}

export interface RawGuildHouseUpdateInformationMessage {
	id: number
	housesInformations: HouseInformationsForGuild
}

export class GuildHouseUpdateInformationMessage extends DofusMessage {
	public static id: number = 7382

	public housesInformations: HouseInformationsForGuild | undefined

	public constructor(
		housesInformations?: HouseInformationsForGuild | undefined
	) {
		super()
		this.housesInformations = housesInformations
	}

	public serialize(writer: BinaryWriter): void {
		this.housesInformations!.serialize(writer)
	}

	public deserialize(reader: BinaryReader): void {
		this.housesInformations = new HouseInformationsForGuild()
		this.housesInformations!.deserialize(reader)
	}

	public hydrate(
		data: GuildHouseUpdateInformationMessage | Record<string, any>
	): GuildHouseUpdateInformationMessage {
		if (data instanceof GuildHouseUpdateInformationMessage) {
			return data
		}

		this.housesInformations = new HouseInformationsForGuild().hydrate(
			data.housesInformations
		)

		return this
	}
}

export interface RawMountDataMessage {
	id: number
	mountData: MountClientData
}

export class MountDataMessage extends DofusMessage {
	public static id: number = 7426

	public mountData: MountClientData | undefined

	public constructor(mountData?: MountClientData | undefined) {
		super()
		this.mountData = mountData
	}

	public serialize(writer: BinaryWriter): void {
		this.mountData!.serialize(writer)
	}

	public deserialize(reader: BinaryReader): void {
		this.mountData = new MountClientData()
		this.mountData!.deserialize(reader)
	}

	public hydrate(
		data: MountDataMessage | Record<string, any>
	): MountDataMessage {
		if (data instanceof MountDataMessage) {
			return data
		}

		this.mountData = new MountClientData().hydrate(data.mountData)

		return this
	}
}

export interface RawNpcDialogCreationMessage {
	id: number
	mapId: number
	npcId: number
}

export class NpcDialogCreationMessage extends DofusMessage {
	public static id: number = 5741

	public mapId: number | undefined = 0
	public npcId: number | undefined = 0

	public constructor(mapId?: number | undefined, npcId?: number | undefined) {
		super()
		this.mapId = mapId
		this.npcId = npcId
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeDouble(this.mapId!)
		writer.writeInt(this.npcId!)
	}

	public deserialize(reader: BinaryReader): void {
		this.mapId = reader.readDouble()
		this.npcId = reader.readInt()
	}

	public hydrate(
		data: NpcDialogCreationMessage | Record<string, any>
	): NpcDialogCreationMessage {
		if (data instanceof NpcDialogCreationMessage) {
			return data
		}

		this.mapId = data.mapId
		this.npcId = data.npcId

		return this
	}
}

export interface RawPortalDialogCreationMessage
	extends RawNpcDialogCreationMessage {
	id: number
	type: number
}

export class PortalDialogCreationMessage extends NpcDialogCreationMessage {
	public static id = 9795

	public type: number | undefined = 0

	public constructor(
		mapId?: number | undefined,
		npcId?: number | undefined,
		type?: number | undefined
	) {
		super(mapId, npcId)
		this.type = type
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeInt(this.type!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.type = reader.readInt()
	}

	public hydrate(
		data: PortalDialogCreationMessage | Record<string, any>
	): PortalDialogCreationMessage {
		if (data instanceof PortalDialogCreationMessage) {
			return data
		}

		super.hydrate(data)

		this.type = data.type

		return this
	}
}

export interface RawPrismSetSabotagedRefusedMessage {
	id: number
	subAreaId: number
	reason: number
}

export class PrismSetSabotagedRefusedMessage extends DofusMessage {
	public static id: number = 2267

	public subAreaId: number | undefined = 0
	public reason: number | undefined = 0

	public constructor(
		subAreaId?: number | undefined,
		reason?: number | undefined
	) {
		super()
		this.subAreaId = subAreaId
		this.reason = reason
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarShort(this.subAreaId!)
		writer.writeByte(this.reason!)
	}

	public deserialize(reader: BinaryReader): void {
		this.subAreaId = reader.readVarShort()
		this.reason = reader.readByte()
	}

	public hydrate(
		data: PrismSetSabotagedRefusedMessage | Record<string, any>
	): PrismSetSabotagedRefusedMessage {
		if (data instanceof PrismSetSabotagedRefusedMessage) {
			return data
		}

		this.subAreaId = data.subAreaId
		this.reason = data.reason

		return this
	}
}

export interface RawMountSetMessage {
	id: number
	mountData: MountClientData
}

export class MountSetMessage extends DofusMessage {
	public static id: number = 7836

	public mountData: MountClientData | undefined

	public constructor(mountData?: MountClientData | undefined) {
		super()
		this.mountData = mountData
	}

	public serialize(writer: BinaryWriter): void {
		this.mountData!.serialize(writer)
	}

	public deserialize(reader: BinaryReader): void {
		this.mountData = new MountClientData()
		this.mountData!.deserialize(reader)
	}

	public hydrate(data: MountSetMessage | Record<string, any>): MountSetMessage {
		if (data instanceof MountSetMessage) {
			return data
		}

		this.mountData = new MountClientData().hydrate(data.mountData)

		return this
	}
}

export interface RawPartyInvitationCancelledForGuestMessage
	extends RawAbstractPartyMessage {
	id: number
	cancelerId: number
}

export class PartyInvitationCancelledForGuestMessage extends AbstractPartyMessage {
	public static id = 2521

	public cancelerId: number | undefined = 0

	public constructor(
		partyId?: number | undefined,
		cancelerId?: number | undefined
	) {
		super(partyId)
		this.cancelerId = cancelerId
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeVarLong(this.cancelerId!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.cancelerId = reader.readVarLong()
	}

	public hydrate(
		data: PartyInvitationCancelledForGuestMessage | Record<string, any>
	): PartyInvitationCancelledForGuestMessage {
		if (data instanceof PartyInvitationCancelledForGuestMessage) {
			return data
		}

		super.hydrate(data)

		this.cancelerId = data.cancelerId

		return this
	}
}

export interface RawExchangeCraftCountModifiedMessage {
	id: number
	count: number
}

export class ExchangeCraftCountModifiedMessage extends DofusMessage {
	public static id: number = 5488

	public count: number | undefined = 0

	public constructor(count?: number | undefined) {
		super()
		this.count = count
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarInt(this.count!)
	}

	public deserialize(reader: BinaryReader): void {
		this.count = reader.readVarInt()
	}

	public hydrate(
		data: ExchangeCraftCountModifiedMessage | Record<string, any>
	): ExchangeCraftCountModifiedMessage {
		if (data instanceof ExchangeCraftCountModifiedMessage) {
			return data
		}

		this.count = data.count

		return this
	}
}

export interface RawExchangeSellOkMessage {
	id: number
}

export class ExchangeSellOkMessage extends DofusMessage {
	public static id: number = 678

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public serialize(writer: BinaryWriter): void {}

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public deserialize(reader: BinaryReader): void {}

	public hydrate(
		data: ExchangeSellOkMessage | Record<string, any>
	): ExchangeSellOkMessage {
		if (data instanceof ExchangeSellOkMessage) {
			return data
		}

		return this
	}
}

export interface RawGuildCreationStartedMessage {
	id: number
}

export class GuildCreationStartedMessage extends DofusMessage {
	public static id: number = 1527

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public serialize(writer: BinaryWriter): void {}

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public deserialize(reader: BinaryReader): void {}

	public hydrate(
		data: GuildCreationStartedMessage | Record<string, any>
	): GuildCreationStartedMessage {
		if (data instanceof GuildCreationStartedMessage) {
			return data
		}

		return this
	}
}

export interface RawMimicryObjectPreviewMessage {
	id: number
	result: ObjectItem
}

export class MimicryObjectPreviewMessage extends DofusMessage {
	public static id: number = 907

	public result: ObjectItem | undefined

	public constructor(result?: ObjectItem | undefined) {
		super()
		this.result = result
	}

	public serialize(writer: BinaryWriter): void {
		this.result!.serialize(writer)
	}

	public deserialize(reader: BinaryReader): void {
		this.result = new ObjectItem()
		this.result!.deserialize(reader)
	}

	public hydrate(
		data: MimicryObjectPreviewMessage | Record<string, any>
	): MimicryObjectPreviewMessage {
		if (data instanceof MimicryObjectPreviewMessage) {
			return data
		}

		this.result = new ObjectItem().hydrate(data.result)

		return this
	}
}

export interface RawNotificationListMessage {
	id: number
	flags: number[]
}

export class NotificationListMessage extends DofusMessage {
	public static id: number = 7372

	public flags: number[] | undefined

	public constructor(flags?: number[] | undefined) {
		super()
		this.flags = flags
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeShort(this.flags!.length)
		this.flags!.forEach((current: number) => writer.writeVarInt(current))
	}

	public deserialize(reader: BinaryReader): void {
		this.flags = []
		const countFlags = reader.readShort()
		for (let i: number = 0; i < countFlags; i++) {
			this.flags.push(reader.readVarInt())
		}
	}

	public hydrate(
		data: NotificationListMessage | Record<string, any>
	): NotificationListMessage {
		if (data instanceof NotificationListMessage) {
			return data
		}

		this.flags = data.flags

		return this
	}
}

export interface RawStorageObjectUpdateMessage {
	id: number
	object_: ObjectItem
}

export class StorageObjectUpdateMessage extends DofusMessage {
	public static id: number = 7486

	public object_: ObjectItem | undefined

	public constructor(object_?: ObjectItem | undefined) {
		super()
		this.object_ = object_
	}

	public serialize(writer: BinaryWriter): void {
		this.object_!.serialize(writer)
	}

	public deserialize(reader: BinaryReader): void {
		this.object_ = new ObjectItem()
		this.object_!.deserialize(reader)
	}

	public hydrate(
		data: StorageObjectUpdateMessage | Record<string, any>
	): StorageObjectUpdateMessage {
		if (data instanceof StorageObjectUpdateMessage) {
			return data
		}

		this.object_ = new ObjectItem().hydrate(data.object_)

		return this
	}
}

export interface RawCharactersListErrorMessage {
	id: number
}

export class CharactersListErrorMessage extends DofusMessage {
	public static id: number = 6801

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public serialize(writer: BinaryWriter): void {}

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public deserialize(reader: BinaryReader): void {}

	public hydrate(
		data: CharactersListErrorMessage | Record<string, any>
	): CharactersListErrorMessage {
		if (data instanceof CharactersListErrorMessage) {
			return data
		}

		return this
	}
}

export interface RawJobCrafterDirectoryListMessage {
	id: number
	listEntries: JobCrafterDirectoryListEntry[]
}

export class JobCrafterDirectoryListMessage extends DofusMessage {
	public static id: number = 9887

	public listEntries: JobCrafterDirectoryListEntry[] | undefined

	public constructor(listEntries?: JobCrafterDirectoryListEntry[] | undefined) {
		super()
		this.listEntries = listEntries
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeShort(this.listEntries!.length)
		this.listEntries!.forEach((current) => {
			current.serialize(writer)
		})
	}

	public deserialize(reader: BinaryReader): void {
		this.listEntries = []
		const countListEntries = reader.readShort()
		for (let i: number = 0; i < countListEntries; i++) {
			const type: JobCrafterDirectoryListEntry = new JobCrafterDirectoryListEntry()
			type.deserialize(reader)
			this.listEntries.push(type)
		}
	}

	public hydrate(
		data: JobCrafterDirectoryListMessage | Record<string, any>
	): JobCrafterDirectoryListMessage {
		if (data instanceof JobCrafterDirectoryListMessage) {
			return data
		}

		this.listEntries = data.listEntries.map(
			(
				dataElement: JobCrafterDirectoryListEntry | Record<string, any>
			): JobCrafterDirectoryListEntry => {
				if (dataElement instanceof JobCrafterDirectoryListEntry) {
					return dataElement
				} else {
					return new JobCrafterDirectoryListEntry().hydrate(dataElement)
				}
			}
		)

		return this
	}
}

export interface RawEditHavenBagFinishedMessage {
	id: number
}

export class EditHavenBagFinishedMessage extends DofusMessage {
	public static id: number = 9636

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public serialize(writer: BinaryWriter): void {}

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public deserialize(reader: BinaryReader): void {}

	public hydrate(
		data: EditHavenBagFinishedMessage | Record<string, any>
	): EditHavenBagFinishedMessage {
		if (data instanceof EditHavenBagFinishedMessage) {
			return data
		}

		return this
	}
}

export interface RawStatedElementUpdatedMessage {
	id: number
	statedElement: StatedElement
}

export class StatedElementUpdatedMessage extends DofusMessage {
	public static id: number = 5876

	public statedElement: StatedElement | undefined

	public constructor(statedElement?: StatedElement | undefined) {
		super()
		this.statedElement = statedElement
	}

	public serialize(writer: BinaryWriter): void {
		this.statedElement!.serialize(writer)
	}

	public deserialize(reader: BinaryReader): void {
		this.statedElement = new StatedElement()
		this.statedElement!.deserialize(reader)
	}

	public hydrate(
		data: StatedElementUpdatedMessage | Record<string, any>
	): StatedElementUpdatedMessage {
		if (data instanceof StatedElementUpdatedMessage) {
			return data
		}

		this.statedElement = new StatedElement().hydrate(data.statedElement)

		return this
	}
}

export interface RawIdolPartyRefreshMessage {
	id: number
	partyIdol: PartyIdol
}

export class IdolPartyRefreshMessage extends DofusMessage {
	public static id: number = 5851

	public partyIdol: PartyIdol | undefined

	public constructor(partyIdol?: PartyIdol | undefined) {
		super()
		this.partyIdol = partyIdol
	}

	public serialize(writer: BinaryWriter): void {
		this.partyIdol!.serialize(writer)
	}

	public deserialize(reader: BinaryReader): void {
		this.partyIdol = new PartyIdol()
		this.partyIdol!.deserialize(reader)
	}

	public hydrate(
		data: IdolPartyRefreshMessage | Record<string, any>
	): IdolPartyRefreshMessage {
		if (data instanceof IdolPartyRefreshMessage) {
			return data
		}

		this.partyIdol = new PartyIdol().hydrate(data.partyIdol)

		return this
	}
}

export interface RawClientYouAreDrunkMessage extends RawDebugInClientMessage {
	id: number
}

export class ClientYouAreDrunkMessage extends DebugInClientMessage {
	public static id = 1921

	public constructor(level?: number | undefined, message?: string | undefined) {
		super(level, message)
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
	}

	public hydrate(
		data: ClientYouAreDrunkMessage | Record<string, any>
	): ClientYouAreDrunkMessage {
		if (data instanceof ClientYouAreDrunkMessage) {
			return data
		}

		super.hydrate(data)

		return this
	}
}

export interface RawGameContextCreateErrorMessage {
	id: number
}

export class GameContextCreateErrorMessage extends DofusMessage {
	public static id: number = 6223

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public serialize(writer: BinaryWriter): void {}

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public deserialize(reader: BinaryReader): void {}

	public hydrate(
		data: GameContextCreateErrorMessage | Record<string, any>
	): GameContextCreateErrorMessage {
		if (data instanceof GameContextCreateErrorMessage) {
			return data
		}

		return this
	}
}

export interface RawObjectQuantityMessage {
	id: number
	objectUID: number
	quantity: number
	origin: number
}

export class ObjectQuantityMessage extends DofusMessage {
	public static id: number = 5076

	public objectUID: number | undefined = 0
	public quantity: number | undefined = 0
	public origin: number | undefined = 0

	public constructor(
		objectUID?: number | undefined,
		quantity?: number | undefined,
		origin?: number | undefined
	) {
		super()
		this.objectUID = objectUID
		this.quantity = quantity
		this.origin = origin
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarInt(this.objectUID!)
		writer.writeVarInt(this.quantity!)
		writer.writeByte(this.origin!)
	}

	public deserialize(reader: BinaryReader): void {
		this.objectUID = reader.readVarInt()
		this.quantity = reader.readVarInt()
		this.origin = reader.readByte()
	}

	public hydrate(
		data: ObjectQuantityMessage | Record<string, any>
	): ObjectQuantityMessage {
		if (data instanceof ObjectQuantityMessage) {
			return data
		}

		this.objectUID = data.objectUID
		this.quantity = data.quantity
		this.origin = data.origin

		return this
	}
}

export interface RawCharacterLevelUpMessage {
	id: number
	newLevel: number
}

export class CharacterLevelUpMessage extends DofusMessage {
	public static id: number = 246

	public newLevel: number | undefined = 0

	public constructor(newLevel?: number | undefined) {
		super()
		this.newLevel = newLevel
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarShort(this.newLevel!)
	}

	public deserialize(reader: BinaryReader): void {
		this.newLevel = reader.readVarShort()
	}

	public hydrate(
		data: CharacterLevelUpMessage | Record<string, any>
	): CharacterLevelUpMessage {
		if (data instanceof CharacterLevelUpMessage) {
			return data
		}

		this.newLevel = data.newLevel

		return this
	}
}

export interface RawCharacterLevelUpInformationMessage
	extends RawCharacterLevelUpMessage {
	id: number
	name: string
	id_: number
}

export class CharacterLevelUpInformationMessage extends CharacterLevelUpMessage {
	public static id = 2236

	public name: string | undefined
	public id_: number | undefined = 0

	public constructor(
		newLevel?: number | undefined,
		name?: string | undefined,
		id_?: number | undefined
	) {
		super(newLevel)
		this.name = name
		this.id_ = id_
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeUTF(this.name!)
		writer.writeVarLong(this.id_!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.name = reader.readUTF()
		this.id_ = reader.readVarLong()
	}

	public hydrate(
		data: CharacterLevelUpInformationMessage | Record<string, any>
	): CharacterLevelUpInformationMessage {
		if (data instanceof CharacterLevelUpInformationMessage) {
			return data
		}

		super.hydrate(data)

		this.name = data.name
		this.id_ = data.id_

		return this
	}
}

export interface RawGuildMemberWarnOnConnectionStateMessage {
	id: number
	enable: boolean
}

export class GuildMemberWarnOnConnectionStateMessage extends DofusMessage {
	public static id: number = 4763

	public enable: boolean | undefined = false

	public constructor(enable?: boolean | undefined) {
		super()
		this.enable = enable
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeBoolean(this.enable!)
	}

	public deserialize(reader: BinaryReader): void {
		this.enable = reader.readBoolean()
	}

	public hydrate(
		data: GuildMemberWarnOnConnectionStateMessage | Record<string, any>
	): GuildMemberWarnOnConnectionStateMessage {
		if (data instanceof GuildMemberWarnOnConnectionStateMessage) {
			return data
		}

		this.enable = data.enable

		return this
	}
}

export interface RawFriendUpdateMessage {
	id: number
	friendUpdated: FriendInformations
}

export class FriendUpdateMessage extends DofusMessage {
	public static id: number = 3021

	public friendUpdated: FriendInformations | undefined

	public constructor(friendUpdated?: FriendInformations | undefined) {
		super()
		this.friendUpdated = friendUpdated
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeShort(this.friendUpdated!.id)
		this.friendUpdated!.serialize(writer)
	}

	public deserialize(reader: BinaryReader): void {
		const friendUpdatedTypeId: number = reader.readShort()
		this.friendUpdated = new types[friendUpdatedTypeId]() as FriendInformations
		this.friendUpdated!.deserialize(reader)
	}

	public hydrate(
		data: FriendUpdateMessage | Record<string, any>
	): FriendUpdateMessage {
		if (data instanceof FriendUpdateMessage) {
			return data
		}

		this.friendUpdated = (new types[
			data.friendUpdated.id
		]() as FriendInformations).hydrate(data.friendUpdated)
		return this
	}
}

export interface RawHavenBagPermissionsUpdateMessage {
	id: number
	permissions: number
}

export class HavenBagPermissionsUpdateMessage extends DofusMessage {
	public static id: number = 1466

	public permissions: number | undefined = 0

	public constructor(permissions?: number | undefined) {
		super()
		this.permissions = permissions
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeInt(this.permissions!)
	}

	public deserialize(reader: BinaryReader): void {
		this.permissions = reader.readInt()
	}

	public hydrate(
		data: HavenBagPermissionsUpdateMessage | Record<string, any>
	): HavenBagPermissionsUpdateMessage {
		if (data instanceof HavenBagPermissionsUpdateMessage) {
			return data
		}

		this.permissions = data.permissions

		return this
	}
}

export interface RawAuthenticationTicketRefusedMessage {
	id: number
}

export class AuthenticationTicketRefusedMessage extends DofusMessage {
	public static id: number = 9238

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public serialize(writer: BinaryWriter): void {}

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public deserialize(reader: BinaryReader): void {}

	public hydrate(
		data: AuthenticationTicketRefusedMessage | Record<string, any>
	): AuthenticationTicketRefusedMessage {
		if (data instanceof AuthenticationTicketRefusedMessage) {
			return data
		}

		return this
	}
}

export interface RawAchievementDetailsMessage {
	id: number
	achievement: Achievement
}

export class AchievementDetailsMessage extends DofusMessage {
	public static id: number = 2146

	public achievement: Achievement | undefined

	public constructor(achievement?: Achievement | undefined) {
		super()
		this.achievement = achievement
	}

	public serialize(writer: BinaryWriter): void {
		this.achievement!.serialize(writer)
	}

	public deserialize(reader: BinaryReader): void {
		this.achievement = new Achievement()
		this.achievement!.deserialize(reader)
	}

	public hydrate(
		data: AchievementDetailsMessage | Record<string, any>
	): AchievementDetailsMessage {
		if (data instanceof AchievementDetailsMessage) {
			return data
		}

		this.achievement = new Achievement().hydrate(data.achievement)

		return this
	}
}

export interface RawTaxCollectorMovementMessage {
	id: number
	movementType: number
	basicInfos: TaxCollectorBasicInformations
	playerId: number
	playerName: string
}

export class TaxCollectorMovementMessage extends DofusMessage {
	public static id: number = 5525

	public movementType: number | undefined = 0
	public basicInfos: TaxCollectorBasicInformations | undefined
	public playerId: number | undefined = 0
	public playerName: string | undefined

	public constructor(
		movementType?: number | undefined,
		basicInfos?: TaxCollectorBasicInformations | undefined,
		playerId?: number | undefined,
		playerName?: string | undefined
	) {
		super()
		this.movementType = movementType
		this.basicInfos = basicInfos
		this.playerId = playerId
		this.playerName = playerName
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeByte(this.movementType!)
		this.basicInfos!.serialize(writer)
		writer.writeVarLong(this.playerId!)
		writer.writeUTF(this.playerName!)
	}

	public deserialize(reader: BinaryReader): void {
		this.movementType = reader.readByte()
		this.basicInfos = new TaxCollectorBasicInformations()
		this.basicInfos!.deserialize(reader)
		this.playerId = reader.readVarLong()
		this.playerName = reader.readUTF()
	}

	public hydrate(
		data: TaxCollectorMovementMessage | Record<string, any>
	): TaxCollectorMovementMessage {
		if (data instanceof TaxCollectorMovementMessage) {
			return data
		}

		this.movementType = data.movementType
		this.basicInfos = new TaxCollectorBasicInformations().hydrate(
			data.basicInfos
		)
		this.playerId = data.playerId
		this.playerName = data.playerName

		return this
	}
}

export interface RawAlliancePrismDialogQuestionMessage {
	id: number
}

export class AlliancePrismDialogQuestionMessage extends DofusMessage {
	public static id: number = 7636

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public serialize(writer: BinaryWriter): void {}

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public deserialize(reader: BinaryReader): void {}

	public hydrate(
		data: AlliancePrismDialogQuestionMessage | Record<string, any>
	): AlliancePrismDialogQuestionMessage {
		if (data instanceof AlliancePrismDialogQuestionMessage) {
			return data
		}

		return this
	}
}

export interface RawExchangeStartOkMountWithOutPaddockMessage {
	id: number
	stabledMountsDescription: MountClientData[]
}

export class ExchangeStartOkMountWithOutPaddockMessage extends DofusMessage {
	public static id: number = 2914

	public stabledMountsDescription: MountClientData[] | undefined

	public constructor(stabledMountsDescription?: MountClientData[] | undefined) {
		super()
		this.stabledMountsDescription = stabledMountsDescription
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeShort(this.stabledMountsDescription!.length)
		this.stabledMountsDescription!.forEach((current) => {
			current.serialize(writer)
		})
	}

	public deserialize(reader: BinaryReader): void {
		this.stabledMountsDescription = []
		const countStabledMountsDescription = reader.readShort()
		for (let i: number = 0; i < countStabledMountsDescription; i++) {
			const type: MountClientData = new MountClientData()
			type.deserialize(reader)
			this.stabledMountsDescription.push(type)
		}
	}

	public hydrate(
		data: ExchangeStartOkMountWithOutPaddockMessage | Record<string, any>
	): ExchangeStartOkMountWithOutPaddockMessage {
		if (data instanceof ExchangeStartOkMountWithOutPaddockMessage) {
			return data
		}

		this.stabledMountsDescription = data.stabledMountsDescription.map(
			(dataElement: MountClientData | Record<string, any>): MountClientData => {
				if (dataElement instanceof MountClientData) {
					return dataElement
				} else {
					return new MountClientData().hydrate(dataElement)
				}
			}
		)

		return this
	}
}

export interface RawTreasureHuntMessage {
	id: number
	questType: number
	startMapId: number
	knownStepsList: TreasureHuntStep[]
	totalStepCount: number
	checkPointCurrent: number
	checkPointTotal: number
	availableRetryCount: number
	flags: TreasureHuntFlag[]
}

export class TreasureHuntMessage extends DofusMessage {
	public static id: number = 7742

	public questType: number | undefined = 0
	public startMapId: number | undefined = 0
	public knownStepsList: TreasureHuntStep[] | undefined
	public totalStepCount: number | undefined = 0
	public checkPointCurrent: number | undefined = 0
	public checkPointTotal: number | undefined = 0
	public availableRetryCount: number | undefined = 0
	public flags: TreasureHuntFlag[] | undefined

	public constructor(
		questType?: number | undefined,
		startMapId?: number | undefined,
		knownStepsList?: TreasureHuntStep[] | undefined,
		totalStepCount?: number | undefined,
		checkPointCurrent?: number | undefined,
		checkPointTotal?: number | undefined,
		availableRetryCount?: number | undefined,
		flags?: TreasureHuntFlag[] | undefined
	) {
		super()
		this.questType = questType
		this.startMapId = startMapId
		this.knownStepsList = knownStepsList
		this.totalStepCount = totalStepCount
		this.checkPointCurrent = checkPointCurrent
		this.checkPointTotal = checkPointTotal
		this.availableRetryCount = availableRetryCount
		this.flags = flags
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeByte(this.questType!)
		writer.writeDouble(this.startMapId!)
		writer.writeShort(this.knownStepsList!.length)
		this.knownStepsList!.forEach((current) => {
			writer.writeShort(current.id)
			current.serialize(writer)
		})
		writer.writeByte(this.totalStepCount!)
		writer.writeVarInt(this.checkPointCurrent!)
		writer.writeVarInt(this.checkPointTotal!)
		writer.writeInt(this.availableRetryCount!)
		writer.writeShort(this.flags!.length)
		this.flags!.forEach((current) => {
			current.serialize(writer)
		})
	}

	public deserialize(reader: BinaryReader): void {
		this.questType = reader.readByte()
		this.startMapId = reader.readDouble()
		this.knownStepsList = []
		const countKnownStepsList = reader.readShort()
		for (let i: number = 0; i < countKnownStepsList; i++) {
			const knownStepsListTypeId: number = reader.readShort()
			const type: TreasureHuntStep = new types[
				knownStepsListTypeId
			]() as TreasureHuntStep
			type.deserialize(reader)
			this.knownStepsList.push(type)
		}
		this.totalStepCount = reader.readByte()
		this.checkPointCurrent = reader.readVarInt()
		this.checkPointTotal = reader.readVarInt()
		this.availableRetryCount = reader.readInt()
		this.flags = []
		const countFlags = reader.readShort()
		for (let i: number = 0; i < countFlags; i++) {
			const type: TreasureHuntFlag = new TreasureHuntFlag()
			type.deserialize(reader)
			this.flags.push(type)
		}
	}

	public hydrate(
		data: TreasureHuntMessage | Record<string, any>
	): TreasureHuntMessage {
		if (data instanceof TreasureHuntMessage) {
			return data
		}

		this.questType = data.questType
		this.startMapId = data.startMapId
		this.knownStepsList = data.knownStepsList.map(
			(
				dataElement: TreasureHuntStep | Record<string, any>
			): TreasureHuntStep => {
				if (dataElement instanceof TreasureHuntStep) {
					return dataElement
				} else {
					return (new types[dataElement.id]() as TreasureHuntStep).hydrate(
						dataElement
					)
				}
			}
		)
		this.totalStepCount = data.totalStepCount
		this.checkPointCurrent = data.checkPointCurrent
		this.checkPointTotal = data.checkPointTotal
		this.availableRetryCount = data.availableRetryCount
		this.flags = data.flags.map(
			(
				dataElement: TreasureHuntFlag | Record<string, any>
			): TreasureHuntFlag => {
				if (dataElement instanceof TreasureHuntFlag) {
					return dataElement
				} else {
					return new TreasureHuntFlag().hydrate(dataElement)
				}
			}
		)

		return this
	}
}

export interface RawExchangeStartedWithPodsMessage
	extends RawExchangeStartedMessage {
	id: number
	firstCharacterId: number
	firstCharacterCurrentWeight: number
	firstCharacterMaxWeight: number
	secondCharacterId: number
	secondCharacterCurrentWeight: number
	secondCharacterMaxWeight: number
}

export class ExchangeStartedWithPodsMessage extends ExchangeStartedMessage {
	public static id = 1554

	public firstCharacterId: number | undefined = 0
	public firstCharacterCurrentWeight: number | undefined = 0
	public firstCharacterMaxWeight: number | undefined = 0
	public secondCharacterId: number | undefined = 0
	public secondCharacterCurrentWeight: number | undefined = 0
	public secondCharacterMaxWeight: number | undefined = 0

	public constructor(
		exchangeType?: number | undefined,
		firstCharacterId?: number | undefined,
		firstCharacterCurrentWeight?: number | undefined,
		firstCharacterMaxWeight?: number | undefined,
		secondCharacterId?: number | undefined,
		secondCharacterCurrentWeight?: number | undefined,
		secondCharacterMaxWeight?: number | undefined
	) {
		super(exchangeType)
		this.firstCharacterId = firstCharacterId
		this.firstCharacterCurrentWeight = firstCharacterCurrentWeight
		this.firstCharacterMaxWeight = firstCharacterMaxWeight
		this.secondCharacterId = secondCharacterId
		this.secondCharacterCurrentWeight = secondCharacterCurrentWeight
		this.secondCharacterMaxWeight = secondCharacterMaxWeight
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeDouble(this.firstCharacterId!)
		writer.writeVarInt(this.firstCharacterCurrentWeight!)
		writer.writeVarInt(this.firstCharacterMaxWeight!)
		writer.writeDouble(this.secondCharacterId!)
		writer.writeVarInt(this.secondCharacterCurrentWeight!)
		writer.writeVarInt(this.secondCharacterMaxWeight!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.firstCharacterId = reader.readDouble()
		this.firstCharacterCurrentWeight = reader.readVarInt()
		this.firstCharacterMaxWeight = reader.readVarInt()
		this.secondCharacterId = reader.readDouble()
		this.secondCharacterCurrentWeight = reader.readVarInt()
		this.secondCharacterMaxWeight = reader.readVarInt()
	}

	public hydrate(
		data: ExchangeStartedWithPodsMessage | Record<string, any>
	): ExchangeStartedWithPodsMessage {
		if (data instanceof ExchangeStartedWithPodsMessage) {
			return data
		}

		super.hydrate(data)

		this.firstCharacterId = data.firstCharacterId
		this.firstCharacterCurrentWeight = data.firstCharacterCurrentWeight
		this.firstCharacterMaxWeight = data.firstCharacterMaxWeight
		this.secondCharacterId = data.secondCharacterId
		this.secondCharacterCurrentWeight = data.secondCharacterCurrentWeight
		this.secondCharacterMaxWeight = data.secondCharacterMaxWeight

		return this
	}
}

export interface RawGameRolePlayArenaFightPropositionMessage {
	id: number
	fightId: number
	alliesId: number[]
	duration: number
}

export class GameRolePlayArenaFightPropositionMessage extends DofusMessage {
	public static id: number = 3669

	public fightId: number | undefined = 0
	public alliesId: number[] | undefined
	public duration: number | undefined = 0

	public constructor(
		fightId?: number | undefined,
		alliesId?: number[] | undefined,
		duration?: number | undefined
	) {
		super()
		this.fightId = fightId
		this.alliesId = alliesId
		this.duration = duration
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarShort(this.fightId!)
		writer.writeShort(this.alliesId!.length)
		this.alliesId!.forEach((current: number) => writer.writeDouble(current))
		writer.writeVarShort(this.duration!)
	}

	public deserialize(reader: BinaryReader): void {
		this.fightId = reader.readVarShort()
		this.alliesId = []
		const countAlliesId = reader.readShort()
		for (let i: number = 0; i < countAlliesId; i++) {
			this.alliesId.push(reader.readDouble())
		}
		this.duration = reader.readVarShort()
	}

	public hydrate(
		data: GameRolePlayArenaFightPropositionMessage | Record<string, any>
	): GameRolePlayArenaFightPropositionMessage {
		if (data instanceof GameRolePlayArenaFightPropositionMessage) {
			return data
		}

		this.fightId = data.fightId
		this.alliesId = data.alliesId
		this.duration = data.duration

		return this
	}
}

export interface RawStartupActionAddMessage {
	id: number
	newAction: StartupActionAddObject
}

export class StartupActionAddMessage extends DofusMessage {
	public static id: number = 1188

	public newAction: StartupActionAddObject | undefined

	public constructor(newAction?: StartupActionAddObject | undefined) {
		super()
		this.newAction = newAction
	}

	public serialize(writer: BinaryWriter): void {
		this.newAction!.serialize(writer)
	}

	public deserialize(reader: BinaryReader): void {
		this.newAction = new StartupActionAddObject()
		this.newAction!.deserialize(reader)
	}

	public hydrate(
		data: StartupActionAddMessage | Record<string, any>
	): StartupActionAddMessage {
		if (data instanceof StartupActionAddMessage) {
			return data
		}

		this.newAction = new StartupActionAddObject().hydrate(data.newAction)

		return this
	}
}

export interface RawPrismFightRemovedMessage {
	id: number
	subAreaId: number
}

export class PrismFightRemovedMessage extends DofusMessage {
	public static id: number = 6447

	public subAreaId: number | undefined = 0

	public constructor(subAreaId?: number | undefined) {
		super()
		this.subAreaId = subAreaId
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarShort(this.subAreaId!)
	}

	public deserialize(reader: BinaryReader): void {
		this.subAreaId = reader.readVarShort()
	}

	public hydrate(
		data: PrismFightRemovedMessage | Record<string, any>
	): PrismFightRemovedMessage {
		if (data instanceof PrismFightRemovedMessage) {
			return data
		}

		this.subAreaId = data.subAreaId

		return this
	}
}

export interface RawItemNoMoreAvailableMessage {
	id: number
}

export class ItemNoMoreAvailableMessage extends DofusMessage {
	public static id: number = 8962

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public serialize(writer: BinaryWriter): void {}

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public deserialize(reader: BinaryReader): void {}

	public hydrate(
		data: ItemNoMoreAvailableMessage | Record<string, any>
	): ItemNoMoreAvailableMessage {
		if (data instanceof ItemNoMoreAvailableMessage) {
			return data
		}

		return this
	}
}

export interface RawChatServerWithObjectMessage extends RawChatServerMessage {
	id: number
	objects: ObjectItem[]
}

export class ChatServerWithObjectMessage extends ChatServerMessage {
	public static id = 1344

	public objects: ObjectItem[] | undefined

	public constructor(
		channel?: number | undefined,
		content?: string | undefined,
		timestamp?: number | undefined,
		fingerprint?: string | undefined,
		senderId?: number | undefined,
		senderName?: string | undefined,
		prefix?: string | undefined,
		senderAccountId?: number | undefined,
		objects?: ObjectItem[] | undefined
	) {
		super(
			channel,
			content,
			timestamp,
			fingerprint,
			senderId,
			senderName,
			prefix,
			senderAccountId
		)
		this.objects = objects
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeShort(this.objects!.length)
		this.objects!.forEach((current) => {
			current.serialize(writer)
		})
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.objects = []
		const countObjects = reader.readShort()
		for (let i: number = 0; i < countObjects; i++) {
			const type: ObjectItem = new ObjectItem()
			type.deserialize(reader)
			this.objects.push(type)
		}
	}

	public hydrate(
		data: ChatServerWithObjectMessage | Record<string, any>
	): ChatServerWithObjectMessage {
		if (data instanceof ChatServerWithObjectMessage) {
			return data
		}

		super.hydrate(data)

		this.objects = data.objects.map(
			(dataElement: ObjectItem | Record<string, any>): ObjectItem => {
				if (dataElement instanceof ObjectItem) {
					return dataElement
				} else {
					return new ObjectItem().hydrate(dataElement)
				}
			}
		)

		return this
	}
}

export interface RawTaxCollectorMovementAddMessage {
	id: number
	informations: TaxCollectorInformations
}

export class TaxCollectorMovementAddMessage extends DofusMessage {
	public static id: number = 3252

	public informations: TaxCollectorInformations | undefined

	public constructor(informations?: TaxCollectorInformations | undefined) {
		super()
		this.informations = informations
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeShort(this.informations!.id)
		this.informations!.serialize(writer)
	}

	public deserialize(reader: BinaryReader): void {
		const informationsTypeId: number = reader.readShort()
		this.informations = new types[
			informationsTypeId
		]() as TaxCollectorInformations
		this.informations!.deserialize(reader)
	}

	public hydrate(
		data: TaxCollectorMovementAddMessage | Record<string, any>
	): TaxCollectorMovementAddMessage {
		if (data instanceof TaxCollectorMovementAddMessage) {
			return data
		}

		this.informations = (new types[
			data.informations.id
		]() as TaxCollectorInformations).hydrate(data.informations)
		return this
	}
}

export interface RawEvolutiveObjectRecycleResultMessage {
	id: number
	recycledItems: RecycledItem[]
}

export class EvolutiveObjectRecycleResultMessage extends DofusMessage {
	public static id: number = 8622

	public recycledItems: RecycledItem[] | undefined

	public constructor(recycledItems?: RecycledItem[] | undefined) {
		super()
		this.recycledItems = recycledItems
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeShort(this.recycledItems!.length)
		this.recycledItems!.forEach((current) => {
			current.serialize(writer)
		})
	}

	public deserialize(reader: BinaryReader): void {
		this.recycledItems = []
		const countRecycledItems = reader.readShort()
		for (let i: number = 0; i < countRecycledItems; i++) {
			const type: RecycledItem = new RecycledItem()
			type.deserialize(reader)
			this.recycledItems.push(type)
		}
	}

	public hydrate(
		data: EvolutiveObjectRecycleResultMessage | Record<string, any>
	): EvolutiveObjectRecycleResultMessage {
		if (data instanceof EvolutiveObjectRecycleResultMessage) {
			return data
		}

		this.recycledItems = data.recycledItems.map(
			(dataElement: RecycledItem | Record<string, any>): RecycledItem => {
				if (dataElement instanceof RecycledItem) {
					return dataElement
				} else {
					return new RecycledItem().hydrate(dataElement)
				}
			}
		)

		return this
	}
}

export interface RawMoodSmileyResultMessage {
	id: number
	resultCode: number
	smileyId: number
}

export class MoodSmileyResultMessage extends DofusMessage {
	public static id: number = 2233

	public resultCode: number | undefined = 1
	public smileyId: number | undefined = 0

	public constructor(
		resultCode?: number | undefined,
		smileyId?: number | undefined
	) {
		super()
		this.resultCode = resultCode
		this.smileyId = smileyId
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeByte(this.resultCode!)
		writer.writeVarShort(this.smileyId!)
	}

	public deserialize(reader: BinaryReader): void {
		this.resultCode = reader.readByte()
		this.smileyId = reader.readVarShort()
	}

	public hydrate(
		data: MoodSmileyResultMessage | Record<string, any>
	): MoodSmileyResultMessage {
		if (data instanceof MoodSmileyResultMessage) {
			return data
		}

		this.resultCode = data.resultCode
		this.smileyId = data.smileyId

		return this
	}
}

export interface RawHaapiSessionMessage {
	id: number
	key: string
	type: number
}

export class HaapiSessionMessage extends DofusMessage {
	public static id: number = 3180

	public key: string | undefined
	public type: number | undefined = 0

	public constructor(key?: string | undefined, type?: number | undefined) {
		super()
		this.key = key
		this.type = type
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeUTF(this.key!)
		writer.writeByte(this.type!)
	}

	public deserialize(reader: BinaryReader): void {
		this.key = reader.readUTF()
		this.type = reader.readByte()
	}

	public hydrate(
		data: HaapiSessionMessage | Record<string, any>
	): HaapiSessionMessage {
		if (data instanceof HaapiSessionMessage) {
			return data
		}

		this.key = data.key
		this.type = data.type

		return this
	}
}

export interface RawExchangeStartOkMountMessage
	extends RawExchangeStartOkMountWithOutPaddockMessage {
	id: number
	paddockedMountsDescription: MountClientData[]
}

export class ExchangeStartOkMountMessage extends ExchangeStartOkMountWithOutPaddockMessage {
	public static id = 1843

	public paddockedMountsDescription: MountClientData[] | undefined

	public constructor(
		stabledMountsDescription?: MountClientData[] | undefined,
		paddockedMountsDescription?: MountClientData[] | undefined
	) {
		super(stabledMountsDescription)
		this.paddockedMountsDescription = paddockedMountsDescription
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeShort(this.paddockedMountsDescription!.length)
		this.paddockedMountsDescription!.forEach((current) => {
			current.serialize(writer)
		})
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.paddockedMountsDescription = []
		const countPaddockedMountsDescription = reader.readShort()
		for (let i: number = 0; i < countPaddockedMountsDescription; i++) {
			const type: MountClientData = new MountClientData()
			type.deserialize(reader)
			this.paddockedMountsDescription.push(type)
		}
	}

	public hydrate(
		data: ExchangeStartOkMountMessage | Record<string, any>
	): ExchangeStartOkMountMessage {
		if (data instanceof ExchangeStartOkMountMessage) {
			return data
		}

		super.hydrate(data)

		this.paddockedMountsDescription = data.paddockedMountsDescription.map(
			(dataElement: MountClientData | Record<string, any>): MountClientData => {
				if (dataElement instanceof MountClientData) {
					return dataElement
				} else {
					return new MountClientData().hydrate(dataElement)
				}
			}
		)

		return this
	}
}

export interface RawDocumentReadingBeginMessage {
	id: number
	documentId: number
}

export class DocumentReadingBeginMessage extends DofusMessage {
	public static id: number = 6648

	public documentId: number | undefined = 0

	public constructor(documentId?: number | undefined) {
		super()
		this.documentId = documentId
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarShort(this.documentId!)
	}

	public deserialize(reader: BinaryReader): void {
		this.documentId = reader.readVarShort()
	}

	public hydrate(
		data: DocumentReadingBeginMessage | Record<string, any>
	): DocumentReadingBeginMessage {
		if (data instanceof DocumentReadingBeginMessage) {
			return data
		}

		this.documentId = data.documentId

		return this
	}
}

export interface RawServerExperienceModificatorMessage {
	id: number
	experiencePercent: number
}

export class ServerExperienceModificatorMessage extends DofusMessage {
	public static id: number = 1898

	public experiencePercent: number | undefined = 0

	public constructor(experiencePercent?: number | undefined) {
		super()
		this.experiencePercent = experiencePercent
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarShort(this.experiencePercent!)
	}

	public deserialize(reader: BinaryReader): void {
		this.experiencePercent = reader.readVarShort()
	}

	public hydrate(
		data: ServerExperienceModificatorMessage | Record<string, any>
	): ServerExperienceModificatorMessage {
		if (data instanceof ServerExperienceModificatorMessage) {
			return data
		}

		this.experiencePercent = data.experiencePercent

		return this
	}
}

export class KnownZaapListMessage extends DofusMessage {
	public static id: number = 974

	public destinations: number[] | undefined = []

	public constructor(destinations?: number[] | undefined) {
		super()
		this.destinations = destinations
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeShort(this.destinations!.length)
		this.destinations!.forEach((current) => {
			writer.writeDouble(current)
		})
	}

	public deserialize(reader: BinaryReader): void {
		const destinations = reader.readUShort()
		for (let i: number = 0; i < destinations; i++) {
			this.destinations?.push(reader.readDouble())
		}
	}
}

export interface RawExchangeKamaModifiedMessage
	extends RawExchangeObjectMessage {
	id: number
	quantity: number
}

export class ExchangeKamaModifiedMessage extends ExchangeObjectMessage {
	public static id = 4917

	public quantity: number | undefined = 0

	public constructor(
		remote?: boolean | undefined,
		quantity?: number | undefined
	) {
		super(remote)
		this.quantity = quantity
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeVarLong(this.quantity!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.quantity = reader.readVarLong()
	}

	public hydrate(
		data: ExchangeKamaModifiedMessage | Record<string, any>
	): ExchangeKamaModifiedMessage {
		if (data instanceof ExchangeKamaModifiedMessage) {
			return data
		}

		super.hydrate(data)

		this.quantity = data.quantity

		return this
	}
}

export interface RawIdentificationSuccessWithLoginTokenMessage
	extends RawIdentificationSuccessMessage {
	id: number
	loginToken: string
}

export class IdentificationSuccessWithLoginTokenMessage extends IdentificationSuccessMessage {
	public static id = 6160

	public loginToken: string | undefined

	public constructor(
		hasRights?: boolean | undefined,
		hasforceRights?: boolean | undefined,
		nickname?: string | undefined,
		tagNumber?: string | undefined,
		wasAlreadyConnected?: boolean | undefined,
		login?: string | undefined,
		accountId?: number | undefined,
		communityId?: number | undefined,
		secretQuestion?: string | undefined,
		accountCreation?: number | undefined,
		subscriptionElapsedDuration?: number | undefined,
		subscriptionEndDate?: number | undefined,
		havenbagAvailableRoom?: number | undefined,
		loginToken?: string | undefined
	) {
		super(
			hasRights,
			hasforceRights,
			nickname,
			tagNumber,
			wasAlreadyConnected,
			login,
			accountId,
			communityId,
			accountCreation,
			subscriptionEndDate,
			havenbagAvailableRoom
		)
		this.loginToken = loginToken
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeUTF(this.loginToken!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.loginToken = reader.readUTF()
	}

	public hydrate(
		data: IdentificationSuccessWithLoginTokenMessage | Record<string, any>
	): IdentificationSuccessWithLoginTokenMessage {
		if (data instanceof IdentificationSuccessWithLoginTokenMessage) {
			return data
		}

		super.hydrate(data)

		this.loginToken = data.loginToken

		return this
	}
}

export interface RawGameRolePlayDelayedObjectUseMessage
	extends RawGameRolePlayDelayedActionMessage {
	id: number
	objectGID: number
}

export class GameRolePlayDelayedObjectUseMessage extends GameRolePlayDelayedActionMessage {
	public static id = 748

	public objectGID: number | undefined = 0

	public constructor(
		delayedCharacterId?: number | undefined,
		delayTypeId?: number | undefined,
		delayEndTime?: number | undefined,
		objectGID?: number | undefined
	) {
		super(delayedCharacterId, delayTypeId, delayEndTime)
		this.objectGID = objectGID
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeVarShort(this.objectGID!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.objectGID = reader.readVarShort()
	}

	public hydrate(
		data: GameRolePlayDelayedObjectUseMessage | Record<string, any>
	): GameRolePlayDelayedObjectUseMessage {
		if (data instanceof GameRolePlayDelayedObjectUseMessage) {
			return data
		}

		super.hydrate(data)

		this.objectGID = data.objectGID

		return this
	}
}

export interface RawCharacterCapabilitiesMessage {
	id: number
	guildEmblemSymbolCategories: number
}

export class CharacterCapabilitiesMessage extends DofusMessage {
	public static id: number = 7400

	public guildEmblemSymbolCategories: number | undefined = 0

	public constructor(guildEmblemSymbolCategories?: number | undefined) {
		super()
		this.guildEmblemSymbolCategories = guildEmblemSymbolCategories
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarInt(this.guildEmblemSymbolCategories!)
	}

	public deserialize(reader: BinaryReader): void {
		this.guildEmblemSymbolCategories = reader.readVarInt()
	}

	public hydrate(
		data: CharacterCapabilitiesMessage | Record<string, any>
	): CharacterCapabilitiesMessage {
		if (data instanceof CharacterCapabilitiesMessage) {
			return data
		}

		this.guildEmblemSymbolCategories = data.guildEmblemSymbolCategories

		return this
	}
}

export interface RawPaddockBuyResultMessage {
	id: number
	paddockId: number
	bought: boolean
	realPrice: number
}

export class PaddockBuyResultMessage extends DofusMessage {
	public static id: number = 6312

	public paddockId: number | undefined = 0
	public bought: boolean | undefined = false
	public realPrice: number | undefined = 0

	public constructor(
		paddockId?: number | undefined,
		bought?: boolean | undefined,
		realPrice?: number | undefined
	) {
		super()
		this.paddockId = paddockId
		this.bought = bought
		this.realPrice = realPrice
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeDouble(this.paddockId!)
		writer.writeBoolean(this.bought!)
		writer.writeVarLong(this.realPrice!)
	}

	public deserialize(reader: BinaryReader): void {
		this.paddockId = reader.readDouble()
		this.bought = reader.readBoolean()
		this.realPrice = reader.readVarLong()
	}

	public hydrate(
		data: PaddockBuyResultMessage | Record<string, any>
	): PaddockBuyResultMessage {
		if (data instanceof PaddockBuyResultMessage) {
			return data
		}

		this.paddockId = data.paddockId
		this.bought = data.bought
		this.realPrice = data.realPrice

		return this
	}
}

export interface RawAllianceCreationResultMessage {
	id: number
	result: number
}

export class AllianceCreationResultMessage extends DofusMessage {
	public static id: number = 1594

	public result: number | undefined = 0

	public constructor(result?: number | undefined) {
		super()
		this.result = result
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeByte(this.result!)
	}

	public deserialize(reader: BinaryReader): void {
		this.result = reader.readByte()
	}

	public hydrate(
		data: AllianceCreationResultMessage | Record<string, any>
	): AllianceCreationResultMessage {
		if (data instanceof AllianceCreationResultMessage) {
			return data
		}

		this.result = data.result

		return this
	}
}

export interface RawPartyMemberInBreachFightMessage
	extends RawAbstractPartyMemberInFightMessage {
	id: number
	floor: number
	room: number
}

export class PartyMemberInBreachFightMessage extends AbstractPartyMemberInFightMessage {
	public static id = 3413

	public floor: number | undefined = 0
	public room: number | undefined = 0

	public constructor(
		partyId?: number | undefined,
		reason?: number | undefined,
		memberId?: number | undefined,
		memberAccountId?: number | undefined,
		memberName?: string | undefined,
		fightId?: number | undefined,
		timeBeforeFightStart?: number | undefined,
		floor?: number | undefined,
		room?: number | undefined
	) {
		super(
			partyId,
			reason,
			memberId,
			memberAccountId,
			memberName,
			fightId,
			timeBeforeFightStart
		)
		this.floor = floor
		this.room = room
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeVarInt(this.floor!)
		writer.writeByte(this.room!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.floor = reader.readVarInt()
		this.room = reader.readByte()
	}

	public hydrate(
		data: PartyMemberInBreachFightMessage | Record<string, any>
	): PartyMemberInBreachFightMessage {
		if (data instanceof PartyMemberInBreachFightMessage) {
			return data
		}

		super.hydrate(data)

		this.floor = data.floor
		this.room = data.room

		return this
	}
}

export interface RawPartyNameUpdateMessage extends RawAbstractPartyMessage {
	id: number
	partyName: string
}

export class PartyNameUpdateMessage extends AbstractPartyMessage {
	public static id = 9548

	public partyName: string | undefined

	public constructor(
		partyId?: number | undefined,
		partyName?: string | undefined
	) {
		super(partyId)
		this.partyName = partyName
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeUTF(this.partyName!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.partyName = reader.readUTF()
	}

	public hydrate(
		data: PartyNameUpdateMessage | Record<string, any>
	): PartyNameUpdateMessage {
		if (data instanceof PartyNameUpdateMessage) {
			return data
		}

		super.hydrate(data)

		this.partyName = data.partyName

		return this
	}
}

export interface RawStartupActionFinishedMessage {
	id: number
	success: boolean
	automaticAction: boolean
	actionId: number
}

export class StartupActionFinishedMessage extends DofusMessage {
	public static id: number = 7923

	public success: boolean | undefined = false
	public automaticAction: boolean | undefined = false
	public actionId: number | undefined = 0

	public constructor(
		success?: boolean | undefined,
		automaticAction?: boolean | undefined,
		actionId?: number | undefined
	) {
		super()
		this.success = success
		this.automaticAction = automaticAction
		this.actionId = actionId
	}

	public serialize(writer: BinaryWriter): void {
		let box0: number = 0
		box0 = setFlag(box0, 0, this.success!)
		box0 = setFlag(box0, 1, this.automaticAction!)
		writer.writeByte(box0)
		writer.writeInt(this.actionId!)
	}

	public deserialize(reader: BinaryReader): void {
		const box0 = reader.readByte()
		this.success = getFlag(box0, 0)
		this.automaticAction = getFlag(box0, 1)
		this.actionId = reader.readInt()
	}

	public hydrate(
		data: StartupActionFinishedMessage | Record<string, any>
	): StartupActionFinishedMessage {
		if (data instanceof StartupActionFinishedMessage) {
			return data
		}

		this.success = data.success
		this.automaticAction = data.automaticAction
		this.actionId = data.actionId

		return this
	}
}

export interface RawExchangeStartOkNpcTradeMessage {
	id: number
	npcId: number
}

export class ExchangeStartOkNpcTradeMessage extends DofusMessage {
	public static id: number = 6872

	public npcId: number | undefined = 0

	public constructor(npcId?: number | undefined) {
		super()
		this.npcId = npcId
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeDouble(this.npcId!)
	}

	public deserialize(reader: BinaryReader): void {
		this.npcId = reader.readDouble()
	}

	public hydrate(
		data: ExchangeStartOkNpcTradeMessage | Record<string, any>
	): ExchangeStartOkNpcTradeMessage {
		if (data instanceof ExchangeStartOkNpcTradeMessage) {
			return data
		}

		this.npcId = data.npcId

		return this
	}
}

export interface RawChatErrorMessage {
	id: number
	reason: number
}

export class ChatErrorMessage extends DofusMessage {
	public static id: number = 1161

	public reason: number | undefined = 0

	public constructor(reason?: number | undefined) {
		super()
		this.reason = reason
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeByte(this.reason!)
	}

	public deserialize(reader: BinaryReader): void {
		this.reason = reader.readByte()
	}

	public hydrate(
		data: ChatErrorMessage | Record<string, any>
	): ChatErrorMessage {
		if (data instanceof ChatErrorMessage) {
			return data
		}

		this.reason = data.reason

		return this
	}
}

export interface RawHouseGuildRightsMessage {
	id: number
	houseId: number
	instanceId: number
	secondHand: boolean
	guildInfo: GuildInformations
	rights: number
}

export class HouseGuildRightsMessage extends DofusMessage {
	public static id: number = 8301

	public houseId: number | undefined = 0
	public instanceId: number | undefined = 0
	public secondHand: boolean | undefined = false
	public guildInfo: GuildInformations | undefined
	public rights: number | undefined = 0

	public constructor(
		houseId?: number | undefined,
		instanceId?: number | undefined,
		secondHand?: boolean | undefined,
		guildInfo?: GuildInformations | undefined,
		rights?: number | undefined
	) {
		super()
		this.houseId = houseId
		this.instanceId = instanceId
		this.secondHand = secondHand
		this.guildInfo = guildInfo
		this.rights = rights
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarInt(this.houseId!)
		writer.writeInt(this.instanceId!)
		writer.writeBoolean(this.secondHand!)
		this.guildInfo!.serialize(writer)
		writer.writeVarInt(this.rights!)
	}

	public deserialize(reader: BinaryReader): void {
		this.houseId = reader.readVarInt()
		this.instanceId = reader.readInt()
		this.secondHand = reader.readBoolean()
		this.guildInfo = new GuildInformations()
		this.guildInfo!.deserialize(reader)
		this.rights = reader.readVarInt()
	}

	public hydrate(
		data: HouseGuildRightsMessage | Record<string, any>
	): HouseGuildRightsMessage {
		if (data instanceof HouseGuildRightsMessage) {
			return data
		}

		this.houseId = data.houseId
		this.instanceId = data.instanceId
		this.secondHand = data.secondHand
		this.guildInfo = new GuildInformations().hydrate(data.guildInfo)
		this.rights = data.rights

		return this
	}
}

export interface RawDungeonKeyRingUpdateMessage {
	id: number
	dungeonId: number
	available: boolean
}

export class DungeonKeyRingUpdateMessage extends DofusMessage {
	public static id: number = 4979

	public dungeonId: number | undefined = 0
	public available: boolean | undefined = false

	public constructor(
		dungeonId?: number | undefined,
		available?: boolean | undefined
	) {
		super()
		this.dungeonId = dungeonId
		this.available = available
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarShort(this.dungeonId!)
		writer.writeBoolean(this.available!)
	}

	public deserialize(reader: BinaryReader): void {
		this.dungeonId = reader.readVarShort()
		this.available = reader.readBoolean()
	}

	public hydrate(
		data: DungeonKeyRingUpdateMessage | Record<string, any>
	): DungeonKeyRingUpdateMessage {
		if (data instanceof DungeonKeyRingUpdateMessage) {
			return data
		}

		this.dungeonId = data.dungeonId
		this.available = data.available

		return this
	}
}

export interface RawPrismFightAttackerRemoveMessage {
	id: number
	subAreaId: number
	fightId: number
	fighterToRemoveId: number
}

export class PrismFightAttackerRemoveMessage extends DofusMessage {
	public static id: number = 1307

	public subAreaId: number | undefined = 0
	public fightId: number | undefined = 0
	public fighterToRemoveId: number | undefined = 0

	public constructor(
		subAreaId?: number | undefined,
		fightId?: number | undefined,
		fighterToRemoveId?: number | undefined
	) {
		super()
		this.subAreaId = subAreaId
		this.fightId = fightId
		this.fighterToRemoveId = fighterToRemoveId
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarShort(this.subAreaId!)
		writer.writeVarShort(this.fightId!)
		writer.writeVarLong(this.fighterToRemoveId!)
	}

	public deserialize(reader: BinaryReader): void {
		this.subAreaId = reader.readVarShort()
		this.fightId = reader.readVarShort()
		this.fighterToRemoveId = reader.readVarLong()
	}

	public hydrate(
		data: PrismFightAttackerRemoveMessage | Record<string, any>
	): PrismFightAttackerRemoveMessage {
		if (data instanceof PrismFightAttackerRemoveMessage) {
			return data
		}

		this.subAreaId = data.subAreaId
		this.fightId = data.fightId
		this.fighterToRemoveId = data.fighterToRemoveId

		return this
	}
}

export interface RawAllianceLeftMessage {
	id: number
}

export class AllianceLeftMessage extends DofusMessage {
	public static id: number = 9560

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public serialize(writer: BinaryWriter): void {}

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public deserialize(reader: BinaryReader): void {}

	public hydrate(
		data: AllianceLeftMessage | Record<string, any>
	): AllianceLeftMessage {
		if (data instanceof AllianceLeftMessage) {
			return data
		}

		return this
	}
}

export interface RawAllianceInvitationStateRecrutedMessage {
	id: number
	invitationState: number
}

export class AllianceInvitationStateRecrutedMessage extends DofusMessage {
	public static id: number = 7315

	public invitationState: number | undefined = 0

	public constructor(invitationState?: number | undefined) {
		super()
		this.invitationState = invitationState
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeByte(this.invitationState!)
	}

	public deserialize(reader: BinaryReader): void {
		this.invitationState = reader.readByte()
	}

	public hydrate(
		data: AllianceInvitationStateRecrutedMessage | Record<string, any>
	): AllianceInvitationStateRecrutedMessage {
		if (data instanceof AllianceInvitationStateRecrutedMessage) {
			return data
		}

		this.invitationState = data.invitationState

		return this
	}
}

export interface RawExchangeStartOkCraftWithInformationMessage
	extends RawExchangeStartOkCraftMessage {
	id: number
	skillId: number
}

export class ExchangeStartOkCraftWithInformationMessage extends ExchangeStartOkCraftMessage {
	public static id = 187
  
	public skillId: number | undefined = 0

	public constructor(skillId?: number | undefined) {
		super()
		this.skillId = skillId
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeVarInt(this.skillId!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.skillId = reader.readVarInt()
	}

	public hydrate(
		data: ExchangeStartOkCraftWithInformationMessage | Record<string, any>
	): ExchangeStartOkCraftWithInformationMessage {
		if (data instanceof ExchangeStartOkCraftWithInformationMessage) {
			return data
		}

		this.skillId = data.skillId

		return this
	}
}

export interface RawMountUnSetMessage {
	id: number
}

export class MountUnSetMessage extends DofusMessage {
	public static id: number = 1968

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public serialize(writer: BinaryWriter): void {}

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public deserialize(reader: BinaryReader): void {}

	public hydrate(
		data: MountUnSetMessage | Record<string, any>
	): MountUnSetMessage {
		if (data instanceof MountUnSetMessage) {
			return data
		}

		return this
	}
}

export interface RawMountXpRatioMessage {
	id: number
	ratio: number
}

export class MountXpRatioMessage extends DofusMessage {
	public static id: number = 5404

	public ratio: number | undefined = 0

	public constructor(ratio?: number | undefined) {
		super()
		this.ratio = ratio
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeByte(this.ratio!)
	}

	public deserialize(reader: BinaryReader): void {
		this.ratio = reader.readByte()
	}

	public hydrate(
		data: MountXpRatioMessage | Record<string, any>
	): MountXpRatioMessage {
		if (data instanceof MountXpRatioMessage) {
			return data
		}

		this.ratio = data.ratio

		return this
	}
}

export interface RawJobExperienceMultiUpdateMessage {
	id: number
	experiencesUpdate: JobExperience[]
}

export class JobExperienceMultiUpdateMessage extends DofusMessage {
	public static id: number = 1449

	public experiencesUpdate: JobExperience[] | undefined

	public constructor(experiencesUpdate?: JobExperience[] | undefined) {
		super()
		this.experiencesUpdate = experiencesUpdate
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeShort(this.experiencesUpdate!.length)
		this.experiencesUpdate!.forEach((current) => {
			current.serialize(writer)
		})
	}

	public deserialize(reader: BinaryReader): void {
		this.experiencesUpdate = []
		const countExperiencesUpdate = reader.readShort()
		for (let i: number = 0; i < countExperiencesUpdate; i++) {
			const type: JobExperience = new JobExperience()
			type.deserialize(reader)
			this.experiencesUpdate.push(type)
		}
	}

	public hydrate(
		data: JobExperienceMultiUpdateMessage | Record<string, any>
	): JobExperienceMultiUpdateMessage {
		if (data instanceof JobExperienceMultiUpdateMessage) {
			return data
		}

		this.experiencesUpdate = data.experiencesUpdate.map(
			(dataElement: JobExperience | Record<string, any>): JobExperience => {
				if (dataElement instanceof JobExperience) {
					return dataElement
				} else {
					return new JobExperience().hydrate(dataElement)
				}
			}
		)

		return this
	}
}

export interface RawAlmanachCalendarDateMessage {
	id: number
	date: number
}

export class AlmanachCalendarDateMessage extends DofusMessage {
	public static id: number = 1985

	public date: number | undefined = 0

	public constructor(date?: number | undefined) {
		super()
		this.date = date
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeInt(this.date!)
	}

	public deserialize(reader: BinaryReader): void {
		this.date = reader.readInt()
	}

	public hydrate(
		data: AlmanachCalendarDateMessage | Record<string, any>
	): AlmanachCalendarDateMessage {
		if (data instanceof AlmanachCalendarDateMessage) {
			return data
		}

		this.date = data.date

		return this
	}
}

export interface RawContactLookErrorMessage {
	id: number
	requestId: number
}

export class ContactLookErrorMessage extends DofusMessage {
	public static id: number = 7031

	public requestId: number | undefined = 0

	public constructor(requestId?: number | undefined) {
		super()
		this.requestId = requestId
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarInt(this.requestId!)
	}

	public deserialize(reader: BinaryReader): void {
		this.requestId = reader.readVarInt()
	}

	public hydrate(
		data: ContactLookErrorMessage | Record<string, any>
	): ContactLookErrorMessage {
		if (data instanceof ContactLookErrorMessage) {
			return data
		}

		this.requestId = data.requestId

		return this
	}
}

export interface RawObjectModifiedMessage {
	id: number
	object_: ObjectItem
}

export class ObjectModifiedMessage extends DofusMessage {
	public static id: number = 9694

	public object_: ObjectItem | undefined

	public constructor(object_?: ObjectItem | undefined) {
		super()
		this.object_ = object_
	}

	public serialize(writer: BinaryWriter): void {
		this.object_!.serialize(writer)
	}

	public deserialize(reader: BinaryReader): void {
		this.object_ = new ObjectItem()
		this.object_!.deserialize(reader)
	}

	public hydrate(
		data: ObjectModifiedMessage | Record<string, any>
	): ObjectModifiedMessage {
		if (data instanceof ObjectModifiedMessage) {
			return data
		}

		this.object_ = new ObjectItem().hydrate(data.object_)

		return this
	}
}

export interface RawExchangeWeightMessage {
	id: number
	currentWeight: number
	maxWeight: number
}

export class ExchangeWeightMessage extends DofusMessage {
	public static id: number = 989

	public currentWeight: number | undefined = 0
	public maxWeight: number | undefined = 0

	public constructor(
		currentWeight?: number | undefined,
		maxWeight?: number | undefined
	) {
		super()
		this.currentWeight = currentWeight
		this.maxWeight = maxWeight
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarInt(this.currentWeight!)
		writer.writeVarInt(this.maxWeight!)
	}

	public deserialize(reader: BinaryReader): void {
		this.currentWeight = reader.readVarInt()
		this.maxWeight = reader.readVarInt()
	}

	public hydrate(
		data: ExchangeWeightMessage | Record<string, any>
	): ExchangeWeightMessage {
		if (data instanceof ExchangeWeightMessage) {
			return data
		}

		this.currentWeight = data.currentWeight
		this.maxWeight = data.maxWeight

		return this
	}
}

export interface RawPartyNewGuestMessage extends RawAbstractPartyEventMessage {
	id: number
	guest: PartyGuestInformations
}

export class PartyNewGuestMessage extends AbstractPartyEventMessage {
	public static id = 1186

	public guest: PartyGuestInformations | undefined

	public constructor(
		partyId?: number | undefined,
		guest?: PartyGuestInformations | undefined
	) {
		super(partyId)
		this.guest = guest
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		this.guest!.serialize(writer)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.guest = new PartyGuestInformations()
		this.guest!.deserialize(reader)
	}

	public hydrate(
		data: PartyNewGuestMessage | Record<string, any>
	): PartyNewGuestMessage {
		if (data instanceof PartyNewGuestMessage) {
			return data
		}

		super.hydrate(data)

		this.guest = new PartyGuestInformations().hydrate(data.guest)

		return this
	}
}

export interface RawHelloConnectMessage {
	id: number
	salt: string
	key: number[]
}

export class HelloConnectMessage extends DofusMessage {
	public static id: number = 7439

	public salt: string | undefined
	public key: number[] | undefined

	public constructor(salt?: string | undefined, key?: number[] | undefined) {
		super()
		this.salt = salt
		this.key = key
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeUTF(this.salt!)
		writer.writeVarInt(this.key!.length)
		this.key!.forEach((current: number) => writer.writeByte(current))
	}

	public deserialize(reader: BinaryReader): void {
		this.salt = reader.readUTF()
		this.key = []
		const countKey = reader.readVarInt()
		for (let i: number = 0; i < countKey; i++) {
			this.key.push(reader.readByte())
		}
	}

	public hydrate(
		data: HelloConnectMessage | Record<string, any>
	): HelloConnectMessage {
		if (data instanceof HelloConnectMessage) {
			return data
		}

		this.salt = data.salt
		this.key = data.key

		return this
	}
}

export interface RawFriendStatusShareStateMessage {
	id: number
	share: boolean
}

export class FriendStatusShareStateMessage extends DofusMessage {
	public static id: number = 9162

	public share: boolean | undefined = false

	public constructor(share?: boolean | undefined) {
		super()
		this.share = share
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeBoolean(this.share!)
	}

	public deserialize(reader: BinaryReader): void {
		this.share = reader.readBoolean()
	}

	public hydrate(
		data: FriendStatusShareStateMessage | Record<string, any>
	): FriendStatusShareStateMessage {
		if (data instanceof FriendStatusShareStateMessage) {
			return data
		}

		this.share = data.share

		return this
	}
}

export interface RawHouseGuildNoneMessage {
	id: number
	houseId: number
	instanceId: number
	secondHand: boolean
}

export class HouseGuildNoneMessage extends DofusMessage {
	public static id: number = 9517

	public houseId: number | undefined = 0
	public instanceId: number | undefined = 0
	public secondHand: boolean | undefined = false

	public constructor(
		houseId?: number | undefined,
		instanceId?: number | undefined,
		secondHand?: boolean | undefined
	) {
		super()
		this.houseId = houseId
		this.instanceId = instanceId
		this.secondHand = secondHand
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarInt(this.houseId!)
		writer.writeInt(this.instanceId!)
		writer.writeBoolean(this.secondHand!)
	}

	public deserialize(reader: BinaryReader): void {
		this.houseId = reader.readVarInt()
		this.instanceId = reader.readInt()
		this.secondHand = reader.readBoolean()
	}

	public hydrate(
		data: HouseGuildNoneMessage | Record<string, any>
	): HouseGuildNoneMessage {
		if (data instanceof HouseGuildNoneMessage) {
			return data
		}

		this.houseId = data.houseId
		this.instanceId = data.instanceId
		this.secondHand = data.secondHand

		return this
	}
}

export interface RawChatServerCopyWithObjectMessage
	extends RawChatServerCopyMessage {
	id: number
	objects: ObjectItem[]
}

export class ChatServerCopyWithObjectMessage extends ChatServerCopyMessage {
	public static id = 7669

	public objects: ObjectItem[] | undefined

	public constructor(
		channel?: number | undefined,
		content?: string | undefined,
		timestamp?: number | undefined,
		fingerprint?: string | undefined,
		receiverId?: number | undefined,
		receiverName?: string | undefined,
		objects?: ObjectItem[] | undefined
	) {
		super(channel, content, timestamp, fingerprint, receiverId, receiverName)
		this.objects = objects
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeShort(this.objects!.length)
		this.objects!.forEach((current) => {
			current.serialize(writer)
		})
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.objects = []
		const countObjects = reader.readShort()
		for (let i: number = 0; i < countObjects; i++) {
			const type: ObjectItem = new ObjectItem()
			type.deserialize(reader)
			this.objects.push(type)
		}
	}

	public hydrate(
		data: ChatServerCopyWithObjectMessage | Record<string, any>
	): ChatServerCopyWithObjectMessage {
		if (data instanceof ChatServerCopyWithObjectMessage) {
			return data
		}

		super.hydrate(data)

		this.objects = data.objects.map(
			(dataElement: ObjectItem | Record<string, any>): ObjectItem => {
				if (dataElement instanceof ObjectItem) {
					return dataElement
				} else {
					return new ObjectItem().hydrate(dataElement)
				}
			}
		)

		return this
	}
}

export interface RawMountRidingMessage {
	id: number
	isRiding: boolean
	isAutopilot: boolean
}

export class MountRidingMessage extends DofusMessage {
	public static id: number = 7744

	public isRiding: boolean | undefined = false
	public isAutopilot: boolean | undefined = false

	public constructor(
		isRiding?: boolean | undefined,
		isAutopilot?: boolean | undefined
	) {
		super()
		this.isRiding = isRiding
		this.isAutopilot = isAutopilot
	}

	public serialize(writer: BinaryWriter): void {
		let box0: number = 0
		box0 = setFlag(box0, 0, this.isRiding!)
		box0 = setFlag(box0, 1, this.isAutopilot!)
		writer.writeByte(box0)
	}

	public deserialize(reader: BinaryReader): void {
		const box0 = reader.readByte()
		this.isRiding = getFlag(box0, 0)
		this.isAutopilot = getFlag(box0, 1)
	}

	public hydrate(
		data: MountRidingMessage | Record<string, any>
	): MountRidingMessage {
		if (data instanceof MountRidingMessage) {
			return data
		}

		this.isRiding = data.isRiding
		this.isAutopilot = data.isAutopilot

		return this
	}
}

export interface RawShortcutBarRemoveErrorMessage {
	id: number
	error: number
}

export class ShortcutBarRemoveErrorMessage extends DofusMessage {
	public static id: number = 2776

	public error: number | undefined = 0

	public constructor(error?: number | undefined) {
		super()
		this.error = error
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeByte(this.error!)
	}

	public deserialize(reader: BinaryReader): void {
		this.error = reader.readByte()
	}

	public hydrate(
		data: ShortcutBarRemoveErrorMessage | Record<string, any>
	): ShortcutBarRemoveErrorMessage {
		if (data instanceof ShortcutBarRemoveErrorMessage) {
			return data
		}

		this.error = data.error

		return this
	}
}

export interface RawChannelEnablingChangeMessage {
	id: number
	channel: number
	enable: boolean
}

export class ChannelEnablingChangeMessage extends DofusMessage {
	public static id: number = 1455

	public channel: number | undefined = 0
	public enable: boolean | undefined = false

	public constructor(
		channel?: number | undefined,
		enable?: boolean | undefined
	) {
		super()
		this.channel = channel
		this.enable = enable
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeByte(this.channel!)
		writer.writeBoolean(this.enable!)
	}

	public deserialize(reader: BinaryReader): void {
		this.channel = reader.readByte()
		this.enable = reader.readBoolean()
	}

	public hydrate(
		data: ChannelEnablingChangeMessage | Record<string, any>
	): ChannelEnablingChangeMessage {
		if (data instanceof ChannelEnablingChangeMessage) {
			return data
		}

		this.channel = data.channel
		this.enable = data.enable

		return this
	}
}

export interface RawPartyNameSetErrorMessage extends RawAbstractPartyMessage {
	id: number
	result: number
}

export class PartyNameSetErrorMessage extends AbstractPartyMessage {
	public static id = 4806

	public result: number | undefined = 0

	public constructor(
		partyId?: number | undefined,
		result?: number | undefined
	) {
		super(partyId)
		this.result = result
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeByte(this.result!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.result = reader.readByte()
	}

	public hydrate(
		data: PartyNameSetErrorMessage | Record<string, any>
	): PartyNameSetErrorMessage {
		if (data instanceof PartyNameSetErrorMessage) {
			return data
		}

		super.hydrate(data)

		this.result = data.result

		return this
	}
}

export interface RawGameFightPlacementSwapPositionsOfferMessage {
	id: number
	requestId: number
	requesterId: number
	requesterCellId: number
	requestedId: number
	requestedCellId: number
}

export class GameFightPlacementSwapPositionsOfferMessage extends DofusMessage {
	public static id: number = 725

	public requestId: number | undefined = 0
	public requesterId: number | undefined = 0
	public requesterCellId: number | undefined = 0
	public requestedId: number | undefined = 0
	public requestedCellId: number | undefined = 0

	public constructor(
		requestId?: number | undefined,
		requesterId?: number | undefined,
		requesterCellId?: number | undefined,
		requestedId?: number | undefined,
		requestedCellId?: number | undefined
	) {
		super()
		this.requestId = requestId
		this.requesterId = requesterId
		this.requesterCellId = requesterCellId
		this.requestedId = requestedId
		this.requestedCellId = requestedCellId
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeInt(this.requestId!)
		writer.writeDouble(this.requesterId!)
		writer.writeVarShort(this.requesterCellId!)
		writer.writeDouble(this.requestedId!)
		writer.writeVarShort(this.requestedCellId!)
	}

	public deserialize(reader: BinaryReader): void {
		this.requestId = reader.readInt()
		this.requesterId = reader.readDouble()
		this.requesterCellId = reader.readVarShort()
		this.requestedId = reader.readDouble()
		this.requestedCellId = reader.readVarShort()
	}

	public hydrate(
		data: GameFightPlacementSwapPositionsOfferMessage | Record<string, any>
	): GameFightPlacementSwapPositionsOfferMessage {
		if (data instanceof GameFightPlacementSwapPositionsOfferMessage) {
			return data
		}

		this.requestId = data.requestId
		this.requesterId = data.requesterId
		this.requesterCellId = data.requesterCellId
		this.requestedId = data.requestedId
		this.requestedCellId = data.requestedCellId

		return this
	}
}

export interface RawAllianceInsiderInfoMessage {
	id: number
	allianceInfos: AllianceFactSheetInformations
	guilds: GuildInsiderFactSheetInformations[]
	prisms: PrismSubareaEmptyInfo[]
}

export class AllianceInsiderInfoMessage extends DofusMessage {
	public static id: number = 7582

	public allianceInfos: AllianceFactSheetInformations | undefined
	public guilds: GuildInsiderFactSheetInformations[] | undefined
	public prisms: PrismSubareaEmptyInfo[] | undefined

	public constructor(
		allianceInfos?: AllianceFactSheetInformations | undefined,
		guilds?: GuildInsiderFactSheetInformations[] | undefined,
		prisms?: PrismSubareaEmptyInfo[] | undefined
	) {
		super()
		this.allianceInfos = allianceInfos
		this.guilds = guilds
		this.prisms = prisms
	}

	public serialize(writer: BinaryWriter): void {
		this.allianceInfos!.serialize(writer)
		writer.writeShort(this.guilds!.length)
		this.guilds!.forEach((current) => {
			current.serialize(writer)
		})
		writer.writeShort(this.prisms!.length)
		this.prisms!.forEach((current) => {
			writer.writeShort(current.id)
			current.serialize(writer)
		})
	}

	public deserialize(reader: BinaryReader): void {
		this.allianceInfos = new AllianceFactSheetInformations()
		this.allianceInfos!.deserialize(reader)
		this.guilds = []
		const countGuilds = reader.readShort()
		for (let i: number = 0; i < countGuilds; i++) {
			const type: GuildInsiderFactSheetInformations = new GuildInsiderFactSheetInformations()
			type.deserialize(reader)
			this.guilds.push(type)
		}
		this.prisms = []
		const countPrisms = reader.readShort()
		for (let i: number = 0; i < countPrisms; i++) {
			const prismsTypeId: number = reader.readShort()
			const type: PrismSubareaEmptyInfo = new types[
				prismsTypeId
			]() as PrismSubareaEmptyInfo
			type.deserialize(reader)
			this.prisms.push(type)
		}
	}

	public hydrate(
		data: AllianceInsiderInfoMessage | Record<string, any>
	): AllianceInsiderInfoMessage {
		if (data instanceof AllianceInsiderInfoMessage) {
			return data
		}

		this.allianceInfos = new AllianceFactSheetInformations().hydrate(
			data.allianceInfos
		)
		this.guilds = data.guilds.map(
			(
				dataElement: GuildInsiderFactSheetInformations | Record<string, any>
			): GuildInsiderFactSheetInformations => {
				if (dataElement instanceof GuildInsiderFactSheetInformations) {
					return dataElement
				} else {
					return new GuildInsiderFactSheetInformations().hydrate(dataElement)
				}
			}
		)
		this.prisms = data.prisms.map(
			(
				dataElement: PrismSubareaEmptyInfo | Record<string, any>
			): PrismSubareaEmptyInfo => {
				if (dataElement instanceof PrismSubareaEmptyInfo) {
					return dataElement
				} else {
					return (new types[dataElement.id]() as PrismSubareaEmptyInfo).hydrate(
						dataElement
					)
				}
			}
		)

		return this
	}
}

export interface RawHouseToSellListMessage {
	id: number
	pageIndex: number
	totalPage: number
	houseList: HouseInformationsForSell[]
}

export class HouseToSellListMessage extends DofusMessage {
	public static id: number = 7851

	public pageIndex: number | undefined = 0
	public totalPage: number | undefined = 0
	public houseList: HouseInformationsForSell[] | undefined

	public constructor(
		pageIndex?: number | undefined,
		totalPage?: number | undefined,
		houseList?: HouseInformationsForSell[] | undefined
	) {
		super()
		this.pageIndex = pageIndex
		this.totalPage = totalPage
		this.houseList = houseList
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarShort(this.pageIndex!)
		writer.writeVarShort(this.totalPage!)
		writer.writeShort(this.houseList!.length)
		this.houseList!.forEach((current) => {
			current.serialize(writer)
		})
	}

	public deserialize(reader: BinaryReader): void {
		this.pageIndex = reader.readVarShort()
		this.totalPage = reader.readVarShort()
		this.houseList = []
		const countHouseList = reader.readShort()
		for (let i: number = 0; i < countHouseList; i++) {
			const type: HouseInformationsForSell = new HouseInformationsForSell()
			type.deserialize(reader)
			this.houseList.push(type)
		}
	}

	public hydrate(
		data: HouseToSellListMessage | Record<string, any>
	): HouseToSellListMessage {
		if (data instanceof HouseToSellListMessage) {
			return data
		}

		this.pageIndex = data.pageIndex
		this.totalPage = data.totalPage
		this.houseList = data.houseList.map(
			(
				dataElement: HouseInformationsForSell | Record<string, any>
			): HouseInformationsForSell => {
				if (dataElement instanceof HouseInformationsForSell) {
					return dataElement
				} else {
					return new HouseInformationsForSell().hydrate(dataElement)
				}
			}
		)

		return this
	}
}

export interface RawBreachRewardBoughtMessage {
	id: number
	id_: number
	bought: boolean
}

export class BreachRewardBoughtMessage extends DofusMessage {
	public static id: number = 1374

	public id_: number | undefined = 0
	public bought: boolean | undefined = false

	public constructor(id_?: number | undefined, bought?: boolean | undefined) {
		super()
		this.id_ = id_
		this.bought = bought
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarInt(this.id_!)
		writer.writeBoolean(this.bought!)
	}

	public deserialize(reader: BinaryReader): void {
		this.id_ = reader.readVarInt()
		this.bought = reader.readBoolean()
	}

	public hydrate(
		data: BreachRewardBoughtMessage | Record<string, any>
	): BreachRewardBoughtMessage {
		if (data instanceof BreachRewardBoughtMessage) {
			return data
		}

		this.id_ = data.id_
		this.bought = data.bought

		return this
	}
}

export interface RawExchangeMountFreeFromPaddockMessage {
	id: number
	name: string
	worldX: number
	worldY: number
	liberator: string
}

export class ExchangeMountFreeFromPaddockMessage extends DofusMessage {
	public static id: number = 8720

	public name: string | undefined
	public worldX: number | undefined = 0
	public worldY: number | undefined = 0
	public liberator: string | undefined

	public constructor(
		name?: string | undefined,
		worldX?: number | undefined,
		worldY?: number | undefined,
		liberator?: string | undefined
	) {
		super()
		this.name = name
		this.worldX = worldX
		this.worldY = worldY
		this.liberator = liberator
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeUTF(this.name!)
		writer.writeShort(this.worldX!)
		writer.writeShort(this.worldY!)
		writer.writeUTF(this.liberator!)
	}

	public deserialize(reader: BinaryReader): void {
		this.name = reader.readUTF()
		this.worldX = reader.readShort()
		this.worldY = reader.readShort()
		this.liberator = reader.readUTF()
	}

	public hydrate(
		data: ExchangeMountFreeFromPaddockMessage | Record<string, any>
	): ExchangeMountFreeFromPaddockMessage {
		if (data instanceof ExchangeMountFreeFromPaddockMessage) {
			return data
		}

		this.name = data.name
		this.worldX = data.worldX
		this.worldY = data.worldY
		this.liberator = data.liberator

		return this
	}
}

export interface RawEnabledChannelsMessage {
	id: number
	channels: number[]
	disallowed: number[]
}

export class EnabledChannelsMessage extends DofusMessage {
	public static id: number = 1211

	public channels: number[] | undefined
	public disallowed: number[] | undefined

	public constructor(
		channels?: number[] | undefined,
		disallowed?: number[] | undefined
	) {
		super()
		this.channels = channels
		this.disallowed = disallowed
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeShort(this.channels!.length)
		this.channels!.forEach((current: number) => writer.writeByte(current))
		writer.writeShort(this.disallowed!.length)
		this.disallowed!.forEach((current: number) => writer.writeByte(current))
	}

	public deserialize(reader: BinaryReader): void {
		this.channels = []
		const countChannels = reader.readShort()
		for (let i: number = 0; i < countChannels; i++) {
			this.channels.push(reader.readByte())
		}
		this.disallowed = []
		const countDisallowed = reader.readShort()
		for (let i: number = 0; i < countDisallowed; i++) {
			this.disallowed.push(reader.readByte())
		}
	}

	public hydrate(
		data: EnabledChannelsMessage | Record<string, any>
	): EnabledChannelsMessage {
		if (data instanceof EnabledChannelsMessage) {
			return data
		}

		this.channels = data.channels
		this.disallowed = data.disallowed

		return this
	}
}

export interface RawCinematicMessage {
	id: number
	cinematicId: number
}

export class CinematicMessage extends DofusMessage {
	public static id: number = 9796

	public cinematicId: number | undefined = 0

	public constructor(cinematicId?: number | undefined) {
		super()
		this.cinematicId = cinematicId
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarShort(this.cinematicId!)
	}

	public deserialize(reader: BinaryReader): void {
		this.cinematicId = reader.readVarShort()
	}

	public hydrate(
		data: CinematicMessage | Record<string, any>
	): CinematicMessage {
		if (data instanceof CinematicMessage) {
			return data
		}

		this.cinematicId = data.cinematicId

		return this
	}
}

export interface RawExchangeStartOkJobIndexMessage {
	id: number
	jobs: number[]
}

export class ExchangeStartOkJobIndexMessage extends DofusMessage {
	public static id: number = 9846

	public jobs: number[] | undefined

	public constructor(jobs?: number[] | undefined) {
		super()
		this.jobs = jobs
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeShort(this.jobs!.length)
		this.jobs!.forEach((current: number) => writer.writeVarInt(current))
	}

	public deserialize(reader: BinaryReader): void {
		this.jobs = []
		const countJobs = reader.readShort()
		for (let i: number = 0; i < countJobs; i++) {
			this.jobs.push(reader.readVarInt())
		}
	}

	public hydrate(
		data: ExchangeStartOkJobIndexMessage | Record<string, any>
	): ExchangeStartOkJobIndexMessage {
		if (data instanceof ExchangeStartOkJobIndexMessage) {
			return data
		}

		this.jobs = data.jobs

		return this
	}
}

export interface RawGameFightPlacementPossiblePositionsMessage {
	id: number
	positionsForChallengers: number[]
	positionsForDefenders: number[]
	teamNumber: number
}

export class GameFightPlacementPossiblePositionsMessage extends DofusMessage {
	public static id: number = 4098

	public positionsForChallengers: number[] | undefined
	public positionsForDefenders: number[] | undefined
	public teamNumber: number | undefined = 2

	public constructor(
		positionsForChallengers?: number[] | undefined,
		positionsForDefenders?: number[] | undefined,
		teamNumber?: number | undefined
	) {
		super()
		this.positionsForChallengers = positionsForChallengers
		this.positionsForDefenders = positionsForDefenders
		this.teamNumber = teamNumber
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeShort(this.positionsForChallengers!.length)
		this.positionsForChallengers!.forEach((current: number) =>
			writer.writeVarShort(current)
		)
		writer.writeShort(this.positionsForDefenders!.length)
		this.positionsForDefenders!.forEach((current: number) =>
			writer.writeVarShort(current)
		)
		writer.writeByte(this.teamNumber!)
	}

	public deserialize(reader: BinaryReader): void {
		this.positionsForChallengers = []
		const countPositionsForChallengers = reader.readShort()
		for (let i: number = 0; i < countPositionsForChallengers; i++) {
			this.positionsForChallengers.push(reader.readVarShort())
		}
		this.positionsForDefenders = []
		const countPositionsForDefenders = reader.readShort()
		for (let i: number = 0; i < countPositionsForDefenders; i++) {
			this.positionsForDefenders.push(reader.readVarShort())
		}
		this.teamNumber = reader.readByte()
	}

	public hydrate(
		data: GameFightPlacementPossiblePositionsMessage | Record<string, any>
	): GameFightPlacementPossiblePositionsMessage {
		if (data instanceof GameFightPlacementPossiblePositionsMessage) {
			return data
		}

		this.positionsForChallengers = data.positionsForChallengers
		this.positionsForDefenders = data.positionsForDefenders
		this.teamNumber = data.teamNumber

		return this
	}
}

export interface RawCharacterSelectedErrorMessage {
	id: number
}

export class CharacterSelectedErrorMessage extends DofusMessage {
	public static id: number = 7442

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public serialize(writer: BinaryWriter): void {}

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public deserialize(reader: BinaryReader): void {}

	public hydrate(
		data: CharacterSelectedErrorMessage | Record<string, any>
	): CharacterSelectedErrorMessage {
		if (data instanceof CharacterSelectedErrorMessage) {
			return data
		}

		return this
	}
}

export interface RawAccountLinkRequiredMessage {
	id: number
}

export class AccountLinkRequiredMessage extends DofusMessage {
	public static id: number = 7982

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public serialize(writer: BinaryWriter): void {}

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public deserialize(reader: BinaryReader): void {}

	public hydrate(
		data: AccountLinkRequiredMessage | Record<string, any>
	): AccountLinkRequiredMessage {
		if (data instanceof AccountLinkRequiredMessage) {
			return data
		}

		return this
	}
}

export interface RawAchievementRewardSuccessMessage {
	id: number
	achievementId: number
}

export class AchievementRewardSuccessMessage extends DofusMessage {
	public static id: number = 3454

	public achievementId: number | undefined = 0

	public constructor(achievementId?: number | undefined) {
		super()
		this.achievementId = achievementId
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeShort(this.achievementId!)
	}

	public deserialize(reader: BinaryReader): void {
		this.achievementId = reader.readShort()
	}

	public hydrate(
		data: AchievementRewardSuccessMessage | Record<string, any>
	): AchievementRewardSuccessMessage {
		if (data instanceof AchievementRewardSuccessMessage) {
			return data
		}

		this.achievementId = data.achievementId

		return this
	}
}

export interface RawMigratedServerListMessage {
	id: number
	migratedServerIds: number[]
}

export class MigratedServerListMessage extends DofusMessage {
	public static id: number = 9270

	public migratedServerIds: number[] | undefined

	public constructor(migratedServerIds?: number[] | undefined) {
		super()
		this.migratedServerIds = migratedServerIds
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeShort(this.migratedServerIds!.length)
		this.migratedServerIds!.forEach((current: number) =>
			writer.writeVarShort(current)
		)
	}

	public deserialize(reader: BinaryReader): void {
		this.migratedServerIds = []
		const countMigratedServerIds = reader.readShort()
		for (let i: number = 0; i < countMigratedServerIds; i++) {
			this.migratedServerIds.push(reader.readVarShort())
		}
	}

	public hydrate(
		data: MigratedServerListMessage | Record<string, any>
	): MigratedServerListMessage {
		if (data instanceof MigratedServerListMessage) {
			return data
		}

		this.migratedServerIds = data.migratedServerIds

		return this
	}
}

export interface RawCompassResetMessage {
	id: number
	type: number
}

export class CompassResetMessage extends DofusMessage {
	public static id: number = 5095

	public type: number | undefined = 0

	public constructor(type?: number | undefined) {
		super()
		this.type = type
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeByte(this.type!)
	}

	public deserialize(reader: BinaryReader): void {
		this.type = reader.readByte()
	}

	public hydrate(
		data: CompassResetMessage | Record<string, any>
	): CompassResetMessage {
		if (data instanceof CompassResetMessage) {
			return data
		}

		this.type = data.type

		return this
	}
}

export interface RawExchangeObjectRemovedFromBagMessage
	extends RawExchangeObjectMessage {
	id: number
	objectUID: number
}

export class ExchangeObjectRemovedFromBagMessage extends ExchangeObjectMessage {
	public static id = 5956

	public objectUID: number | undefined = 0

	public constructor(
		remote?: boolean | undefined,
		objectUID?: number | undefined
	) {
		super(remote)
		this.objectUID = objectUID
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeVarInt(this.objectUID!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.objectUID = reader.readVarInt()
	}

	public hydrate(
		data: ExchangeObjectRemovedFromBagMessage | Record<string, any>
	): ExchangeObjectRemovedFromBagMessage {
		if (data instanceof ExchangeObjectRemovedFromBagMessage) {
			return data
		}

		super.hydrate(data)

		this.objectUID = data.objectUID

		return this
	}
}

export interface RawPartyJoinMessage extends RawAbstractPartyMessage {
	id: number
	partyType: number
	partyLeaderId: number
	maxParticipants: number
	members: PartyMemberInformations[]
	guests: PartyGuestInformations[]
	restricted: boolean
	partyName: string
}

export class PartyJoinMessage extends AbstractPartyMessage {
	public static id = 5273

	public partyType: number | undefined = 0
	public partyLeaderId: number | undefined = 0
	public maxParticipants: number | undefined = 0
	public members: PartyMemberInformations[] | undefined
	public guests: PartyGuestInformations[] | undefined
	public restricted: boolean | undefined = false
	public partyName: string | undefined

	public constructor(
		partyId?: number | undefined,
		partyType?: number | undefined,
		partyLeaderId?: number | undefined,
		maxParticipants?: number | undefined,
		members?: PartyMemberInformations[] | undefined,
		guests?: PartyGuestInformations[] | undefined,
		restricted?: boolean | undefined,
		partyName?: string | undefined
	) {
		super(partyId)
		this.partyType = partyType
		this.partyLeaderId = partyLeaderId
		this.maxParticipants = maxParticipants
		this.members = members
		this.guests = guests
		this.restricted = restricted
		this.partyName = partyName
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeByte(this.partyType!)
		writer.writeVarLong(this.partyLeaderId!)
		writer.writeByte(this.maxParticipants!)
		writer.writeShort(this.members!.length)
		this.members!.forEach((current) => {
			writer.writeShort(current.id)
			current.serialize(writer)
		})
		writer.writeShort(this.guests!.length)
		this.guests!.forEach((current) => {
			current.serialize(writer)
		})
		writer.writeBoolean(this.restricted!)
		writer.writeUTF(this.partyName!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.partyType = reader.readByte()
		this.partyLeaderId = reader.readVarLong()
		this.maxParticipants = reader.readByte()
		this.members = []
		const countMembers = reader.readShort()
		for (let i: number = 0; i < countMembers; i++) {
			const membersTypeId: number = reader.readShort()
			const type: PartyMemberInformations = new types[
				membersTypeId
			]() as PartyMemberInformations
			type.deserialize(reader)
			this.members.push(type)
		}
		this.guests = []
		const countGuests = reader.readShort()
		for (let i: number = 0; i < countGuests; i++) {
			const type: PartyGuestInformations = new PartyGuestInformations()
			type.deserialize(reader)
			this.guests.push(type)
		}
		this.restricted = reader.readBoolean()
		this.partyName = reader.readUTF()
	}

	public hydrate(
		data: PartyJoinMessage | Record<string, any>
	): PartyJoinMessage {
		if (data instanceof PartyJoinMessage) {
			return data
		}

		super.hydrate(data)

		this.partyType = data.partyType
		this.partyLeaderId = data.partyLeaderId
		this.maxParticipants = data.maxParticipants
		this.members = data.members.map(
			(
				dataElement: PartyMemberInformations | Record<string, any>
			): PartyMemberInformations => {
				if (dataElement instanceof PartyMemberInformations) {
					return dataElement
				} else {
					return (new types[
						dataElement.id
					]() as PartyMemberInformations).hydrate(dataElement)
				}
			}
		)
		this.guests = data.guests.map(
			(
				dataElement: PartyGuestInformations | Record<string, any>
			): PartyGuestInformations => {
				if (dataElement instanceof PartyGuestInformations) {
					return dataElement
				} else {
					return new PartyGuestInformations().hydrate(dataElement)
				}
			}
		)
		this.restricted = data.restricted
		this.partyName = data.partyName

		return this
	}
}

export interface RawWatchInventoryContentMessage
	extends RawInventoryContentMessage {
	id: number
}

export class WatchInventoryContentMessage extends InventoryContentMessage {
	public static id = 1656

	public constructor(
		objects?: ObjectItem[] | undefined,
		kamas?: number | undefined
	) {
		super(objects, kamas)
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
	}

	public hydrate(
		data: WatchInventoryContentMessage | Record<string, any>
	): WatchInventoryContentMessage {
		if (data instanceof WatchInventoryContentMessage) {
			return data
		}

		super.hydrate(data)

		return this
	}
}

export interface RawStorageKamasUpdateMessage {
	id: number
	kamasTotal: number
}

export class StorageKamasUpdateMessage extends DofusMessage {
	public static id: number = 9471

	public kamasTotal: number | undefined = 0

	public constructor(kamasTotal?: number | undefined) {
		super()
		this.kamasTotal = kamasTotal
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarLong(this.kamasTotal!)
	}

	public deserialize(reader: BinaryReader): void {
		this.kamasTotal = reader.readVarLong()
	}

	public hydrate(
		data: StorageKamasUpdateMessage | Record<string, any>
	): StorageKamasUpdateMessage {
		if (data instanceof StorageKamasUpdateMessage) {
			return data
		}

		this.kamasTotal = data.kamasTotal

		return this
	}
}

export interface RawHouseSellingUpdateMessage {
	id: number
	houseId: number
	instanceId: number
	secondHand: boolean
	realPrice: number
	buyerName: string
}

export class HouseSellingUpdateMessage extends DofusMessage {
	public static id: number = 8778

	public houseId: number | undefined = 0
	public instanceId: number | undefined = 0
	public secondHand: boolean | undefined = false
	public realPrice: number | undefined = 0
	public buyerName: string | undefined

	public constructor(
		houseId?: number | undefined,
		instanceId?: number | undefined,
		secondHand?: boolean | undefined,
		realPrice?: number | undefined,
		buyerName?: string | undefined
	) {
		super()
		this.houseId = houseId
		this.instanceId = instanceId
		this.secondHand = secondHand
		this.realPrice = realPrice
		this.buyerName = buyerName
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarInt(this.houseId!)
		writer.writeInt(this.instanceId!)
		writer.writeBoolean(this.secondHand!)
		writer.writeVarLong(this.realPrice!)
		writer.writeUTF(this.buyerName!)
	}

	public deserialize(reader: BinaryReader): void {
		this.houseId = reader.readVarInt()
		this.instanceId = reader.readInt()
		this.secondHand = reader.readBoolean()
		this.realPrice = reader.readVarLong()
		this.buyerName = reader.readUTF()
	}

	public hydrate(
		data: HouseSellingUpdateMessage | Record<string, any>
	): HouseSellingUpdateMessage {
		if (data instanceof HouseSellingUpdateMessage) {
			return data
		}

		this.houseId = data.houseId
		this.instanceId = data.instanceId
		this.secondHand = data.secondHand
		this.realPrice = data.realPrice
		this.buyerName = data.buyerName

		return this
	}
}

export interface RawShortcutBarReplacedMessage {
	id: number
	barType: number
	shortcut: Shortcut
}

export class ShortcutBarReplacedMessage extends DofusMessage {
	public static id: number = 5098

	public barType: number | undefined = 0
	public shortcut: Shortcut | undefined

	public constructor(
		barType?: number | undefined,
		shortcut?: Shortcut | undefined
	) {
		super()
		this.barType = barType
		this.shortcut = shortcut
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeByte(this.barType!)
		writer.writeShort(this.shortcut!.id)
		this.shortcut!.serialize(writer)
	}

	public deserialize(reader: BinaryReader): void {
		this.barType = reader.readByte()
		const shortcutTypeId: number = reader.readShort()
		this.shortcut = new types[shortcutTypeId]() as Shortcut
		this.shortcut!.deserialize(reader)
	}

	public hydrate(
		data: ShortcutBarReplacedMessage | Record<string, any>
	): ShortcutBarReplacedMessage {
		if (data instanceof ShortcutBarReplacedMessage) {
			return data
		}

		this.barType = data.barType
		this.shortcut = (new types[data.shortcut.id]() as Shortcut).hydrate(
			data.shortcut
		)
		return this
	}
}

export interface RawJobBookSubscriptionMessage {
	id: number
	subscriptions: JobBookSubscription[]
}

export class JobBookSubscriptionMessage extends DofusMessage {
	public static id: number = 7522

	public subscriptions: JobBookSubscription[] | undefined

	public constructor(subscriptions?: JobBookSubscription[] | undefined) {
		super()
		this.subscriptions = subscriptions
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeShort(this.subscriptions!.length)
		this.subscriptions!.forEach((current) => {
			current.serialize(writer)
		})
	}

	public deserialize(reader: BinaryReader): void {
		this.subscriptions = []
		const countSubscriptions = reader.readShort()
		for (let i: number = 0; i < countSubscriptions; i++) {
			const type: JobBookSubscription = new JobBookSubscription()
			type.deserialize(reader)
			this.subscriptions.push(type)
		}
	}

	public hydrate(
		data: JobBookSubscriptionMessage | Record<string, any>
	): JobBookSubscriptionMessage {
		if (data instanceof JobBookSubscriptionMessage) {
			return data
		}

		this.subscriptions = data.subscriptions.map(
			(
				dataElement: JobBookSubscription | Record<string, any>
			): JobBookSubscription => {
				if (dataElement instanceof JobBookSubscription) {
					return dataElement
				} else {
					return new JobBookSubscription().hydrate(dataElement)
				}
			}
		)

		return this
	}
}

export interface RawPrismSettingsErrorMessage {
	id: number
}

export class PrismSettingsErrorMessage extends DofusMessage {
	public static id: number = 6258

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public serialize(writer: BinaryWriter): void {}

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public deserialize(reader: BinaryReader): void {}

	public hydrate(
		data: PrismSettingsErrorMessage | Record<string, any>
	): PrismSettingsErrorMessage {
		if (data instanceof PrismSettingsErrorMessage) {
			return data
		}

		return this
	}
}

export interface RawBreachKickResponseMessage {
	id: number
	target: CharacterMinimalInformations
	kicked: boolean
}

export class BreachKickResponseMessage extends DofusMessage {
	public static id: number = 5951

	public target: CharacterMinimalInformations | undefined
	public kicked: boolean | undefined = false

	public constructor(
		target?: CharacterMinimalInformations | undefined,
		kicked?: boolean | undefined
	) {
		super()
		this.target = target
		this.kicked = kicked
	}

	public serialize(writer: BinaryWriter): void {
		this.target!.serialize(writer)
		writer.writeBoolean(this.kicked!)
	}

	public deserialize(reader: BinaryReader): void {
		this.target = new CharacterMinimalInformations()
		this.target!.deserialize(reader)
		this.kicked = reader.readBoolean()
	}

	public hydrate(
		data: BreachKickResponseMessage | Record<string, any>
	): BreachKickResponseMessage {
		if (data instanceof BreachKickResponseMessage) {
			return data
		}

		this.target = new CharacterMinimalInformations().hydrate(data.target)
		this.kicked = data.kicked

		return this
	}
}

export interface RawSpouseInformationsMessage {
	id: number
	spouse: FriendSpouseInformations
}

export class SpouseInformationsMessage extends DofusMessage {
	public static id: number = 940

	public spouse: FriendSpouseInformations | undefined

	public constructor(spouse?: FriendSpouseInformations | undefined) {
		super()
		this.spouse = spouse
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeShort(this.spouse!.id)
		this.spouse!.serialize(writer)
	}

	public deserialize(reader: BinaryReader): void {
		const spouseTypeId: number = reader.readShort()
		this.spouse = new types[spouseTypeId]() as FriendSpouseInformations
		this.spouse!.deserialize(reader)
	}

	public hydrate(
		data: SpouseInformationsMessage | Record<string, any>
	): SpouseInformationsMessage {
		if (data instanceof SpouseInformationsMessage) {
			return data
		}

		this.spouse = (new types[
			data.spouse.id
		]() as FriendSpouseInformations).hydrate(data.spouse)
		return this
	}
}

export interface RawHaapiBuyValidationMessage
	extends RawHaapiValidationMessage {
	id: number
	amount: number
	email: string
}

export class HaapiBuyValidationMessage extends HaapiValidationMessage {
	public static id = 8752

	public amount: number | undefined = 0
	public email: string | undefined

	public constructor(
		action?: number | undefined,
		code?: number | undefined,
		amount?: number | undefined,
		email?: string | undefined
	) {
		super(action, code)
		this.amount = amount
		this.email = email
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeVarLong(this.amount!)
		writer.writeUTF(this.email!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.amount = reader.readVarLong()
		this.email = reader.readUTF()
	}

	public hydrate(
		data: HaapiBuyValidationMessage | Record<string, any>
	): HaapiBuyValidationMessage {
		if (data instanceof HaapiBuyValidationMessage) {
			return data
		}

		super.hydrate(data)

		this.amount = data.amount
		this.email = data.email

		return this
	}
}

export interface RawTitleLostMessage {
	id: number
	titleId: number
}

export class TitleLostMessage extends DofusMessage {
	public static id: number = 7521

	public titleId: number | undefined = 0

	public constructor(titleId?: number | undefined) {
		super()
		this.titleId = titleId
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarShort(this.titleId!)
	}

	public deserialize(reader: BinaryReader): void {
		this.titleId = reader.readVarShort()
	}

	public hydrate(
		data: TitleLostMessage | Record<string, any>
	): TitleLostMessage {
		if (data instanceof TitleLostMessage) {
			return data
		}

		this.titleId = data.titleId

		return this
	}
}

export interface RawPresetSavedMessage {
	id: number
	presetId: number
	preset: Preset
}

export class PresetSavedMessage extends DofusMessage {
	public static id: number = 2420

	public presetId: number | undefined = 0
	public preset: Preset | undefined

	public constructor(
		presetId?: number | undefined,
		preset?: Preset | undefined
	) {
		super()
		this.presetId = presetId
		this.preset = preset
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeShort(this.presetId!)
		writer.writeShort(this.preset!.id)
		this.preset!.serialize(writer)
	}

	public deserialize(reader: BinaryReader): void {
		this.presetId = reader.readShort()
		const presetTypeId: number = reader.readShort()
		this.preset = new types[presetTypeId]() as Preset
		this.preset!.deserialize(reader)
	}

	public hydrate(
		data: PresetSavedMessage | Record<string, any>
	): PresetSavedMessage {
		if (data instanceof PresetSavedMessage) {
			return data
		}

		this.presetId = data.presetId
		this.preset = (new types[data.preset.id]() as Preset).hydrate(data.preset)
		return this
	}
}

export interface RawExchangeStartOkRunesTradeMessage {
	id: number
}

export class ExchangeStartOkRunesTradeMessage extends DofusMessage {
	public static id: number = 4206

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public serialize(writer: BinaryWriter): void {}

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public deserialize(reader: BinaryReader): void {}

	public hydrate(
		data: ExchangeStartOkRunesTradeMessage | Record<string, any>
	): ExchangeStartOkRunesTradeMessage {
		if (data instanceof ExchangeStartOkRunesTradeMessage) {
			return data
		}

		return this
	}
}

export interface RawShortcutBarRefreshMessage {
	id: number
	barType: number
	shortcut: Shortcut
}

export class ShortcutBarRefreshMessage extends DofusMessage {
	public static id: number = 5855

	public barType: number | undefined = 0
	public shortcut: Shortcut | undefined

	public constructor(
		barType?: number | undefined,
		shortcut?: Shortcut | undefined
	) {
		super()
		this.barType = barType
		this.shortcut = shortcut
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeByte(this.barType!)
		writer.writeShort(this.shortcut!.id)
		this.shortcut!.serialize(writer)
	}

	public deserialize(reader: BinaryReader): void {
		this.barType = reader.readByte()
		const shortcutTypeId: number = reader.readShort()
		this.shortcut = new types[shortcutTypeId]() as Shortcut
		this.shortcut!.deserialize(reader)
	}

	public hydrate(
		data: ShortcutBarRefreshMessage | Record<string, any>
	): ShortcutBarRefreshMessage {
		if (data instanceof ShortcutBarRefreshMessage) {
			return data
		}

		this.barType = data.barType
		this.shortcut = (new types[data.shortcut.id]() as Shortcut).hydrate(
			data.shortcut
		)
		return this
	}
}

export interface RawDungeonKeyRingMessage {
	id: number
	availables: number[]
	unavailables: number[]
}

export class DungeonKeyRingMessage extends DofusMessage {
	public static id: number = 4148

	public availables: number[] | undefined
	public unavailables: number[] | undefined

	public constructor(
		availables?: number[] | undefined,
		unavailables?: number[] | undefined
	) {
		super()
		this.availables = availables
		this.unavailables = unavailables
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeShort(this.availables!.length)
		this.availables!.forEach((current: number) => writer.writeVarShort(current))
		writer.writeShort(this.unavailables!.length)
		this.unavailables!.forEach((current: number) =>
			writer.writeVarShort(current)
		)
	}

	public deserialize(reader: BinaryReader): void {
		this.availables = []
		const countAvailables = reader.readShort()
		for (let i: number = 0; i < countAvailables; i++) {
			this.availables.push(reader.readVarShort())
		}
		this.unavailables = []
		const countUnavailables = reader.readShort()
		for (let i: number = 0; i < countUnavailables; i++) {
			this.unavailables.push(reader.readVarShort())
		}
	}

	public hydrate(
		data: DungeonKeyRingMessage | Record<string, any>
	): DungeonKeyRingMessage {
		if (data instanceof DungeonKeyRingMessage) {
			return data
		}

		this.availables = data.availables
		this.unavailables = data.unavailables

		return this
	}
}

export interface RawTeleportOnSameMapMessage {
	id: number
	targetId: number
	cellId: number
}

export class TeleportOnSameMapMessage extends DofusMessage {
	public static id: number = 8234

	public targetId: number | undefined = 0
	public cellId: number | undefined = 0

	public constructor(
		targetId?: number | undefined,
		cellId?: number | undefined
	) {
		super()
		this.targetId = targetId
		this.cellId = cellId
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeDouble(this.targetId!)
		writer.writeVarShort(this.cellId!)
	}

	public deserialize(reader: BinaryReader): void {
		this.targetId = reader.readDouble()
		this.cellId = reader.readVarShort()
	}

	public hydrate(
		data: TeleportOnSameMapMessage | Record<string, any>
	): TeleportOnSameMapMessage {
		if (data instanceof TeleportOnSameMapMessage) {
			return data
		}

		this.targetId = data.targetId
		this.cellId = data.cellId

		return this
	}
}

export interface RawTreasureHuntShowLegendaryUIMessage {
	id: number
	availableLegendaryIds: number[]
}

export class TreasureHuntShowLegendaryUIMessage extends DofusMessage {
	public static id: number = 9952

	public availableLegendaryIds: number[] | undefined

	public constructor(availableLegendaryIds?: number[] | undefined) {
		super()
		this.availableLegendaryIds = availableLegendaryIds
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeShort(this.availableLegendaryIds!.length)
		this.availableLegendaryIds!.forEach((current: number) =>
			writer.writeVarShort(current)
		)
	}

	public deserialize(reader: BinaryReader): void {
		this.availableLegendaryIds = []
		const countAvailableLegendaryIds = reader.readShort()
		for (let i: number = 0; i < countAvailableLegendaryIds; i++) {
			this.availableLegendaryIds.push(reader.readVarShort())
		}
	}

	public hydrate(
		data: TreasureHuntShowLegendaryUIMessage | Record<string, any>
	): TreasureHuntShowLegendaryUIMessage {
		if (data instanceof TreasureHuntShowLegendaryUIMessage) {
			return data
		}

		this.availableLegendaryIds = data.availableLegendaryIds

		return this
	}
}

export interface RawChatSmileyExtraPackListMessage {
	id: number
	packIds: number[]
}

export class ChatSmileyExtraPackListMessage extends DofusMessage {
	public static id: number = 6

	public packIds: number[] | undefined

	public constructor(packIds?: number[] | undefined) {
		super()
		this.packIds = packIds
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeShort(this.packIds!.length)
		this.packIds!.forEach((current: number) => writer.writeByte(current))
	}

	public deserialize(reader: BinaryReader): void {
		this.packIds = []
		const countPackIds = reader.readShort()
		for (let i: number = 0; i < countPackIds; i++) {
			this.packIds.push(reader.readByte())
		}
	}

	public hydrate(
		data: ChatSmileyExtraPackListMessage | Record<string, any>
	): ChatSmileyExtraPackListMessage {
		if (data instanceof ChatSmileyExtraPackListMessage) {
			return data
		}

		this.packIds = data.packIds

		return this
	}
}

export interface RawServerStatusUpdateMessage {
	id: number
	server: GameServerInformations
}

export class ServerStatusUpdateMessage extends DofusMessage {
	public static id: number = 3516

	public server: GameServerInformations | undefined

	public constructor(server?: GameServerInformations | undefined) {
		super()
		this.server = server
	}

	public serialize(writer: BinaryWriter): void {
		this.server!.serialize(writer)
	}

	public deserialize(reader: BinaryReader): void {
		this.server = new GameServerInformations()
		this.server!.deserialize(reader)
	}

	public hydrate(
		data: ServerStatusUpdateMessage | Record<string, any>
	): ServerStatusUpdateMessage {
		if (data instanceof ServerStatusUpdateMessage) {
			return data
		}

		this.server = new GameServerInformations().hydrate(data.server)

		return this
	}
}

export interface RawTeleportBuddiesMessage {
	id: number
	dungeonId: number
}

export class TeleportBuddiesMessage extends DofusMessage {
	public static id: number = 8443

	public dungeonId: number | undefined = 0

	public constructor(dungeonId?: number | undefined) {
		super()
		this.dungeonId = dungeonId
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarShort(this.dungeonId!)
	}

	public deserialize(reader: BinaryReader): void {
		this.dungeonId = reader.readVarShort()
	}

	public hydrate(
		data: TeleportBuddiesMessage | Record<string, any>
	): TeleportBuddiesMessage {
		if (data instanceof TeleportBuddiesMessage) {
			return data
		}

		this.dungeonId = data.dungeonId

		return this
	}
}

export interface RawAlignmentWarEffortDonatePreviewMessage {
	id: number
	xp: number
}

export class AlignmentWarEffortDonatePreviewMessage extends DofusMessage {
	public static id: number = 8421

	public xp: number | undefined = 0

	public constructor(xp?: number | undefined) {
		super()
		this.xp = xp
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeDouble(this.xp!)
	}

	public deserialize(reader: BinaryReader): void {
		this.xp = reader.readDouble()
	}

	public hydrate(
		data: AlignmentWarEffortDonatePreviewMessage | Record<string, any>
	): AlignmentWarEffortDonatePreviewMessage {
		if (data instanceof AlignmentWarEffortDonatePreviewMessage) {
			return data
		}

		this.xp = data.xp

		return this
	}
}

export interface RawGoldAddedMessage {
	id: number
	gold: GoldItem
}

export class GoldAddedMessage extends DofusMessage {
	public static id: number = 1255

	public gold: GoldItem | undefined

	public constructor(gold?: GoldItem | undefined) {
		super()
		this.gold = gold
	}

	public serialize(writer: BinaryWriter): void {
		this.gold!.serialize(writer)
	}

	public deserialize(reader: BinaryReader): void {
		this.gold = new GoldItem()
		this.gold!.deserialize(reader)
	}

	public hydrate(
		data: GoldAddedMessage | Record<string, any>
	): GoldAddedMessage {
		if (data instanceof GoldAddedMessage) {
			return data
		}

		this.gold = new GoldItem().hydrate(data.gold)

		return this
	}
}

export interface RawFriendWarnOnLevelGainStateMessage {
	id: number
	enable: boolean
}

export class FriendWarnOnLevelGainStateMessage extends DofusMessage {
	public static id: number = 7752

	public enable: boolean | undefined = false

	public constructor(enable?: boolean | undefined) {
		super()
		this.enable = enable
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeBoolean(this.enable!)
	}

	public deserialize(reader: BinaryReader): void {
		this.enable = reader.readBoolean()
	}

	public hydrate(
		data: FriendWarnOnLevelGainStateMessage | Record<string, any>
	): FriendWarnOnLevelGainStateMessage {
		if (data instanceof FriendWarnOnLevelGainStateMessage) {
			return data
		}

		this.enable = data.enable

		return this
	}
}

export interface RawGuildListMessage {
	id: number
	guilds: GuildInformations[]
}

export class GuildListMessage extends DofusMessage {
	public static id: number = 7453

	public guilds: GuildInformations[] | undefined

	public constructor(guilds?: GuildInformations[] | undefined) {
		super()
		this.guilds = guilds
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeShort(this.guilds!.length)
		this.guilds!.forEach((current) => {
			current.serialize(writer)
		})
	}

	public deserialize(reader: BinaryReader): void {
		this.guilds = []
		const countGuilds = reader.readShort()
		for (let i: number = 0; i < countGuilds; i++) {
			const type: GuildInformations = new GuildInformations()
			type.deserialize(reader)
			this.guilds.push(type)
		}
	}

	public hydrate(
		data: GuildListMessage | Record<string, any>
	): GuildListMessage {
		if (data instanceof GuildListMessage) {
			return data
		}

		this.guilds = data.guilds.map(
			(
				dataElement: GuildInformations | Record<string, any>
			): GuildInformations => {
				if (dataElement instanceof GuildInformations) {
					return dataElement
				} else {
					return new GuildInformations().hydrate(dataElement)
				}
			}
		)

		return this
	}
}

export interface RawPresetDeleteResultMessage {
	id: number
	presetId: number
	code: number
}

export class PresetDeleteResultMessage extends DofusMessage {
	public static id: number = 2952

	public presetId: number | undefined = 0
	public code: number | undefined = 2

	public constructor(presetId?: number | undefined, code?: number | undefined) {
		super()
		this.presetId = presetId
		this.code = code
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeShort(this.presetId!)
		writer.writeByte(this.code!)
	}

	public deserialize(reader: BinaryReader): void {
		this.presetId = reader.readShort()
		this.code = reader.readByte()
	}

	public hydrate(
		data: PresetDeleteResultMessage | Record<string, any>
	): PresetDeleteResultMessage {
		if (data instanceof PresetDeleteResultMessage) {
			return data
		}

		this.presetId = data.presetId
		this.code = data.code

		return this
	}
}

export interface RawExchangeItemAutoCraftStopedMessage {
	id: number
	reason: number
}

export class ExchangeItemAutoCraftStopedMessage extends DofusMessage {
	public static id: number = 526

	public reason: number | undefined = 0

	public constructor(reason?: number | undefined) {
		super()
		this.reason = reason
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeByte(this.reason!)
	}

	public deserialize(reader: BinaryReader): void {
		this.reason = reader.readByte()
	}

	public hydrate(
		data: ExchangeItemAutoCraftStopedMessage | Record<string, any>
	): ExchangeItemAutoCraftStopedMessage {
		if (data instanceof ExchangeItemAutoCraftStopedMessage) {
			return data
		}

		this.reason = data.reason

		return this
	}
}

export interface RawExchangeErrorMessage {
	id: number
	errorType: number
}

export class ExchangeErrorMessage extends DofusMessage {
	public static id: number = 9003

	public errorType: number | undefined = 0

	public constructor(errorType?: number | undefined) {
		super()
		this.errorType = errorType
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeByte(this.errorType!)
	}

	public deserialize(reader: BinaryReader): void {
		this.errorType = reader.readByte()
	}

	public hydrate(
		data: ExchangeErrorMessage | Record<string, any>
	): ExchangeErrorMessage {
		if (data instanceof ExchangeErrorMessage) {
			return data
		}

		this.errorType = data.errorType

		return this
	}
}

export interface RawPrismFightStateUpdateMessage {
	id: number
	state: number
}

export class PrismFightStateUpdateMessage extends DofusMessage {
	public static id: number = 2395

	public state: number | undefined = 0

	public constructor(state?: number | undefined) {
		super()
		this.state = state
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeByte(this.state!)
	}

	public deserialize(reader: BinaryReader): void {
		this.state = reader.readByte()
	}

	public hydrate(
		data: PrismFightStateUpdateMessage | Record<string, any>
	): PrismFightStateUpdateMessage {
		if (data instanceof PrismFightStateUpdateMessage) {
			return data
		}

		this.state = data.state

		return this
	}
}

export interface RawExchangeMountSterilizeFromPaddockMessage {
	id: number
	name: string
	worldX: number
	worldY: number
	sterilizator: string
}

export class ExchangeMountSterilizeFromPaddockMessage extends DofusMessage {
	public static id: number = 4993

	public name: string | undefined
	public worldX: number | undefined = 0
	public worldY: number | undefined = 0
	public sterilizator: string | undefined

	public constructor(
		name?: string | undefined,
		worldX?: number | undefined,
		worldY?: number | undefined,
		sterilizator?: string | undefined
	) {
		super()
		this.name = name
		this.worldX = worldX
		this.worldY = worldY
		this.sterilizator = sterilizator
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeUTF(this.name!)
		writer.writeShort(this.worldX!)
		writer.writeShort(this.worldY!)
		writer.writeUTF(this.sterilizator!)
	}

	public deserialize(reader: BinaryReader): void {
		this.name = reader.readUTF()
		this.worldX = reader.readShort()
		this.worldY = reader.readShort()
		this.sterilizator = reader.readUTF()
	}

	public hydrate(
		data: ExchangeMountSterilizeFromPaddockMessage | Record<string, any>
	): ExchangeMountSterilizeFromPaddockMessage {
		if (data instanceof ExchangeMountSterilizeFromPaddockMessage) {
			return data
		}

		this.name = data.name
		this.worldX = data.worldX
		this.worldY = data.worldY
		this.sterilizator = data.sterilizator

		return this
	}
}

export interface RawTaxCollectorAttackedMessage {
	id: number
	firstNameId: number
	lastNameId: number
	worldX: number
	worldY: number
	mapId: number
	subAreaId: number
	guild: BasicGuildInformations
}

export class TaxCollectorAttackedMessage extends DofusMessage {
	public static id: number = 5749

	public firstNameId: number | undefined = 0
	public lastNameId: number | undefined = 0
	public worldX: number | undefined = 0
	public worldY: number | undefined = 0
	public mapId: number | undefined = 0
	public subAreaId: number | undefined = 0
	public guild: BasicGuildInformations | undefined

	public constructor(
		firstNameId?: number | undefined,
		lastNameId?: number | undefined,
		worldX?: number | undefined,
		worldY?: number | undefined,
		mapId?: number | undefined,
		subAreaId?: number | undefined,
		guild?: BasicGuildInformations | undefined
	) {
		super()
		this.firstNameId = firstNameId
		this.lastNameId = lastNameId
		this.worldX = worldX
		this.worldY = worldY
		this.mapId = mapId
		this.subAreaId = subAreaId
		this.guild = guild
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarShort(this.firstNameId!)
		writer.writeVarShort(this.lastNameId!)
		writer.writeShort(this.worldX!)
		writer.writeShort(this.worldY!)
		writer.writeDouble(this.mapId!)
		writer.writeVarShort(this.subAreaId!)
		this.guild!.serialize(writer)
	}

	public deserialize(reader: BinaryReader): void {
		this.firstNameId = reader.readVarShort()
		this.lastNameId = reader.readVarShort()
		this.worldX = reader.readShort()
		this.worldY = reader.readShort()
		this.mapId = reader.readDouble()
		this.subAreaId = reader.readVarShort()
		this.guild = new BasicGuildInformations()
		this.guild!.deserialize(reader)
	}

	public hydrate(
		data: TaxCollectorAttackedMessage | Record<string, any>
	): TaxCollectorAttackedMessage {
		if (data instanceof TaxCollectorAttackedMessage) {
			return data
		}

		this.firstNameId = data.firstNameId
		this.lastNameId = data.lastNameId
		this.worldX = data.worldX
		this.worldY = data.worldY
		this.mapId = data.mapId
		this.subAreaId = data.subAreaId
		this.guild = new BasicGuildInformations().hydrate(data.guild)

		return this
	}
}

export interface RawServerSettingsMessage {
	id: number
	isMonoAccount: boolean
	hasFreeAutopilot: boolean
	lang: string
	community: number
	gameType: number
	arenaLeaveBanTime: number
	itemMaxLevel: number
}

export class ServerSettingsMessage extends DofusMessage {
	public static id: number = 666

	public lang: string | undefined
	public community: number | undefined = 0
	public gameType: number | undefined = -1
	public isMonoAccount: boolean | undefined = false
	public arenaLeaveBanTime: number | undefined = 0
	public itemMaxLevel: number | undefined = 0
	public hasFreeAutopilot: boolean | undefined = false

	public constructor(
		isMonoAccount?: boolean | undefined,
		hasFreeAutopilot?: boolean | undefined,
		lang?: string | undefined,
		community?: number | undefined,
		gameType?: number | undefined,
		arenaLeaveBanTime?: number | undefined,
		itemMaxLevel?: number | undefined
	) {
		super()
		this.isMonoAccount = isMonoAccount
		this.hasFreeAutopilot = hasFreeAutopilot
		this.lang = lang
		this.community = community
		this.gameType = gameType
		this.arenaLeaveBanTime = arenaLeaveBanTime
		this.itemMaxLevel = itemMaxLevel
	}

	public serialize(writer: BinaryWriter): void {
		let box0: number = 0
		box0 = setFlag(box0, 0, this.isMonoAccount!)
		box0 = setFlag(box0, 1, this.hasFreeAutopilot!)
		writer.writeByte(box0)
		writer.writeUTF(this.lang!)
		writer.writeByte(this.community!)
		writer.writeByte(this.gameType!)
		writer.writeVarShort(this.arenaLeaveBanTime!)
		writer.writeInt(this.itemMaxLevel!)
	}

	public deserialize(reader: BinaryReader): void {
		const box0 = reader.readByte()
		this.isMonoAccount = getFlag(box0, 0)
		this.hasFreeAutopilot = getFlag(box0, 1)
		this.lang = reader.readUTF()
		this.community = reader.readByte()
		this.gameType = reader.readByte()
		this.arenaLeaveBanTime = reader.readVarShort()
		this.itemMaxLevel = reader.readInt()
	}

	public hydrate(
		data: ServerSettingsMessage | Record<string, any>
	): ServerSettingsMessage {
		if (data instanceof ServerSettingsMessage) {
			return data
		}

		this.isMonoAccount = data.isMonoAccount
		this.hasFreeAutopilot = data.hasFreeAutopilot
		this.lang = data.lang
		this.community = data.community
		this.gameType = data.gameType
		this.arenaLeaveBanTime = data.arenaLeaveBanTime
		this.itemMaxLevel = data.itemMaxLevel

		return this
	}
}

export interface RawAcquaintanceAddedMessage {
	id: number
	acquaintanceAdded: AcquaintanceInformation
}

export class AcquaintanceAddedMessage extends DofusMessage {
	public static id: number = 1543

	public acquaintanceAdded: AcquaintanceInformation | undefined

	public constructor(acquaintanceAdded?: AcquaintanceInformation | undefined) {
		super()
		this.acquaintanceAdded = acquaintanceAdded
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeShort(this.acquaintanceAdded!.id)
		this.acquaintanceAdded!.serialize(writer)
	}

	public deserialize(reader: BinaryReader): void {
		const acquaintanceAddedTypeId: number = reader.readShort()
		this.acquaintanceAdded = new types[
			acquaintanceAddedTypeId
		]() as AcquaintanceInformation
		this.acquaintanceAdded!.deserialize(reader)
	}

	public hydrate(
		data: AcquaintanceAddedMessage | Record<string, any>
	): AcquaintanceAddedMessage {
		if (data instanceof AcquaintanceAddedMessage) {
			return data
		}

		this.acquaintanceAdded = (new types[
			data.acquaintanceAdded.id
		]() as AcquaintanceInformation).hydrate(data.acquaintanceAdded)
		return this
	}
}

export interface RawStorageObjectRemoveMessage {
	id: number
	objectUID: number
}

export class StorageObjectRemoveMessage extends DofusMessage {
	public static id: number = 7419

	public objectUID: number | undefined = 0

	public constructor(objectUID?: number | undefined) {
		super()
		this.objectUID = objectUID
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarInt(this.objectUID!)
	}

	public deserialize(reader: BinaryReader): void {
		this.objectUID = reader.readVarInt()
	}

	public hydrate(
		data: StorageObjectRemoveMessage | Record<string, any>
	): StorageObjectRemoveMessage {
		if (data instanceof StorageObjectRemoveMessage) {
			return data
		}

		this.objectUID = data.objectUID

		return this
	}
}

export interface RawFollowedQuestsMessage {
	id: number
	quests: QuestActiveDetailedInformations[]
}

export class FollowedQuestsMessage extends DofusMessage {
	public static id: number = 3134

	public quests: QuestActiveDetailedInformations[] | undefined

	public constructor(quests?: QuestActiveDetailedInformations[] | undefined) {
		super()
		this.quests = quests
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeShort(this.quests!.length)
		this.quests!.forEach((current) => {
			current.serialize(writer)
		})
	}

	public deserialize(reader: BinaryReader): void {
		this.quests = []
		const countQuests = reader.readShort()
		for (let i: number = 0; i < countQuests; i++) {
			const type: QuestActiveDetailedInformations = new QuestActiveDetailedInformations()
			type.deserialize(reader)
			this.quests.push(type)
		}
	}

	public hydrate(
		data: FollowedQuestsMessage | Record<string, any>
	): FollowedQuestsMessage {
		if (data instanceof FollowedQuestsMessage) {
			return data
		}

		this.quests = data.quests.map(
			(
				dataElement: QuestActiveDetailedInformations | Record<string, any>
			): QuestActiveDetailedInformations => {
				if (dataElement instanceof QuestActiveDetailedInformations) {
					return dataElement
				} else {
					return new QuestActiveDetailedInformations().hydrate(dataElement)
				}
			}
		)

		return this
	}
}

export interface RawServerSessionConstantsMessage {
	id: number
	variables: ServerSessionConstant[]
}

export class ServerSessionConstantsMessage extends DofusMessage {
	public static id: number = 3329

	public variables: ServerSessionConstant[] | undefined

	public constructor(variables?: ServerSessionConstant[] | undefined) {
		super()
		this.variables = variables
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeShort(this.variables!.length)
		this.variables!.forEach((current) => {
			writer.writeShort(current.id)
			current.serialize(writer)
		})
	}

	public deserialize(reader: BinaryReader): void {
		this.variables = []
		const countVariables = reader.readShort()
		for (let i: number = 0; i < countVariables; i++) {
			const variablesTypeId: number = reader.readShort()
			const type: ServerSessionConstant = new types[
				variablesTypeId
			]() as ServerSessionConstant
			type.deserialize(reader)
			this.variables.push(type)
		}
	}

	public hydrate(
		data: ServerSessionConstantsMessage | Record<string, any>
	): ServerSessionConstantsMessage {
		if (data instanceof ServerSessionConstantsMessage) {
			return data
		}

		this.variables = data.variables.map(
			(
				dataElement: ServerSessionConstant | Record<string, any>
			): ServerSessionConstant => {
				if (dataElement instanceof ServerSessionConstant) {
					return dataElement
				} else {
					return (new types[dataElement.id]() as ServerSessionConstant).hydrate(
						dataElement
					)
				}
			}
		)

		return this
	}
}

export interface RawDungeonPartyFinderAvailableDungeonsMessage {
	id: number
	dungeonIds: number[]
}

export class DungeonPartyFinderAvailableDungeonsMessage extends DofusMessage {
	public static id: number = 5177

	public dungeonIds: number[] | undefined

	public constructor(dungeonIds?: number[] | undefined) {
		super()
		this.dungeonIds = dungeonIds
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeShort(this.dungeonIds!.length)
		this.dungeonIds!.forEach((current: number) => writer.writeVarShort(current))
	}

	public deserialize(reader: BinaryReader): void {
		this.dungeonIds = []
		const countDungeonIds = reader.readShort()
		for (let i: number = 0; i < countDungeonIds; i++) {
			this.dungeonIds.push(reader.readVarShort())
		}
	}

	public hydrate(
		data: DungeonPartyFinderAvailableDungeonsMessage | Record<string, any>
	): DungeonPartyFinderAvailableDungeonsMessage {
		if (data instanceof DungeonPartyFinderAvailableDungeonsMessage) {
			return data
		}

		this.dungeonIds = data.dungeonIds

		return this
	}
}

export interface RawCharacterNameSuggestionSuccessMessage {
	id: number
	suggestion: string
}

export class CharacterNameSuggestionSuccessMessage extends DofusMessage {
	public static id: number = 5866

	public suggestion: string | undefined

	public constructor(suggestion?: string | undefined) {
		super()
		this.suggestion = suggestion
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeUTF(this.suggestion!)
	}

	public deserialize(reader: BinaryReader): void {
		this.suggestion = reader.readUTF()
	}

	public hydrate(
		data: CharacterNameSuggestionSuccessMessage | Record<string, any>
	): CharacterNameSuggestionSuccessMessage {
		if (data instanceof CharacterNameSuggestionSuccessMessage) {
			return data
		}

		this.suggestion = data.suggestion

		return this
	}
}

export interface RawGameMapNoMovementMessage {
	id: number
	cellX: number
	cellY: number
}

export class GameMapNoMovementMessage extends DofusMessage {
	public static id: number = 8603

	public cellX: number | undefined = 0
	public cellY: number | undefined = 0

	public constructor(cellX?: number | undefined, cellY?: number | undefined) {
		super()
		this.cellX = cellX
		this.cellY = cellY
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeShort(this.cellX!)
		writer.writeShort(this.cellY!)
	}

	public deserialize(reader: BinaryReader): void {
		this.cellX = reader.readShort()
		this.cellY = reader.readShort()
	}

	public hydrate(
		data: GameMapNoMovementMessage | Record<string, any>
	): GameMapNoMovementMessage {
		if (data instanceof GameMapNoMovementMessage) {
			return data
		}

		this.cellX = data.cellX
		this.cellY = data.cellY

		return this
	}
}

export interface RawMountEmoteIconUsedOkMessage {
	id: number
	mountId: number
	reactionType: number
}

export class MountEmoteIconUsedOkMessage extends DofusMessage {
	public static id: number = 2786

	public mountId: number | undefined = 0
	public reactionType: number | undefined = 0

	public constructor(
		mountId?: number | undefined,
		reactionType?: number | undefined
	) {
		super()
		this.mountId = mountId
		this.reactionType = reactionType
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarInt(this.mountId!)
		writer.writeByte(this.reactionType!)
	}

	public deserialize(reader: BinaryReader): void {
		this.mountId = reader.readVarInt()
		this.reactionType = reader.readByte()
	}

	public hydrate(
		data: MountEmoteIconUsedOkMessage | Record<string, any>
	): MountEmoteIconUsedOkMessage {
		if (data instanceof MountEmoteIconUsedOkMessage) {
			return data
		}

		this.mountId = data.mountId
		this.reactionType = data.reactionType

		return this
	}
}

export interface RawQuestStartedMessage {
	id: number
	questId: number
}

export class QuestStartedMessage extends DofusMessage {
	public static id: number = 5795

	public questId: number | undefined = 0

	public constructor(questId?: number | undefined) {
		super()
		this.questId = questId
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarShort(this.questId!)
	}

	public deserialize(reader: BinaryReader): void {
		this.questId = reader.readVarShort()
	}

	public hydrate(
		data: QuestStartedMessage | Record<string, any>
	): QuestStartedMessage {
		if (data instanceof QuestStartedMessage) {
			return data
		}

		this.questId = data.questId

		return this
	}
}

export interface RawMountRenamedMessage {
	id: number
	mountId: number
	name: string
}

export class MountRenamedMessage extends DofusMessage {
	public static id: number = 2798

	public mountId: number | undefined = 0
	public name: string | undefined

	public constructor(mountId?: number | undefined, name?: string | undefined) {
		super()
		this.mountId = mountId
		this.name = name
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarInt(this.mountId!)
		writer.writeUTF(this.name!)
	}

	public deserialize(reader: BinaryReader): void {
		this.mountId = reader.readVarInt()
		this.name = reader.readUTF()
	}

	public hydrate(
		data: MountRenamedMessage | Record<string, any>
	): MountRenamedMessage {
		if (data instanceof MountRenamedMessage) {
			return data
		}

		this.mountId = data.mountId
		this.name = data.name

		return this
	}
}

export interface RawExchangeObjectsAddedMessage
	extends RawExchangeObjectMessage {
	id: number
	object_: ObjectItem[]
}

export class ExchangeObjectsAddedMessage extends ExchangeObjectMessage {
	public static id = 697

	public object_: ObjectItem[] | undefined

	public constructor(
		remote?: boolean | undefined,
		object_?: ObjectItem[] | undefined
	) {
		super(remote)
		this.object_ = object_
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeShort(this.object_!.length)
		this.object_!.forEach((current) => {
			current.serialize(writer)
		})
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.object_ = []
		const countObject_ = reader.readShort()
		for (let i: number = 0; i < countObject_; i++) {
			const type: ObjectItem = new ObjectItem()
			type.deserialize(reader)
			this.object_.push(type)
		}
	}

	public hydrate(
		data: ExchangeObjectsAddedMessage | Record<string, any>
	): ExchangeObjectsAddedMessage {
		if (data instanceof ExchangeObjectsAddedMessage) {
			return data
		}

		super.hydrate(data)

		this.object_ = data.object_.map(
			(dataElement: ObjectItem | Record<string, any>): ObjectItem => {
				if (dataElement instanceof ObjectItem) {
					return dataElement
				} else {
					return new ObjectItem().hydrate(dataElement)
				}
			}
		)

		return this
	}
}

export interface RawGuestLimitationMessage {
	id: number
	reason: number
}

export class GuestLimitationMessage extends DofusMessage {
	public static id: number = 5232

	public reason: number | undefined = 0

	public constructor(reason?: number | undefined) {
		super()
		this.reason = reason
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeByte(this.reason!)
	}

	public deserialize(reader: BinaryReader): void {
		this.reason = reader.readByte()
	}

	public hydrate(
		data: GuestLimitationMessage | Record<string, any>
	): GuestLimitationMessage {
		if (data instanceof GuestLimitationMessage) {
			return data
		}

		this.reason = data.reason

		return this
	}
}

export interface RawExchangeObjectsModifiedMessage
	extends RawExchangeObjectMessage {
	id: number
	object_: ObjectItem[]
}

export class ExchangeObjectsModifiedMessage extends ExchangeObjectMessage {
	public static id = 1269

	public object_: ObjectItem[] | undefined

	public constructor(
		remote?: boolean | undefined,
		object_?: ObjectItem[] | undefined
	) {
		super(remote)
		this.object_ = object_
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeShort(this.object_!.length)
		this.object_!.forEach((current) => {
			current.serialize(writer)
		})
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.object_ = []
		const countObject_ = reader.readShort()
		for (let i: number = 0; i < countObject_; i++) {
			const type: ObjectItem = new ObjectItem()
			type.deserialize(reader)
			this.object_.push(type)
		}
	}

	public hydrate(
		data: ExchangeObjectsModifiedMessage | Record<string, any>
	): ExchangeObjectsModifiedMessage {
		if (data instanceof ExchangeObjectsModifiedMessage) {
			return data
		}

		super.hydrate(data)

		this.object_ = data.object_.map(
			(dataElement: ObjectItem | Record<string, any>): ObjectItem => {
				if (dataElement instanceof ObjectItem) {
					return dataElement
				} else {
					return new ObjectItem().hydrate(dataElement)
				}
			}
		)

		return this
	}
}

export interface RawWrapperObjectErrorMessage
	extends RawSymbioticObjectErrorMessage {
	id: number
}

export class WrapperObjectErrorMessage extends SymbioticObjectErrorMessage {
	public static id = 6972

	public constructor(
		reason?: number | undefined,
		errorCode?: number | undefined
	) {
		super(reason, errorCode)
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
	}

	public hydrate(
		data: WrapperObjectErrorMessage | Record<string, any>
	): WrapperObjectErrorMessage {
		if (data instanceof WrapperObjectErrorMessage) {
			return data
		}

		super.hydrate(data)

		return this
	}
}

export interface RawExchangeRequestedMessage {
	id: number
	exchangeType: number
}

export class ExchangeRequestedMessage extends DofusMessage {
	public static id: number = 2157

	public exchangeType: number | undefined = 0

	public constructor(exchangeType?: number | undefined) {
		super()
		this.exchangeType = exchangeType
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeByte(this.exchangeType!)
	}

	public deserialize(reader: BinaryReader): void {
		this.exchangeType = reader.readByte()
	}

	public hydrate(
		data: ExchangeRequestedMessage | Record<string, any>
	): ExchangeRequestedMessage {
		if (data instanceof ExchangeRequestedMessage) {
			return data
		}

		this.exchangeType = data.exchangeType

		return this
	}
}

export interface RawExchangeRequestedTradeMessage
	extends RawExchangeRequestedMessage {
	id: number
	source: number
	target: number
}

export class ExchangeRequestedTradeMessage extends ExchangeRequestedMessage {
	public static id = 4929

	public source: number | undefined = 0
	public target: number | undefined = 0

	public constructor(
		exchangeType?: number | undefined,
		source?: number | undefined,
		target?: number | undefined
	) {
		super(exchangeType)
		this.source = source
		this.target = target
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeVarLong(this.source!)
		writer.writeVarLong(this.target!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.source = reader.readVarLong()
		this.target = reader.readVarLong()
	}

	public hydrate(
		data: ExchangeRequestedTradeMessage | Record<string, any>
	): ExchangeRequestedTradeMessage {
		if (data instanceof ExchangeRequestedTradeMessage) {
			return data
		}

		super.hydrate(data)

		this.source = data.source
		this.target = data.target

		return this
	}
}

export interface RawIdolFightPreparationUpdateMessage {
	id: number
	idolSource: number
	idols: Idol[]
}

export class IdolFightPreparationUpdateMessage extends DofusMessage {
	public static id: number = 4921

	public idolSource: number | undefined = 0
	public idols: Idol[] | undefined

	public constructor(
		idolSource?: number | undefined,
		idols?: Idol[] | undefined
	) {
		super()
		this.idolSource = idolSource
		this.idols = idols
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeByte(this.idolSource!)
		writer.writeShort(this.idols!.length)
		this.idols!.forEach((current) => {
			writer.writeShort(current.id)
			current.serialize(writer)
		})
	}

	public deserialize(reader: BinaryReader): void {
		this.idolSource = reader.readByte()
		this.idols = []
		const countIdols = reader.readShort()
		for (let i: number = 0; i < countIdols; i++) {
			const idolsTypeId: number = reader.readShort()
			const type: Idol = new types[idolsTypeId]() as Idol
			type.deserialize(reader)
			this.idols.push(type)
		}
	}

	public hydrate(
		data: IdolFightPreparationUpdateMessage | Record<string, any>
	): IdolFightPreparationUpdateMessage {
		if (data instanceof IdolFightPreparationUpdateMessage) {
			return data
		}

		this.idolSource = data.idolSource
		this.idols = data.idols.map(
			(dataElement: Idol | Record<string, any>): Idol => {
				if (dataElement instanceof Idol) {
					return dataElement
				} else {
					return (new types[dataElement.id]() as Idol).hydrate(dataElement)
				}
			}
		)

		return this
	}
}

export interface RawShortcutBarAddErrorMessage {
	id: number
	error: number
}

export class ShortcutBarAddErrorMessage extends DofusMessage {
	public static id: number = 6840

	public error: number | undefined = 0

	public constructor(error?: number | undefined) {
		super()
		this.error = error
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeByte(this.error!)
	}

	public deserialize(reader: BinaryReader): void {
		this.error = reader.readByte()
	}

	public hydrate(
		data: ShortcutBarAddErrorMessage | Record<string, any>
	): ShortcutBarAddErrorMessage {
		if (data instanceof ShortcutBarAddErrorMessage) {
			return data
		}

		this.error = data.error

		return this
	}
}

export interface RawIdolSelectedMessage {
	id: number
	activate: boolean
	party: boolean
	idolId: number
}

export class IdolSelectedMessage extends DofusMessage {
	public static id: number = 2458

	public activate: boolean | undefined = false
	public party: boolean | undefined = false
	public idolId: number | undefined = 0

	public constructor(
		activate?: boolean | undefined,
		party?: boolean | undefined,
		idolId?: number | undefined
	) {
		super()
		this.activate = activate
		this.party = party
		this.idolId = idolId
	}

	public serialize(writer: BinaryWriter): void {
		let box0: number = 0
		box0 = setFlag(box0, 0, this.activate!)
		box0 = setFlag(box0, 1, this.party!)
		writer.writeByte(box0)
		writer.writeVarShort(this.idolId!)
	}

	public deserialize(reader: BinaryReader): void {
		const box0 = reader.readByte()
		this.activate = getFlag(box0, 0)
		this.party = getFlag(box0, 1)
		this.idolId = reader.readVarShort()
	}

	public hydrate(
		data: IdolSelectedMessage | Record<string, any>
	): IdolSelectedMessage {
		if (data instanceof IdolSelectedMessage) {
			return data
		}

		this.activate = data.activate
		this.party = data.party
		this.idolId = data.idolId

		return this
	}
}

export interface RawExchangeStartOkHumanVendorMessage {
	id: number
	sellerId: number
	objectsInfos: ObjectItemToSellInHumanVendorShop[]
}

export class ExchangeStartOkHumanVendorMessage extends DofusMessage {
	public static id: number = 5814

	public sellerId: number | undefined = 0
	public objectsInfos: ObjectItemToSellInHumanVendorShop[] | undefined

	public constructor(
		sellerId?: number | undefined,
		objectsInfos?: ObjectItemToSellInHumanVendorShop[] | undefined
	) {
		super()
		this.sellerId = sellerId
		this.objectsInfos = objectsInfos
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeDouble(this.sellerId!)
		writer.writeShort(this.objectsInfos!.length)
		this.objectsInfos!.forEach((current) => {
			current.serialize(writer)
		})
	}

	public deserialize(reader: BinaryReader): void {
		this.sellerId = reader.readDouble()
		this.objectsInfos = []
		const countObjectsInfos = reader.readShort()
		for (let i: number = 0; i < countObjectsInfos; i++) {
			const type: ObjectItemToSellInHumanVendorShop = new ObjectItemToSellInHumanVendorShop()
			type.deserialize(reader)
			this.objectsInfos.push(type)
		}
	}

	public hydrate(
		data: ExchangeStartOkHumanVendorMessage | Record<string, any>
	): ExchangeStartOkHumanVendorMessage {
		if (data instanceof ExchangeStartOkHumanVendorMessage) {
			return data
		}

		this.sellerId = data.sellerId
		this.objectsInfos = data.objectsInfos.map(
			(
				dataElement: ObjectItemToSellInHumanVendorShop | Record<string, any>
			): ObjectItemToSellInHumanVendorShop => {
				if (dataElement instanceof ObjectItemToSellInHumanVendorShop) {
					return dataElement
				} else {
					return new ObjectItemToSellInHumanVendorShop().hydrate(dataElement)
				}
			}
		)

		return this
	}
}

export interface RawFriendDeleteResultMessage {
	id: number
	success: boolean
	name: string
}

export class FriendDeleteResultMessage extends DofusMessage {
	public static id: number = 5776

	public success: boolean | undefined = false
	public name: string | undefined

	public constructor(success?: boolean | undefined, name?: string | undefined) {
		super()
		this.success = success
		this.name = name
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeBoolean(this.success!)
		writer.writeUTF(this.name!)
	}

	public deserialize(reader: BinaryReader): void {
		this.success = reader.readBoolean()
		this.name = reader.readUTF()
	}

	public hydrate(
		data: FriendDeleteResultMessage | Record<string, any>
	): FriendDeleteResultMessage {
		if (data instanceof FriendDeleteResultMessage) {
			return data
		}

		this.success = data.success
		this.name = data.name

		return this
	}
}

export interface RawPresetsMessage {
	id: number
	presets: Preset[]
}

export class PresetsMessage extends DofusMessage {
	public static id: number = 3014

	public presets: Preset[] | undefined

	public constructor(presets?: Preset[] | undefined) {
		super()
		this.presets = presets
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeShort(this.presets!.length)
		this.presets!.forEach((current) => {
			writer.writeShort(current.id)
			current.serialize(writer)
		})
	}

	public deserialize(reader: BinaryReader): void {
		this.presets = []
		const countPresets = reader.readShort()
		for (let i: number = 0; i < countPresets; i++) {
			const presetsTypeId: number = reader.readShort()
			const type: Preset = new types[presetsTypeId]() as Preset
			type.deserialize(reader)
			this.presets.push(type)
		}
	}

	public hydrate(data: PresetsMessage | Record<string, any>): PresetsMessage {
		if (data instanceof PresetsMessage) {
			return data
		}

		this.presets = data.presets.map(
			(dataElement: Preset | Record<string, any>): Preset => {
				if (dataElement instanceof Preset) {
					return dataElement
				} else {
					return (new types[dataElement.id]() as Preset).hydrate(dataElement)
				}
			}
		)

		return this
	}
}

export interface RawObjectsQuantityMessage {
	id: number
	objectsUIDAndQty: ObjectItemQuantity[]
}

export class ObjectsQuantityMessage extends DofusMessage {
	public static id: number = 8051

	public objectsUIDAndQty: ObjectItemQuantity[] | undefined

	public constructor(objectsUIDAndQty?: ObjectItemQuantity[] | undefined) {
		super()
		this.objectsUIDAndQty = objectsUIDAndQty
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeShort(this.objectsUIDAndQty!.length)
		this.objectsUIDAndQty!.forEach((current) => {
			current.serialize(writer)
		})
	}

	public deserialize(reader: BinaryReader): void {
		this.objectsUIDAndQty = []
		const countObjectsUIDAndQty = reader.readShort()
		for (let i: number = 0; i < countObjectsUIDAndQty; i++) {
			const type: ObjectItemQuantity = new ObjectItemQuantity()
			type.deserialize(reader)
			this.objectsUIDAndQty.push(type)
		}
	}

	public hydrate(
		data: ObjectsQuantityMessage | Record<string, any>
	): ObjectsQuantityMessage {
		if (data instanceof ObjectsQuantityMessage) {
			return data
		}

		this.objectsUIDAndQty = data.objectsUIDAndQty.map(
			(
				dataElement: ObjectItemQuantity | Record<string, any>
			): ObjectItemQuantity => {
				if (dataElement instanceof ObjectItemQuantity) {
					return dataElement
				} else {
					return new ObjectItemQuantity().hydrate(dataElement)
				}
			}
		)

		return this
	}
}

export interface RawQuestObjectiveValidatedMessage {
	id: number
	questId: number
	objectiveId: number
}

export class QuestObjectiveValidatedMessage extends DofusMessage {
	public static id: number = 8139

	public questId: number | undefined = 0
	public objectiveId: number | undefined = 0

	public constructor(
		questId?: number | undefined,
		objectiveId?: number | undefined
	) {
		super()
		this.questId = questId
		this.objectiveId = objectiveId
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarShort(this.questId!)
		writer.writeVarShort(this.objectiveId!)
	}

	public deserialize(reader: BinaryReader): void {
		this.questId = reader.readVarShort()
		this.objectiveId = reader.readVarShort()
	}

	public hydrate(
		data: QuestObjectiveValidatedMessage | Record<string, any>
	): QuestObjectiveValidatedMessage {
		if (data instanceof QuestObjectiveValidatedMessage) {
			return data
		}

		this.questId = data.questId
		this.objectiveId = data.objectiveId

		return this
	}
}

export interface RawGameRolePlayAggressionMessage {
	id: number
	attackerId: number
	defenderId: number
}

export class GameRolePlayAggressionMessage extends DofusMessage {
	public static id: number = 5626

	public attackerId: number | undefined = 0
	public defenderId: number | undefined = 0

	public constructor(
		attackerId?: number | undefined,
		defenderId?: number | undefined
	) {
		super()
		this.attackerId = attackerId
		this.defenderId = defenderId
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarLong(this.attackerId!)
		writer.writeVarLong(this.defenderId!)
	}

	public deserialize(reader: BinaryReader): void {
		this.attackerId = reader.readVarLong()
		this.defenderId = reader.readVarLong()
	}

	public hydrate(
		data: GameRolePlayAggressionMessage | Record<string, any>
	): GameRolePlayAggressionMessage {
		if (data instanceof GameRolePlayAggressionMessage) {
			return data
		}

		this.attackerId = data.attackerId
		this.defenderId = data.defenderId

		return this
	}
}

export interface RawGuildInformationsMembersMessage {
	id: number
	members: GuildMember[]
}

export class GuildInformationsMembersMessage extends DofusMessage {
	public static id: number = 7251

	public members: GuildMember[] | undefined

	public constructor(members?: GuildMember[] | undefined) {
		super()
		this.members = members
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeShort(this.members!.length)
		this.members!.forEach((current) => {
			current.serialize(writer)
		})
	}

	public deserialize(reader: BinaryReader): void {
		this.members = []
		const countMembers = reader.readShort()
		for (let i: number = 0; i < countMembers; i++) {
			const type: GuildMember = new GuildMember()
			type.deserialize(reader)
			this.members.push(type)
		}
	}

	public hydrate(
		data: GuildInformationsMembersMessage | Record<string, any>
	): GuildInformationsMembersMessage {
		if (data instanceof GuildInformationsMembersMessage) {
			return data
		}

		this.members = data.members.map(
			(dataElement: GuildMember | Record<string, any>): GuildMember => {
				if (dataElement instanceof GuildMember) {
					return dataElement
				} else {
					return new GuildMember().hydrate(dataElement)
				}
			}
		)

		return this
	}
}

export interface RawSetUpdateMessage {
	id: number
	setId: number
	setObjects: number[]
	setEffects: ObjectEffect[]
}

export class SetUpdateMessage extends DofusMessage {
	public static id: number = 2262

	public setId: number | undefined = 0
	public setObjects: number[] | undefined
	public setEffects: ObjectEffect[] | undefined

	public constructor(
		setId?: number | undefined,
		setObjects?: number[] | undefined,
		setEffects?: ObjectEffect[] | undefined
	) {
		super()
		this.setId = setId
		this.setObjects = setObjects
		this.setEffects = setEffects
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarShort(this.setId!)
		writer.writeShort(this.setObjects!.length)
		this.setObjects!.forEach((current: number) => writer.writeVarInt(current))
		writer.writeShort(this.setEffects!.length)
		this.setEffects!.forEach((current) => {
			writer.writeShort(current.id)
			current.serialize(writer)
		})
	}

	public deserialize(reader: BinaryReader): void {
		this.setId = reader.readVarShort()
		this.setObjects = []
		const countSetObjects = reader.readShort()
		for (let i: number = 0; i < countSetObjects; i++) {
			this.setObjects.push(reader.readVarUInt())
		}
		this.setEffects = []
		const countSetEffects = reader.readShort()
		for (let i: number = 0; i < countSetEffects; i++) {
			const setEffectsTypeId: number = reader.readShort()
			const type: ObjectEffect = new types[setEffectsTypeId]() as ObjectEffect
			type.deserialize(reader)
			this.setEffects.push(type)
		}
	}

	public hydrate(
		data: SetUpdateMessage | Record<string, any>
	): SetUpdateMessage {
		if (data instanceof SetUpdateMessage) {
			return data
		}

		this.setId = data.setId
		this.setObjects = data.setObjects
		this.setEffects = data.setEffects.map(
			(dataElement: ObjectEffect | Record<string, any>): ObjectEffect => {
				if (dataElement instanceof ObjectEffect) {
					return dataElement
				} else {
					return (new types[dataElement.id]() as ObjectEffect).hydrate(
						dataElement
					)
				}
			}
		)

		return this
	}
}

export interface RawExchangeMountsPaddockAddMessage {
	id: number
	mountDescription: MountClientData[]
}

export class ExchangeMountsPaddockAddMessage extends DofusMessage {
	public static id: number = 7611

	public mountDescription: MountClientData[] | undefined

	public constructor(mountDescription?: MountClientData[] | undefined) {
		super()
		this.mountDescription = mountDescription
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeShort(this.mountDescription!.length)
		this.mountDescription!.forEach((current) => {
			current.serialize(writer)
		})
	}

	public deserialize(reader: BinaryReader): void {
		this.mountDescription = []
		const countMountDescription = reader.readShort()
		for (let i: number = 0; i < countMountDescription; i++) {
			const type: MountClientData = new MountClientData()
			type.deserialize(reader)
			this.mountDescription.push(type)
		}
	}

	public hydrate(
		data: ExchangeMountsPaddockAddMessage | Record<string, any>
	): ExchangeMountsPaddockAddMessage {
		if (data instanceof ExchangeMountsPaddockAddMessage) {
			return data
		}

		this.mountDescription = data.mountDescription.map(
			(dataElement: MountClientData | Record<string, any>): MountClientData => {
				if (dataElement instanceof MountClientData) {
					return dataElement
				} else {
					return new MountClientData().hydrate(dataElement)
				}
			}
		)

		return this
	}
}

export interface RawCharacterExperienceGainMessage {
	id: number
	experienceCharacter: number
	experienceMount: number
	experienceGuild: number
	experienceIncarnation: number
}

export class CharacterExperienceGainMessage extends DofusMessage {
	public static id: number = 9486

	public experienceCharacter: number | undefined = 0
	public experienceMount: number | undefined = 0
	public experienceGuild: number | undefined = 0
	public experienceIncarnation: number | undefined = 0

	public constructor(
		experienceCharacter?: number | undefined,
		experienceMount?: number | undefined,
		experienceGuild?: number | undefined,
		experienceIncarnation?: number | undefined
	) {
		super()
		this.experienceCharacter = experienceCharacter
		this.experienceMount = experienceMount
		this.experienceGuild = experienceGuild
		this.experienceIncarnation = experienceIncarnation
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarLong(this.experienceCharacter!)
		writer.writeVarLong(this.experienceMount!)
		writer.writeVarLong(this.experienceGuild!)
		writer.writeVarLong(this.experienceIncarnation!)
	}

	public deserialize(reader: BinaryReader): void {
		this.experienceCharacter = reader.readVarLong()
		this.experienceMount = reader.readVarLong()
		this.experienceGuild = reader.readVarLong()
		this.experienceIncarnation = reader.readVarLong()
	}

	public hydrate(
		data: CharacterExperienceGainMessage | Record<string, any>
	): CharacterExperienceGainMessage {
		if (data instanceof CharacterExperienceGainMessage) {
			return data
		}

		this.experienceCharacter = data.experienceCharacter
		this.experienceMount = data.experienceMount
		this.experienceGuild = data.experienceGuild
		this.experienceIncarnation = data.experienceIncarnation

		return this
	}
}

export interface RawPrismsListMessage {
	id: number
	prisms: PrismSubareaEmptyInfo[]
}

export class PrismsListMessage extends DofusMessage {
	public static id: number = 4815

	public prisms: PrismSubareaEmptyInfo[] | undefined

	public constructor(prisms?: PrismSubareaEmptyInfo[] | undefined) {
		super()
		this.prisms = prisms
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeShort(this.prisms!.length)
		this.prisms!.forEach((current) => {
			writer.writeShort(current.id)
			current.serialize(writer)
		})
	}

	public deserialize(reader: BinaryReader): void {
		this.prisms = []
		const countPrisms = reader.readShort()
		for (let i: number = 0; i < countPrisms; i++) {
			const prismsTypeId: number = reader.readShort()
			const type: PrismSubareaEmptyInfo = new types[
				prismsTypeId
			]() as PrismSubareaEmptyInfo
			type.deserialize(reader)
			this.prisms.push(type)
		}
	}

	public hydrate(
		data: PrismsListMessage | Record<string, any>
	): PrismsListMessage {
		if (data instanceof PrismsListMessage) {
			return data
		}

		this.prisms = data.prisms.map(
			(
				dataElement: PrismSubareaEmptyInfo | Record<string, any>
			): PrismSubareaEmptyInfo => {
				if (dataElement instanceof PrismSubareaEmptyInfo) {
					return dataElement
				} else {
					return (new types[dataElement.id]() as PrismSubareaEmptyInfo).hydrate(
						dataElement
					)
				}
			}
		)

		return this
	}
}

export interface RawPrismsListUpdateMessage extends RawPrismsListMessage {
	id: number
}

export class PrismsListUpdateMessage extends PrismsListMessage {
	public static id = 9870

	public constructor(prisms?: PrismSubareaEmptyInfo[] | undefined) {
		super(prisms)
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
	}

	public hydrate(
		data: PrismsListUpdateMessage | Record<string, any>
	): PrismsListUpdateMessage {
		if (data instanceof PrismsListUpdateMessage) {
			return data
		}

		super.hydrate(data)

		return this
	}
}

export interface RawEntitiesInformationMessage {
	id: number
	entities: EntityInformation[]
}

export class EntitiesInformationMessage extends DofusMessage {
	public static id: number = 9744

	public entities: EntityInformation[] | undefined

	public constructor(entities?: EntityInformation[] | undefined) {
		super()
		this.entities = entities
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeShort(this.entities!.length)
		this.entities!.forEach((current) => {
			current.serialize(writer)
		})
	}

	public deserialize(reader: BinaryReader): void {
		this.entities = []
		const countEntities = reader.readShort()
		for (let i: number = 0; i < countEntities; i++) {
			const type: EntityInformation = new EntityInformation()
			type.deserialize(reader)
			this.entities.push(type)
		}
	}

	public hydrate(
		data: EntitiesInformationMessage | Record<string, any>
	): EntitiesInformationMessage {
		if (data instanceof EntitiesInformationMessage) {
			return data
		}

		this.entities = data.entities.map(
			(
				dataElement: EntityInformation | Record<string, any>
			): EntityInformation => {
				if (dataElement instanceof EntityInformation) {
					return dataElement
				} else {
					return new EntityInformation().hydrate(dataElement)
				}
			}
		)

		return this
	}
}

export interface RawFinishMoveListMessage {
	id: number
	finishMoves: FinishMoveInformations[]
}

export class FinishMoveListMessage extends DofusMessage {
	public static id: number = 4627

	public finishMoves: FinishMoveInformations[] | undefined

	public constructor(finishMoves?: FinishMoveInformations[] | undefined) {
		super()
		this.finishMoves = finishMoves
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeShort(this.finishMoves!.length)
		this.finishMoves!.forEach((current) => {
			current.serialize(writer)
		})
	}

	public deserialize(reader: BinaryReader): void {
		this.finishMoves = []
		const countFinishMoves = reader.readShort()
		for (let i: number = 0; i < countFinishMoves; i++) {
			const type: FinishMoveInformations = new FinishMoveInformations()
			type.deserialize(reader)
			this.finishMoves.push(type)
		}
	}

	public hydrate(
		data: FinishMoveListMessage | Record<string, any>
	): FinishMoveListMessage {
		if (data instanceof FinishMoveListMessage) {
			return data
		}

		this.finishMoves = data.finishMoves.map(
			(
				dataElement: FinishMoveInformations | Record<string, any>
			): FinishMoveInformations => {
				if (dataElement instanceof FinishMoveInformations) {
					return dataElement
				} else {
					return new FinishMoveInformations().hydrate(dataElement)
				}
			}
		)

		return this
	}
}

export interface RawPartyModifiableStatusMessage
	extends RawAbstractPartyMessage {
	id: number
	enabled: boolean
}

export class PartyModifiableStatusMessage extends AbstractPartyMessage {
	public static id = 6887

	public enabled: boolean | undefined = false

	public constructor(
		partyId?: number | undefined,
		enabled?: boolean | undefined
	) {
		super(partyId)
		this.enabled = enabled
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeBoolean(this.enabled!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.enabled = reader.readBoolean()
	}

	public hydrate(
		data: PartyModifiableStatusMessage | Record<string, any>
	): PartyModifiableStatusMessage {
		if (data instanceof PartyModifiableStatusMessage) {
			return data
		}

		super.hydrate(data)

		this.enabled = data.enabled

		return this
	}
}

export interface RawJobExperienceOtherPlayerUpdateMessage
	extends RawJobExperienceUpdateMessage {
	id: number
	playerId: number
}

export class JobExperienceOtherPlayerUpdateMessage extends JobExperienceUpdateMessage {
	public static id = 6469

	public playerId: number | undefined = 0

	public constructor(
		experiencesUpdate?: JobExperience | undefined,
		playerId?: number | undefined
	) {
		super(experiencesUpdate)
		this.playerId = playerId
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeVarLong(this.playerId!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.playerId = reader.readVarLong()
	}

	public hydrate(
		data: JobExperienceOtherPlayerUpdateMessage | Record<string, any>
	): JobExperienceOtherPlayerUpdateMessage {
		if (data instanceof JobExperienceOtherPlayerUpdateMessage) {
			return data
		}

		super.hydrate(data)

		this.playerId = data.playerId

		return this
	}
}

export interface RawGuildModificationStartedMessage {
	id: number
	canChangeName: boolean
	canChangeEmblem: boolean
}

export class GuildModificationStartedMessage extends DofusMessage {
	public static id: number = 8188

	public canChangeName: boolean | undefined = false
	public canChangeEmblem: boolean | undefined = false

	public constructor(
		canChangeName?: boolean | undefined,
		canChangeEmblem?: boolean | undefined
	) {
		super()
		this.canChangeName = canChangeName
		this.canChangeEmblem = canChangeEmblem
	}

	public serialize(writer: BinaryWriter): void {
		let box0: number = 0
		box0 = setFlag(box0, 0, this.canChangeName!)
		box0 = setFlag(box0, 1, this.canChangeEmblem!)
		writer.writeByte(box0)
	}

	public deserialize(reader: BinaryReader): void {
		const box0 = reader.readByte()
		this.canChangeName = getFlag(box0, 0)
		this.canChangeEmblem = getFlag(box0, 1)
	}

	public hydrate(
		data: GuildModificationStartedMessage | Record<string, any>
	): GuildModificationStartedMessage {
		if (data instanceof GuildModificationStartedMessage) {
			return data
		}

		this.canChangeName = data.canChangeName
		this.canChangeEmblem = data.canChangeEmblem

		return this
	}
}

export interface RawPartyRestrictedMessage extends RawAbstractPartyMessage {
	id: number
	restricted: boolean
}

export class PartyRestrictedMessage extends AbstractPartyMessage {
	public static id = 5979

	public restricted: boolean | undefined = false

	public constructor(
		partyId?: number | undefined,
		restricted?: boolean | undefined
	) {
		super(partyId)
		this.restricted = restricted
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeBoolean(this.restricted!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.restricted = reader.readBoolean()
	}

	public hydrate(
		data: PartyRestrictedMessage | Record<string, any>
	): PartyRestrictedMessage {
		if (data instanceof PartyRestrictedMessage) {
			return data
		}

		super.hydrate(data)

		this.restricted = data.restricted

		return this
	}
}

export interface RawNicknameRegistrationMessage {
	id: number
}

export class NicknameRegistrationMessage extends DofusMessage {
	public static id: number = 2411

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public serialize(writer: BinaryWriter): void {}

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public deserialize(reader: BinaryReader): void {}

	public hydrate(
		data: NicknameRegistrationMessage | Record<string, any>
	): NicknameRegistrationMessage {
		if (data instanceof NicknameRegistrationMessage) {
			return data
		}

		return this
	}
}

export interface RawGameContextRemoveElementWithEventMessage
	extends RawGameContextRemoveElementMessage {
	id: number
	elementEventId: number
}

export class GameContextRemoveElementWithEventMessage extends GameContextRemoveElementMessage {
	public static id = 6005

	public elementEventId: number | undefined = 0

	public constructor(
		id_?: number | undefined,
		elementEventId?: number | undefined
	) {
		super(id_)
		this.elementEventId = elementEventId
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeByte(this.elementEventId!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.elementEventId = reader.readByte()
	}

	public hydrate(
		data: GameContextRemoveElementWithEventMessage | Record<string, any>
	): GameContextRemoveElementWithEventMessage {
		if (data instanceof GameContextRemoveElementWithEventMessage) {
			return data
		}

		super.hydrate(data)

		this.elementEventId = data.elementEventId

		return this
	}
}

export interface RawGameRolePlayPlayerFightFriendlyRequestedMessage {
	id: number
	fightId: number
	sourceId: number
	targetId: number
}

export class GameRolePlayPlayerFightFriendlyRequestedMessage extends DofusMessage {
	public static id: number = 8153

	public fightId: number | undefined = 0
	public sourceId: number | undefined = 0
	public targetId: number | undefined = 0

	public constructor(
		fightId?: number | undefined,
		sourceId?: number | undefined,
		targetId?: number | undefined
	) {
		super()
		this.fightId = fightId
		this.sourceId = sourceId
		this.targetId = targetId
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarShort(this.fightId!)
		writer.writeVarLong(this.sourceId!)
		writer.writeVarLong(this.targetId!)
	}

	public deserialize(reader: BinaryReader): void {
		this.fightId = reader.readVarShort()
		this.sourceId = reader.readVarLong()
		this.targetId = reader.readVarLong()
	}

	public hydrate(
		data: GameRolePlayPlayerFightFriendlyRequestedMessage | Record<string, any>
	): GameRolePlayPlayerFightFriendlyRequestedMessage {
		if (data instanceof GameRolePlayPlayerFightFriendlyRequestedMessage) {
			return data
		}

		this.fightId = data.fightId
		this.sourceId = data.sourceId
		this.targetId = data.targetId

		return this
	}
}

export interface RawUpdateMountCharacteristicsMessage {
	id: number
	rideId: number
	boostToUpdateList: UpdateMountCharacteristic[]
}

export class UpdateMountCharacteristicsMessage extends DofusMessage {
	public static id: number = 7079

	public rideId: number | undefined = 0
	public boostToUpdateList: UpdateMountCharacteristic[] | undefined

	public constructor(
		rideId?: number | undefined,
		boostToUpdateList?: UpdateMountCharacteristic[] | undefined
	) {
		super()
		this.rideId = rideId
		this.boostToUpdateList = boostToUpdateList
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarInt(this.rideId!)
		writer.writeShort(this.boostToUpdateList!.length)
		this.boostToUpdateList!.forEach((current) => {
			writer.writeShort(current.id)
			current.serialize(writer)
		})
	}

	public deserialize(reader: BinaryReader): void {
		this.rideId = reader.readVarInt()
		this.boostToUpdateList = []
		const countBoostToUpdateList = reader.readShort()
		for (let i: number = 0; i < countBoostToUpdateList; i++) {
			const boostToUpdateListTypeId: number = reader.readShort()
			const type: UpdateMountCharacteristic = new types[
				boostToUpdateListTypeId
			]() as UpdateMountCharacteristic
			type.deserialize(reader)
			this.boostToUpdateList.push(type)
		}
	}

	public hydrate(
		data: UpdateMountCharacteristicsMessage | Record<string, any>
	): UpdateMountCharacteristicsMessage {
		if (data instanceof UpdateMountCharacteristicsMessage) {
			return data
		}

		this.rideId = data.rideId
		this.boostToUpdateList = data.boostToUpdateList.map(
			(
				dataElement: UpdateMountCharacteristic | Record<string, any>
			): UpdateMountCharacteristic => {
				if (dataElement instanceof UpdateMountCharacteristic) {
					return dataElement
				} else {
					return (new types[
						dataElement.id
					]() as UpdateMountCharacteristic).hydrate(dataElement)
				}
			}
		)

		return this
	}
}

export interface RawShortcutBarRemovedMessage {
	id: number
	barType: number
	slot: number
}

export class ShortcutBarRemovedMessage extends DofusMessage {
	public static id: number = 2604

	public barType: number | undefined = 0
	public slot: number | undefined = 0

	public constructor(barType?: number | undefined, slot?: number | undefined) {
		super()
		this.barType = barType
		this.slot = slot
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeByte(this.barType!)
		writer.writeByte(this.slot!)
	}

	public deserialize(reader: BinaryReader): void {
		this.barType = reader.readByte()
		this.slot = reader.readByte()
	}

	public hydrate(
		data: ShortcutBarRemovedMessage | Record<string, any>
	): ShortcutBarRemovedMessage {
		if (data instanceof ShortcutBarRemovedMessage) {
			return data
		}

		this.barType = data.barType
		this.slot = data.slot

		return this
	}
}

export interface RawExchangeBuyOkMessage {
	id: number
}

export class ExchangeBuyOkMessage extends DofusMessage {
	public static id: number = 35

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public serialize(writer: BinaryWriter): void {}

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public deserialize(reader: BinaryReader): void {}

	public hydrate(
		data: ExchangeBuyOkMessage | Record<string, any>
	): ExchangeBuyOkMessage {
		if (data instanceof ExchangeBuyOkMessage) {
			return data
		}

		return this
	}
}

export interface RawLifePointsRegenEndMessage
	extends RawUpdateLifePointsMessage {
	id: number
	lifePointsGained: number
}

export class LifePointsRegenEndMessage extends UpdateLifePointsMessage {
	public static id = 1338

	public lifePointsGained: number | undefined = 0

	public constructor(
		lifePoints?: number | undefined,
		maxLifePoints?: number | undefined,
		lifePointsGained?: number | undefined
	) {
		super(lifePoints, maxLifePoints)
		this.lifePointsGained = lifePointsGained
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeVarInt(this.lifePointsGained!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.lifePointsGained = reader.readVarInt()
	}

	public hydrate(
		data: LifePointsRegenEndMessage | Record<string, any>
	): LifePointsRegenEndMessage {
		if (data instanceof LifePointsRegenEndMessage) {
			return data
		}

		super.hydrate(data)

		this.lifePointsGained = data.lifePointsGained

		return this
	}
}

export interface RawGameContextCreateMessage {
	id: number
	context: number
}

export class GameContextCreateMessage extends DofusMessage {
	public static id: number = 1030

	public context: number | undefined = 1

	public constructor(context?: number | undefined) {
		super()
		this.context = context
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeByte(this.context!)
	}

	public deserialize(reader: BinaryReader): void {
		this.context = reader.readByte()
	}

	public hydrate(
		data: GameContextCreateMessage | Record<string, any>
	): GameContextCreateMessage {
		if (data instanceof GameContextCreateMessage) {
			return data
		}

		this.context = data.context

		return this
	}
}

export interface RawPlayerStatusUpdateErrorMessage {
	id: number
}

export class PlayerStatusUpdateErrorMessage extends DofusMessage {
	public static id: number = 9276

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public serialize(writer: BinaryWriter): void {}

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public deserialize(reader: BinaryReader): void {}

	public hydrate(
		data: PlayerStatusUpdateErrorMessage | Record<string, any>
	): PlayerStatusUpdateErrorMessage {
		if (data instanceof PlayerStatusUpdateErrorMessage) {
			return data
		}

		return this
	}
}

export interface RawGameFightPlacementSwapPositionsCancelledMessage {
	id: number
	requestId: number
	cancellerId: number
}

export class GameFightPlacementSwapPositionsCancelledMessage extends DofusMessage {
	public static id: number = 5555

	public requestId: number | undefined = 0
	public cancellerId: number | undefined = 0

	public constructor(
		requestId?: number | undefined,
		cancellerId?: number | undefined
	) {
		super()
		this.requestId = requestId
		this.cancellerId = cancellerId
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeInt(this.requestId!)
		writer.writeDouble(this.cancellerId!)
	}

	public deserialize(reader: BinaryReader): void {
		this.requestId = reader.readInt()
		this.cancellerId = reader.readDouble()
	}

	public hydrate(
		data: GameFightPlacementSwapPositionsCancelledMessage | Record<string, any>
	): GameFightPlacementSwapPositionsCancelledMessage {
		if (data instanceof GameFightPlacementSwapPositionsCancelledMessage) {
			return data
		}

		this.requestId = data.requestId
		this.cancellerId = data.cancellerId

		return this
	}
}

export interface RawConsoleCommandsListMessage {
	id: number
	aliases: string[]
	args: string[]
	descriptions: string[]
}

export class ConsoleCommandsListMessage extends DofusMessage {
	public static id: number = 7414

	public aliases: string[] | undefined
	public args: string[] | undefined
	public descriptions: string[] | undefined

	public constructor(
		aliases?: string[] | undefined,
		args?: string[] | undefined,
		descriptions?: string[] | undefined
	) {
		super()
		this.aliases = aliases
		this.args = args
		this.descriptions = descriptions
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeShort(this.aliases!.length)
		this.aliases!.forEach((current: string) => writer.writeUTF(current))
		writer.writeShort(this.args!.length)
		this.args!.forEach((current: string) => writer.writeUTF(current))
		writer.writeShort(this.descriptions!.length)
		this.descriptions!.forEach((current: string) => writer.writeUTF(current))
	}

	public deserialize(reader: BinaryReader): void {
		this.aliases = []
		const countAliases = reader.readShort()
		for (let i: number = 0; i < countAliases; i++) {
			this.aliases.push(reader.readUTF())
		}
		this.args = []
		const countArgs = reader.readShort()
		for (let i: number = 0; i < countArgs; i++) {
			this.args.push(reader.readUTF())
		}
		this.descriptions = []
		const countDescriptions = reader.readShort()
		for (let i: number = 0; i < countDescriptions; i++) {
			this.descriptions.push(reader.readUTF())
		}
	}

	public hydrate(
		data: ConsoleCommandsListMessage | Record<string, any>
	): ConsoleCommandsListMessage {
		if (data instanceof ConsoleCommandsListMessage) {
			return data
		}

		this.aliases = data.aliases
		this.args = data.args
		this.descriptions = data.descriptions

		return this
	}
}

export interface RawStartupActionsListMessage {
	id: number
	actions: StartupActionAddObject[]
}

export class StartupActionsListMessage extends DofusMessage {
	public static id: number = 9417

	public actions: StartupActionAddObject[] | undefined

	public constructor(actions?: StartupActionAddObject[] | undefined) {
		super()
		this.actions = actions
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeShort(this.actions!.length)
		this.actions!.forEach((current) => {
			current.serialize(writer)
		})
	}

	public deserialize(reader: BinaryReader): void {
		this.actions = []
		const countActions = reader.readShort()
		for (let i: number = 0; i < countActions; i++) {
			const type: StartupActionAddObject = new StartupActionAddObject()
			type.deserialize(reader)
			this.actions.push(type)
		}
	}

	public hydrate(
		data: StartupActionsListMessage | Record<string, any>
	): StartupActionsListMessage {
		if (data instanceof StartupActionsListMessage) {
			return data
		}

		this.actions = data.actions.map(
			(
				dataElement: StartupActionAddObject | Record<string, any>
			): StartupActionAddObject => {
				if (dataElement instanceof StartupActionAddObject) {
					return dataElement
				} else {
					return new StartupActionAddObject().hydrate(dataElement)
				}
			}
		)

		return this
	}
}

export interface RawTaxCollectorMovementRemoveMessage {
	id: number
	collectorId: number
}

export class TaxCollectorMovementRemoveMessage extends DofusMessage {
	public static id: number = 9648

	public collectorId: number | undefined = 0

	public constructor(collectorId?: number | undefined) {
		super()
		this.collectorId = collectorId
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeDouble(this.collectorId!)
	}

	public deserialize(reader: BinaryReader): void {
		this.collectorId = reader.readDouble()
	}

	public hydrate(
		data: TaxCollectorMovementRemoveMessage | Record<string, any>
	): TaxCollectorMovementRemoveMessage {
		if (data instanceof TaxCollectorMovementRemoveMessage) {
			return data
		}

		this.collectorId = data.collectorId

		return this
	}
}

export interface RawAreaFightModificatorUpdateMessage {
	id: number
	spellPairId: number
}

export class AreaFightModificatorUpdateMessage extends DofusMessage {
	public static id: number = 4867

	public spellPairId: number | undefined = 0

	public constructor(spellPairId?: number | undefined) {
		super()
		this.spellPairId = spellPairId
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeInt(this.spellPairId!)
	}

	public deserialize(reader: BinaryReader): void {
		this.spellPairId = reader.readInt()
	}

	public hydrate(
		data: AreaFightModificatorUpdateMessage | Record<string, any>
	): AreaFightModificatorUpdateMessage {
		if (data instanceof AreaFightModificatorUpdateMessage) {
			return data
		}

		this.spellPairId = data.spellPairId

		return this
	}
}

export interface RawExchangeBidHouseInListRemovedMessage {
	id: number
	itemUID: number
	objectGID: number
	objectType: number
}

export class ExchangeBidHouseInListRemovedMessage extends DofusMessage {
	public static id: number = 1444

	public itemUID: number | undefined = 0
	public objectGID: number | undefined = 0
	public objectType: number | undefined = 0

	public constructor(
		itemUID?: number | undefined,
		objectGID?: number | undefined,
		objectType?: number | undefined
	) {
		super()
		this.itemUID = itemUID
		this.objectGID = objectGID
		this.objectType = objectType
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeInt(this.itemUID!)
		writer.writeVarShort(this.objectGID!)
		writer.writeInt(this.objectType!)
	}

	public deserialize(reader: BinaryReader): void {
		this.itemUID = reader.readInt()
		this.objectGID = reader.readVarShort()
		this.objectType = reader.readInt()
	}

	public hydrate(
		data: ExchangeBidHouseInListRemovedMessage | Record<string, any>
	): ExchangeBidHouseInListRemovedMessage {
		if (data instanceof ExchangeBidHouseInListRemovedMessage) {
			return data
		}

		this.itemUID = data.itemUID
		this.objectGID = data.objectGID
		this.objectType = data.objectType

		return this
	}
}

export interface RawAllianceBulletinSetErrorMessage
	extends RawSocialNoticeSetErrorMessage {
	id: number
}

export class AllianceBulletinSetErrorMessage extends SocialNoticeSetErrorMessage {
	public static id = 3716

	public constructor(reason?: number | undefined) {
		super(reason)
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
	}

	public hydrate(
		data: AllianceBulletinSetErrorMessage | Record<string, any>
	): AllianceBulletinSetErrorMessage {
		if (data instanceof AllianceBulletinSetErrorMessage) {
			return data
		}

		super.hydrate(data)

		return this
	}
}

export interface RawForgettableSpellDeleteMessage {
	id: number
	reason: number
	spells: number[]
}

export class ForgettableSpellDeleteMessage extends DofusMessage {
	public static id: number = 1920

	public reason: number | undefined = 0
	public spells: number[] | undefined

	public constructor(
		reason?: number | undefined,
		spells?: number[] | undefined
	) {
		super()
		this.reason = reason
		this.spells = spells
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeByte(this.reason!)
		writer.writeShort(this.spells!.length)
		this.spells!.forEach((current: number) => writer.writeInt(current))
	}

	public deserialize(reader: BinaryReader): void {
		this.reason = reader.readByte()
		this.spells = []
		const countSpells = reader.readShort()
		for (let i: number = 0; i < countSpells; i++) {
			this.spells.push(reader.readInt())
		}
	}

	public hydrate(
		data: ForgettableSpellDeleteMessage | Record<string, any>
	): ForgettableSpellDeleteMessage {
		if (data instanceof ForgettableSpellDeleteMessage) {
			return data
		}

		this.reason = data.reason
		this.spells = data.spells

		return this
	}
}

export interface RawDebtsDeleteMessage {
	id: number
	reason: number
	debts: number[]
}

export class DebtsDeleteMessage extends DofusMessage {
	public static id: number = 5410

	public reason: number | undefined = 0
	public debts: number[] | undefined

	public constructor(
		reason?: number | undefined,
		debts?: number[] | undefined
	) {
		super()
		this.reason = reason
		this.debts = debts
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeByte(this.reason!)
		writer.writeShort(this.debts!.length)
		this.debts!.forEach((current: number) => writer.writeDouble(current))
	}

	public deserialize(reader: BinaryReader): void {
		this.reason = reader.readByte()
		this.debts = []
		const countDebts = reader.readShort()
		for (let i: number = 0; i < countDebts; i++) {
			this.debts.push(reader.readDouble())
		}
	}

	public hydrate(
		data: DebtsDeleteMessage | Record<string, any>
	): DebtsDeleteMessage {
		if (data instanceof DebtsDeleteMessage) {
			return data
		}

		this.reason = data.reason
		this.debts = data.debts

		return this
	}
}

export interface RawExchangeCraftResultMagicWithObjectDescMessage
	extends RawExchangeCraftResultWithObjectDescMessage {
	id: number
	magicPoolStatus: number
}

export class ExchangeCraftResultMagicWithObjectDescMessage extends ExchangeCraftResultWithObjectDescMessage {
	public static id = 4882

	public magicPoolStatus: number | undefined = 0

	public constructor(
		craftResult?: number | undefined,
		objectInfo?: ObjectItemNotInContainer | undefined,
		magicPoolStatus?: number | undefined
	) {
		super(craftResult, objectInfo)
		this.magicPoolStatus = magicPoolStatus
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeByte(this.magicPoolStatus!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.magicPoolStatus = reader.readByte()
	}

	public hydrate(
		data: ExchangeCraftResultMagicWithObjectDescMessage | Record<string, any>
	): ExchangeCraftResultMagicWithObjectDescMessage {
		if (data instanceof ExchangeCraftResultMagicWithObjectDescMessage) {
			return data
		}

		super.hydrate(data)

		this.magicPoolStatus = data.magicPoolStatus

		return this
	}
}

export interface RawTitleSelectedMessage {
	id: number
	titleId: number
}

export class TitleSelectedMessage extends DofusMessage {
	public static id: number = 2229

	public titleId: number | undefined = 0

	public constructor(titleId?: number | undefined) {
		super()
		this.titleId = titleId
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarShort(this.titleId!)
	}

	public deserialize(reader: BinaryReader): void {
		this.titleId = reader.readVarShort()
	}

	public hydrate(
		data: TitleSelectedMessage | Record<string, any>
	): TitleSelectedMessage {
		if (data instanceof TitleSelectedMessage) {
			return data
		}

		this.titleId = data.titleId

		return this
	}
}

export interface RawAbstractGameActionWithAckMessage
	extends RawAbstractGameActionMessage {
	id: number
	waitAckId: number
}

export class AbstractGameActionWithAckMessage extends AbstractGameActionMessage {
	public static id = 7030

	public waitAckId: number | undefined = 0

	public constructor(
		actionId?: number | undefined,
		sourceId?: number | undefined,
		waitAckId?: number | undefined
	) {
		super(actionId, sourceId)
		this.waitAckId = waitAckId
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeShort(this.waitAckId!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.waitAckId = reader.readShort()
	}

	public hydrate(
		data: AbstractGameActionWithAckMessage | Record<string, any>
	): AbstractGameActionWithAckMessage {
		if (data instanceof AbstractGameActionWithAckMessage) {
			return data
		}

		super.hydrate(data)

		this.waitAckId = data.waitAckId

		return this
	}
}

export interface RawExchangeBidHouseItemRemoveOkMessage {
	id: number
	sellerId: number
}

export class ExchangeBidHouseItemRemoveOkMessage extends DofusMessage {
	public static id: number = 8459

	public sellerId: number | undefined = 0

	public constructor(sellerId?: number | undefined) {
		super()
		this.sellerId = sellerId
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeInt(this.sellerId!)
	}

	public deserialize(reader: BinaryReader): void {
		this.sellerId = reader.readInt()
	}

	public hydrate(
		data: ExchangeBidHouseItemRemoveOkMessage | Record<string, any>
	): ExchangeBidHouseItemRemoveOkMessage {
		if (data instanceof ExchangeBidHouseItemRemoveOkMessage) {
			return data
		}

		this.sellerId = data.sellerId

		return this
	}
}

export interface RawOrnamentSelectedMessage {
	id: number
	ornamentId: number
}

export class OrnamentSelectedMessage extends DofusMessage {
	public static id: number = 50

	public ornamentId: number | undefined = 0

	public constructor(ornamentId?: number | undefined) {
		super()
		this.ornamentId = ornamentId
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarShort(this.ornamentId!)
	}

	public deserialize(reader: BinaryReader): void {
		this.ornamentId = reader.readVarShort()
	}

	public hydrate(
		data: OrnamentSelectedMessage | Record<string, any>
	): OrnamentSelectedMessage {
		if (data instanceof OrnamentSelectedMessage) {
			return data
		}

		this.ornamentId = data.ornamentId

		return this
	}
}

export interface RawAllianceBulletinMessage extends RawBulletinMessage {
	id: number
}

export class AllianceBulletinMessage extends BulletinMessage {
	public static id = 5460

	public constructor(
		content?: string | undefined,
		timestamp?: number | undefined,
		memberId?: number | undefined,
		memberName?: string | undefined,
		lastNotifiedTimestamp?: number | undefined
	) {
		super(content, timestamp, memberId, memberName, lastNotifiedTimestamp)
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
	}

	public hydrate(
		data: AllianceBulletinMessage | Record<string, any>
	): AllianceBulletinMessage {
		if (data instanceof AllianceBulletinMessage) {
			return data
		}

		super.hydrate(data)

		return this
	}
}

export interface RawObjectAveragePricesErrorMessage {
	id: number
}

export class ObjectAveragePricesErrorMessage extends DofusMessage {
	public static id: number = 4399

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public serialize(writer: BinaryWriter): void {}

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public deserialize(reader: BinaryReader): void {}

	public hydrate(
		data: ObjectAveragePricesErrorMessage | Record<string, any>
	): ObjectAveragePricesErrorMessage {
		if (data instanceof ObjectAveragePricesErrorMessage) {
			return data
		}

		return this
	}
}

export interface RawPresetUseResultWithMissingIdsMessage
	extends RawPresetUseResultMessage {
	id: number
	missingIds: number[]
}

export class PresetUseResultWithMissingIdsMessage extends PresetUseResultMessage {
	public static id = 2959

	public missingIds: number[] | undefined

	public constructor(
		presetId?: number | undefined,
		code?: number | undefined,
		missingIds?: number[] | undefined
	) {
		super(presetId, code)
		this.missingIds = missingIds
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeShort(this.missingIds!.length)
		this.missingIds!.forEach((current: number) => writer.writeVarShort(current))
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.missingIds = []
		const countMissingIds = reader.readShort()
		for (let i: number = 0; i < countMissingIds; i++) {
			this.missingIds.push(reader.readVarShort())
		}
	}

	public hydrate(
		data: PresetUseResultWithMissingIdsMessage | Record<string, any>
	): PresetUseResultWithMissingIdsMessage {
		if (data instanceof PresetUseResultWithMissingIdsMessage) {
			return data
		}

		super.hydrate(data)

		this.missingIds = data.missingIds

		return this
	}
}

export interface RawOrnamentSelectErrorMessage {
	id: number
	reason: number
}

export class OrnamentSelectErrorMessage extends DofusMessage {
	public static id: number = 6085

	public reason: number | undefined = 0

	public constructor(reason?: number | undefined) {
		super()
		this.reason = reason
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeByte(this.reason!)
	}

	public deserialize(reader: BinaryReader): void {
		this.reason = reader.readByte()
	}

	public hydrate(
		data: OrnamentSelectErrorMessage | Record<string, any>
	): OrnamentSelectErrorMessage {
		if (data instanceof OrnamentSelectErrorMessage) {
			return data
		}

		this.reason = data.reason

		return this
	}
}

export interface RawGameContextMoveElementMessage {
	id: number
	movement: EntityMovementInformations
}

export class GameContextMoveElementMessage extends DofusMessage {
	public static id: number = 7867

	public movement: EntityMovementInformations | undefined

	public constructor(movement?: EntityMovementInformations | undefined) {
		super()
		this.movement = movement
	}

	public serialize(writer: BinaryWriter): void {
		this.movement!.serialize(writer)
	}

	public deserialize(reader: BinaryReader): void {
		this.movement = new EntityMovementInformations()
		this.movement!.deserialize(reader)
	}

	public hydrate(
		data: GameContextMoveElementMessage | Record<string, any>
	): GameContextMoveElementMessage {
		if (data instanceof GameContextMoveElementMessage) {
			return data
		}

		this.movement = new EntityMovementInformations().hydrate(data.movement)

		return this
	}
}

export interface RawExchangeTypesItemsExchangerDescriptionForUserMessage {
	id: number
	objectType: number
	itemTypeDescriptions: BidExchangerObjectInfo[]
}

export class ExchangeTypesItemsExchangerDescriptionForUserMessage extends DofusMessage {
	public static id: number = 7377

	public objectType: number | undefined = 0
	public itemTypeDescriptions: BidExchangerObjectInfo[] | undefined

	public constructor(
		objectType?: number | undefined,
		itemTypeDescriptions?: BidExchangerObjectInfo[] | undefined
	) {
		super()
		this.objectType = objectType
		this.itemTypeDescriptions = itemTypeDescriptions
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeInt(this.objectType!)
		writer.writeShort(this.itemTypeDescriptions!.length)
		this.itemTypeDescriptions!.forEach((current) => {
			current.serialize(writer)
		})
	}

	public deserialize(reader: BinaryReader): void {
		this.objectType = reader.readInt()
		this.itemTypeDescriptions = []
		const countItemTypeDescriptions = reader.readShort()
		for (let i: number = 0; i < countItemTypeDescriptions; i++) {
			const type: BidExchangerObjectInfo = new BidExchangerObjectInfo()
			type.deserialize(reader)
			this.itemTypeDescriptions.push(type)
		}
	}

	public hydrate(
		data:
			| ExchangeTypesItemsExchangerDescriptionForUserMessage
			| Record<string, any>
	): ExchangeTypesItemsExchangerDescriptionForUserMessage {
		if (data instanceof ExchangeTypesItemsExchangerDescriptionForUserMessage) {
			return data
		}

		this.objectType = data.objectType
		this.itemTypeDescriptions = data.itemTypeDescriptions.map(
			(
				dataElement: BidExchangerObjectInfo | Record<string, any>
			): BidExchangerObjectInfo => {
				if (dataElement instanceof BidExchangerObjectInfo) {
					return dataElement
				} else {
					return new BidExchangerObjectInfo().hydrate(dataElement)
				}
			}
		)

		return this
	}
}

export interface RawFriendsListMessage {
	id: number
	friendsList: FriendInformations[]
}

export class FriendsListMessage extends DofusMessage {
	public static id: number = 8697

	public friendsList: FriendInformations[] | undefined

	public constructor(friendsList?: FriendInformations[] | undefined) {
		super()
		this.friendsList = friendsList
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeShort(this.friendsList!.length)
		this.friendsList!.forEach((current) => {
			writer.writeShort(current.id)
			current.serialize(writer)
		})
	}

	public deserialize(reader: BinaryReader): void {
		this.friendsList = []
		const countFriendsList = reader.readShort()
		for (let i: number = 0; i < countFriendsList; i++) {
			const friendsListTypeId: number = reader.readShort()
			const type: FriendInformations = new types[
				friendsListTypeId
			]() as FriendInformations
			type.deserialize(reader)
			this.friendsList.push(type)
		}
	}

	public hydrate(
		data: FriendsListMessage | Record<string, any>
	): FriendsListMessage {
		if (data instanceof FriendsListMessage) {
			return data
		}

		this.friendsList = data.friendsList.map(
			(
				dataElement: FriendInformations | Record<string, any>
			): FriendInformations => {
				if (dataElement instanceof FriendInformations) {
					return dataElement
				} else {
					return (new types[dataElement.id]() as FriendInformations).hydrate(
						dataElement
					)
				}
			}
		)

		return this
	}
}

export interface RawPrismInfoCloseMessage {
	id: number
}

export class PrismInfoCloseMessage extends DofusMessage {
	public static id: number = 6760

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public serialize(writer: BinaryWriter): void {}

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public deserialize(reader: BinaryReader): void {}

	public hydrate(
		data: PrismInfoCloseMessage | Record<string, any>
	): PrismInfoCloseMessage {
		if (data instanceof PrismInfoCloseMessage) {
			return data
		}

		return this
	}
}

export interface RawPrismFightDefenderLeaveMessage {
	id: number
	subAreaId: number
	fightId: number
	fighterToRemoveId: number
}

export class PrismFightDefenderLeaveMessage extends DofusMessage {
	public static id: number = 3077

	public subAreaId: number | undefined = 0
	public fightId: number | undefined = 0
	public fighterToRemoveId: number | undefined = 0

	public constructor(
		subAreaId?: number | undefined,
		fightId?: number | undefined,
		fighterToRemoveId?: number | undefined
	) {
		super()
		this.subAreaId = subAreaId
		this.fightId = fightId
		this.fighterToRemoveId = fighterToRemoveId
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarShort(this.subAreaId!)
		writer.writeVarShort(this.fightId!)
		writer.writeVarLong(this.fighterToRemoveId!)
	}

	public deserialize(reader: BinaryReader): void {
		this.subAreaId = reader.readVarShort()
		this.fightId = reader.readVarShort()
		this.fighterToRemoveId = reader.readVarLong()
	}

	public hydrate(
		data: PrismFightDefenderLeaveMessage | Record<string, any>
	): PrismFightDefenderLeaveMessage {
		if (data instanceof PrismFightDefenderLeaveMessage) {
			return data
		}

		this.subAreaId = data.subAreaId
		this.fightId = data.fightId
		this.fighterToRemoveId = data.fighterToRemoveId

		return this
	}
}

export interface RawGameRolePlayPlayerLifeStatusMessage {
	id: number
	state: number
	phenixMapId: number
}

export class GameRolePlayPlayerLifeStatusMessage extends DofusMessage {
	public static id: number = 528

	public state: number | undefined = 0
	public phenixMapId: number | undefined = 0

	public constructor(
		state?: number | undefined,
		phenixMapId?: number | undefined
	) {
		super()
		this.state = state
		this.phenixMapId = phenixMapId
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeByte(this.state!)
		writer.writeDouble(this.phenixMapId!)
	}

	public deserialize(reader: BinaryReader): void {
		this.state = reader.readByte()
		this.phenixMapId = reader.readDouble()
	}

	public hydrate(
		data: GameRolePlayPlayerLifeStatusMessage | Record<string, any>
	): GameRolePlayPlayerLifeStatusMessage {
		if (data instanceof GameRolePlayPlayerLifeStatusMessage) {
			return data
		}

		this.state = data.state
		this.phenixMapId = data.phenixMapId

		return this
	}
}

export interface RawFriendGuildWarnOnAchievementCompleteStateMessage {
	id: number
	enable: boolean
}

export class FriendGuildWarnOnAchievementCompleteStateMessage extends DofusMessage {
	public static id: number = 2035

	public enable: boolean | undefined = false

	public constructor(enable?: boolean | undefined) {
		super()
		this.enable = enable
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeBoolean(this.enable!)
	}

	public deserialize(reader: BinaryReader): void {
		this.enable = reader.readBoolean()
	}

	public hydrate(
		data: FriendGuildWarnOnAchievementCompleteStateMessage | Record<string, any>
	): FriendGuildWarnOnAchievementCompleteStateMessage {
		if (data instanceof FriendGuildWarnOnAchievementCompleteStateMessage) {
			return data
		}

		this.enable = data.enable

		return this
	}
}

export interface RawGameRolePlayArenaInvitationCandidatesAnswer {
	id: number
	candidates: LeagueFriendInformations[]
}

export class GameRolePlayArenaInvitationCandidatesAnswer extends DofusMessage {
	public static id: number = 6871

	public candidates: LeagueFriendInformations[] | undefined

	public constructor(candidates?: LeagueFriendInformations[] | undefined) {
		super()
		this.candidates = candidates
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeShort(this.candidates!.length)
		this.candidates!.forEach((current) => {
			current.serialize(writer)
		})
	}

	public deserialize(reader: BinaryReader): void {
		this.candidates = []
		const countCandidates = reader.readShort()
		for (let i: number = 0; i < countCandidates; i++) {
			const type: LeagueFriendInformations = new LeagueFriendInformations()
			type.deserialize(reader)
			this.candidates.push(type)
		}
	}

	public hydrate(
		data: GameRolePlayArenaInvitationCandidatesAnswer | Record<string, any>
	): GameRolePlayArenaInvitationCandidatesAnswer {
		if (data instanceof GameRolePlayArenaInvitationCandidatesAnswer) {
			return data
		}

		this.candidates = data.candidates.map(
			(
				dataElement: LeagueFriendInformations | Record<string, any>
			): LeagueFriendInformations => {
				if (dataElement instanceof LeagueFriendInformations) {
					return dataElement
				} else {
					return new LeagueFriendInformations().hydrate(dataElement)
				}
			}
		)

		return this
	}
}

export interface RawBreachInvitationCloseMessage {
	id: number
	host: CharacterMinimalInformations
}

export class BreachInvitationCloseMessage extends DofusMessage {
	public static id: number = 8376

	public host: CharacterMinimalInformations | undefined

	public constructor(host?: CharacterMinimalInformations | undefined) {
		super()
		this.host = host
	}

	public serialize(writer: BinaryWriter): void {
		this.host!.serialize(writer)
	}

	public deserialize(reader: BinaryReader): void {
		this.host = new CharacterMinimalInformations()
		this.host!.deserialize(reader)
	}

	public hydrate(
		data: BreachInvitationCloseMessage | Record<string, any>
	): BreachInvitationCloseMessage {
		if (data instanceof BreachInvitationCloseMessage) {
			return data
		}

		this.host = new CharacterMinimalInformations().hydrate(data.host)

		return this
	}
}

export interface RawLockableStateUpdateHouseDoorMessage
	extends RawLockableStateUpdateAbstractMessage {
	id: number
	houseId: number
	instanceId: number
	secondHand: boolean
}

export class LockableStateUpdateHouseDoorMessage extends LockableStateUpdateAbstractMessage {
	public static id = 2112

	public houseId: number | undefined = 0
	public instanceId: number | undefined = 0
	public secondHand: boolean | undefined = false

	public constructor(
		locked?: boolean | undefined,
		houseId?: number | undefined,
		instanceId?: number | undefined,
		secondHand?: boolean | undefined
	) {
		super(locked)
		this.houseId = houseId
		this.instanceId = instanceId
		this.secondHand = secondHand
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeVarInt(this.houseId!)
		writer.writeInt(this.instanceId!)
		writer.writeBoolean(this.secondHand!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.houseId = reader.readVarInt()
		this.instanceId = reader.readInt()
		this.secondHand = reader.readBoolean()
	}

	public hydrate(
		data: LockableStateUpdateHouseDoorMessage | Record<string, any>
	): LockableStateUpdateHouseDoorMessage {
		if (data instanceof LockableStateUpdateHouseDoorMessage) {
			return data
		}

		super.hydrate(data)

		this.houseId = data.houseId
		this.instanceId = data.instanceId
		this.secondHand = data.secondHand

		return this
	}
}

export interface RawPaddockSellBuyDialogMessage {
	id: number
	bsell: boolean
	ownerId: number
	price: number
}

export class PaddockSellBuyDialogMessage extends DofusMessage {
	public static id: number = 8137

	public bsell: boolean | undefined = false
	public ownerId: number | undefined = 0
	public price: number | undefined = 0

	public constructor(
		bsell?: boolean | undefined,
		ownerId?: number | undefined,
		price?: number | undefined
	) {
		super()
		this.bsell = bsell
		this.ownerId = ownerId
		this.price = price
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeBoolean(this.bsell!)
		writer.writeVarInt(this.ownerId!)
		writer.writeVarLong(this.price!)
	}

	public deserialize(reader: BinaryReader): void {
		this.bsell = reader.readBoolean()
		this.ownerId = reader.readVarInt()
		this.price = reader.readVarLong()
	}

	public hydrate(
		data: PaddockSellBuyDialogMessage | Record<string, any>
	): PaddockSellBuyDialogMessage {
		if (data instanceof PaddockSellBuyDialogMessage) {
			return data
		}

		this.bsell = data.bsell
		this.ownerId = data.ownerId
		this.price = data.price

		return this
	}
}

export interface RawExchangeOkMultiCraftMessage {
	id: number
	initiatorId: number
	otherId: number
	role: number
}

export class ExchangeOkMultiCraftMessage extends DofusMessage {
	public static id: number = 5183

	public initiatorId: number | undefined = 0
	public otherId: number | undefined = 0
	public role: number | undefined = 0

	public constructor(
		initiatorId?: number | undefined,
		otherId?: number | undefined,
		role?: number | undefined
	) {
		super()
		this.initiatorId = initiatorId
		this.otherId = otherId
		this.role = role
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarLong(this.initiatorId!)
		writer.writeVarLong(this.otherId!)
		writer.writeByte(this.role!)
	}

	public deserialize(reader: BinaryReader): void {
		this.initiatorId = reader.readVarLong()
		this.otherId = reader.readVarLong()
		this.role = reader.readByte()
	}

	public hydrate(
		data: ExchangeOkMultiCraftMessage | Record<string, any>
	): ExchangeOkMultiCraftMessage {
		if (data instanceof ExchangeOkMultiCraftMessage) {
			return data
		}

		this.initiatorId = data.initiatorId
		this.otherId = data.otherId
		this.role = data.role

		return this
	}
}

export interface RawExchangeWaitingResultMessage {
	id: number
	bwait: boolean
}

export class ExchangeWaitingResultMessage extends DofusMessage {
	public static id: number = 5909

	public bwait: boolean | undefined = false

	public constructor(bwait?: boolean | undefined) {
		super()
		this.bwait = bwait
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeBoolean(this.bwait!)
	}

	public deserialize(reader: BinaryReader): void {
		this.bwait = reader.readBoolean()
	}

	public hydrate(
		data: ExchangeWaitingResultMessage | Record<string, any>
	): ExchangeWaitingResultMessage {
		if (data instanceof ExchangeWaitingResultMessage) {
			return data
		}

		this.bwait = data.bwait

		return this
	}
}

export interface RawAlreadyConnectedMessage {
	id: number
}

export class AlreadyConnectedMessage extends DofusMessage {
	public static id: number = 13

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public serialize(writer: BinaryWriter): void {}

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public deserialize(reader: BinaryReader): void {}

	public hydrate(
		data: AlreadyConnectedMessage | Record<string, any>
	): AlreadyConnectedMessage {
		if (data instanceof AlreadyConnectedMessage) {
			return data
		}

		return this
	}
}

export interface RawNpcDialogQuestionMessage {
	id: number
	messageId: number
	dialogParams: string[]
	visibleReplies: number[]
}

export class NpcDialogQuestionMessage extends DofusMessage {
	public static id: number = 7921

	public messageId: number | undefined = 0
	public dialogParams: string[] | undefined
	public visibleReplies: number[] | undefined

	public constructor(
		messageId?: number | undefined,
		dialogParams?: string[] | undefined,
		visibleReplies?: number[] | undefined
	) {
		super()
		this.messageId = messageId
		this.dialogParams = dialogParams
		this.visibleReplies = visibleReplies
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarInt(this.messageId!)
		writer.writeShort(this.dialogParams!.length)
		this.dialogParams!.forEach((current: string) => writer.writeUTF(current))
		writer.writeShort(this.visibleReplies!.length)
		this.visibleReplies!.forEach((current: number) =>
			writer.writeVarInt(current)
		)
	}

	public deserialize(reader: BinaryReader): void {
		this.messageId = reader.readVarInt()
		this.dialogParams = []
		const countDialogParams = reader.readShort()
		for (let i: number = 0; i < countDialogParams; i++) {
			this.dialogParams.push(reader.readUTF())
		}
		this.visibleReplies = []
		const countVisibleReplies = reader.readShort()
		for (let i: number = 0; i < countVisibleReplies; i++) {
			this.visibleReplies.push(reader.readVarInt())
		}
	}

	public hydrate(
		data: NpcDialogQuestionMessage | Record<string, any>
	): NpcDialogQuestionMessage {
		if (data instanceof NpcDialogQuestionMessage) {
			return data
		}

		this.messageId = data.messageId
		this.dialogParams = data.dialogParams
		this.visibleReplies = data.visibleReplies

		return this
	}
}

export interface RawEmotePlayErrorMessage {
	id: number
	emoteId: number
}

export class EmotePlayErrorMessage extends DofusMessage {
	public static id: number = 790

	public emoteId: number | undefined = 0

	public constructor(emoteId?: number | undefined) {
		super()
		this.emoteId = emoteId
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeByte(this.emoteId!)
	}

	public deserialize(reader: BinaryReader): void {
		this.emoteId = reader.readByte()
	}

	public hydrate(
		data: EmotePlayErrorMessage | Record<string, any>
	): EmotePlayErrorMessage {
		if (data instanceof EmotePlayErrorMessage) {
			return data
		}

		this.emoteId = data.emoteId

		return this
	}
}

export interface RawGameRolePlayDelayedActionFinishedMessage {
	id: number
	delayedCharacterId: number
	delayTypeId: number
}

export class GameRolePlayDelayedActionFinishedMessage extends DofusMessage {
	public static id: number = 2289

	public delayedCharacterId: number | undefined = 0
	public delayTypeId: number | undefined = 0

	public constructor(
		delayedCharacterId?: number | undefined,
		delayTypeId?: number | undefined
	) {
		super()
		this.delayedCharacterId = delayedCharacterId
		this.delayTypeId = delayTypeId
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeDouble(this.delayedCharacterId!)
		writer.writeByte(this.delayTypeId!)
	}

	public deserialize(reader: BinaryReader): void {
		this.delayedCharacterId = reader.readDouble()
		this.delayTypeId = reader.readByte()
	}

	public hydrate(
		data: GameRolePlayDelayedActionFinishedMessage | Record<string, any>
	): GameRolePlayDelayedActionFinishedMessage {
		if (data instanceof GameRolePlayDelayedActionFinishedMessage) {
			return data
		}

		this.delayedCharacterId = data.delayedCharacterId
		this.delayTypeId = data.delayTypeId

		return this
	}
}

export interface RawContactAddFailureMessage {
	id: number
	reason: number
}

export class ContactAddFailureMessage extends DofusMessage {
	public static id: number = 3991

	public reason: number | undefined = 0

	public constructor(reason?: number | undefined) {
		super()
		this.reason = reason
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeByte(this.reason!)
	}

	public deserialize(reader: BinaryReader): void {
		this.reason = reader.readByte()
	}

	public hydrate(
		data: ContactAddFailureMessage | Record<string, any>
	): ContactAddFailureMessage {
		if (data instanceof ContactAddFailureMessage) {
			return data
		}

		this.reason = data.reason

		return this
	}
}

export interface RawCharacterAlignmentWarEffortProgressionMessage {
	id: number
	alignmentWarEffortDailyLimit: number
	alignmentWarEffortDailyDonation: number
	alignmentWarEffortPersonalDonation: number
}

export class CharacterAlignmentWarEffortProgressionMessage extends DofusMessage {
	public static id: number = 4989

	public alignmentWarEffortDailyLimit: number | undefined = 0
	public alignmentWarEffortDailyDonation: number | undefined = 0
	public alignmentWarEffortPersonalDonation: number | undefined = 0

	public constructor(
		alignmentWarEffortDailyLimit?: number | undefined,
		alignmentWarEffortDailyDonation?: number | undefined,
		alignmentWarEffortPersonalDonation?: number | undefined
	) {
		super()
		this.alignmentWarEffortDailyLimit = alignmentWarEffortDailyLimit
		this.alignmentWarEffortDailyDonation = alignmentWarEffortDailyDonation
		this.alignmentWarEffortPersonalDonation = alignmentWarEffortPersonalDonation
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarLong(this.alignmentWarEffortDailyLimit!)
		writer.writeVarLong(this.alignmentWarEffortDailyDonation!)
		writer.writeVarLong(this.alignmentWarEffortPersonalDonation!)
	}

	public deserialize(reader: BinaryReader): void {
		this.alignmentWarEffortDailyLimit = reader.readVarLong()
		this.alignmentWarEffortDailyDonation = reader.readVarLong()
		this.alignmentWarEffortPersonalDonation = reader.readVarLong()
	}

	public hydrate(
		data: CharacterAlignmentWarEffortProgressionMessage | Record<string, any>
	): CharacterAlignmentWarEffortProgressionMessage {
		if (data instanceof CharacterAlignmentWarEffortProgressionMessage) {
			return data
		}

		this.alignmentWarEffortDailyLimit = data.alignmentWarEffortDailyLimit
		this.alignmentWarEffortDailyDonation = data.alignmentWarEffortDailyDonation
		this.alignmentWarEffortPersonalDonation =
			data.alignmentWarEffortPersonalDonation

		return this
	}
}

export interface RawAtlasPointInformationsMessage {
	id: number
	type: AtlasPointsInformations
}

export class AtlasPointInformationsMessage extends DofusMessage {
	public static id: number = 2529

	public type: AtlasPointsInformations | undefined

	public constructor(type?: AtlasPointsInformations | undefined) {
		super()
		this.type = type
	}

	public serialize(writer: BinaryWriter): void {
		this.type!.serialize(writer)
	}

	public deserialize(reader: BinaryReader): void {
		this.type = new AtlasPointsInformations()
		this.type!.deserialize(reader)
	}

	public hydrate(
		data: AtlasPointInformationsMessage | Record<string, any>
	): AtlasPointInformationsMessage {
		if (data instanceof AtlasPointInformationsMessage) {
			return data
		}

		this.type = new AtlasPointsInformations().hydrate(data.type)

		return this
	}
}

export interface RawGuestModeMessage {
	id: number
	active: boolean
}

export class GuestModeMessage extends DofusMessage {
	public static id: number = 6071

	public active: boolean | undefined = false

	public constructor(active?: boolean | undefined) {
		super()
		this.active = active
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeBoolean(this.active!)
	}

	public deserialize(reader: BinaryReader): void {
		this.active = reader.readBoolean()
	}

	public hydrate(
		data: GuestModeMessage | Record<string, any>
	): GuestModeMessage {
		if (data instanceof GuestModeMessage) {
			return data
		}

		this.active = data.active

		return this
	}
}

export interface RawObjectMovementMessage {
	id: number
	objectUID: number
	position: number
}

export class ObjectMovementMessage extends DofusMessage {
	public static id: number = 8402

	public objectUID: number | undefined = 0
	public position: number | undefined = 63

	public constructor(
		objectUID?: number | undefined,
		position?: number | undefined
	) {
		super()
		this.objectUID = objectUID
		this.position = position
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarInt(this.objectUID!)
		writer.writeShort(this.position!)
	}

	public deserialize(reader: BinaryReader): void {
		this.objectUID = reader.readVarInt()
		this.position = reader.readShort()
	}

	public hydrate(
		data: ObjectMovementMessage | Record<string, any>
	): ObjectMovementMessage {
		if (data instanceof ObjectMovementMessage) {
			return data
		}

		this.objectUID = data.objectUID
		this.position = data.position

		return this
	}
}

export interface RawLockableCodeResultMessage {
	id: number
	result: number
}

export class LockableCodeResultMessage extends DofusMessage {
	public static id: number = 7160

	public result: number | undefined = 0

	public constructor(result?: number | undefined) {
		super()
		this.result = result
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeByte(this.result!)
	}

	public deserialize(reader: BinaryReader): void {
		this.result = reader.readByte()
	}

	public hydrate(
		data: LockableCodeResultMessage | Record<string, any>
	): LockableCodeResultMessage {
		if (data instanceof LockableCodeResultMessage) {
			return data
		}

		this.result = data.result

		return this
	}
}

export interface RawExchangeMountStableErrorMessage {
	id: number
}

export class ExchangeMountStableErrorMessage extends DofusMessage {
	public static id: number = 2208

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public serialize(writer: BinaryWriter): void {}

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public deserialize(reader: BinaryReader): void {}

	public hydrate(
		data: ExchangeMountStableErrorMessage | Record<string, any>
	): ExchangeMountStableErrorMessage {
		if (data instanceof ExchangeMountStableErrorMessage) {
			return data
		}

		return this
	}
}

export interface RawGuildFightPlayersEnemyRemoveMessage {
	id: number
	fightId: number
	playerId: number
}

export class GuildFightPlayersEnemyRemoveMessage extends DofusMessage {
	public static id: number = 9096

	public fightId: number | undefined = 0
	public playerId: number | undefined = 0

	public constructor(
		fightId?: number | undefined,
		playerId?: number | undefined
	) {
		super()
		this.fightId = fightId
		this.playerId = playerId
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeDouble(this.fightId!)
		writer.writeVarLong(this.playerId!)
	}

	public deserialize(reader: BinaryReader): void {
		this.fightId = reader.readDouble()
		this.playerId = reader.readVarLong()
	}

	public hydrate(
		data: GuildFightPlayersEnemyRemoveMessage | Record<string, any>
	): GuildFightPlayersEnemyRemoveMessage {
		if (data instanceof GuildFightPlayersEnemyRemoveMessage) {
			return data
		}

		this.fightId = data.fightId
		this.playerId = data.playerId

		return this
	}
}

export interface RawBreachStateMessage {
	id: number
	owner: CharacterMinimalInformations
	bonuses: ObjectEffectInteger[]
	bugdet: number
	saved: boolean
}

export class BreachStateMessage extends DofusMessage {
	public static id: number = 1220

	public owner: CharacterMinimalInformations | undefined
	public bonuses: ObjectEffectInteger[] | undefined
	public bugdet: number | undefined = 0
	public saved: boolean | undefined = false

	public constructor(
		owner?: CharacterMinimalInformations | undefined,
		bonuses?: ObjectEffectInteger[] | undefined,
		bugdet?: number | undefined,
		saved?: boolean | undefined
	) {
		super()
		this.owner = owner
		this.bonuses = bonuses
		this.bugdet = bugdet
		this.saved = saved
	}

	public serialize(writer: BinaryWriter): void {
		this.owner!.serialize(writer)
		writer.writeShort(this.bonuses!.length)
		this.bonuses!.forEach((current) => {
			current.serialize(writer)
		})
		writer.writeVarInt(this.bugdet!)
		writer.writeBoolean(this.saved!)
	}

	public deserialize(reader: BinaryReader): void {
		this.owner = new CharacterMinimalInformations()
		this.owner!.deserialize(reader)
		this.bonuses = []
		const countBonuses = reader.readShort()
		for (let i: number = 0; i < countBonuses; i++) {
			const type: ObjectEffectInteger = new ObjectEffectInteger()
			type.deserialize(reader)
			this.bonuses.push(type)
		}
		this.bugdet = reader.readVarInt()
		this.saved = reader.readBoolean()
	}

	public hydrate(
		data: BreachStateMessage | Record<string, any>
	): BreachStateMessage {
		if (data instanceof BreachStateMessage) {
			return data
		}

		this.owner = new CharacterMinimalInformations().hydrate(data.owner)
		this.bonuses = data.bonuses.map(
			(
				dataElement: ObjectEffectInteger | Record<string, any>
			): ObjectEffectInteger => {
				if (dataElement instanceof ObjectEffectInteger) {
					return dataElement
				} else {
					return new ObjectEffectInteger().hydrate(dataElement)
				}
			}
		)
		this.bugdet = data.bugdet
		this.saved = data.saved

		return this
	}
}

export interface RawGuildInformationsGeneralMessage {
	id: number
	abandonnedPaddock: boolean
	level: number
	expLevelFloor: number
	experience: number
	expNextLevelFloor: number
	creationDate: number
	nbTotalMembers: number
	nbConnectedMembers: number
}

export class GuildInformationsGeneralMessage extends DofusMessage {
	public static id: number = 4532

	public abandonnedPaddock: boolean | undefined = false
	public level: number | undefined = 0
	public expLevelFloor: number | undefined = 0
	public experience: number | undefined = 0
	public expNextLevelFloor: number | undefined = 0
	public creationDate: number | undefined = 0
	public nbTotalMembers: number | undefined = 0
	public nbConnectedMembers: number | undefined = 0

	public constructor(
		abandonnedPaddock?: boolean | undefined,
		level?: number | undefined,
		expLevelFloor?: number | undefined,
		experience?: number | undefined,
		expNextLevelFloor?: number | undefined,
		creationDate?: number | undefined,
		nbTotalMembers?: number | undefined,
		nbConnectedMembers?: number | undefined
	) {
		super()
		this.abandonnedPaddock = abandonnedPaddock
		this.level = level
		this.expLevelFloor = expLevelFloor
		this.experience = experience
		this.expNextLevelFloor = expNextLevelFloor
		this.creationDate = creationDate
		this.nbTotalMembers = nbTotalMembers
		this.nbConnectedMembers = nbConnectedMembers
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeBoolean(this.abandonnedPaddock!)
		writer.writeByte(this.level!)
		writer.writeVarLong(this.expLevelFloor!)
		writer.writeVarLong(this.experience!)
		writer.writeVarLong(this.expNextLevelFloor!)
		writer.writeInt(this.creationDate!)
		writer.writeVarShort(this.nbTotalMembers!)
		writer.writeVarShort(this.nbConnectedMembers!)
	}

	public deserialize(reader: BinaryReader): void {
		this.abandonnedPaddock = reader.readBoolean()
		this.level = reader.readByte()
		this.expLevelFloor = reader.readVarLong()
		this.experience = reader.readVarLong()
		this.expNextLevelFloor = reader.readVarLong()
		this.creationDate = reader.readInt()
		this.nbTotalMembers = reader.readVarShort()
		this.nbConnectedMembers = reader.readVarShort()
	}

	public hydrate(
		data: GuildInformationsGeneralMessage | Record<string, any>
	): GuildInformationsGeneralMessage {
		if (data instanceof GuildInformationsGeneralMessage) {
			return data
		}

		this.abandonnedPaddock = data.abandonnedPaddock
		this.level = data.level
		this.expLevelFloor = data.expLevelFloor
		this.experience = data.experience
		this.expNextLevelFloor = data.expNextLevelFloor
		this.creationDate = data.creationDate
		this.nbTotalMembers = data.nbTotalMembers
		this.nbConnectedMembers = data.nbConnectedMembers

		return this
	}
}

export interface RawTeleportToBuddyCloseMessage {
	id: number
	dungeonId: number
	buddyId: number
}

export class TeleportToBuddyCloseMessage extends DofusMessage {
	public static id: number = 2919

	public dungeonId: number | undefined = 0
	public buddyId: number | undefined = 0

	public constructor(
		dungeonId?: number | undefined,
		buddyId?: number | undefined
	) {
		super()
		this.dungeonId = dungeonId
		this.buddyId = buddyId
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarShort(this.dungeonId!)
		writer.writeVarLong(this.buddyId!)
	}

	public deserialize(reader: BinaryReader): void {
		this.dungeonId = reader.readVarShort()
		this.buddyId = reader.readVarLong()
	}

	public hydrate(
		data: TeleportToBuddyCloseMessage | Record<string, any>
	): TeleportToBuddyCloseMessage {
		if (data instanceof TeleportToBuddyCloseMessage) {
			return data
		}

		this.dungeonId = data.dungeonId
		this.buddyId = data.buddyId

		return this
	}
}

export interface RawBreachBonusMessage {
	id: number
	bonus: ObjectEffectInteger
}

export class BreachBonusMessage extends DofusMessage {
	public static id: number = 3478

	public bonus: ObjectEffectInteger | undefined

	public constructor(bonus?: ObjectEffectInteger | undefined) {
		super()
		this.bonus = bonus
	}

	public serialize(writer: BinaryWriter): void {
		this.bonus!.serialize(writer)
	}

	public deserialize(reader: BinaryReader): void {
		this.bonus = new ObjectEffectInteger()
		this.bonus!.deserialize(reader)
	}

	public hydrate(
		data: BreachBonusMessage | Record<string, any>
	): BreachBonusMessage {
		if (data instanceof BreachBonusMessage) {
			return data
		}

		this.bonus = new ObjectEffectInteger().hydrate(data.bonus)

		return this
	}
}

export interface RawExchangeStartOkMulticraftCrafterMessage {
	id: number
	skillId: number
}

export class ExchangeStartOkMulticraftCrafterMessage extends DofusMessage {
	public static id: number = 6701

	public skillId: number | undefined = 0

	public constructor(skillId?: number | undefined) {
		super()
		this.skillId = skillId
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarInt(this.skillId!)
	}

	public deserialize(reader: BinaryReader): void {
		this.skillId = reader.readVarInt()
	}

	public hydrate(
		data: ExchangeStartOkMulticraftCrafterMessage | Record<string, any>
	): ExchangeStartOkMulticraftCrafterMessage {
		if (data instanceof ExchangeStartOkMulticraftCrafterMessage) {
			return data
		}

		this.skillId = data.skillId

		return this
	}
}

export interface RawExchangeShopStockStartedMessage {
	id: number
	objectsInfos: ObjectItemToSell[]
}

export class ExchangeShopStockStartedMessage extends DofusMessage {
	public static id: number = 9089

	public objectsInfos: ObjectItemToSell[] | undefined

	public constructor(objectsInfos?: ObjectItemToSell[] | undefined) {
		super()
		this.objectsInfos = objectsInfos
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeShort(this.objectsInfos!.length)
		this.objectsInfos!.forEach((current) => {
			current.serialize(writer)
		})
	}

	public deserialize(reader: BinaryReader): void {
		this.objectsInfos = []
		const countObjectsInfos = reader.readShort()
		for (let i: number = 0; i < countObjectsInfos; i++) {
			const type: ObjectItemToSell = new ObjectItemToSell()
			type.deserialize(reader)
			this.objectsInfos.push(type)
		}
	}

	public hydrate(
		data: ExchangeShopStockStartedMessage | Record<string, any>
	): ExchangeShopStockStartedMessage {
		if (data instanceof ExchangeShopStockStartedMessage) {
			return data
		}

		this.objectsInfos = data.objectsInfos.map(
			(
				dataElement: ObjectItemToSell | Record<string, any>
			): ObjectItemToSell => {
				if (dataElement instanceof ObjectItemToSell) {
					return dataElement
				} else {
					return new ObjectItemToSell().hydrate(dataElement)
				}
			}
		)

		return this
	}
}

export interface RawBasicTimeMessage {
	id: number
	timestamp: number
	timezoneOffset: number
}

export class BasicTimeMessage extends DofusMessage {
	public static id: number = 6808

	public timestamp: number | undefined = 0
	public timezoneOffset: number | undefined = 0

	public constructor(
		timestamp?: number | undefined,
		timezoneOffset?: number | undefined
	) {
		super()
		this.timestamp = timestamp
		this.timezoneOffset = timezoneOffset
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeDouble(this.timestamp!)
		writer.writeShort(this.timezoneOffset!)
	}

	public deserialize(reader: BinaryReader): void {
		this.timestamp = reader.readDouble()
		this.timezoneOffset = reader.readShort()
	}

	public hydrate(
		data: BasicTimeMessage | Record<string, any>
	): BasicTimeMessage {
		if (data instanceof BasicTimeMessage) {
			return data
		}

		this.timestamp = data.timestamp
		this.timezoneOffset = data.timezoneOffset

		return this
	}
}

export interface RawZaapDestinationsMessage
	extends RawTeleportDestinationsMessage {
	id: number
	spawnMapId: number
}

export class ZaapDestinationsMessage extends TeleportDestinationsMessage {
	public static id = 5427

	public spawnMapId: number | undefined = 0

	public constructor(
		type?: number | undefined,
		destinations?: TeleportDestination[] | undefined,
		spawnMapId?: number | undefined
	) {
		super(type, destinations)
		this.spawnMapId = spawnMapId
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeDouble(this.spawnMapId!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.spawnMapId = reader.readDouble()
	}

	public hydrate(
		data: ZaapDestinationsMessage | Record<string, any>
	): ZaapDestinationsMessage {
		if (data instanceof ZaapDestinationsMessage) {
			return data
		}

		super.hydrate(data)

		this.spawnMapId = data.spawnMapId

		return this
	}
}

export interface RawGuildInfosUpgradeMessage {
	id: number
	maxTaxCollectorsCount: number
	taxCollectorsCount: number
	taxCollectorLifePoints: number
	taxCollectorDamagesBonuses: number
	taxCollectorPods: number
	taxCollectorProspecting: number
	taxCollectorWisdom: number
	boostPoints: number
	spellId: number[]
	spellLevel: number[]
}

export class GuildInfosUpgradeMessage extends DofusMessage {
	public static id: number = 2425

	public maxTaxCollectorsCount: number | undefined = 0
	public taxCollectorsCount: number | undefined = 0
	public taxCollectorLifePoints: number | undefined = 0
	public taxCollectorDamagesBonuses: number | undefined = 0
	public taxCollectorPods: number | undefined = 0
	public taxCollectorProspecting: number | undefined = 0
	public taxCollectorWisdom: number | undefined = 0
	public boostPoints: number | undefined = 0
	public spellId: number[] | undefined
	public spellLevel: number[] | undefined

	public constructor(
		maxTaxCollectorsCount?: number | undefined,
		taxCollectorsCount?: number | undefined,
		taxCollectorLifePoints?: number | undefined,
		taxCollectorDamagesBonuses?: number | undefined,
		taxCollectorPods?: number | undefined,
		taxCollectorProspecting?: number | undefined,
		taxCollectorWisdom?: number | undefined,
		boostPoints?: number | undefined,
		spellId?: number[] | undefined,
		spellLevel?: number[] | undefined
	) {
		super()
		this.maxTaxCollectorsCount = maxTaxCollectorsCount
		this.taxCollectorsCount = taxCollectorsCount
		this.taxCollectorLifePoints = taxCollectorLifePoints
		this.taxCollectorDamagesBonuses = taxCollectorDamagesBonuses
		this.taxCollectorPods = taxCollectorPods
		this.taxCollectorProspecting = taxCollectorProspecting
		this.taxCollectorWisdom = taxCollectorWisdom
		this.boostPoints = boostPoints
		this.spellId = spellId
		this.spellLevel = spellLevel
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeByte(this.maxTaxCollectorsCount!)
		writer.writeByte(this.taxCollectorsCount!)
		writer.writeVarShort(this.taxCollectorLifePoints!)
		writer.writeVarShort(this.taxCollectorDamagesBonuses!)
		writer.writeVarShort(this.taxCollectorPods!)
		writer.writeVarShort(this.taxCollectorProspecting!)
		writer.writeVarShort(this.taxCollectorWisdom!)
		writer.writeVarShort(this.boostPoints!)
		writer.writeShort(this.spellId!.length)
		this.spellId!.forEach((current: number) => writer.writeVarShort(current))
		writer.writeShort(this.spellLevel!.length)
		this.spellLevel!.forEach((current: number) => writer.writeShort(current))
	}

	public deserialize(reader: BinaryReader): void {
		this.maxTaxCollectorsCount = reader.readByte()
		this.taxCollectorsCount = reader.readByte()
		this.taxCollectorLifePoints = reader.readVarShort()
		this.taxCollectorDamagesBonuses = reader.readVarShort()
		this.taxCollectorPods = reader.readVarShort()
		this.taxCollectorProspecting = reader.readVarShort()
		this.taxCollectorWisdom = reader.readVarShort()
		this.boostPoints = reader.readVarShort()
		this.spellId = []
		const countSpellId = reader.readShort()
		for (let i: number = 0; i < countSpellId; i++) {
			this.spellId.push(reader.readVarShort())
		}
		this.spellLevel = []
		const countSpellLevel = reader.readShort()
		for (let i: number = 0; i < countSpellLevel; i++) {
			this.spellLevel.push(reader.readShort())
		}
	}

	public hydrate(
		data: GuildInfosUpgradeMessage | Record<string, any>
	): GuildInfosUpgradeMessage {
		if (data instanceof GuildInfosUpgradeMessage) {
			return data
		}

		this.maxTaxCollectorsCount = data.maxTaxCollectorsCount
		this.taxCollectorsCount = data.taxCollectorsCount
		this.taxCollectorLifePoints = data.taxCollectorLifePoints
		this.taxCollectorDamagesBonuses = data.taxCollectorDamagesBonuses
		this.taxCollectorPods = data.taxCollectorPods
		this.taxCollectorProspecting = data.taxCollectorProspecting
		this.taxCollectorWisdom = data.taxCollectorWisdom
		this.boostPoints = data.boostPoints
		this.spellId = data.spellId
		this.spellLevel = data.spellLevel

		return this
	}
}

export interface RawExchangeBidHouseItemAddOkMessage {
	id: number
	itemInfo: ObjectItemToSellInBid
}

export class ExchangeBidHouseItemAddOkMessage extends DofusMessage {
	public static id: number = 806

	public itemInfo: ObjectItemToSellInBid | undefined

	public constructor(itemInfo?: ObjectItemToSellInBid | undefined) {
		super()
		this.itemInfo = itemInfo
	}

	public serialize(writer: BinaryWriter): void {
		this.itemInfo!.serialize(writer)
	}

	public deserialize(reader: BinaryReader): void {
		this.itemInfo = new ObjectItemToSellInBid()
		this.itemInfo!.deserialize(reader)
	}

	public hydrate(
		data: ExchangeBidHouseItemAddOkMessage | Record<string, any>
	): ExchangeBidHouseItemAddOkMessage {
		if (data instanceof ExchangeBidHouseItemAddOkMessage) {
			return data
		}

		this.itemInfo = new ObjectItemToSellInBid().hydrate(data.itemInfo)

		return this
	}
}

export interface RawGameRolePlayArenaRegistrationStatusMessage {
	id: number
	registered: boolean
	step: number
	battleMode: number
}

export class GameRolePlayArenaRegistrationStatusMessage extends DofusMessage {
	public static id: number = 9995

	public registered: boolean | undefined = false
	public step: number | undefined = 0
	public battleMode: number | undefined = 3

	public constructor(
		registered?: boolean | undefined,
		step?: number | undefined,
		battleMode?: number | undefined
	) {
		super()
		this.registered = registered
		this.step = step
		this.battleMode = battleMode
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeBoolean(this.registered!)
		writer.writeByte(this.step!)
		writer.writeInt(this.battleMode!)
	}

	public deserialize(reader: BinaryReader): void {
		this.registered = reader.readBoolean()
		this.step = reader.readByte()
		this.battleMode = reader.readInt()
	}

	public hydrate(
		data: GameRolePlayArenaRegistrationStatusMessage | Record<string, any>
	): GameRolePlayArenaRegistrationStatusMessage {
		if (data instanceof GameRolePlayArenaRegistrationStatusMessage) {
			return data
		}

		this.registered = data.registered
		this.step = data.step
		this.battleMode = data.battleMode

		return this
	}
}

export interface RawPartyEntityUpdateLightMessage
	extends RawPartyUpdateLightMessage {
	id: number
	indexId: number
}

export class PartyEntityUpdateLightMessage extends PartyUpdateLightMessage {
	public static id = 3389

	public indexId: number | undefined = 0

	public constructor(
		partyId?: number | undefined,
		id_?: number | undefined,
		lifePoints?: number | undefined,
		maxLifePoints?: number | undefined,
		prospecting?: number | undefined,
		regenRate?: number | undefined,
		indexId?: number | undefined
	) {
		super(partyId, id_, lifePoints, maxLifePoints, prospecting, regenRate)
		this.indexId = indexId
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeByte(this.indexId!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.indexId = reader.readByte()
	}

	public hydrate(
		data: PartyEntityUpdateLightMessage | Record<string, any>
	): PartyEntityUpdateLightMessage {
		if (data instanceof PartyEntityUpdateLightMessage) {
			return data
		}

		super.hydrate(data)

		this.indexId = data.indexId

		return this
	}
}

export interface RawGameContextMoveMultipleElementsMessage {
	id: number
	movements: EntityMovementInformations[]
}

export class GameContextMoveMultipleElementsMessage extends DofusMessage {
	public static id: number = 721

	public movements: EntityMovementInformations[] | undefined

	public constructor(movements?: EntityMovementInformations[] | undefined) {
		super()
		this.movements = movements
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeShort(this.movements!.length)
		this.movements!.forEach((current) => {
			current.serialize(writer)
		})
	}

	public deserialize(reader: BinaryReader): void {
		this.movements = []
		const countMovements = reader.readShort()
		for (let i: number = 0; i < countMovements; i++) {
			const type: EntityMovementInformations = new EntityMovementInformations()
			type.deserialize(reader)
			this.movements.push(type)
		}
	}

	public hydrate(
		data: GameContextMoveMultipleElementsMessage | Record<string, any>
	): GameContextMoveMultipleElementsMessage {
		if (data instanceof GameContextMoveMultipleElementsMessage) {
			return data
		}

		this.movements = data.movements.map(
			(
				dataElement: EntityMovementInformations | Record<string, any>
			): EntityMovementInformations => {
				if (dataElement instanceof EntityMovementInformations) {
					return dataElement
				} else {
					return new EntityMovementInformations().hydrate(dataElement)
				}
			}
		)

		return this
	}
}

export interface RawPartyFollowStatusUpdateMessage
	extends RawAbstractPartyMessage {
	id: number
	success: boolean
	isFollowed: boolean
	followedId: number
}

export class PartyFollowStatusUpdateMessage extends AbstractPartyMessage {
	public static id = 8395

	public success: boolean | undefined = false
	public isFollowed: boolean | undefined = false
	public followedId: number | undefined = 0

	public constructor(
		partyId?: number | undefined,
		success?: boolean | undefined,
		isFollowed?: boolean | undefined,
		followedId?: number | undefined
	) {
		super(partyId)
		this.success = success
		this.isFollowed = isFollowed
		this.followedId = followedId
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		let box0: number = 0
		box0 = setFlag(box0, 0, this.success!)
		box0 = setFlag(box0, 1, this.isFollowed!)
		writer.writeByte(box0)
		writer.writeVarLong(this.followedId!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		const box0 = reader.readByte()
		this.success = getFlag(box0, 0)
		this.isFollowed = getFlag(box0, 1)
		this.followedId = reader.readVarLong()
	}

	public hydrate(
		data: PartyFollowStatusUpdateMessage | Record<string, any>
	): PartyFollowStatusUpdateMessage {
		if (data instanceof PartyFollowStatusUpdateMessage) {
			return data
		}

		super.hydrate(data)

		this.success = data.success
		this.isFollowed = data.isFollowed
		this.followedId = data.followedId

		return this
	}
}

export interface RawPrismFightAddedMessage {
	id: number
	fight: PrismFightersInformation
}

export class PrismFightAddedMessage extends DofusMessage {
	public static id: number = 5640

	public fight: PrismFightersInformation | undefined

	public constructor(fight?: PrismFightersInformation | undefined) {
		super()
		this.fight = fight
	}

	public serialize(writer: BinaryWriter): void {
		this.fight!.serialize(writer)
	}

	public deserialize(reader: BinaryReader): void {
		this.fight = new PrismFightersInformation()
		this.fight!.deserialize(reader)
	}

	public hydrate(
		data: PrismFightAddedMessage | Record<string, any>
	): PrismFightAddedMessage {
		if (data instanceof PrismFightAddedMessage) {
			return data
		}

		this.fight = new PrismFightersInformation().hydrate(data.fight)

		return this
	}
}

export interface RawItemForPresetUpdateMessage {
	id: number
	presetId: number
	presetItem: ItemForPreset
}

export class ItemForPresetUpdateMessage extends DofusMessage {
	public static id: number = 6150

	public presetId: number | undefined = 0
	public presetItem: ItemForPreset | undefined

	public constructor(
		presetId?: number | undefined,
		presetItem?: ItemForPreset | undefined
	) {
		super()
		this.presetId = presetId
		this.presetItem = presetItem
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeShort(this.presetId!)
		this.presetItem!.serialize(writer)
	}

	public deserialize(reader: BinaryReader): void {
		this.presetId = reader.readShort()
		this.presetItem = new ItemForPreset()
		this.presetItem!.deserialize(reader)
	}

	public hydrate(
		data: ItemForPresetUpdateMessage | Record<string, any>
	): ItemForPresetUpdateMessage {
		if (data instanceof ItemForPresetUpdateMessage) {
			return data
		}

		this.presetId = data.presetId
		this.presetItem = new ItemForPreset().hydrate(data.presetItem)

		return this
	}
}

export interface RawSetCharacterRestrictionsMessage {
	id: number
	actorId: number
	restrictions: ActorRestrictionsInformations
}

export class SetCharacterRestrictionsMessage extends DofusMessage {
	public static id: number = 8111

	public actorId: number | undefined = 0
	public restrictions: ActorRestrictionsInformations | undefined

	public constructor(
		actorId?: number | undefined,
		restrictions?: ActorRestrictionsInformations | undefined
	) {
		super()
		this.actorId = actorId
		this.restrictions = restrictions
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeDouble(this.actorId!)
		this.restrictions!.serialize(writer)
	}

	public deserialize(reader: BinaryReader): void {
		this.actorId = reader.readDouble()
		this.restrictions = new ActorRestrictionsInformations()
		this.restrictions!.deserialize(reader)
	}

	public hydrate(
		data: SetCharacterRestrictionsMessage | Record<string, any>
	): SetCharacterRestrictionsMessage {
		if (data instanceof SetCharacterRestrictionsMessage) {
			return data
		}

		this.actorId = data.actorId
		this.restrictions = new ActorRestrictionsInformations().hydrate(
			data.restrictions
		)

		return this
	}
}

export interface RawPartyKickedByMessage extends RawAbstractPartyMessage {
	id: number
	kickerId: number
}

export class PartyKickedByMessage extends AbstractPartyMessage {
	public static id = 9472

	public kickerId: number | undefined = 0

	public constructor(
		partyId?: number | undefined,
		kickerId?: number | undefined
	) {
		super(partyId)
		this.kickerId = kickerId
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeVarLong(this.kickerId!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.kickerId = reader.readVarLong()
	}

	public hydrate(
		data: PartyKickedByMessage | Record<string, any>
	): PartyKickedByMessage {
		if (data instanceof PartyKickedByMessage) {
			return data
		}

		super.hydrate(data)

		this.kickerId = data.kickerId

		return this
	}
}

export interface RawQuestStepStartedMessage {
	id: number
	questId: number
	stepId: number
}

export class QuestStepStartedMessage extends DofusMessage {
	public static id: number = 2692

	public questId: number | undefined = 0
	public stepId: number | undefined = 0

	public constructor(
		questId?: number | undefined,
		stepId?: number | undefined
	) {
		super()
		this.questId = questId
		this.stepId = stepId
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarShort(this.questId!)
		writer.writeVarShort(this.stepId!)
	}

	public deserialize(reader: BinaryReader): void {
		this.questId = reader.readVarShort()
		this.stepId = reader.readVarShort()
	}

	public hydrate(
		data: QuestStepStartedMessage | Record<string, any>
	): QuestStepStartedMessage {
		if (data instanceof QuestStepStartedMessage) {
			return data
		}

		this.questId = data.questId
		this.stepId = data.stepId

		return this
	}
}

export interface RawAllianceMembershipMessage extends RawAllianceJoinedMessage {
	id: number
}

export class AllianceMembershipMessage extends AllianceJoinedMessage {
	public static id = 1682

	public constructor(
		allianceInfo?: AllianceInformations | undefined,
		enabled?: boolean | undefined,
		leadingGuildId?: number | undefined
	) {
		super(allianceInfo, enabled, leadingGuildId)
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
	}

	public hydrate(
		data: AllianceMembershipMessage | Record<string, any>
	): AllianceMembershipMessage {
		if (data instanceof AllianceMembershipMessage) {
			return data
		}

		super.hydrate(data)

		return this
	}
}

export interface RawInviteInHavenBagClosedMessage {
	id: number
	hostInformations: CharacterMinimalInformations
}

export class InviteInHavenBagClosedMessage extends DofusMessage {
	public static id: number = 5649

	public hostInformations: CharacterMinimalInformations | undefined

	public constructor(
		hostInformations?: CharacterMinimalInformations | undefined
	) {
		super()
		this.hostInformations = hostInformations
	}

	public serialize(writer: BinaryWriter): void {
		this.hostInformations!.serialize(writer)
	}

	public deserialize(reader: BinaryReader): void {
		this.hostInformations = new CharacterMinimalInformations()
		this.hostInformations!.deserialize(reader)
	}

	public hydrate(
		data: InviteInHavenBagClosedMessage | Record<string, any>
	): InviteInHavenBagClosedMessage {
		if (data instanceof InviteInHavenBagClosedMessage) {
			return data
		}

		this.hostInformations = new CharacterMinimalInformations().hydrate(
			data.hostInformations
		)

		return this
	}
}

export interface RawExchangeBidHouseGenericItemAddedMessage {
	id: number
	objGenericId: number
}

export class ExchangeBidHouseGenericItemAddedMessage extends DofusMessage {
	public static id: number = 9722

	public objGenericId: number | undefined = 0

	public constructor(objGenericId?: number | undefined) {
		super()
		this.objGenericId = objGenericId
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarShort(this.objGenericId!)
	}

	public deserialize(reader: BinaryReader): void {
		this.objGenericId = reader.readVarShort()
	}

	public hydrate(
		data: ExchangeBidHouseGenericItemAddedMessage | Record<string, any>
	): ExchangeBidHouseGenericItemAddedMessage {
		if (data instanceof ExchangeBidHouseGenericItemAddedMessage) {
			return data
		}

		this.objGenericId = data.objGenericId

		return this
	}
}

export interface RawAlignmentRankUpdateMessage {
	id: number
	alignmentRank: number
	verbose: boolean
}

export class AlignmentRankUpdateMessage extends DofusMessage {
	public static id: number = 2029

	public alignmentRank: number | undefined = 0
	public verbose: boolean | undefined = false

	public constructor(
		alignmentRank?: number | undefined,
		verbose?: boolean | undefined
	) {
		super()
		this.alignmentRank = alignmentRank
		this.verbose = verbose
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeByte(this.alignmentRank!)
		writer.writeBoolean(this.verbose!)
	}

	public deserialize(reader: BinaryReader): void {
		this.alignmentRank = reader.readByte()
		this.verbose = reader.readBoolean()
	}

	public hydrate(
		data: AlignmentRankUpdateMessage | Record<string, any>
	): AlignmentRankUpdateMessage {
		if (data instanceof AlignmentRankUpdateMessage) {
			return data
		}

		this.alignmentRank = data.alignmentRank
		this.verbose = data.verbose

		return this
	}
}

export interface RawAccessoryPreviewErrorMessage {
	id: number
	error: number
}

export class AccessoryPreviewErrorMessage extends DofusMessage {
	public static id: number = 8715

	public error: number | undefined = 0

	public constructor(error?: number | undefined) {
		super()
		this.error = error
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeByte(this.error!)
	}

	public deserialize(reader: BinaryReader): void {
		this.error = reader.readByte()
	}

	public hydrate(
		data: AccessoryPreviewErrorMessage | Record<string, any>
	): AccessoryPreviewErrorMessage {
		if (data instanceof AccessoryPreviewErrorMessage) {
			return data
		}

		this.error = data.error

		return this
	}
}

export interface RawCharacterSelectedForceMessage {
	id: number
	id_: number
}

export class CharacterSelectedForceMessage extends DofusMessage {
	public static id: number = 2068

	public id_: number | undefined = 0

	public constructor(id_?: number | undefined) {
		super()
		this.id_ = id_
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeInt(this.id_!)
	}

	public deserialize(reader: BinaryReader): void {
		this.id_ = reader.readInt()
	}

	public hydrate(
		data: CharacterSelectedForceMessage | Record<string, any>
	): CharacterSelectedForceMessage {
		if (data instanceof CharacterSelectedForceMessage) {
			return data
		}

		this.id_ = data.id_

		return this
	}
}

export interface RawGuildFactsRequestMessage {
	id: number
	guildId: number
}

export class GuildFactsRequestMessage extends DofusMessage {
	public static id: number = 3153

	public guildId: number | undefined = 0

	public constructor(guildId?: number | undefined) {
		super()
		this.guildId = guildId
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarInt(this.guildId!)
	}

	public deserialize(reader: BinaryReader): void {
		this.guildId = reader.readVarInt()
	}

	public hydrate(
		data: GuildFactsRequestMessage | Record<string, any>
	): GuildFactsRequestMessage {
		if (data instanceof GuildFactsRequestMessage) {
			return data
		}

		this.guildId = data.guildId

		return this
	}
}

export interface RawClientKeyMessage {
	id: number
	key: string
}

export class ClientKeyMessage extends DofusMessage {
	public static id: number = 5072

	public key: string | undefined

	public constructor(key?: string | undefined) {
		super()
		this.key = key
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeUTF(this.key!)
	}

	public deserialize(reader: BinaryReader): void {
		this.key = reader.readUTF()
	}

	public hydrate(
		data: ClientKeyMessage | Record<string, any>
	): ClientKeyMessage {
		if (data instanceof ClientKeyMessage) {
			return data
		}

		this.key = data.key

		return this
	}
}

export interface RawNicknameChoiceRequestMessage {
	id: number
	nickname: string
}

export class NicknameChoiceRequestMessage extends DofusMessage {
	public static id: number = 4355

	public nickname: string | undefined

	public constructor(nickname?: string | undefined) {
		super()
		this.nickname = nickname
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeUTF(this.nickname!)
	}

	public deserialize(reader: BinaryReader): void {
		this.nickname = reader.readUTF()
	}

	public hydrate(
		data: NicknameChoiceRequestMessage | Record<string, any>
	): NicknameChoiceRequestMessage {
		if (data instanceof NicknameChoiceRequestMessage) {
			return data
		}

		this.nickname = data.nickname

		return this
	}
}

export interface RawAllianceFactsRequestMessage {
	id: number
	allianceId: number
}

export class AllianceFactsRequestMessage extends DofusMessage {
	public static id: number = 4229

	public allianceId: number | undefined = 0

	public constructor(allianceId?: number | undefined) {
		super()
		this.allianceId = allianceId
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarInt(this.allianceId!)
	}

	public deserialize(reader: BinaryReader): void {
		this.allianceId = reader.readVarInt()
	}

	public hydrate(
		data: AllianceFactsRequestMessage | Record<string, any>
	): AllianceFactsRequestMessage {
		if (data instanceof AllianceFactsRequestMessage) {
			return data
		}

		this.allianceId = data.allianceId

		return this
	}
}

export interface RawTeleportHavenBagRequestMessage {
	id: number
	guestId: number
}

export class TeleportHavenBagRequestMessage extends DofusMessage {
	public static id: number = 5508

	public guestId: number | undefined = 0

	public constructor(guestId?: number | undefined) {
		super()
		this.guestId = guestId
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarLong(this.guestId!)
	}

	public deserialize(reader: BinaryReader): void {
		this.guestId = reader.readVarLong()
	}

	public hydrate(
		data: TeleportHavenBagRequestMessage | Record<string, any>
	): TeleportHavenBagRequestMessage {
		if (data instanceof TeleportHavenBagRequestMessage) {
			return data
		}

		this.guestId = data.guestId

		return this
	}
}

export interface RawGameMapChangeOrientationRequestMessage {
	id: number
	direction: number
}

export class GameMapChangeOrientationRequestMessage extends DofusMessage {
	public static id: number = 5569

	public direction: number | undefined = 1

	public constructor(direction?: number | undefined) {
		super()
		this.direction = direction
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeByte(this.direction!)
	}

	public deserialize(reader: BinaryReader): void {
		this.direction = reader.readByte()
	}

	public hydrate(
		data: GameMapChangeOrientationRequestMessage | Record<string, any>
	): GameMapChangeOrientationRequestMessage {
		if (data instanceof GameMapChangeOrientationRequestMessage) {
			return data
		}

		this.direction = data.direction

		return this
	}
}

export interface RawExchangeRequestOnTaxCollectorMessage {
	id: number
}

export class ExchangeRequestOnTaxCollectorMessage extends DofusMessage {
	public static id: number = 69

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public serialize(writer: BinaryWriter): void {}

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public deserialize(reader: BinaryReader): void {}

	public hydrate(
		data: ExchangeRequestOnTaxCollectorMessage | Record<string, any>
	): ExchangeRequestOnTaxCollectorMessage {
		if (data instanceof ExchangeRequestOnTaxCollectorMessage) {
			return data
		}

		return this
	}
}

export interface RawExchangeOnHumanVendorRequestMessage {
	id: number
	humanVendorId: number
	humanVendorCell: number
}

export class ExchangeOnHumanVendorRequestMessage extends DofusMessage {
	public static id: number = 5687

	public humanVendorId: number | undefined = 0
	public humanVendorCell: number | undefined = 0

	public constructor(
		humanVendorId?: number | undefined,
		humanVendorCell?: number | undefined
	) {
		super()
		this.humanVendorId = humanVendorId
		this.humanVendorCell = humanVendorCell
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarLong(this.humanVendorId!)
		writer.writeVarShort(this.humanVendorCell!)
	}

	public deserialize(reader: BinaryReader): void {
		this.humanVendorId = reader.readVarLong()
		this.humanVendorCell = reader.readVarShort()
	}

	public hydrate(
		data: ExchangeOnHumanVendorRequestMessage | Record<string, any>
	): ExchangeOnHumanVendorRequestMessage {
		if (data instanceof ExchangeOnHumanVendorRequestMessage) {
			return data
		}

		this.humanVendorId = data.humanVendorId
		this.humanVendorCell = data.humanVendorCell

		return this
	}
}

export interface RawExchangeBuyMessage {
	id: number
	objectToBuyId: number
	quantity: number
}

export class ExchangeBuyMessage extends DofusMessage {
	public static id: number = 8531

	public objectToBuyId: number | undefined = 0
	public quantity: number | undefined = 0

	public constructor(
		objectToBuyId?: number | undefined,
		quantity?: number | undefined
	) {
		super()
		this.objectToBuyId = objectToBuyId
		this.quantity = quantity
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarInt(this.objectToBuyId!)
		writer.writeVarInt(this.quantity!)
	}

	public deserialize(reader: BinaryReader): void {
		this.objectToBuyId = reader.readVarInt()
		this.quantity = reader.readVarInt()
	}

	public hydrate(
		data: ExchangeBuyMessage | Record<string, any>
	): ExchangeBuyMessage {
		if (data instanceof ExchangeBuyMessage) {
			return data
		}

		this.objectToBuyId = data.objectToBuyId
		this.quantity = data.quantity

		return this
	}
}

export interface RawEnterHavenBagRequestMessage {
	id: number
	havenBagOwner: number
}

export class EnterHavenBagRequestMessage extends DofusMessage {
	public static id: number = 6025

	public havenBagOwner: number | undefined = 0

	public constructor(havenBagOwner?: number | undefined) {
		super()
		this.havenBagOwner = havenBagOwner
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarLong(this.havenBagOwner!)
	}

	public deserialize(reader: BinaryReader): void {
		this.havenBagOwner = reader.readVarLong()
	}

	public hydrate(
		data: EnterHavenBagRequestMessage | Record<string, any>
	): EnterHavenBagRequestMessage {
		if (data instanceof EnterHavenBagRequestMessage) {
			return data
		}

		this.havenBagOwner = data.havenBagOwner

		return this
	}
}

export interface RawErrorMapNotFoundMessage {
	id: number
	mapId: number
}

export class ErrorMapNotFoundMessage extends DofusMessage {
	public static id: number = 6086

	public mapId: number | undefined = 0

	public constructor(mapId?: number | undefined) {
		super()
		this.mapId = mapId
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeDouble(this.mapId!)
	}

	public deserialize(reader: BinaryReader): void {
		this.mapId = reader.readDouble()
	}

	public hydrate(
		data: ErrorMapNotFoundMessage | Record<string, any>
	): ErrorMapNotFoundMessage {
		if (data instanceof ErrorMapNotFoundMessage) {
			return data
		}

		this.mapId = data.mapId

		return this
	}
}

export interface RawExchangeRequestMessage {
	id: number
	exchangeType: number
}

export class ExchangeRequestMessage extends DofusMessage {
	public static id: number = 2334

	public exchangeType: number | undefined = 0

	public constructor(exchangeType?: number | undefined) {
		super()
		this.exchangeType = exchangeType
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeByte(this.exchangeType!)
	}

	public deserialize(reader: BinaryReader): void {
		this.exchangeType = reader.readByte()
	}

	public hydrate(
		data: ExchangeRequestMessage | Record<string, any>
	): ExchangeRequestMessage {
		if (data instanceof ExchangeRequestMessage) {
			return data
		}

		this.exchangeType = data.exchangeType

		return this
	}
}

export interface RawExchangePlayerRequestMessage
	extends RawExchangeRequestMessage {
	id: number
	target: number
}

export class ExchangePlayerRequestMessage extends ExchangeRequestMessage {
	public static id = 4040

	public target: number | undefined = 0

	public constructor(
		exchangeType?: number | undefined,
		target?: number | undefined
	) {
		super(exchangeType)
		this.target = target
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeVarLong(this.target!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.target = reader.readVarLong()
	}

	public hydrate(
		data: ExchangePlayerRequestMessage | Record<string, any>
	): ExchangePlayerRequestMessage {
		if (data instanceof ExchangePlayerRequestMessage) {
			return data
		}

		super.hydrate(data)

		this.target = data.target

		return this
	}
}

export interface RawGameRolePlayPlayerFightRequestMessage {
	id: number
	targetId: number
	targetCellId: number
	friendly: boolean
}

export class GameRolePlayPlayerFightRequestMessage extends DofusMessage {
	public static id: number = 8087

	public targetId: number | undefined = 0
	public targetCellId: number | undefined = 0
	public friendly: boolean | undefined = false

	public constructor(
		targetId?: number | undefined,
		targetCellId?: number | undefined,
		friendly?: boolean | undefined
	) {
		super()
		this.targetId = targetId
		this.targetCellId = targetCellId
		this.friendly = friendly
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarLong(this.targetId!)
		writer.writeShort(this.targetCellId!)
		writer.writeBoolean(this.friendly!)
	}

	public deserialize(reader: BinaryReader): void {
		this.targetId = reader.readVarLong()
		this.targetCellId = reader.readShort()
		this.friendly = reader.readBoolean()
	}

	public hydrate(
		data: GameRolePlayPlayerFightRequestMessage | Record<string, any>
	): GameRolePlayPlayerFightRequestMessage {
		if (data instanceof GameRolePlayPlayerFightRequestMessage) {
			return data
		}

		this.targetId = data.targetId
		this.targetCellId = data.targetCellId
		this.friendly = data.friendly

		return this
	}
}

export interface RawExchangePlayerMultiCraftRequestMessage
	extends RawExchangeRequestMessage {
	id: number
	target: number
	skillId: number
}

export class ExchangePlayerMultiCraftRequestMessage extends ExchangeRequestMessage {
	public static id = 8527

	public target: number | undefined = 0
	public skillId: number | undefined = 0

	public constructor(
		exchangeType?: number | undefined,
		target?: number | undefined,
		skillId?: number | undefined
	) {
		super(exchangeType)
		this.target = target
		this.skillId = skillId
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeVarLong(this.target!)
		writer.writeVarInt(this.skillId!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.target = reader.readVarLong()
		this.skillId = reader.readVarInt()
	}

	public hydrate(
		data: ExchangePlayerMultiCraftRequestMessage | Record<string, any>
	): ExchangePlayerMultiCraftRequestMessage {
		if (data instanceof ExchangePlayerMultiCraftRequestMessage) {
			return data
		}

		super.hydrate(data)

		this.target = data.target
		this.skillId = data.skillId

		return this
	}
}

export interface RawExchangeObjectMoveMessage {
	id: number
	objectUID: number
	quantity: number
}

export class ExchangeObjectMoveMessage extends DofusMessage {
	public static id: number = 1070

	public objectUID: number | undefined = 0
	public quantity: number | undefined = 0

	public constructor(
		objectUID?: number | undefined,
		quantity?: number | undefined
	) {
		super()
		this.objectUID = objectUID
		this.quantity = quantity
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarInt(this.objectUID!)
		writer.writeVarInt(this.quantity!)
	}

	public deserialize(reader: BinaryReader): void {
		this.objectUID = reader.readVarInt()
		this.quantity = reader.readVarInt()
	}

	public hydrate(
		data: ExchangeObjectMoveMessage | Record<string, any>
	): ExchangeObjectMoveMessage {
		if (data instanceof ExchangeObjectMoveMessage) {
			return data
		}

		this.objectUID = data.objectUID
		this.quantity = data.quantity

		return this
	}
}

export interface RawExchangeObjectMovePricedMessage
	extends RawExchangeObjectMoveMessage {
	id: number
	price: number
}

export class ExchangeObjectMovePricedMessage extends ExchangeObjectMoveMessage {
	public static id = 3567

	public price: number | undefined = 0

	public constructor(
		objectUID?: number | undefined,
		quantity?: number | undefined,
		price?: number | undefined
	) {
		super(objectUID, quantity)
		this.price = price
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeVarLong(this.price!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.price = reader.readVarLong()
	}

	public hydrate(
		data: ExchangeObjectMovePricedMessage | Record<string, any>
	): ExchangeObjectMovePricedMessage {
		if (data instanceof ExchangeObjectMovePricedMessage) {
			return data
		}

		super.hydrate(data)

		this.price = data.price

		return this
	}
}

export interface RawExchangeStartAsVendorMessage {
	id: number
}

export class ExchangeStartAsVendorMessage extends DofusMessage {
	public static id: number = 3439

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public serialize(writer: BinaryWriter): void {}

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public deserialize(reader: BinaryReader): void {}

	public hydrate(
		data: ExchangeStartAsVendorMessage | Record<string, any>
	): ExchangeStartAsVendorMessage {
		if (data instanceof ExchangeStartAsVendorMessage) {
			return data
		}

		return this
	}
}

export interface RawPortalUseRequestMessage {
	id: number
	portalId: number
}

export class PortalUseRequestMessage extends DofusMessage {
	public static id: number = 6789

	public portalId: number | undefined = 0

	public constructor(portalId?: number | undefined) {
		super()
		this.portalId = portalId
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarInt(this.portalId!)
	}

	public deserialize(reader: BinaryReader): void {
		this.portalId = reader.readVarInt()
	}

	public hydrate(
		data: PortalUseRequestMessage | Record<string, any>
	): PortalUseRequestMessage {
		if (data instanceof PortalUseRequestMessage) {
			return data
		}

		this.portalId = data.portalId

		return this
	}
}

export interface RawExchangeSellMessage {
	id: number
	objectToSellId: number
	quantity: number
}

export class ExchangeSellMessage extends DofusMessage {
	public static id: number = 6306

	public objectToSellId: number | undefined = 0
	public quantity: number | undefined = 0

	public constructor(
		objectToSellId?: number | undefined,
		quantity?: number | undefined
	) {
		super()
		this.objectToSellId = objectToSellId
		this.quantity = quantity
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarInt(this.objectToSellId!)
		writer.writeVarInt(this.quantity!)
	}

	public deserialize(reader: BinaryReader): void {
		this.objectToSellId = reader.readVarInt()
		this.quantity = reader.readVarInt()
	}

	public hydrate(
		data: ExchangeSellMessage | Record<string, any>
	): ExchangeSellMessage {
		if (data instanceof ExchangeSellMessage) {
			return data
		}

		this.objectToSellId = data.objectToSellId
		this.quantity = data.quantity

		return this
	}
}

export interface RawGameRolePlayFreeSoulRequestMessage {
	id: number
}

export class GameRolePlayFreeSoulRequestMessage extends DofusMessage {
	public static id: number = 6865

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public serialize(writer: BinaryWriter): void {}

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public deserialize(reader: BinaryReader): void {}

	public hydrate(
		data: GameRolePlayFreeSoulRequestMessage | Record<string, any>
	): GameRolePlayFreeSoulRequestMessage {
		if (data instanceof GameRolePlayFreeSoulRequestMessage) {
			return data
		}

		return this
	}
}

export interface RawLeaveDialogRequestMessage {
	id: number
}

export class LeaveDialogRequestMessage extends DofusMessage {
	public static id: number = 9751

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public serialize(writer: BinaryWriter): void {}

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public deserialize(reader: BinaryReader): void {}

	public hydrate(
		data: LeaveDialogRequestMessage | Record<string, any>
	): LeaveDialogRequestMessage {
		if (data instanceof LeaveDialogRequestMessage) {
			return data
		}

		return this
	}
}

export interface RawTeleportHavenBagAnswerMessage {
	id: number
	accept: boolean
}

export class TeleportHavenBagAnswerMessage extends DofusMessage {
	public static id: number = 205

	public accept: boolean | undefined = false

	public constructor(accept?: boolean | undefined) {
		super()
		this.accept = accept
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeBoolean(this.accept!)
	}

	public deserialize(reader: BinaryReader): void {
		this.accept = reader.readBoolean()
	}

	public hydrate(
		data: TeleportHavenBagAnswerMessage | Record<string, any>
	): TeleportHavenBagAnswerMessage {
		if (data instanceof TeleportHavenBagAnswerMessage) {
			return data
		}

		this.accept = data.accept

		return this
	}
}

export interface RawKickHavenBagRequestMessage {
	id: number
	guestId: number
}

export class KickHavenBagRequestMessage extends DofusMessage {
	public static id: number = 9331

	public guestId: number | undefined = 0

	public constructor(guestId?: number | undefined) {
		super()
		this.guestId = guestId
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarLong(this.guestId!)
	}

	public deserialize(reader: BinaryReader): void {
		this.guestId = reader.readVarLong()
	}

	public hydrate(
		data: KickHavenBagRequestMessage | Record<string, any>
	): KickHavenBagRequestMessage {
		if (data instanceof KickHavenBagRequestMessage) {
			return data
		}

		this.guestId = data.guestId

		return this
	}
}

export interface RawNpcGenericActionRequestMessage {
	id: number
	npcId: number
	npcActionId: number
	npcMapId: number
}

export class NpcGenericActionRequestMessage extends DofusMessage {
	public static id: number = 6002

	public npcId: number | undefined = 0
	public npcActionId: number | undefined = 0
	public npcMapId: number | undefined = 0

	public constructor(
		npcId?: number | undefined,
		npcActionId?: number | undefined,
		npcMapId?: number | undefined
	) {
		super()
		this.npcId = npcId
		this.npcActionId = npcActionId
		this.npcMapId = npcMapId
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeInt(this.npcId!)
		writer.writeByte(this.npcActionId!)
		writer.writeDouble(this.npcMapId!)
	}

	public deserialize(reader: BinaryReader): void {
		this.npcId = reader.readInt()
		this.npcActionId = reader.readByte()
		this.npcMapId = reader.readDouble()
	}

	public hydrate(
		data: NpcGenericActionRequestMessage | Record<string, any>
	): NpcGenericActionRequestMessage {
		if (data instanceof NpcGenericActionRequestMessage) {
			return data
		}

		this.npcId = data.npcId
		this.npcActionId = data.npcActionId
		this.npcMapId = data.npcMapId

		return this
	}
}

export interface RawGameRolePlayTaxCollectorFightRequestMessage {
	id: number
}

export class GameRolePlayTaxCollectorFightRequestMessage extends DofusMessage {
	public static id: number = 7175

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public serialize(writer: BinaryWriter): void {}

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public deserialize(reader: BinaryReader): void {}

	public hydrate(
		data: GameRolePlayTaxCollectorFightRequestMessage | Record<string, any>
	): GameRolePlayTaxCollectorFightRequestMessage {
		if (data instanceof GameRolePlayTaxCollectorFightRequestMessage) {
			return data
		}

		return this
	}
}

export interface RawGameRolePlayPlayerFightFriendlyAnswerMessage {
	id: number
	fightId: number
	accept: boolean
}

export class GameRolePlayPlayerFightFriendlyAnswerMessage extends DofusMessage {
	public static id: number = 3588

	public fightId: number | undefined = 0
	public accept: boolean | undefined = false

	public constructor(
		fightId?: number | undefined,
		accept?: boolean | undefined
	) {
		super()
		this.fightId = fightId
		this.accept = accept
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarShort(this.fightId!)
		writer.writeBoolean(this.accept!)
	}

	public deserialize(reader: BinaryReader): void {
		this.fightId = reader.readVarShort()
		this.accept = reader.readBoolean()
	}

	public hydrate(
		data: GameRolePlayPlayerFightFriendlyAnswerMessage | Record<string, any>
	): GameRolePlayPlayerFightFriendlyAnswerMessage {
		if (data instanceof GameRolePlayPlayerFightFriendlyAnswerMessage) {
			return data
		}

		this.fightId = data.fightId
		this.accept = data.accept

		return this
	}
}

export interface RawExchangeShowVendorTaxMessage {
	id: number
}

export class ExchangeShowVendorTaxMessage extends DofusMessage {
	public static id: number = 2113

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public serialize(writer: BinaryWriter): void {}

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public deserialize(reader: BinaryReader): void {}

	public hydrate(
		data: ExchangeShowVendorTaxMessage | Record<string, any>
	): ExchangeShowVendorTaxMessage {
		if (data instanceof ExchangeShowVendorTaxMessage) {
			return data
		}

		return this
	}
}

export interface RawExchangeRequestOnShopStockMessage {
	id: number
}

export class ExchangeRequestOnShopStockMessage extends DofusMessage {
	public static id: number = 1872

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public serialize(writer: BinaryWriter): void {}

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public deserialize(reader: BinaryReader): void {}

	public hydrate(
		data: ExchangeRequestOnShopStockMessage | Record<string, any>
	): ExchangeRequestOnShopStockMessage {
		if (data instanceof ExchangeRequestOnShopStockMessage) {
			return data
		}

		return this
	}
}

export interface RawHouseTeleportRequestMessage {
	id: number
	houseId: number
	houseInstanceId: number
}

export class HouseTeleportRequestMessage extends DofusMessage {
	public static id: number = 2580

	public houseId: number | undefined = 0
	public houseInstanceId: number | undefined = 0

	public constructor(
		houseId?: number | undefined,
		houseInstanceId?: number | undefined
	) {
		super()
		this.houseId = houseId
		this.houseInstanceId = houseInstanceId
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarInt(this.houseId!)
		writer.writeInt(this.houseInstanceId!)
	}

	public deserialize(reader: BinaryReader): void {
		this.houseId = reader.readVarInt()
		this.houseInstanceId = reader.readInt()
	}

	public hydrate(
		data: HouseTeleportRequestMessage | Record<string, any>
	): HouseTeleportRequestMessage {
		if (data instanceof HouseTeleportRequestMessage) {
			return data
		}

		this.houseId = data.houseId
		this.houseInstanceId = data.houseInstanceId

		return this
	}
}

export interface RawFriendJoinRequestMessage {
	id: number
	name: string
}

export class FriendJoinRequestMessage extends DofusMessage {
	public static id: number = 800

	public name: string | undefined

	public constructor(name?: string | undefined) {
		super()
		this.name = name
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeUTF(this.name!)
	}

	public deserialize(reader: BinaryReader): void {
		this.name = reader.readUTF()
	}

	public hydrate(
		data: FriendJoinRequestMessage | Record<string, any>
	): FriendJoinRequestMessage {
		if (data instanceof FriendJoinRequestMessage) {
			return data
		}

		this.name = data.name

		return this
	}
}

export interface RawFriendSpouseFollowWithCompassRequestMessage {
	id: number
	enable: boolean
}

export class FriendSpouseFollowWithCompassRequestMessage extends DofusMessage {
	public static id: number = 9603

	public enable: boolean | undefined = false

	public constructor(enable?: boolean | undefined) {
		super()
		this.enable = enable
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeBoolean(this.enable!)
	}

	public deserialize(reader: BinaryReader): void {
		this.enable = reader.readBoolean()
	}

	public hydrate(
		data: FriendSpouseFollowWithCompassRequestMessage | Record<string, any>
	): FriendSpouseFollowWithCompassRequestMessage {
		if (data instanceof FriendSpouseFollowWithCompassRequestMessage) {
			return data
		}

		this.enable = data.enable

		return this
	}
}

export interface RawSocialNoticeSetRequestMessage {
	id: number
}

export class SocialNoticeSetRequestMessage extends DofusMessage {
	public static id: number = 7244

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public serialize(writer: BinaryWriter): void {}

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public deserialize(reader: BinaryReader): void {}

	public hydrate(
		data: SocialNoticeSetRequestMessage | Record<string, any>
	): SocialNoticeSetRequestMessage {
		if (data instanceof SocialNoticeSetRequestMessage) {
			return data
		}

		return this
	}
}

export interface RawGuildBulletinSetRequestMessage
	extends RawSocialNoticeSetRequestMessage {
	id: number
	content: string
	notifyMembers: boolean
}

export class GuildBulletinSetRequestMessage extends SocialNoticeSetRequestMessage {
	public static id = 9793

	public content: string | undefined
	public notifyMembers: boolean | undefined = false

	public constructor(
		content?: string | undefined,
		notifyMembers?: boolean | undefined
	) {
		super()
		this.content = content
		this.notifyMembers = notifyMembers
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeUTF(this.content!)
		writer.writeBoolean(this.notifyMembers!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.content = reader.readUTF()
		this.notifyMembers = reader.readBoolean()
	}

	public hydrate(
		data: GuildBulletinSetRequestMessage | Record<string, any>
	): GuildBulletinSetRequestMessage {
		if (data instanceof GuildBulletinSetRequestMessage) {
			return data
		}

		this.content = data.content
		this.notifyMembers = data.notifyMembers

		return this
	}
}

export interface RawGuildSpellUpgradeRequestMessage {
	id: number
	spellId: number
}

export class GuildSpellUpgradeRequestMessage extends DofusMessage {
	public static id: number = 7668

	public spellId: number | undefined = 0

	public constructor(spellId?: number | undefined) {
		super()
		this.spellId = spellId
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeInt(this.spellId!)
	}

	public deserialize(reader: BinaryReader): void {
		this.spellId = reader.readInt()
	}

	public hydrate(
		data: GuildSpellUpgradeRequestMessage | Record<string, any>
	): GuildSpellUpgradeRequestMessage {
		if (data instanceof GuildSpellUpgradeRequestMessage) {
			return data
		}

		this.spellId = data.spellId

		return this
	}
}

export interface RawGuildCharacsUpgradeRequestMessage {
	id: number
	charaTypeTarget: number
}

export class GuildCharacsUpgradeRequestMessage extends DofusMessage {
	public static id: number = 1666

	public charaTypeTarget: number | undefined = 0

	public constructor(charaTypeTarget?: number | undefined) {
		super()
		this.charaTypeTarget = charaTypeTarget
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeByte(this.charaTypeTarget!)
	}

	public deserialize(reader: BinaryReader): void {
		this.charaTypeTarget = reader.readByte()
	}

	public hydrate(
		data: GuildCharacsUpgradeRequestMessage | Record<string, any>
	): GuildCharacsUpgradeRequestMessage {
		if (data instanceof GuildCharacsUpgradeRequestMessage) {
			return data
		}

		this.charaTypeTarget = data.charaTypeTarget

		return this
	}
}

export interface RawSpouseGetInformationsMessage {
	id: number
}

export class SpouseGetInformationsMessage extends DofusMessage {
	public static id: number = 3095

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public serialize(writer: BinaryWriter): void {}

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public deserialize(reader: BinaryReader): void {}

	public hydrate(
		data: SpouseGetInformationsMessage | Record<string, any>
	): SpouseGetInformationsMessage {
		if (data instanceof SpouseGetInformationsMessage) {
			return data
		}

		return this
	}
}

export interface RawWarnOnPermaDeathMessage {
	id: number
	enable: boolean
}

export class WarnOnPermaDeathMessage extends DofusMessage {
	public static id: number = 8483

	public enable: boolean | undefined = false

	public constructor(enable?: boolean | undefined) {
		super()
		this.enable = enable
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeBoolean(this.enable!)
	}

	public deserialize(reader: BinaryReader): void {
		this.enable = reader.readBoolean()
	}

	public hydrate(
		data: WarnOnPermaDeathMessage | Record<string, any>
	): WarnOnPermaDeathMessage {
		if (data instanceof WarnOnPermaDeathMessage) {
			return data
		}

		this.enable = data.enable

		return this
	}
}

export interface RawGuildGetInformationsMessage {
	id: number
	infoType: number
}

export class GuildGetInformationsMessage extends DofusMessage {
	public static id: number = 5452

	public infoType: number | undefined = 0

	public constructor(infoType?: number | undefined) {
		super()
		this.infoType = infoType
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeByte(this.infoType!)
	}

	public deserialize(reader: BinaryReader): void {
		this.infoType = reader.readByte()
	}

	public hydrate(
		data: GuildGetInformationsMessage | Record<string, any>
	): GuildGetInformationsMessage {
		if (data instanceof GuildGetInformationsMessage) {
			return data
		}

		this.infoType = data.infoType

		return this
	}
}

export interface RawFriendSetWarnOnConnectionMessage {
	id: number
	enable: boolean
}

export class FriendSetWarnOnConnectionMessage extends DofusMessage {
	public static id: number = 2659

	public enable: boolean | undefined = false

	public constructor(enable?: boolean | undefined) {
		super()
		this.enable = enable
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeBoolean(this.enable!)
	}

	public deserialize(reader: BinaryReader): void {
		this.enable = reader.readBoolean()
	}

	public hydrate(
		data: FriendSetWarnOnConnectionMessage | Record<string, any>
	): FriendSetWarnOnConnectionMessage {
		if (data instanceof FriendSetWarnOnConnectionMessage) {
			return data
		}

		this.enable = data.enable

		return this
	}
}

export interface RawIgnoredGetListMessage {
	id: number
}

export class IgnoredGetListMessage extends DofusMessage {
	public static id: number = 8701

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public serialize(writer: BinaryWriter): void {}

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public deserialize(reader: BinaryReader): void {}

	public hydrate(
		data: IgnoredGetListMessage | Record<string, any>
	): IgnoredGetListMessage {
		if (data instanceof IgnoredGetListMessage) {
			return data
		}

		return this
	}
}

export interface RawGuildMotdSetRequestMessage
	extends RawSocialNoticeSetRequestMessage {
	id: number
	content: string
}

export class GuildMotdSetRequestMessage extends SocialNoticeSetRequestMessage {
	public static id = 9563

	public content: string | undefined

	public constructor(content?: string | undefined) {
		super()
		this.content = content
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeUTF(this.content!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.content = reader.readUTF()
	}

	public hydrate(
		data: GuildMotdSetRequestMessage | Record<string, any>
	): GuildMotdSetRequestMessage {
		if (data instanceof GuildMotdSetRequestMessage) {
			return data
		}

		this.content = data.content

		return this
	}
}

export interface RawGuildMemberSetWarnOnConnectionMessage {
	id: number
	enable: boolean
}

export class GuildMemberSetWarnOnConnectionMessage extends DofusMessage {
	public static id: number = 3898

	public enable: boolean | undefined = false

	public constructor(enable?: boolean | undefined) {
		super()
		this.enable = enable
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeBoolean(this.enable!)
	}

	public deserialize(reader: BinaryReader): void {
		this.enable = reader.readBoolean()
	}

	public hydrate(
		data: GuildMemberSetWarnOnConnectionMessage | Record<string, any>
	): GuildMemberSetWarnOnConnectionMessage {
		if (data instanceof GuildMemberSetWarnOnConnectionMessage) {
			return data
		}

		this.enable = data.enable

		return this
	}
}

export interface RawIgnoredDeleteRequestMessage {
	id: number
	accountId: number
	session: boolean
}

export class IgnoredDeleteRequestMessage extends DofusMessage {
	public static id: number = 9881

	public accountId: number | undefined = 0
	public session: boolean | undefined = false

	public constructor(
		accountId?: number | undefined,
		session?: boolean | undefined
	) {
		super()
		this.accountId = accountId
		this.session = session
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeInt(this.accountId!)
		writer.writeBoolean(this.session!)
	}

	public deserialize(reader: BinaryReader): void {
		this.accountId = reader.readInt()
		this.session = reader.readBoolean()
	}

	public hydrate(
		data: IgnoredDeleteRequestMessage | Record<string, any>
	): IgnoredDeleteRequestMessage {
		if (data instanceof IgnoredDeleteRequestMessage) {
			return data
		}

		this.accountId = data.accountId
		this.session = data.session

		return this
	}
}

export interface RawGuildChangeMemberParametersMessage {
	id: number
	memberId: number
	rank: number
	experienceGivenPercent: number
	rights: number
}

export class GuildChangeMemberParametersMessage extends DofusMessage {
	public static id: number = 2729

	public memberId: number | undefined = 0
	public rank: number | undefined = 0
	public experienceGivenPercent: number | undefined = 0
	public rights: number | undefined = 0

	public constructor(
		memberId?: number | undefined,
		rank?: number | undefined,
		experienceGivenPercent?: number | undefined,
		rights?: number | undefined
	) {
		super()
		this.memberId = memberId
		this.rank = rank
		this.experienceGivenPercent = experienceGivenPercent
		this.rights = rights
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarLong(this.memberId!)
		writer.writeVarShort(this.rank!)
		writer.writeByte(this.experienceGivenPercent!)
		writer.writeVarInt(this.rights!)
	}

	public deserialize(reader: BinaryReader): void {
		this.memberId = reader.readVarLong()
		this.rank = reader.readVarShort()
		this.experienceGivenPercent = reader.readByte()
		this.rights = reader.readVarInt()
	}

	public hydrate(
		data: GuildChangeMemberParametersMessage | Record<string, any>
	): GuildChangeMemberParametersMessage {
		if (data instanceof GuildChangeMemberParametersMessage) {
			return data
		}

		this.memberId = data.memberId
		this.rank = data.rank
		this.experienceGivenPercent = data.experienceGivenPercent
		this.rights = data.rights

		return this
	}
}

export interface RawGuildFightJoinRequestMessage {
	id: number
	taxCollectorId: number
}

export class GuildFightJoinRequestMessage extends DofusMessage {
	public static id: number = 7195

	public taxCollectorId: number | undefined = 0

	public constructor(taxCollectorId?: number | undefined) {
		super()
		this.taxCollectorId = taxCollectorId
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeDouble(this.taxCollectorId!)
	}

	public deserialize(reader: BinaryReader): void {
		this.taxCollectorId = reader.readDouble()
	}

	public hydrate(
		data: GuildFightJoinRequestMessage | Record<string, any>
	): GuildFightJoinRequestMessage {
		if (data instanceof GuildFightJoinRequestMessage) {
			return data
		}

		this.taxCollectorId = data.taxCollectorId

		return this
	}
}

export interface RawFriendDeleteRequestMessage {
	id: number
	accountId: number
}

export class FriendDeleteRequestMessage extends DofusMessage {
	public static id: number = 5614

	public accountId: number | undefined = 0

	public constructor(accountId?: number | undefined) {
		super()
		this.accountId = accountId
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeInt(this.accountId!)
	}

	public deserialize(reader: BinaryReader): void {
		this.accountId = reader.readInt()
	}

	public hydrate(
		data: FriendDeleteRequestMessage | Record<string, any>
	): FriendDeleteRequestMessage {
		if (data instanceof FriendDeleteRequestMessage) {
			return data
		}

		this.accountId = data.accountId

		return this
	}
}

export interface RawContactLookRequestMessage {
	id: number
	requestId: number
	contactType: number
}

export class ContactLookRequestMessage extends DofusMessage {
	public static id: number = 6653

	public requestId: number | undefined = 0
	public contactType: number | undefined = 0

	public constructor(
		requestId?: number | undefined,
		contactType?: number | undefined
	) {
		super()
		this.requestId = requestId
		this.contactType = contactType
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeByte(this.requestId!)
		writer.writeByte(this.contactType!)
	}

	public deserialize(reader: BinaryReader): void {
		this.requestId = reader.readByte()
		this.contactType = reader.readByte()
	}

	public hydrate(
		data: ContactLookRequestMessage | Record<string, any>
	): ContactLookRequestMessage {
		if (data instanceof ContactLookRequestMessage) {
			return data
		}

		this.requestId = data.requestId
		this.contactType = data.contactType

		return this
	}
}

export interface RawContactLookRequestByIdMessage
	extends RawContactLookRequestMessage {
	id: number
	playerId: number
}

export class ContactLookRequestByIdMessage extends ContactLookRequestMessage {
	public static id = 3633

	public playerId: number | undefined = 0

	public constructor(
		requestId?: number | undefined,
		contactType?: number | undefined,
		playerId?: number | undefined
	) {
		super(requestId, contactType)
		this.playerId = playerId
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeVarLong(this.playerId!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.playerId = reader.readVarLong()
	}

	public hydrate(
		data: ContactLookRequestByIdMessage | Record<string, any>
	): ContactLookRequestByIdMessage {
		if (data instanceof ContactLookRequestByIdMessage) {
			return data
		}

		super.hydrate(data)

		this.playerId = data.playerId

		return this
	}
}

export interface RawFriendAddRequestMessage {
	id: number
	name: string
}

export class FriendAddRequestMessage extends DofusMessage {
	public static id: number = 1663

	public name: string | undefined

	public constructor(name?: string | undefined) {
		super()
		this.name = name
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeUTF(this.name!)
	}

	public deserialize(reader: BinaryReader): void {
		this.name = reader.readUTF()
	}

	public hydrate(
		data: FriendAddRequestMessage | Record<string, any>
	): FriendAddRequestMessage {
		if (data instanceof FriendAddRequestMessage) {
			return data
		}

		this.name = data.name

		return this
	}
}

export interface RawPlayerStatusUpdateRequestMessage {
	id: number
	status: PlayerStatus
}

export class PlayerStatusUpdateRequestMessage extends DofusMessage {
	public static id: number = 9450

	public status: PlayerStatus | undefined

	public constructor(status?: PlayerStatus | undefined) {
		super()
		this.status = status
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeShort(this.status!.id)
		this.status!.serialize(writer)
	}

	public deserialize(reader: BinaryReader): void {
		const statusTypeId: number = reader.readShort()
		this.status = new types[statusTypeId]() as PlayerStatus
		this.status!.deserialize(reader)
	}

	public hydrate(
		data: PlayerStatusUpdateRequestMessage | Record<string, any>
	): PlayerStatusUpdateRequestMessage {
		if (data instanceof PlayerStatusUpdateRequestMessage) {
			return data
		}

		this.status = (new types[data.status.id]() as PlayerStatus).hydrate(
			data.status
		)
		return this
	}
}

export interface RawGuildPaddockTeleportRequestMessage {
	id: number
	paddockId: number
}

export class GuildPaddockTeleportRequestMessage extends DofusMessage {
	public static id: number = 6284

	public paddockId: number | undefined = 0

	public constructor(paddockId?: number | undefined) {
		super()
		this.paddockId = paddockId
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeDouble(this.paddockId!)
	}

	public deserialize(reader: BinaryReader): void {
		this.paddockId = reader.readDouble()
	}

	public hydrate(
		data: GuildPaddockTeleportRequestMessage | Record<string, any>
	): GuildPaddockTeleportRequestMessage {
		if (data instanceof GuildPaddockTeleportRequestMessage) {
			return data
		}

		this.paddockId = data.paddockId

		return this
	}
}

export interface RawIgnoredAddRequestMessage {
	id: number
	name: string
	session: boolean
}

export class IgnoredAddRequestMessage extends DofusMessage {
	public static id: number = 5690

	public name: string | undefined
	public session: boolean | undefined = false

	public constructor(name?: string | undefined, session?: boolean | undefined) {
		super()
		this.name = name
		this.session = session
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeUTF(this.name!)
		writer.writeBoolean(this.session!)
	}

	public deserialize(reader: BinaryReader): void {
		this.name = reader.readUTF()
		this.session = reader.readBoolean()
	}

	public hydrate(
		data: IgnoredAddRequestMessage | Record<string, any>
	): IgnoredAddRequestMessage {
		if (data instanceof IgnoredAddRequestMessage) {
			return data
		}

		this.name = data.name
		this.session = data.session

		return this
	}
}

export interface RawFriendSetStatusShareMessage {
	id: number
	share: boolean
}

export class FriendSetStatusShareMessage extends DofusMessage {
	public static id: number = 6299

	public share: boolean | undefined = false

	public constructor(share?: boolean | undefined) {
		super()
		this.share = share
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeBoolean(this.share!)
	}

	public deserialize(reader: BinaryReader): void {
		this.share = reader.readBoolean()
	}

	public hydrate(
		data: FriendSetStatusShareMessage | Record<string, any>
	): FriendSetStatusShareMessage {
		if (data instanceof FriendSetStatusShareMessage) {
			return data
		}

		this.share = data.share

		return this
	}
}

export interface RawGuildKickRequestMessage {
	id: number
	kickedId: number
}

export class GuildKickRequestMessage extends DofusMessage {
	public static id: number = 5473

	public kickedId: number | undefined = 0

	public constructor(kickedId?: number | undefined) {
		super()
		this.kickedId = kickedId
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarLong(this.kickedId!)
	}

	public deserialize(reader: BinaryReader): void {
		this.kickedId = reader.readVarLong()
	}

	public hydrate(
		data: GuildKickRequestMessage | Record<string, any>
	): GuildKickRequestMessage {
		if (data instanceof GuildKickRequestMessage) {
			return data
		}

		this.kickedId = data.kickedId

		return this
	}
}

export interface RawFriendGuildSetWarnOnAchievementCompleteMessage {
	id: number
	enable: boolean
}

export class FriendGuildSetWarnOnAchievementCompleteMessage extends DofusMessage {
	public static id: number = 5495

	public enable: boolean | undefined = false

	public constructor(enable?: boolean | undefined) {
		super()
		this.enable = enable
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeBoolean(this.enable!)
	}

	public deserialize(reader: BinaryReader): void {
		this.enable = reader.readBoolean()
	}

	public hydrate(
		data: FriendGuildSetWarnOnAchievementCompleteMessage | Record<string, any>
	): FriendGuildSetWarnOnAchievementCompleteMessage {
		if (data instanceof FriendGuildSetWarnOnAchievementCompleteMessage) {
			return data
		}

		this.enable = data.enable

		return this
	}
}

export interface RawGuildInvitationMessage {
	id: number
	targetId: number
}

export class GuildInvitationMessage extends DofusMessage {
	public static id: number = 8404

	public targetId: number | undefined = 0

	public constructor(targetId?: number | undefined) {
		super()
		this.targetId = targetId
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarLong(this.targetId!)
	}

	public deserialize(reader: BinaryReader): void {
		this.targetId = reader.readVarLong()
	}

	public hydrate(
		data: GuildInvitationMessage | Record<string, any>
	): GuildInvitationMessage {
		if (data instanceof GuildInvitationMessage) {
			return data
		}

		this.targetId = data.targetId

		return this
	}
}

export interface RawGuildFightLeaveRequestMessage {
	id: number
	taxCollectorId: number
	characterId: number
}

export class GuildFightLeaveRequestMessage extends DofusMessage {
	public static id: number = 1328

	public taxCollectorId: number | undefined = 0
	public characterId: number | undefined = 0

	public constructor(
		taxCollectorId?: number | undefined,
		characterId?: number | undefined
	) {
		super()
		this.taxCollectorId = taxCollectorId
		this.characterId = characterId
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeDouble(this.taxCollectorId!)
		writer.writeVarLong(this.characterId!)
	}

	public deserialize(reader: BinaryReader): void {
		this.taxCollectorId = reader.readDouble()
		this.characterId = reader.readVarLong()
	}

	public hydrate(
		data: GuildFightLeaveRequestMessage | Record<string, any>
	): GuildFightLeaveRequestMessage {
		if (data instanceof GuildFightLeaveRequestMessage) {
			return data
		}

		this.taxCollectorId = data.taxCollectorId
		this.characterId = data.characterId

		return this
	}
}

export interface RawAcquaintancesGetListMessage {
	id: number
}

export class AcquaintancesGetListMessage extends DofusMessage {
	public static id: number = 9107

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public serialize(writer: BinaryWriter): void {}

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public deserialize(reader: BinaryReader): void {}

	public hydrate(
		data: AcquaintancesGetListMessage | Record<string, any>
	): AcquaintancesGetListMessage {
		if (data instanceof AcquaintancesGetListMessage) {
			return data
		}

		return this
	}
}

export interface RawFriendSpouseJoinRequestMessage {
	id: number
}

export class FriendSpouseJoinRequestMessage extends DofusMessage {
	public static id: number = 3828

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public serialize(writer: BinaryWriter): void {}

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public deserialize(reader: BinaryReader): void {}

	public hydrate(
		data: FriendSpouseJoinRequestMessage | Record<string, any>
	): FriendSpouseJoinRequestMessage {
		if (data instanceof FriendSpouseJoinRequestMessage) {
			return data
		}

		return this
	}
}

export interface RawFriendSetWarnOnLevelGainMessage {
	id: number
	enable: boolean
}

export class FriendSetWarnOnLevelGainMessage extends DofusMessage {
	public static id: number = 429

	public enable: boolean | undefined = false

	public constructor(enable?: boolean | undefined) {
		super()
		this.enable = enable
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeBoolean(this.enable!)
	}

	public deserialize(reader: BinaryReader): void {
		this.enable = reader.readBoolean()
	}

	public hydrate(
		data: FriendSetWarnOnLevelGainMessage | Record<string, any>
	): FriendSetWarnOnLevelGainMessage {
		if (data instanceof FriendSetWarnOnLevelGainMessage) {
			return data
		}

		this.enable = data.enable

		return this
	}
}

export interface RawFriendsGetListMessage {
	id: number
}

export class FriendsGetListMessage extends DofusMessage {
	public static id: number = 3897

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public serialize(writer: BinaryWriter): void {}

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public deserialize(reader: BinaryReader): void {}

	public hydrate(
		data: FriendsGetListMessage | Record<string, any>
	): FriendsGetListMessage {
		if (data instanceof FriendsGetListMessage) {
			return data
		}

		return this
	}
}

export interface RawGuildInvitationByNameMessage {
	id: number
	name: string
}

export class GuildInvitationByNameMessage extends DofusMessage {
	public static id: number = 5265

	public name: string | undefined

	public constructor(name?: string | undefined) {
		super()
		this.name = name
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeUTF(this.name!)
	}

	public deserialize(reader: BinaryReader): void {
		this.name = reader.readUTF()
	}

	public hydrate(
		data: GuildInvitationByNameMessage | Record<string, any>
	): GuildInvitationByNameMessage {
		if (data instanceof GuildInvitationByNameMessage) {
			return data
		}

		this.name = data.name

		return this
	}
}

export interface RawGuildFightTakePlaceRequestMessage
	extends RawGuildFightJoinRequestMessage {
	id: number
	replacedCharacterId: number
}

export class GuildFightTakePlaceRequestMessage extends GuildFightJoinRequestMessage {
	public static id = 11111

	public replacedCharacterId: number | undefined = 0

	public constructor(
		taxCollectorId?: number | undefined,
		replacedCharacterId?: number | undefined
	) {
		super(taxCollectorId)
		this.replacedCharacterId = replacedCharacterId
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeInt(this.replacedCharacterId!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.replacedCharacterId = reader.readInt()
	}

	public hydrate(
		data: GuildFightTakePlaceRequestMessage | Record<string, any>
	): GuildFightTakePlaceRequestMessage {
		if (data instanceof GuildFightTakePlaceRequestMessage) {
			return data
		}

		super.hydrate(data)

		this.replacedCharacterId = data.replacedCharacterId

		return this
	}
}

export interface RawChatAbstractClientMessage {
	id: number
	content: string
}

export class ChatAbstractClientMessage extends DofusMessage {
	public static id: number = 832

	public content: string | undefined

	public constructor(content?: string | undefined) {
		super()
		this.content = content
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeUTF(this.content!)
	}

	public deserialize(reader: BinaryReader): void {
		this.content = reader.readUTF()
	}

	public hydrate(
		data: ChatAbstractClientMessage | Record<string, any>
	): ChatAbstractClientMessage {
		if (data instanceof ChatAbstractClientMessage) {
			return data
		}

		this.content = data.content

		return this
	}
}

export interface RawChatClientPrivateMessage
	extends RawChatAbstractClientMessage {
	id: number
	receiver: string
}

export class ChatClientPrivateMessage extends ChatAbstractClientMessage {
	public static id = 6307

	public receiver: string | undefined

	public constructor(
		content?: string | undefined,
		receiver?: string | undefined
	) {
		super(content)
		this.receiver = receiver
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeUTF(this.receiver!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.receiver = reader.readUTF()
	}

	public hydrate(
		data: ChatClientPrivateMessage | Record<string, any>
	): ChatClientPrivateMessage {
		if (data instanceof ChatClientPrivateMessage) {
			return data
		}

		super.hydrate(data)

		this.receiver = data.receiver

		return this
	}
}

export interface RawChatClientPrivateWithObjectMessage
	extends RawChatClientPrivateMessage {
	id: number
	objects: ObjectItem[]
}

export class ChatClientPrivateWithObjectMessage extends ChatClientPrivateMessage {
	public static id = 5903

	public objects: ObjectItem[] | undefined

	public constructor(
		content?: string | undefined,
		receiver?: string | undefined,
		objects?: ObjectItem[] | undefined
	) {
		super(content, receiver)
		this.objects = objects
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeShort(this.objects!.length)
		this.objects!.forEach((current) => {
			current.serialize(writer)
		})
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.objects = []
		const countObjects = reader.readShort()
		for (let i: number = 0; i < countObjects; i++) {
			const type: ObjectItem = new ObjectItem()
			type.deserialize(reader)
			this.objects.push(type)
		}
	}

	public hydrate(
		data: ChatClientPrivateWithObjectMessage | Record<string, any>
	): ChatClientPrivateWithObjectMessage {
		if (data instanceof ChatClientPrivateWithObjectMessage) {
			return data
		}

		super.hydrate(data)

		this.objects = data.objects.map(
			(dataElement: ObjectItem | Record<string, any>): ObjectItem => {
				if (dataElement instanceof ObjectItem) {
					return dataElement
				} else {
					return new ObjectItem().hydrate(dataElement)
				}
			}
		)

		return this
	}
}

export interface RawMoodSmileyRequestMessage {
	id: number
	smileyId: number
}

export class MoodSmileyRequestMessage extends DofusMessage {
	public static id: number = 670

	public smileyId: number | undefined = 0

	public constructor(smileyId?: number | undefined) {
		super()
		this.smileyId = smileyId
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarShort(this.smileyId!)
	}

	public deserialize(reader: BinaryReader): void {
		this.smileyId = reader.readVarShort()
	}

	public hydrate(
		data: MoodSmileyRequestMessage | Record<string, any>
	): MoodSmileyRequestMessage {
		if (data instanceof MoodSmileyRequestMessage) {
			return data
		}

		this.smileyId = data.smileyId

		return this
	}
}

export interface RawChatSmileyRequestMessage {
	id: number
	smileyId: number
}

export class ChatSmileyRequestMessage extends DofusMessage {
	public static id: number = 5172

	public smileyId: number | undefined = 0

	public constructor(smileyId?: number | undefined) {
		super()
		this.smileyId = smileyId
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarShort(this.smileyId!)
	}

	public deserialize(reader: BinaryReader): void {
		this.smileyId = reader.readVarShort()
	}

	public hydrate(
		data: ChatSmileyRequestMessage | Record<string, any>
	): ChatSmileyRequestMessage {
		if (data instanceof ChatSmileyRequestMessage) {
			return data
		}

		this.smileyId = data.smileyId

		return this
	}
}

export interface RawChatCommunityChannelSetCommunityRequestMessage {
	id: number
	communityId: number
}

export class ChatCommunityChannelSetCommunityRequestMessage extends DofusMessage {
	public static id: number = 43

	public communityId: number | undefined = 0

	public constructor(communityId?: number | undefined) {
		super()
		this.communityId = communityId
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeShort(this.communityId!)
	}

	public deserialize(reader: BinaryReader): void {
		this.communityId = reader.readShort()
	}

	public hydrate(
		data: ChatCommunityChannelSetCommunityRequestMessage | Record<string, any>
	): ChatCommunityChannelSetCommunityRequestMessage {
		if (data instanceof ChatCommunityChannelSetCommunityRequestMessage) {
			return data
		}

		this.communityId = data.communityId

		return this
	}
}

export interface RawBasicWhoIsRequestMessage {
	id: number
	verbose: boolean
	search: string
}

export class BasicWhoIsRequestMessage extends DofusMessage {
	public static id: number = 6558

	public verbose: boolean | undefined = false
	public search: string | undefined

	public constructor(
		verbose?: boolean | undefined,
		search?: string | undefined
	) {
		super()
		this.verbose = verbose
		this.search = search
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeBoolean(this.verbose!)
		writer.writeUTF(this.search!)
	}

	public deserialize(reader: BinaryReader): void {
		this.verbose = reader.readBoolean()
		this.search = reader.readUTF()
	}

	public hydrate(
		data: BasicWhoIsRequestMessage | Record<string, any>
	): BasicWhoIsRequestMessage {
		if (data instanceof BasicWhoIsRequestMessage) {
			return data
		}

		this.verbose = data.verbose
		this.search = data.search

		return this
	}
}

export interface RawChatClientMultiMessage
	extends RawChatAbstractClientMessage {
	id: number
	channel: number
}

export class ChatClientMultiMessage extends ChatAbstractClientMessage {
	public static id = 4617

	public channel: number | undefined = 0

	public constructor(
		content?: string | undefined,
		channel?: number | undefined
	) {
		super(content)
		this.channel = channel
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeByte(this.channel!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.channel = reader.readByte()
	}

	public hydrate(
		data: ChatClientMultiMessage | Record<string, any>
	): ChatClientMultiMessage {
		if (data instanceof ChatClientMultiMessage) {
			return data
		}

		super.hydrate(data)

		this.channel = data.channel

		return this
	}
}

export interface RawChatClientMultiWithObjectMessage
	extends RawChatClientMultiMessage {
	id: number
	objects: ObjectItem[]
}

export class ChatClientMultiWithObjectMessage extends ChatClientMultiMessage {
	public static id = 5275

	public objects: ObjectItem[] | undefined

	public constructor(
		content?: string | undefined,
		channel?: number | undefined,
		objects?: ObjectItem[] | undefined
	) {
		super(content, channel)
		this.objects = objects
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeShort(this.objects!.length)
		this.objects!.forEach((current) => {
			current.serialize(writer)
		})
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.objects = []
		const countObjects = reader.readShort()
		for (let i: number = 0; i < countObjects; i++) {
			const type: ObjectItem = new ObjectItem()
			type.deserialize(reader)
			this.objects.push(type)
		}
	}

	public hydrate(
		data: ChatClientMultiWithObjectMessage | Record<string, any>
	): ChatClientMultiWithObjectMessage {
		if (data instanceof ChatClientMultiWithObjectMessage) {
			return data
		}

		super.hydrate(data)

		this.objects = data.objects.map(
			(dataElement: ObjectItem | Record<string, any>): ObjectItem => {
				if (dataElement instanceof ObjectItem) {
					return dataElement
				} else {
					return new ObjectItem().hydrate(dataElement)
				}
			}
		)

		return this
	}
}

export interface RawChannelEnablingMessage {
	id: number
	channel: number
	enable: boolean
}

export class ChannelEnablingMessage extends DofusMessage {
	public static id: number = 1902

	public channel: number | undefined = 0
	public enable: boolean | undefined = false

	public constructor(
		channel?: number | undefined,
		enable?: boolean | undefined
	) {
		super()
		this.channel = channel
		this.enable = enable
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeByte(this.channel!)
		writer.writeBoolean(this.enable!)
	}

	public deserialize(reader: BinaryReader): void {
		this.channel = reader.readByte()
		this.enable = reader.readBoolean()
	}

	public hydrate(
		data: ChannelEnablingMessage | Record<string, any>
	): ChannelEnablingMessage {
		if (data instanceof ChannelEnablingMessage) {
			return data
		}

		this.channel = data.channel
		this.enable = data.enable

		return this
	}
}

export interface RawNumericWhoIsRequestMessage {
	id: number
	playerId: number
}

export class NumericWhoIsRequestMessage extends DofusMessage {
	public static id: number = 1244

	public playerId: number | undefined = 0

	public constructor(playerId?: number | undefined) {
		super()
		this.playerId = playerId
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarLong(this.playerId!)
	}

	public deserialize(reader: BinaryReader): void {
		this.playerId = reader.readVarLong()
	}

	public hydrate(
		data: NumericWhoIsRequestMessage | Record<string, any>
	): NumericWhoIsRequestMessage {
		if (data instanceof NumericWhoIsRequestMessage) {
			return data
		}

		this.playerId = data.playerId

		return this
	}
}

export interface RawPartyPledgeLoyaltyRequestMessage
	extends RawAbstractPartyMessage {
	id: number
	loyal: boolean
}

export class PartyPledgeLoyaltyRequestMessage extends AbstractPartyMessage {
	public static id = 8938

	public loyal: boolean | undefined = false

	public constructor(
		partyId?: number | undefined,
		loyal?: boolean | undefined
	) {
		super(partyId)
		this.loyal = loyal
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeBoolean(this.loyal!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.loyal = reader.readBoolean()
	}

	public hydrate(
		data: PartyPledgeLoyaltyRequestMessage | Record<string, any>
	): PartyPledgeLoyaltyRequestMessage {
		if (data instanceof PartyPledgeLoyaltyRequestMessage) {
			return data
		}

		super.hydrate(data)

		this.loyal = data.loyal

		return this
	}
}

export interface RawPartyFollowMemberRequestMessage
	extends RawAbstractPartyMessage {
	id: number
	playerId: number
}

export class PartyFollowMemberRequestMessage extends AbstractPartyMessage {
	public static id = 7104

	public playerId: number | undefined = 0

	public constructor(
		partyId?: number | undefined,
		playerId?: number | undefined
	) {
		super(partyId)
		this.playerId = playerId
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeVarLong(this.playerId!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.playerId = reader.readVarLong()
	}

	public hydrate(
		data: PartyFollowMemberRequestMessage | Record<string, any>
	): PartyFollowMemberRequestMessage {
		if (data instanceof PartyFollowMemberRequestMessage) {
			return data
		}

		super.hydrate(data)

		this.playerId = data.playerId

		return this
	}
}

export interface RawPartyFollowThisMemberRequestMessage
	extends RawPartyFollowMemberRequestMessage {
	id: number
	enabled: boolean
}

export class PartyFollowThisMemberRequestMessage extends PartyFollowMemberRequestMessage {
	public static id = 8893

	public enabled: boolean | undefined = false

	public constructor(
		partyId?: number | undefined,
		playerId?: number | undefined,
		enabled?: boolean | undefined
	) {
		super(partyId, playerId)
		this.enabled = enabled
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeBoolean(this.enabled!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.enabled = reader.readBoolean()
	}

	public hydrate(
		data: PartyFollowThisMemberRequestMessage | Record<string, any>
	): PartyFollowThisMemberRequestMessage {
		if (data instanceof PartyFollowThisMemberRequestMessage) {
			return data
		}

		super.hydrate(data)

		this.enabled = data.enabled

		return this
	}
}

export interface RawDungeonPartyFinderAvailableDungeonsRequestMessage {
	id: number
}

export class DungeonPartyFinderAvailableDungeonsRequestMessage extends DofusMessage {
	public static id: number = 8721

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public serialize(writer: BinaryWriter): void {}

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public deserialize(reader: BinaryReader): void {}

	public hydrate(
		data:
			| DungeonPartyFinderAvailableDungeonsRequestMessage
			| Record<string, any>
	): DungeonPartyFinderAvailableDungeonsRequestMessage {
		if (data instanceof DungeonPartyFinderAvailableDungeonsRequestMessage) {
			return data
		}

		return this
	}
}

export interface RawPartyRefuseInvitationMessage
	extends RawAbstractPartyMessage {
	id: number
}

export class PartyRefuseInvitationMessage extends AbstractPartyMessage {
	public static id = 8642

	public constructor(partyId?: number | undefined) {
		super(partyId)
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
	}

	public hydrate(
		data: PartyRefuseInvitationMessage | Record<string, any>
	): PartyRefuseInvitationMessage {
		if (data instanceof PartyRefuseInvitationMessage) {
			return data
		}

		super.hydrate(data)

		return this
	}
}

export interface RawPartyNameSetRequestMessage extends RawAbstractPartyMessage {
	id: number
	partyName: string
}

export class PartyNameSetRequestMessage extends AbstractPartyMessage {
	public static id = 5482

	public partyName: string | undefined

	public constructor(
		partyId?: number | undefined,
		partyName?: string | undefined
	) {
		super(partyId)
		this.partyName = partyName
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeUTF(this.partyName!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.partyName = reader.readUTF()
	}

	public hydrate(
		data: PartyNameSetRequestMessage | Record<string, any>
	): PartyNameSetRequestMessage {
		if (data instanceof PartyNameSetRequestMessage) {
			return data
		}

		super.hydrate(data)

		this.partyName = data.partyName

		return this
	}
}

export interface RawPartyLeaveRequestMessage extends RawAbstractPartyMessage {
	id: number
}

export class PartyLeaveRequestMessage extends AbstractPartyMessage {
	public static id = 6141

	public constructor(partyId?: number | undefined) {
		super(partyId)
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
	}

	public hydrate(
		data: PartyLeaveRequestMessage | Record<string, any>
	): PartyLeaveRequestMessage {
		if (data instanceof PartyLeaveRequestMessage) {
			return data
		}

		super.hydrate(data)

		return this
	}
}

export interface RawTeleportToBuddyAnswerMessage {
	id: number
	dungeonId: number
	buddyId: number
	accept: boolean
}

export class TeleportToBuddyAnswerMessage extends DofusMessage {
	public static id: number = 4262

	public dungeonId: number | undefined = 0
	public buddyId: number | undefined = 0
	public accept: boolean | undefined = false

	public constructor(
		dungeonId?: number | undefined,
		buddyId?: number | undefined,
		accept?: boolean | undefined
	) {
		super()
		this.dungeonId = dungeonId
		this.buddyId = buddyId
		this.accept = accept
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarShort(this.dungeonId!)
		writer.writeVarLong(this.buddyId!)
		writer.writeBoolean(this.accept!)
	}

	public deserialize(reader: BinaryReader): void {
		this.dungeonId = reader.readVarShort()
		this.buddyId = reader.readVarLong()
		this.accept = reader.readBoolean()
	}

	public hydrate(
		data: TeleportToBuddyAnswerMessage | Record<string, any>
	): TeleportToBuddyAnswerMessage {
		if (data instanceof TeleportToBuddyAnswerMessage) {
			return data
		}

		this.dungeonId = data.dungeonId
		this.buddyId = data.buddyId
		this.accept = data.accept

		return this
	}
}

export interface RawGameRolePlayArenaFightAnswerMessage {
	id: number
	fightId: number
	accept: boolean
}

export class GameRolePlayArenaFightAnswerMessage extends DofusMessage {
	public static id: number = 2536

	public fightId: number | undefined = 0
	public accept: boolean | undefined = false

	public constructor(
		fightId?: number | undefined,
		accept?: boolean | undefined
	) {
		super()
		this.fightId = fightId
		this.accept = accept
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarShort(this.fightId!)
		writer.writeBoolean(this.accept!)
	}

	public deserialize(reader: BinaryReader): void {
		this.fightId = reader.readVarShort()
		this.accept = reader.readBoolean()
	}

	public hydrate(
		data: GameRolePlayArenaFightAnswerMessage | Record<string, any>
	): GameRolePlayArenaFightAnswerMessage {
		if (data instanceof GameRolePlayArenaFightAnswerMessage) {
			return data
		}

		this.fightId = data.fightId
		this.accept = data.accept

		return this
	}
}

export interface RawPartyAbdicateThroneMessage extends RawAbstractPartyMessage {
	id: number
	playerId: number
}

export class PartyAbdicateThroneMessage extends AbstractPartyMessage {
	public static id = 2850

	public playerId: number | undefined = 0

	public constructor(
		partyId?: number | undefined,
		playerId?: number | undefined
	) {
		super(partyId)
		this.playerId = playerId
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeVarLong(this.playerId!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.playerId = reader.readVarLong()
	}

	public hydrate(
		data: PartyAbdicateThroneMessage | Record<string, any>
	): PartyAbdicateThroneMessage {
		if (data instanceof PartyAbdicateThroneMessage) {
			return data
		}

		super.hydrate(data)

		this.playerId = data.playerId

		return this
	}
}

export interface RawBreachInvitationAnswerMessage {
	id: number
	accept: boolean
}

export class BreachInvitationAnswerMessage extends DofusMessage {
	public static id: number = 7999

	public accept: boolean | undefined = false

	public constructor(accept?: boolean | undefined) {
		super()
		this.accept = accept
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeBoolean(this.accept!)
	}

	public deserialize(reader: BinaryReader): void {
		this.accept = reader.readBoolean()
	}

	public hydrate(
		data: BreachInvitationAnswerMessage | Record<string, any>
	): BreachInvitationAnswerMessage {
		if (data instanceof BreachInvitationAnswerMessage) {
			return data
		}

		this.accept = data.accept

		return this
	}
}

export interface RawGameRolePlayArenaRegisterMessage {
	id: number
	battleMode: number
}

export class GameRolePlayArenaRegisterMessage extends DofusMessage {
	public static id: number = 4371

	public battleMode: number | undefined = 3

	public constructor(battleMode?: number | undefined) {
		super()
		this.battleMode = battleMode
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeInt(this.battleMode!)
	}

	public deserialize(reader: BinaryReader): void {
		this.battleMode = reader.readInt()
	}

	public hydrate(
		data: GameRolePlayArenaRegisterMessage | Record<string, any>
	): GameRolePlayArenaRegisterMessage {
		if (data instanceof GameRolePlayArenaRegisterMessage) {
			return data
		}

		this.battleMode = data.battleMode

		return this
	}
}

export interface RawPartyInvitationRequestMessage {
	id: number
	name: string
}

export class PartyInvitationRequestMessage extends DofusMessage {
	public static id: number = 1084

	public name: string | undefined

	public constructor(name?: string | undefined) {
		super()
		this.name = name
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeUTF(this.name!)
	}

	public deserialize(reader: BinaryReader): void {
		this.name = reader.readUTF()
	}

	public hydrate(
		data: PartyInvitationRequestMessage | Record<string, any>
	): PartyInvitationRequestMessage {
		if (data instanceof PartyInvitationRequestMessage) {
			return data
		}

		this.name = data.name

		return this
	}
}

export interface RawPartyInvitationArenaRequestMessage
	extends RawPartyInvitationRequestMessage {
	id: number
}

export class PartyInvitationArenaRequestMessage extends PartyInvitationRequestMessage {
	public static id = 4310

	public constructor(name?: string | undefined) {
		super(name)
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
	}

	public hydrate(
		data: PartyInvitationArenaRequestMessage | Record<string, any>
	): PartyInvitationArenaRequestMessage {
		if (data instanceof PartyInvitationArenaRequestMessage) {
			return data
		}

		super.hydrate(data)

		return this
	}
}

export interface RawDungeonPartyFinderListenRequestMessage {
	id: number
	dungeonId: number
}

export class DungeonPartyFinderListenRequestMessage extends DofusMessage {
	public static id: number = 5213

	public dungeonId: number | undefined = 0

	public constructor(dungeonId?: number | undefined) {
		super()
		this.dungeonId = dungeonId
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarShort(this.dungeonId!)
	}

	public deserialize(reader: BinaryReader): void {
		this.dungeonId = reader.readVarShort()
	}

	public hydrate(
		data: DungeonPartyFinderListenRequestMessage | Record<string, any>
	): DungeonPartyFinderListenRequestMessage {
		if (data instanceof DungeonPartyFinderListenRequestMessage) {
			return data
		}

		this.dungeonId = data.dungeonId

		return this
	}
}

export interface RawPartyInvitationDetailsRequestMessage
	extends RawAbstractPartyMessage {
	id: number
}

export class PartyInvitationDetailsRequestMessage extends AbstractPartyMessage {
	public static id = 2173

	public constructor(partyId?: number | undefined) {
		super(partyId)
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
	}

	public hydrate(
		data: PartyInvitationDetailsRequestMessage | Record<string, any>
	): PartyInvitationDetailsRequestMessage {
		if (data instanceof PartyInvitationDetailsRequestMessage) {
			return data
		}

		super.hydrate(data)

		return this
	}
}

export interface RawPartyCancelInvitationMessage
	extends RawAbstractPartyMessage {
	id: number
	guestId: number
}

export class PartyCancelInvitationMessage extends AbstractPartyMessage {
	public static id = 1048

	public guestId: number | undefined = 0

	public constructor(
		partyId?: number | undefined,
		guestId?: number | undefined
	) {
		super(partyId)
		this.guestId = guestId
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeVarLong(this.guestId!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.guestId = reader.readVarLong()
	}

	public hydrate(
		data: PartyCancelInvitationMessage | Record<string, any>
	): PartyCancelInvitationMessage {
		if (data instanceof PartyCancelInvitationMessage) {
			return data
		}

		super.hydrate(data)

		this.guestId = data.guestId

		return this
	}
}

export interface RawPartyInvitationDungeonRequestMessage
	extends RawPartyInvitationRequestMessage {
	id: number
	dungeonId: number
}

export class PartyInvitationDungeonRequestMessage extends PartyInvitationRequestMessage {
	public static id = 931

	public dungeonId: number | undefined = 0

	public constructor(
		name?: string | undefined,
		dungeonId?: number | undefined
	) {
		super(name)
		this.dungeonId = dungeonId
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeVarShort(this.dungeonId!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.dungeonId = reader.readVarShort()
	}

	public hydrate(
		data: PartyInvitationDungeonRequestMessage | Record<string, any>
	): PartyInvitationDungeonRequestMessage {
		if (data instanceof PartyInvitationDungeonRequestMessage) {
			return data
		}

		super.hydrate(data)

		this.dungeonId = data.dungeonId

		return this
	}
}

export interface RawDungeonPartyFinderRegisterRequestMessage {
	id: number
	dungeonIds: number[]
}

export class DungeonPartyFinderRegisterRequestMessage extends DofusMessage {
	public static id: number = 5219

	public dungeonIds: number[] | undefined

	public constructor(dungeonIds?: number[] | undefined) {
		super()
		this.dungeonIds = dungeonIds
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeShort(this.dungeonIds!.length)
		this.dungeonIds!.forEach((current: number) => writer.writeVarShort(current))
	}

	public deserialize(reader: BinaryReader): void {
		this.dungeonIds = []
		const countDungeonIds = reader.readShort()
		for (let i: number = 0; i < countDungeonIds; i++) {
			this.dungeonIds.push(reader.readVarShort())
		}
	}

	public hydrate(
		data: DungeonPartyFinderRegisterRequestMessage | Record<string, any>
	): DungeonPartyFinderRegisterRequestMessage {
		if (data instanceof DungeonPartyFinderRegisterRequestMessage) {
			return data
		}

		this.dungeonIds = data.dungeonIds

		return this
	}
}

export interface RawGameRolePlayArenaUnregisterMessage {
	id: number
}

export class GameRolePlayArenaUnregisterMessage extends DofusMessage {
	public static id: number = 6661

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public serialize(writer: BinaryWriter): void {}

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public deserialize(reader: BinaryReader): void {}

	public hydrate(
		data: GameRolePlayArenaUnregisterMessage | Record<string, any>
	): GameRolePlayArenaUnregisterMessage {
		if (data instanceof GameRolePlayArenaUnregisterMessage) {
			return data
		}

		return this
	}
}

export interface RawPartyAcceptInvitationMessage
	extends RawAbstractPartyMessage {
	id: number
}

export class PartyAcceptInvitationMessage extends AbstractPartyMessage {
	public static id = 6538

	public constructor(partyId?: number | undefined) {
		super(partyId)
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
	}

	public hydrate(
		data: PartyAcceptInvitationMessage | Record<string, any>
	): PartyAcceptInvitationMessage {
		if (data instanceof PartyAcceptInvitationMessage) {
			return data
		}

		super.hydrate(data)

		return this
	}
}

export interface RawPartyStopFollowRequestMessage
	extends RawAbstractPartyMessage {
	id: number
	playerId: number
}

export class PartyStopFollowRequestMessage extends AbstractPartyMessage {
	public static id = 4679

	public playerId: number | undefined = 0

	public constructor(
		partyId?: number | undefined,
		playerId?: number | undefined
	) {
		super(partyId)
		this.playerId = playerId
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeVarLong(this.playerId!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.playerId = reader.readVarLong()
	}

	public hydrate(
		data: PartyStopFollowRequestMessage | Record<string, any>
	): PartyStopFollowRequestMessage {
		if (data instanceof PartyStopFollowRequestMessage) {
			return data
		}

		super.hydrate(data)

		this.playerId = data.playerId

		return this
	}
}

export interface RawPartyKickRequestMessage extends RawAbstractPartyMessage {
	id: number
	playerId: number
}

export class PartyKickRequestMessage extends AbstractPartyMessage {
	public static id = 7424

	public playerId: number | undefined = 0

	public constructor(
		partyId?: number | undefined,
		playerId?: number | undefined
	) {
		super(partyId)
		this.playerId = playerId
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeVarLong(this.playerId!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.playerId = reader.readVarLong()
	}

	public hydrate(
		data: PartyKickRequestMessage | Record<string, any>
	): PartyKickRequestMessage {
		if (data instanceof PartyKickRequestMessage) {
			return data
		}

		super.hydrate(data)

		this.playerId = data.playerId

		return this
	}
}

export interface RawPrismFightJoinLeaveRequestMessage {
	id: number
	subAreaId: number
	join: boolean
}

export class PrismFightJoinLeaveRequestMessage extends DofusMessage {
	public static id: number = 6578

	public subAreaId: number | undefined = 0
	public join: boolean | undefined = false

	public constructor(
		subAreaId?: number | undefined,
		join?: boolean | undefined
	) {
		super()
		this.subAreaId = subAreaId
		this.join = join
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarShort(this.subAreaId!)
		writer.writeBoolean(this.join!)
	}

	public deserialize(reader: BinaryReader): void {
		this.subAreaId = reader.readVarShort()
		this.join = reader.readBoolean()
	}

	public hydrate(
		data: PrismFightJoinLeaveRequestMessage | Record<string, any>
	): PrismFightJoinLeaveRequestMessage {
		if (data instanceof PrismFightJoinLeaveRequestMessage) {
			return data
		}

		this.subAreaId = data.subAreaId
		this.join = data.join

		return this
	}
}

export interface RawPrismSettingsRequestMessage {
	id: number
	subAreaId: number
	startDefenseTime: number
}

export class PrismSettingsRequestMessage extends DofusMessage {
	public static id: number = 5624

	public subAreaId: number | undefined = 0
	public startDefenseTime: number | undefined = 0

	public constructor(
		subAreaId?: number | undefined,
		startDefenseTime?: number | undefined
	) {
		super()
		this.subAreaId = subAreaId
		this.startDefenseTime = startDefenseTime
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarShort(this.subAreaId!)
		writer.writeByte(this.startDefenseTime!)
	}

	public deserialize(reader: BinaryReader): void {
		this.subAreaId = reader.readVarShort()
		this.startDefenseTime = reader.readByte()
	}

	public hydrate(
		data: PrismSettingsRequestMessage | Record<string, any>
	): PrismSettingsRequestMessage {
		if (data instanceof PrismSettingsRequestMessage) {
			return data
		}

		this.subAreaId = data.subAreaId
		this.startDefenseTime = data.startDefenseTime

		return this
	}
}

export interface RawAllianceKickRequestMessage {
	id: number
	kickedId: number
}

export class AllianceKickRequestMessage extends DofusMessage {
	public static id: number = 4475

	public kickedId: number | undefined = 0

	public constructor(kickedId?: number | undefined) {
		super()
		this.kickedId = kickedId
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarInt(this.kickedId!)
	}

	public deserialize(reader: BinaryReader): void {
		this.kickedId = reader.readVarInt()
	}

	public hydrate(
		data: AllianceKickRequestMessage | Record<string, any>
	): AllianceKickRequestMessage {
		if (data instanceof AllianceKickRequestMessage) {
			return data
		}

		this.kickedId = data.kickedId

		return this
	}
}

export interface RawPrismInfoJoinLeaveRequestMessage {
	id: number
	join: boolean
}

export class PrismInfoJoinLeaveRequestMessage extends DofusMessage {
	public static id: number = 9455

	public join: boolean | undefined = false

	public constructor(join?: boolean | undefined) {
		super()
		this.join = join
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeBoolean(this.join!)
	}

	public deserialize(reader: BinaryReader): void {
		this.join = reader.readBoolean()
	}

	public hydrate(
		data: PrismInfoJoinLeaveRequestMessage | Record<string, any>
	): PrismInfoJoinLeaveRequestMessage {
		if (data instanceof PrismInfoJoinLeaveRequestMessage) {
			return data
		}

		this.join = data.join

		return this
	}
}

export interface RawPrismFightSwapRequestMessage {
	id: number
	subAreaId: number
	targetId: number
}

export class PrismFightSwapRequestMessage extends DofusMessage {
	public static id: number = 7833

	public subAreaId: number | undefined = 0
	public targetId: number | undefined = 0

	public constructor(
		subAreaId?: number | undefined,
		targetId?: number | undefined
	) {
		super()
		this.subAreaId = subAreaId
		this.targetId = targetId
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarShort(this.subAreaId!)
		writer.writeVarLong(this.targetId!)
	}

	public deserialize(reader: BinaryReader): void {
		this.subAreaId = reader.readVarShort()
		this.targetId = reader.readVarLong()
	}

	public hydrate(
		data: PrismFightSwapRequestMessage | Record<string, any>
	): PrismFightSwapRequestMessage {
		if (data instanceof PrismFightSwapRequestMessage) {
			return data
		}

		this.subAreaId = data.subAreaId
		this.targetId = data.targetId

		return this
	}
}

export interface RawPrismSetSabotagedRequestMessage {
	id: number
	subAreaId: number
}

export class PrismSetSabotagedRequestMessage extends DofusMessage {
	public static id: number = 1806

	public subAreaId: number | undefined = 0

	public constructor(subAreaId?: number | undefined) {
		super()
		this.subAreaId = subAreaId
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarShort(this.subAreaId!)
	}

	public deserialize(reader: BinaryReader): void {
		this.subAreaId = reader.readVarShort()
	}

	public hydrate(
		data: PrismSetSabotagedRequestMessage | Record<string, any>
	): PrismSetSabotagedRequestMessage {
		if (data instanceof PrismSetSabotagedRequestMessage) {
			return data
		}

		this.subAreaId = data.subAreaId

		return this
	}
}

export interface RawPrismUseRequestMessage {
	id: number
	moduleToUse: number
}

export class PrismUseRequestMessage extends DofusMessage {
	public static id: number = 9551

	public moduleToUse: number | undefined = 0

	public constructor(moduleToUse?: number | undefined) {
		super()
		this.moduleToUse = moduleToUse
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeByte(this.moduleToUse!)
	}

	public deserialize(reader: BinaryReader): void {
		this.moduleToUse = reader.readByte()
	}

	public hydrate(
		data: PrismUseRequestMessage | Record<string, any>
	): PrismUseRequestMessage {
		if (data instanceof PrismUseRequestMessage) {
			return data
		}

		this.moduleToUse = data.moduleToUse

		return this
	}
}

export interface RawPrismModuleExchangeRequestMessage {
	id: number
}

export class PrismModuleExchangeRequestMessage extends DofusMessage {
	public static id: number = 4413

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public serialize(writer: BinaryWriter): void {}

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public deserialize(reader: BinaryReader): void {}

	public hydrate(
		data: PrismModuleExchangeRequestMessage | Record<string, any>
	): PrismModuleExchangeRequestMessage {
		if (data instanceof PrismModuleExchangeRequestMessage) {
			return data
		}

		return this
	}
}

export interface RawSetEnableAVARequestMessage {
	id: number
	enable: boolean
}

export class SetEnableAVARequestMessage extends DofusMessage {
	public static id: number = 7829

	public enable: boolean | undefined = false

	public constructor(enable?: boolean | undefined) {
		super()
		this.enable = enable
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeBoolean(this.enable!)
	}

	public deserialize(reader: BinaryReader): void {
		this.enable = reader.readBoolean()
	}

	public hydrate(
		data: SetEnableAVARequestMessage | Record<string, any>
	): SetEnableAVARequestMessage {
		if (data instanceof SetEnableAVARequestMessage) {
			return data
		}

		this.enable = data.enable

		return this
	}
}

export interface RawPrismsListRegisterMessage {
	id: number
	listen: number
}

export class PrismsListRegisterMessage extends DofusMessage {
	public static id: number = 5140

	public listen: number | undefined = 0

	public constructor(listen?: number | undefined) {
		super()
		this.listen = listen
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeByte(this.listen!)
	}

	public deserialize(reader: BinaryReader): void {
		this.listen = reader.readByte()
	}

	public hydrate(
		data: PrismsListRegisterMessage | Record<string, any>
	): PrismsListRegisterMessage {
		if (data instanceof PrismsListRegisterMessage) {
			return data
		}

		this.listen = data.listen

		return this
	}
}

export interface RawAllianceMotdSetRequestMessage
	extends RawSocialNoticeSetRequestMessage {
	id: number
	content: string
}

export class AllianceMotdSetRequestMessage extends SocialNoticeSetRequestMessage {
	public static id = 9138

	public content: string | undefined

	public constructor(content?: string | undefined) {
		super()
		this.content = content
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeUTF(this.content!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.content = reader.readUTF()
	}

	public hydrate(
		data: AllianceMotdSetRequestMessage | Record<string, any>
	): AllianceMotdSetRequestMessage {
		if (data instanceof AllianceMotdSetRequestMessage) {
			return data
		}

		this.content = data.content

		return this
	}
}

export interface RawPrismAttackRequestMessage {
	id: number
}

export class PrismAttackRequestMessage extends DofusMessage {
	public static id: number = 972

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public serialize(writer: BinaryWriter): void {}

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public deserialize(reader: BinaryReader): void {}

	public hydrate(
		data: PrismAttackRequestMessage | Record<string, any>
	): PrismAttackRequestMessage {
		if (data instanceof PrismAttackRequestMessage) {
			return data
		}

		return this
	}
}

export interface RawAllianceChangeGuildRightsMessage {
	id: number
	guildId: number
	rights: number
}

export class AllianceChangeGuildRightsMessage extends DofusMessage {
	public static id: number = 8973

	public guildId: number | undefined = 0
	public rights: number | undefined = 0

	public constructor(
		guildId?: number | undefined,
		rights?: number | undefined
	) {
		super()
		this.guildId = guildId
		this.rights = rights
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarInt(this.guildId!)
		writer.writeByte(this.rights!)
	}

	public deserialize(reader: BinaryReader): void {
		this.guildId = reader.readVarInt()
		this.rights = reader.readByte()
	}

	public hydrate(
		data: AllianceChangeGuildRightsMessage | Record<string, any>
	): AllianceChangeGuildRightsMessage {
		if (data instanceof AllianceChangeGuildRightsMessage) {
			return data
		}

		this.guildId = data.guildId
		this.rights = data.rights

		return this
	}
}

export interface RawAllianceBulletinSetRequestMessage
	extends RawSocialNoticeSetRequestMessage {
	id: number
	content: string
	notifyMembers: boolean
}

export class AllianceBulletinSetRequestMessage extends SocialNoticeSetRequestMessage {
	public static id = 7301

	public content: string | undefined
	public notifyMembers: boolean | undefined = false

	public constructor(
		content?: string | undefined,
		notifyMembers?: boolean | undefined
	) {
		super()
		this.content = content
		this.notifyMembers = notifyMembers
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeUTF(this.content!)
		writer.writeBoolean(this.notifyMembers!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.content = reader.readUTF()
		this.notifyMembers = reader.readBoolean()
	}

	public hydrate(
		data: AllianceBulletinSetRequestMessage | Record<string, any>
	): AllianceBulletinSetRequestMessage {
		if (data instanceof AllianceBulletinSetRequestMessage) {
			return data
		}

		this.content = data.content
		this.notifyMembers = data.notifyMembers

		return this
	}
}

export interface RawAllianceInsiderInfoRequestMessage {
	id: number
}

export class AllianceInsiderInfoRequestMessage extends DofusMessage {
	public static id: number = 1729

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public serialize(writer: BinaryWriter): void {}

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public deserialize(reader: BinaryReader): void {}

	public hydrate(
		data: AllianceInsiderInfoRequestMessage | Record<string, any>
	): AllianceInsiderInfoRequestMessage {
		if (data instanceof AllianceInsiderInfoRequestMessage) {
			return data
		}

		return this
	}
}

export interface RawAllianceInvitationMessage {
	id: number
	targetId: number
}

export class AllianceInvitationMessage extends DofusMessage {
	public static id: number = 9978

	public targetId: number | undefined = 0

	public constructor(targetId?: number | undefined) {
		super()
		this.targetId = targetId
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarLong(this.targetId!)
	}

	public deserialize(reader: BinaryReader): void {
		this.targetId = reader.readVarLong()
	}

	public hydrate(
		data: AllianceInvitationMessage | Record<string, any>
	): AllianceInvitationMessage {
		if (data instanceof AllianceInvitationMessage) {
			return data
		}

		this.targetId = data.targetId

		return this
	}
}

export class AchievementAlmostFinishedDetailedListRequestMessage extends DofusMessage {
	public static id: number = 8255

	public constructor() {
		super()
	}

	public serialize(writer: BinaryWriter): void {}

	public deserialize(reader: BinaryReader): void {}
}

export class AchievementAlmostFinishedDetailedListMessage extends DofusMessage {
  public static id: number = 211

  public almostFinishedAchievements: Achievement[] | undefined = []

  public constructor(almostFinishedAchievements?: Achievement[] | undefined) {
    super()
    this.almostFinishedAchievements = almostFinishedAchievements
  }

  public serialize(writer: BinaryWriter): void {
    writer.writeShort(this.almostFinishedAchievements?.length!)
		this.almostFinishedAchievements!.forEach((achievement: Achievement) => achievement.serialize(writer))
  }

  public deserialize(reader: BinaryReader): void {
		this.almostFinishedAchievements = []
		const countAlmostFinishedAchievements = reader.readShort()
		for (let i: number = 0; i < countAlmostFinishedAchievements; i++) {
      const achievement: Achievement = new Achievement()
      achievement.deserialize(reader)
      this.almostFinishedAchievements.push(achievement)
		}
  }
}

export interface RawShowCellRequestMessage {
	id: number
	cellId: number
}

export class ShowCellRequestMessage extends DofusMessage {
	public static id: number = 3535

	public cellId: number | undefined = 0

	public constructor(cellId?: number | undefined) {
		super()
		this.cellId = cellId
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarShort(this.cellId!)
	}

	public deserialize(reader: BinaryReader): void {
		this.cellId = reader.readVarShort()
	}

	public hydrate(
		data: ShowCellRequestMessage | Record<string, any>
	): ShowCellRequestMessage {
		if (data instanceof ShowCellRequestMessage) {
			return data
		}

		this.cellId = data.cellId

		return this
	}
}

export interface RawGameFightTurnFinishMessage {
	id: number
	isAfk: boolean
}

export class GameFightTurnFinishMessage extends DofusMessage {
	public static id: number = 1536

	public isAfk: boolean | undefined = false

	public constructor(isAfk?: boolean | undefined) {
		super()
		this.isAfk = isAfk
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeBoolean(this.isAfk!)
	}

	public deserialize(reader: BinaryReader): void {
		this.isAfk = reader.readBoolean()
	}

	public hydrate(
		data: GameFightTurnFinishMessage | Record<string, any>
	): GameFightTurnFinishMessage {
		if (data instanceof GameFightTurnFinishMessage) {
			return data
		}

		this.isAfk = data.isAfk

		return this
	}
}

export interface RawGameMapMovementRequestMessage {
	id: number
	keyMovements: number[]
	mapId: number
}

export class GameMapMovementRequestMessage extends DofusMessage {
	public static id: number = 1119

	public keyMovements: number[] | undefined
	public mapId: number | undefined = 0

	public constructor(
		keyMovements?: number[] | undefined,
		mapId?: number | undefined
	) {
		super()
		this.keyMovements = keyMovements
		this.mapId = mapId
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeShort(this.keyMovements!.length)
		this.keyMovements!.forEach((current: number) => writer.writeShort(current))
		writer.writeDouble(this.mapId!)
	}

	public deserialize(reader: BinaryReader): void {
		this.keyMovements = []
		const countKeyMovements = reader.readShort()
		for (let i: number = 0; i < countKeyMovements; i++) {
			this.keyMovements.push(reader.readShort())
		}
		this.mapId = reader.readDouble()
	}

	public hydrate(
		data: GameMapMovementRequestMessage | Record<string, any>
	): GameMapMovementRequestMessage {
		if (data instanceof GameMapMovementRequestMessage) {
			return data
		}

		this.keyMovements = data.keyMovements
		this.mapId = data.mapId

		return this
	}
}

export interface RawGameActionFightCastOnTargetRequestMessage {
	id: number
	spellId: number
	targetId: number
}

export class GameActionFightCastOnTargetRequestMessage extends DofusMessage {
	public static id: number = 5055

	public spellId: number | undefined = 0
	public targetId: number | undefined = 0

	public constructor(
		spellId?: number | undefined,
		targetId?: number | undefined
	) {
		super()
		this.spellId = spellId
		this.targetId = targetId
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarShort(this.spellId!)
		writer.writeDouble(this.targetId!)
	}

	public deserialize(reader: BinaryReader): void {
		this.spellId = reader.readVarShort()
		this.targetId = reader.readDouble()
	}

	public hydrate(
		data: GameActionFightCastOnTargetRequestMessage | Record<string, any>
	): GameActionFightCastOnTargetRequestMessage {
		if (data instanceof GameActionFightCastOnTargetRequestMessage) {
			return data
		}

		this.spellId = data.spellId
		this.targetId = data.targetId

		return this
	}
}

export interface RawGameActionFightCastRequestMessage {
	id: number
	spellId: number
	cellId: number
}

export class GameActionFightCastRequestMessage extends DofusMessage {
	public static id: number = 1470

	public spellId: number | undefined = 0
	public cellId: number | undefined = 0

	public constructor(
		spellId?: number | undefined,
		cellId?: number | undefined
	) {
		super()
		this.spellId = spellId
		this.cellId = cellId
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarShort(this.spellId!)
		writer.writeShort(this.cellId!)
	}

	public deserialize(reader: BinaryReader): void {
		this.spellId = reader.readVarShort()
		this.cellId = reader.readShort()
	}

	public hydrate(
		data: GameActionFightCastRequestMessage | Record<string, any>
	): GameActionFightCastRequestMessage {
		if (data instanceof GameActionFightCastRequestMessage) {
			return data
		}

		this.spellId = data.spellId
		this.cellId = data.cellId

		return this
	}
}

export interface RawFinishMoveSetRequestMessage {
	id: number
	finishMoveId: number
	finishMoveState: boolean
}

export class FinishMoveSetRequestMessage extends DofusMessage {
	public static id: number = 1852

	public finishMoveId: number | undefined = 0
	public finishMoveState: boolean | undefined = false

	public constructor(
		finishMoveId?: number | undefined,
		finishMoveState?: boolean | undefined
	) {
		super()
		this.finishMoveId = finishMoveId
		this.finishMoveState = finishMoveState
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeInt(this.finishMoveId!)
		writer.writeBoolean(this.finishMoveState!)
	}

	public deserialize(reader: BinaryReader): void {
		this.finishMoveId = reader.readInt()
		this.finishMoveState = reader.readBoolean()
	}

	public hydrate(
		data: FinishMoveSetRequestMessage | Record<string, any>
	): FinishMoveSetRequestMessage {
		if (data instanceof FinishMoveSetRequestMessage) {
			return data
		}

		this.finishMoveId = data.finishMoveId
		this.finishMoveState = data.finishMoveState

		return this
	}
}

export interface RawFinishMoveListRequestMessage {
	id: number
}

export class FinishMoveListRequestMessage extends DofusMessage {
	public static id: number = 3924

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public serialize(writer: BinaryWriter): void {}

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public deserialize(reader: BinaryReader): void {}

	public hydrate(
		data: FinishMoveListRequestMessage | Record<string, any>
	): FinishMoveListRequestMessage {
		if (data instanceof FinishMoveListRequestMessage) {
			return data
		}

		return this
	}
}

export interface RawSpellVariantActivationRequestMessage {
	id: number
	spellId: number
}

export class SpellVariantActivationRequestMessage extends DofusMessage {
	public static id: number = 7240

	public spellId: number | undefined = 0

	public constructor(spellId?: number | undefined) {
		super()
		this.spellId = spellId
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarShort(this.spellId!)
	}

	public deserialize(reader: BinaryReader): void {
		this.spellId = reader.readVarShort()
	}

	public hydrate(
		data: SpellVariantActivationRequestMessage | Record<string, any>
	): SpellVariantActivationRequestMessage {
		if (data instanceof SpellVariantActivationRequestMessage) {
			return data
		}

		this.spellId = data.spellId

		return this
	}
}

export interface RawGameContextQuitMessage {
	id: number
}

export class GameContextQuitMessage extends DofusMessage {
	public static id: number = 927

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public serialize(writer: BinaryWriter): void {}

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public deserialize(reader: BinaryReader): void {}

	public hydrate(
		data: GameContextQuitMessage | Record<string, any>
	): GameContextQuitMessage {
		if (data instanceof GameContextQuitMessage) {
			return data
		}

		return this
	}
}

export interface RawBreachRoomUnlockRequestMessage {
	id: number
	roomId: number
}

export class BreachRoomUnlockRequestMessage extends DofusMessage {
	public static id: number = 6725

	public roomId: number | undefined = 0

	public constructor(roomId?: number | undefined) {
		super()
		this.roomId = roomId
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeByte(this.roomId!)
	}

	public deserialize(reader: BinaryReader): void {
		this.roomId = reader.readByte()
	}

	public hydrate(
		data: BreachRoomUnlockRequestMessage | Record<string, any>
	): BreachRoomUnlockRequestMessage {
		if (data instanceof BreachRoomUnlockRequestMessage) {
			return data
		}

		this.roomId = data.roomId

		return this
	}
}

export interface RawBreachRewardBuyMessage {
	id: number
	id_: number
}

export class BreachRewardBuyMessage extends DofusMessage {
	public static id: number = 836

	public id_: number | undefined = 0

	public constructor(id_?: number | undefined) {
		super()
		this.id_ = id_
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarInt(this.id_!)
	}

	public deserialize(reader: BinaryReader): void {
		this.id_ = reader.readVarInt()
	}

	public hydrate(
		data: BreachRewardBuyMessage | Record<string, any>
	): BreachRewardBuyMessage {
		if (data instanceof BreachRewardBuyMessage) {
			return data
		}

		this.id_ = data.id_

		return this
	}
}

export interface RawBreachExitRequestMessage {
	id: number
}

export class BreachExitRequestMessage extends DofusMessage {
	public static id: number = 9437

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public serialize(writer: BinaryWriter): void {}

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public deserialize(reader: BinaryReader): void {}

	public hydrate(
		data: BreachExitRequestMessage | Record<string, any>
	): BreachExitRequestMessage {
		if (data instanceof BreachExitRequestMessage) {
			return data
		}

		return this
	}
}

export interface RawBreachKickRequestMessage {
	id: number
	target: number
}

export class BreachKickRequestMessage extends DofusMessage {
	public static id: number = 1305

	public target: number | undefined = 0

	public constructor(target?: number | undefined) {
		super()
		this.target = target
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarLong(this.target!)
	}

	public deserialize(reader: BinaryReader): void {
		this.target = reader.readVarLong()
	}

	public hydrate(
		data: BreachKickRequestMessage | Record<string, any>
	): BreachKickRequestMessage {
		if (data instanceof BreachKickRequestMessage) {
			return data
		}

		this.target = data.target

		return this
	}
}

export interface RawBreachInvitationRequestMessage {
	id: number
	guests: number[]
}

export class BreachInvitationRequestMessage extends DofusMessage {
	public static id: number = 4246

	public guests: number[] | undefined

	public constructor(guests?: number[] | undefined) {
		super()
		this.guests = guests
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeShort(this.guests!.length)
		this.guests!.forEach((current: number) => writer.writeVarLong(current))
	}

	public deserialize(reader: BinaryReader): void {
		this.guests = []
		const countGuests = reader.readShort()
		for (let i: number = 0; i < countGuests; i++) {
			this.guests.push(reader.readVarLong())
		}
	}

	public hydrate(
		data: BreachInvitationRequestMessage | Record<string, any>
	): BreachInvitationRequestMessage {
		if (data instanceof BreachInvitationRequestMessage) {
			return data
		}

		this.guests = data.guests

		return this
	}
}

export interface RawEditHavenBagRequestMessage {
	id: number
}

export class EditHavenBagRequestMessage extends DofusMessage {
	public static id: number = 2826

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public serialize(writer: BinaryWriter): void {}

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public deserialize(reader: BinaryReader): void {}

	public hydrate(
		data: EditHavenBagRequestMessage | Record<string, any>
	): EditHavenBagRequestMessage {
		if (data instanceof EditHavenBagRequestMessage) {
			return data
		}

		return this
	}
}

export interface RawChangeHavenBagRoomRequestMessage {
	id: number
	roomId: number
}

export class ChangeHavenBagRoomRequestMessage extends DofusMessage {
	public static id: number = 5326

	public roomId: number | undefined = 0

	public constructor(roomId?: number | undefined) {
		super()
		this.roomId = roomId
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeByte(this.roomId!)
	}

	public deserialize(reader: BinaryReader): void {
		this.roomId = reader.readByte()
	}

	public hydrate(
		data: ChangeHavenBagRoomRequestMessage | Record<string, any>
	): ChangeHavenBagRoomRequestMessage {
		if (data instanceof ChangeHavenBagRoomRequestMessage) {
			return data
		}

		this.roomId = data.roomId

		return this
	}
}

export interface RawEditHavenBagCancelRequestMessage {
	id: number
}

export class EditHavenBagCancelRequestMessage extends DofusMessage {
	public static id: number = 9787

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public serialize(writer: BinaryWriter): void {}

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public deserialize(reader: BinaryReader): void {}

	public hydrate(
		data: EditHavenBagCancelRequestMessage | Record<string, any>
	): EditHavenBagCancelRequestMessage {
		if (data instanceof EditHavenBagCancelRequestMessage) {
			return data
		}

		return this
	}
}

export interface RawHavenBagFurnituresRequestMessage {
	id: number
	cellIds: number[]
	funitureIds: number[]
	orientations: number[]
}

export class HavenBagFurnituresRequestMessage extends DofusMessage {
	public static id: number = 5848

	public cellIds: number[] | undefined
	public funitureIds: number[] | undefined
	public orientations: number[] | undefined

	public constructor(
		cellIds?: number[] | undefined,
		funitureIds?: number[] | undefined,
		orientations?: number[] | undefined
	) {
		super()
		this.cellIds = cellIds
		this.funitureIds = funitureIds
		this.orientations = orientations
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeShort(this.cellIds!.length)
		this.cellIds!.forEach((current: number) => writer.writeVarShort(current))
		writer.writeShort(this.funitureIds!.length)
		this.funitureIds!.forEach((current: number) => writer.writeInt(current))
		writer.writeShort(this.orientations!.length)
		this.orientations!.forEach((current: number) => writer.writeByte(current))
	}

	public deserialize(reader: BinaryReader): void {
		this.cellIds = []
		const countCellIds = reader.readShort()
		for (let i: number = 0; i < countCellIds; i++) {
			this.cellIds.push(reader.readVarShort())
		}
		this.funitureIds = []
		const countFunitureIds = reader.readShort()
		for (let i: number = 0; i < countFunitureIds; i++) {
			this.funitureIds.push(reader.readInt())
		}
		this.orientations = []
		const countOrientations = reader.readShort()
		for (let i: number = 0; i < countOrientations; i++) {
			this.orientations.push(reader.readByte())
		}
	}

	public hydrate(
		data: HavenBagFurnituresRequestMessage | Record<string, any>
	): HavenBagFurnituresRequestMessage {
		if (data instanceof HavenBagFurnituresRequestMessage) {
			return data
		}

		this.cellIds = data.cellIds
		this.funitureIds = data.funitureIds
		this.orientations = data.orientations

		return this
	}
}

export interface RawHavenBagPermissionsUpdateRequestMessage {
	id: number
	permissions: number
}

export class HavenBagPermissionsUpdateRequestMessage extends DofusMessage {
	public static id: number = 4397

	public permissions: number | undefined = 0

	public constructor(permissions?: number | undefined) {
		super()
		this.permissions = permissions
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeInt(this.permissions!)
	}

	public deserialize(reader: BinaryReader): void {
		this.permissions = reader.readInt()
	}

	public hydrate(
		data: HavenBagPermissionsUpdateRequestMessage | Record<string, any>
	): HavenBagPermissionsUpdateRequestMessage {
		if (data instanceof HavenBagPermissionsUpdateRequestMessage) {
			return data
		}

		this.permissions = data.permissions

		return this
	}
}

export interface RawOpenHavenBagFurnitureSequenceRequestMessage {
	id: number
}

export class OpenHavenBagFurnitureSequenceRequestMessage extends DofusMessage {
	public static id: number = 2398

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public serialize(writer: BinaryWriter): void {}

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public deserialize(reader: BinaryReader): void {}

	public hydrate(
		data: OpenHavenBagFurnitureSequenceRequestMessage | Record<string, any>
	): OpenHavenBagFurnitureSequenceRequestMessage {
		if (data instanceof OpenHavenBagFurnitureSequenceRequestMessage) {
			return data
		}

		return this
	}
}

export interface RawCloseHavenBagFurnitureSequenceRequestMessage {
	id: number
}

export class CloseHavenBagFurnitureSequenceRequestMessage extends DofusMessage {
	public static id: number = 6985

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public serialize(writer: BinaryWriter): void {}

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public deserialize(reader: BinaryReader): void {}

	public hydrate(
		data: CloseHavenBagFurnitureSequenceRequestMessage | Record<string, any>
	): CloseHavenBagFurnitureSequenceRequestMessage {
		if (data instanceof CloseHavenBagFurnitureSequenceRequestMessage) {
			return data
		}

		return this
	}
}

export interface RawChangeThemeRequestMessage {
	id: number
	theme: number
}

export class ChangeThemeRequestMessage extends DofusMessage {
	public static id: number = 4026

	public theme: number | undefined = 0

	public constructor(theme?: number | undefined) {
		super()
		this.theme = theme
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeByte(this.theme!)
	}

	public deserialize(reader: BinaryReader): void {
		this.theme = reader.readByte()
	}

	public hydrate(
		data: ChangeThemeRequestMessage | Record<string, any>
	): ChangeThemeRequestMessage {
		if (data instanceof ChangeThemeRequestMessage) {
			return data
		}

		this.theme = data.theme

		return this
	}
}

export interface RawExitHavenBagRequestMessage {
	id: number
}

export class ExitHavenBagRequestMessage extends DofusMessage {
	public static id: number = 9801

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public serialize(writer: BinaryWriter): void {}

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public deserialize(reader: BinaryReader): void {}

	public hydrate(
		data: ExitHavenBagRequestMessage | Record<string, any>
	): ExitHavenBagRequestMessage {
		if (data instanceof ExitHavenBagRequestMessage) {
			return data
		}

		return this
	}
}

export interface RawHouseKickIndoorMerchantRequestMessage {
	id: number
	cellId: number
}

export class HouseKickIndoorMerchantRequestMessage extends DofusMessage {
	public static id: number = 3696

	public cellId: number | undefined = 0

	public constructor(cellId?: number | undefined) {
		super()
		this.cellId = cellId
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarShort(this.cellId!)
	}

	public deserialize(reader: BinaryReader): void {
		this.cellId = reader.readVarShort()
	}

	public hydrate(
		data: HouseKickIndoorMerchantRequestMessage | Record<string, any>
	): HouseKickIndoorMerchantRequestMessage {
		if (data instanceof HouseKickIndoorMerchantRequestMessage) {
			return data
		}

		this.cellId = data.cellId

		return this
	}
}

export interface RawGameFightJoinRequestMessage {
	id: number
	fighterId: number
	fightId: number
}

export class GameFightJoinRequestMessage extends DofusMessage {
	public static id: number = 6133

	public fighterId: number | undefined = 0
	public fightId: number | undefined = 0

	public constructor(
		fighterId?: number | undefined,
		fightId?: number | undefined
	) {
		super()
		this.fighterId = fighterId
		this.fightId = fightId
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeDouble(this.fighterId!)
		writer.writeVarShort(this.fightId!)
	}

	public deserialize(reader: BinaryReader): void {
		this.fighterId = reader.readDouble()
		this.fightId = reader.readVarShort()
	}

	public hydrate(
		data: GameFightJoinRequestMessage | Record<string, any>
	): GameFightJoinRequestMessage {
		if (data instanceof GameFightJoinRequestMessage) {
			return data
		}

		this.fighterId = data.fighterId
		this.fightId = data.fightId

		return this
	}
}

export interface RawGameFightPlacementPositionRequestMessage {
	id: number
	cellId: number
}

export class GameFightPlacementPositionRequestMessage extends DofusMessage {
	public static id: number = 8878

	public cellId: number | undefined = 0

	public constructor(cellId?: number | undefined) {
		super()
		this.cellId = cellId
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarShort(this.cellId!)
	}

	public deserialize(reader: BinaryReader): void {
		this.cellId = reader.readVarShort()
	}

	public hydrate(
		data: GameFightPlacementPositionRequestMessage | Record<string, any>
	): GameFightPlacementPositionRequestMessage {
		if (data instanceof GameFightPlacementPositionRequestMessage) {
			return data
		}

		this.cellId = data.cellId

		return this
	}
}

export interface RawGameFightPlacementSwapPositionsRequestMessage
	extends RawGameFightPlacementPositionRequestMessage {
	id: number
	requestedId: number
}

export class GameFightPlacementSwapPositionsRequestMessage extends GameFightPlacementPositionRequestMessage {
	public static id = 1380

	public requestedId: number | undefined = 0

	public constructor(
		cellId?: number | undefined,
		requestedId?: number | undefined
	) {
		super(cellId)
		this.requestedId = requestedId
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeDouble(this.requestedId!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.requestedId = reader.readDouble()
	}

	public hydrate(
		data: GameFightPlacementSwapPositionsRequestMessage | Record<string, any>
	): GameFightPlacementSwapPositionsRequestMessage {
		if (data instanceof GameFightPlacementSwapPositionsRequestMessage) {
			return data
		}

		super.hydrate(data)

		this.requestedId = data.requestedId

		return this
	}
}

export interface RawGameContextKickMessage {
	id: number
	targetId: number
}

export class GameContextKickMessage extends DofusMessage {
	public static id: number = 4471

	public targetId: number | undefined = 0

	public constructor(targetId?: number | undefined) {
		super()
		this.targetId = targetId
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeDouble(this.targetId!)
	}

	public deserialize(reader: BinaryReader): void {
		this.targetId = reader.readDouble()
	}

	public hydrate(
		data: GameContextKickMessage | Record<string, any>
	): GameContextKickMessage {
		if (data instanceof GameContextKickMessage) {
			return data
		}

		this.targetId = data.targetId

		return this
	}
}

export interface RawGameFightPlacementSwapPositionsCancelMessage {
	id: number
	requestId: number
}

export class GameFightPlacementSwapPositionsCancelMessage extends DofusMessage {
	public static id: number = 9929

	public requestId: number | undefined = 0

	public constructor(requestId?: number | undefined) {
		super()
		this.requestId = requestId
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeInt(this.requestId!)
	}

	public deserialize(reader: BinaryReader): void {
		this.requestId = reader.readInt()
	}

	public hydrate(
		data: GameFightPlacementSwapPositionsCancelMessage | Record<string, any>
	): GameFightPlacementSwapPositionsCancelMessage {
		if (data instanceof GameFightPlacementSwapPositionsCancelMessage) {
			return data
		}

		this.requestId = data.requestId

		return this
	}
}

export interface RawGameFightReadyMessage {
	id: number
	isReady: boolean
}

export class GameFightReadyMessage extends DofusMessage {
	public static id: number = 266

	public isReady: boolean | undefined = false

	public constructor(isReady?: boolean | undefined) {
		super()
		this.isReady = isReady
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeBoolean(this.isReady!)
	}

	public deserialize(reader: BinaryReader): void {
		this.isReady = reader.readBoolean()
	}

	public hydrate(
		data: GameFightReadyMessage | Record<string, any>
	): GameFightReadyMessage {
		if (data instanceof GameFightReadyMessage) {
			return data
		}

		this.isReady = data.isReady

		return this
	}
}

export interface RawGameFightPlacementSwapPositionsAcceptMessage {
	id: number
	requestId: number
}

export class GameFightPlacementSwapPositionsAcceptMessage extends DofusMessage {
	public static id: number = 3893

	public requestId: number | undefined = 0

	public constructor(requestId?: number | undefined) {
		super()
		this.requestId = requestId
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeInt(this.requestId!)
	}

	public deserialize(reader: BinaryReader): void {
		this.requestId = reader.readInt()
	}

	public hydrate(
		data: GameFightPlacementSwapPositionsAcceptMessage | Record<string, any>
	): GameFightPlacementSwapPositionsAcceptMessage {
		if (data instanceof GameFightPlacementSwapPositionsAcceptMessage) {
			return data
		}

		this.requestId = data.requestId

		return this
	}
}

export interface RawNotificationResetMessage {
	id: number
}

export class NotificationResetMessage extends DofusMessage {
	public static id: number = 9352

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public serialize(writer: BinaryWriter): void {}

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public deserialize(reader: BinaryReader): void {}

	public hydrate(
		data: NotificationResetMessage | Record<string, any>
	): NotificationResetMessage {
		if (data instanceof NotificationResetMessage) {
			return data
		}

		return this
	}
}

export interface RawUnfollowQuestObjectiveRequestMessage {
	id: number
	questId: number
	objectiveId: number
}

export class UnfollowQuestObjectiveRequestMessage extends DofusMessage {
	public static id: number = 2332

	public questId: number | undefined = 0
	public objectiveId: number | undefined = 0

	public constructor(
		questId?: number | undefined,
		objectiveId?: number | undefined
	) {
		super()
		this.questId = questId
		this.objectiveId = objectiveId
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarShort(this.questId!)
		writer.writeShort(this.objectiveId!)
	}

	public deserialize(reader: BinaryReader): void {
		this.questId = reader.readVarShort()
		this.objectiveId = reader.readShort()
	}

	public hydrate(
		data: UnfollowQuestObjectiveRequestMessage | Record<string, any>
	): UnfollowQuestObjectiveRequestMessage {
		if (data instanceof UnfollowQuestObjectiveRequestMessage) {
			return data
		}

		this.questId = data.questId
		this.objectiveId = data.objectiveId

		return this
	}
}

export interface RawTreasureHuntFlagRemoveRequestMessage {
	id: number
	questType: number
	index: number
}

export class TreasureHuntFlagRemoveRequestMessage extends DofusMessage {
	public static id: number = 7565

	public questType: number | undefined = 0
	public index: number | undefined = 0

	public constructor(
		questType?: number | undefined,
		index?: number | undefined
	) {
		super()
		this.questType = questType
		this.index = index
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeByte(this.questType!)
		writer.writeByte(this.index!)
	}

	public deserialize(reader: BinaryReader): void {
		this.questType = reader.readByte()
		this.index = reader.readByte()
	}

	public hydrate(
		data: TreasureHuntFlagRemoveRequestMessage | Record<string, any>
	): TreasureHuntFlagRemoveRequestMessage {
		if (data instanceof TreasureHuntFlagRemoveRequestMessage) {
			return data
		}

		this.questType = data.questType
		this.index = data.index

		return this
	}
}

export interface RawTreasureHuntFlagRequestMessage {
	id: number
	questType: number
	index: number
}

export class TreasureHuntFlagRequestMessage extends DofusMessage {
	public static id: number = 692

	public questType: number | undefined = 0
	public index: number | undefined = 0

	public constructor(
		questType?: number | undefined,
		index?: number | undefined
	) {
		super()
		this.questType = questType
		this.index = index
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeByte(this.questType!)
		writer.writeByte(this.index!)
	}

	public deserialize(reader: BinaryReader): void {
		this.questType = reader.readByte()
		this.index = reader.readByte()
	}

	public hydrate(
		data: TreasureHuntFlagRequestMessage | Record<string, any>
	): TreasureHuntFlagRequestMessage {
		if (data instanceof TreasureHuntFlagRequestMessage) {
			return data
		}

		this.questType = data.questType
		this.index = data.index

		return this
	}
}

export interface RawGuidedModeReturnRequestMessage {
	id: number
}

export class GuidedModeReturnRequestMessage extends DofusMessage {
	public static id: number = 1205

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public serialize(writer: BinaryWriter): void {}

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public deserialize(reader: BinaryReader): void {}

	public hydrate(
		data: GuidedModeReturnRequestMessage | Record<string, any>
	): GuidedModeReturnRequestMessage {
		if (data instanceof GuidedModeReturnRequestMessage) {
			return data
		}

		return this
	}
}

export interface RawTreasureHuntLegendaryRequestMessage {
	id: number
	legendaryId: number
}

export class TreasureHuntLegendaryRequestMessage extends DofusMessage {
	public static id: number = 7662

	public legendaryId: number | undefined = 0

	public constructor(legendaryId?: number | undefined) {
		super()
		this.legendaryId = legendaryId
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarShort(this.legendaryId!)
	}

	public deserialize(reader: BinaryReader): void {
		this.legendaryId = reader.readVarShort()
	}

	public hydrate(
		data: TreasureHuntLegendaryRequestMessage | Record<string, any>
	): TreasureHuntLegendaryRequestMessage {
		if (data instanceof TreasureHuntLegendaryRequestMessage) {
			return data
		}

		this.legendaryId = data.legendaryId

		return this
	}
}

export interface RawGuidedModeQuitRequestMessage {
	id: number
}

export class GuidedModeQuitRequestMessage extends DofusMessage {
	public static id: number = 5740

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public serialize(writer: BinaryWriter): void {}

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public deserialize(reader: BinaryReader): void {}

	public hydrate(
		data: GuidedModeQuitRequestMessage | Record<string, any>
	): GuidedModeQuitRequestMessage {
		if (data instanceof GuidedModeQuitRequestMessage) {
			return data
		}

		return this
	}
}

export interface RawTreasureHuntGiveUpRequestMessage {
	id: number
	questType: number
}

export class TreasureHuntGiveUpRequestMessage extends DofusMessage {
	public static id: number = 1622

	public questType: number | undefined = 0

	public constructor(questType?: number | undefined) {
		super()
		this.questType = questType
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeByte(this.questType!)
	}

	public deserialize(reader: BinaryReader): void {
		this.questType = reader.readByte()
	}

	public hydrate(
		data: TreasureHuntGiveUpRequestMessage | Record<string, any>
	): TreasureHuntGiveUpRequestMessage {
		if (data instanceof TreasureHuntGiveUpRequestMessage) {
			return data
		}

		this.questType = data.questType

		return this
	}
}

export interface RawQuestListRequestMessage {
	id: number
}

export class QuestListRequestMessage extends DofusMessage {
	public static id: number = 7112

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public serialize(writer: BinaryWriter): void {}

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public deserialize(reader: BinaryReader): void {}

	public hydrate(
		data: QuestListRequestMessage | Record<string, any>
	): QuestListRequestMessage {
		if (data instanceof QuestListRequestMessage) {
			return data
		}

		return this
	}
}

export interface RawQuestStepInfoRequestMessage {
	id: number
	questId: number
}

export class QuestStepInfoRequestMessage extends DofusMessage {
	public static id: number = 2214

	public questId: number | undefined = 0

	public constructor(questId?: number | undefined) {
		super()
		this.questId = questId
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarShort(this.questId!)
	}

	public deserialize(reader: BinaryReader): void {
		this.questId = reader.readVarShort()
	}

	public hydrate(
		data: QuestStepInfoRequestMessage | Record<string, any>
	): QuestStepInfoRequestMessage {
		if (data instanceof QuestStepInfoRequestMessage) {
			return data
		}

		this.questId = data.questId

		return this
	}
}

export interface RawFollowQuestObjectiveRequestMessage {
	id: number
	questId: number
	objectiveId: number
}

export class FollowQuestObjectiveRequestMessage extends DofusMessage {
	public static id: number = 2378

	public questId: number | undefined = 0
	public objectiveId: number | undefined = 0

	public constructor(
		questId?: number | undefined,
		objectiveId?: number | undefined
	) {
		super()
		this.questId = questId
		this.objectiveId = objectiveId
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarShort(this.questId!)
		writer.writeShort(this.objectiveId!)
	}

	public deserialize(reader: BinaryReader): void {
		this.questId = reader.readVarShort()
		this.objectiveId = reader.readShort()
	}

	public hydrate(
		data: FollowQuestObjectiveRequestMessage | Record<string, any>
	): FollowQuestObjectiveRequestMessage {
		if (data instanceof FollowQuestObjectiveRequestMessage) {
			return data
		}

		this.questId = data.questId
		this.objectiveId = data.objectiveId

		return this
	}
}

export interface RawAchievementRewardRequestMessage {
	id: number
	achievementId: number
}

export class AchievementRewardRequestMessage extends DofusMessage {
	public static id: number = 795

	public achievementId: number | undefined = 0

	public constructor(achievementId?: number | undefined) {
		super()
		this.achievementId = achievementId
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeShort(this.achievementId!)
	}

	public deserialize(reader: BinaryReader): void {
		this.achievementId = reader.readShort()
	}

	public hydrate(
		data: AchievementRewardRequestMessage | Record<string, any>
	): AchievementRewardRequestMessage {
		if (data instanceof AchievementRewardRequestMessage) {
			return data
		}

		this.achievementId = data.achievementId

		return this
	}
}

export interface RawNotificationUpdateFlagMessage {
	id: number
	index: number
}

export class NotificationUpdateFlagMessage extends DofusMessage {
	public static id: number = 534

	public index: number | undefined = 0

	public constructor(index?: number | undefined) {
		super()
		this.index = index
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarShort(this.index!)
	}

	public deserialize(reader: BinaryReader): void {
		this.index = reader.readVarShort()
	}

	public hydrate(
		data: NotificationUpdateFlagMessage | Record<string, any>
	): NotificationUpdateFlagMessage {
		if (data instanceof NotificationUpdateFlagMessage) {
			return data
		}

		this.index = data.index

		return this
	}
}

export interface RawQuestObjectiveValidationMessage {
	id: number
	questId: number
	objectiveId: number
}

export class QuestObjectiveValidationMessage extends DofusMessage {
	public static id: number = 6610

	public questId: number | undefined = 0
	public objectiveId: number | undefined = 0

	public constructor(
		questId?: number | undefined,
		objectiveId?: number | undefined
	) {
		super()
		this.questId = questId
		this.objectiveId = objectiveId
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarShort(this.questId!)
		writer.writeVarShort(this.objectiveId!)
	}

	public deserialize(reader: BinaryReader): void {
		this.questId = reader.readVarShort()
		this.objectiveId = reader.readVarShort()
	}

	public hydrate(
		data: QuestObjectiveValidationMessage | Record<string, any>
	): QuestObjectiveValidationMessage {
		if (data instanceof QuestObjectiveValidationMessage) {
			return data
		}

		this.questId = data.questId
		this.objectiveId = data.objectiveId

		return this
	}
}

export interface RawAchievementDetailsRequestMessage {
	id: number
	achievementId: number
}

export class AchievementDetailsRequestMessage extends DofusMessage {
	public static id: number = 5403

	public achievementId: number | undefined = 0

	public constructor(achievementId?: number | undefined) {
		super()
		this.achievementId = achievementId
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarShort(this.achievementId!)
	}

	public deserialize(reader: BinaryReader): void {
		this.achievementId = reader.readVarShort()
	}

	public hydrate(
		data: AchievementDetailsRequestMessage | Record<string, any>
	): AchievementDetailsRequestMessage {
		if (data instanceof AchievementDetailsRequestMessage) {
			return data
		}

		this.achievementId = data.achievementId

		return this
	}
}

export interface RawRefreshFollowedQuestsOrderRequestMessage {
	id: number
	quests: number[]
}

export class RefreshFollowedQuestsOrderRequestMessage extends DofusMessage {
	public static id: number = 1822

	public quests: number[] | undefined

	public constructor(quests?: number[] | undefined) {
		super()
		this.quests = quests
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeShort(this.quests!.length)
		this.quests!.forEach((current: number) => writer.writeVarShort(current))
	}

	public deserialize(reader: BinaryReader): void {
		this.quests = []
		const countQuests = reader.readShort()
		for (let i: number = 0; i < countQuests; i++) {
			this.quests.push(reader.readVarShort())
		}
	}

	public hydrate(
		data: RefreshFollowedQuestsOrderRequestMessage | Record<string, any>
	): RefreshFollowedQuestsOrderRequestMessage {
		if (data instanceof RefreshFollowedQuestsOrderRequestMessage) {
			return data
		}

		this.quests = data.quests

		return this
	}
}

export interface RawQuestStartRequestMessage {
	id: number
	questId: number
}

export class QuestStartRequestMessage extends DofusMessage {
	public static id: number = 6177

	public questId: number | undefined = 0

	public constructor(questId?: number | undefined) {
		super()
		this.questId = questId
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarShort(this.questId!)
	}

	public deserialize(reader: BinaryReader): void {
		this.questId = reader.readVarShort()
	}

	public hydrate(
		data: QuestStartRequestMessage | Record<string, any>
	): QuestStartRequestMessage {
		if (data instanceof QuestStartRequestMessage) {
			return data
		}

		this.questId = data.questId

		return this
	}
}

export interface RawAchievementDetailedListRequestMessage {
	id: number
	categoryId: number
}

export class AchievementDetailedListRequestMessage extends DofusMessage {
	public static id: number = 8751

	public categoryId: number | undefined = 0

	public constructor(categoryId?: number | undefined) {
		super()
		this.categoryId = categoryId
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarShort(this.categoryId!)
	}

	public deserialize(reader: BinaryReader): void {
		this.categoryId = reader.readVarShort()
	}

	public hydrate(
		data: AchievementDetailedListRequestMessage | Record<string, any>
	): AchievementDetailedListRequestMessage {
		if (data instanceof AchievementDetailedListRequestMessage) {
			return data
		}

		this.categoryId = data.categoryId

		return this
	}
}

export interface RawTreasureHuntDigRequestMessage {
	id: number
	questType: number
}

export class TreasureHuntDigRequestMessage extends DofusMessage {
	public static id: number = 2632

	public questType: number | undefined = 0

	public constructor(questType?: number | undefined) {
		super()
		this.questType = questType
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeByte(this.questType!)
	}

	public deserialize(reader: BinaryReader): void {
		this.questType = reader.readByte()
	}

	public hydrate(
		data: TreasureHuntDigRequestMessage | Record<string, any>
	): TreasureHuntDigRequestMessage {
		if (data instanceof TreasureHuntDigRequestMessage) {
			return data
		}

		this.questType = data.questType

		return this
	}
}

export interface RawAuthenticationTicketMessage {
	id: number
	lang: string
	ticket: string
}

export class AuthenticationTicketMessage extends DofusMessage {
	public static id: number = 3503

	public lang: string | undefined
	public ticket: string | undefined

	public constructor(lang?: string | undefined, ticket?: string | undefined) {
		super()
		this.lang = lang
		this.ticket = ticket
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeUTF(this.lang!)
		writer.writeUTF(this.ticket!)
	}

	public deserialize(reader: BinaryReader): void {
		this.lang = reader.readUTF()
		this.ticket = reader.readUTF()
	}

	public hydrate(
		data: AuthenticationTicketMessage | Record<string, any>
	): AuthenticationTicketMessage {
		if (data instanceof AuthenticationTicketMessage) {
			return data
		}

		this.lang = data.lang
		this.ticket = data.ticket

		return this
	}
}

export interface RawCharacterSelectionMessage {
	id: number
	id_: number
}

export class CharacterSelectionMessage extends DofusMessage {
	public static id: number = 4312

	public id_: number | undefined = 0

	public constructor(id_?: number | undefined) {
		super()
		this.id_ = id_
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarLong(this.id_!)
	}

	public deserialize(reader: BinaryReader): void {
		this.id_ = reader.readVarLong()
	}

	public hydrate(
		data: CharacterSelectionMessage | Record<string, any>
	): CharacterSelectionMessage {
		if (data instanceof CharacterSelectionMessage) {
			return data
		}

		this.id_ = data.id_

		return this
	}
}

export interface RawCharacterSelectionWithRemodelMessage
	extends RawCharacterSelectionMessage {
	id: number
	remodel: RemodelingInformation
}

export class CharacterSelectionWithRemodelMessage extends CharacterSelectionMessage {
	public static id = 3592

	public remodel: RemodelingInformation | undefined

	public constructor(
		id_?: number | undefined,
		remodel?: RemodelingInformation | undefined
	) {
		super(id_)
		this.remodel = remodel
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		this.remodel!.serialize(writer)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.remodel = new RemodelingInformation()
		this.remodel!.deserialize(reader)
	}

	public hydrate(
		data: CharacterSelectionWithRemodelMessage | Record<string, any>
	): CharacterSelectionWithRemodelMessage {
		if (data instanceof CharacterSelectionWithRemodelMessage) {
			return data
		}

		super.hydrate(data)

		this.remodel = new RemodelingInformation().hydrate(data.remodel)

		return this
	}
}

export interface RawCharacterNameSuggestionRequestMessage {
	id: number
}

export class CharacterNameSuggestionRequestMessage extends DofusMessage {
	public static id: number = 1741

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public serialize(writer: BinaryWriter): void {}

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public deserialize(reader: BinaryReader): void {}

	public hydrate(
		data: CharacterNameSuggestionRequestMessage | Record<string, any>
	): CharacterNameSuggestionRequestMessage {
		if (data instanceof CharacterNameSuggestionRequestMessage) {
			return data
		}

		return this
	}
}

export interface RawCharacterSelectedForceReadyMessage {
	id: number
}

export class CharacterSelectedForceReadyMessage extends DofusMessage {
	public static id: number = 5754

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public serialize(writer: BinaryWriter): void {}

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public deserialize(reader: BinaryReader): void {}

	public hydrate(
		data: CharacterSelectedForceReadyMessage | Record<string, any>
	): CharacterSelectedForceReadyMessage {
		if (data instanceof CharacterSelectedForceReadyMessage) {
			return data
		}

		return this
	}
}

export interface RawCharactersListRequestMessage {
	id: number
}

export class CharactersListRequestMessage extends DofusMessage {
	public static id: number = 5450

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public serialize(writer: BinaryWriter): void {}

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public deserialize(reader: BinaryReader): void {}

	public hydrate(
		data: CharactersListRequestMessage | Record<string, any>
	): CharactersListRequestMessage {
		if (data instanceof CharactersListRequestMessage) {
			return data
		}

		return this
	}
}

export interface RawCharacterCreationRequestMessage {
	id: number
	name: string
	breed: number
	sex: boolean
	colors: number[]
	cosmeticId: number
}

export class CharacterCreationRequestMessage extends DofusMessage {
	public static id: number = 774

	public name: string | undefined
	public breed: number | undefined = 0
	public sex: boolean | undefined = false
	public colors: number[] | undefined
	public cosmeticId: number | undefined = 0

	public constructor(
		name?: string | undefined,
		breed?: number | undefined,
		sex?: boolean | undefined,
		colors?: number[] | undefined,
		cosmeticId?: number | undefined
	) {
		super()
		this.name = name
		this.breed = breed
		this.sex = sex
		this.colors = colors
		this.cosmeticId = cosmeticId
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeUTF(this.name!)
		writer.writeByte(this.breed!)
		writer.writeBoolean(this.sex!)
		this.colors!.forEach((current: number) => writer.writeInt(current))
		writer.writeVarShort(this.cosmeticId!)
	}

	public deserialize(reader: BinaryReader): void {
		this.name = reader.readUTF()
		this.breed = reader.readByte()
		this.sex = reader.readBoolean()
		this.colors = []
		for (let i: number = 0; i < 5; i++) {
			this.colors.push(reader.readInt())
		}
		this.cosmeticId = reader.readVarShort()
	}

	public hydrate(
		data: CharacterCreationRequestMessage | Record<string, any>
	): CharacterCreationRequestMessage {
		if (data instanceof CharacterCreationRequestMessage) {
			return data
		}

		this.name = data.name
		this.breed = data.breed
		this.sex = data.sex
		this.colors = data.colors
		this.cosmeticId = data.cosmeticId

		return this
	}
}

export interface RawCharacterCanBeCreatedRequestMessage {
	id: number
}

export class CharacterCanBeCreatedRequestMessage extends DofusMessage {
	public static id: number = 2372

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public serialize(writer: BinaryWriter): void {}

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public deserialize(reader: BinaryReader): void {}

	public hydrate(
		data: CharacterCanBeCreatedRequestMessage | Record<string, any>
	): CharacterCanBeCreatedRequestMessage {
		if (data instanceof CharacterCanBeCreatedRequestMessage) {
			return data
		}

		return this
	}
}

export interface RawCharacterReplayRequestMessage {
	id: number
	characterId: number
}

export class CharacterReplayRequestMessage extends DofusMessage {
	public static id: number = 9005

	public characterId: number | undefined = 0

	public constructor(characterId?: number | undefined) {
		super()
		this.characterId = characterId
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarLong(this.characterId!)
	}

	public deserialize(reader: BinaryReader): void {
		this.characterId = reader.readVarLong()
	}

	public hydrate(
		data: CharacterReplayRequestMessage | Record<string, any>
	): CharacterReplayRequestMessage {
		if (data instanceof CharacterReplayRequestMessage) {
			return data
		}

		this.characterId = data.characterId

		return this
	}
}

export interface RawCharacterReplayWithRemodelRequestMessage
	extends RawCharacterReplayRequestMessage {
	id: number
	remodel: RemodelingInformation
}

export class CharacterReplayWithRemodelRequestMessage extends CharacterReplayRequestMessage {
	public static id = 8678

	public remodel: RemodelingInformation | undefined

	public constructor(
		characterId?: number | undefined,
		remodel?: RemodelingInformation | undefined
	) {
		super(characterId)
		this.remodel = remodel
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		this.remodel!.serialize(writer)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.remodel = new RemodelingInformation()
		this.remodel!.deserialize(reader)
	}

	public hydrate(
		data: CharacterReplayWithRemodelRequestMessage | Record<string, any>
	): CharacterReplayWithRemodelRequestMessage {
		if (data instanceof CharacterReplayWithRemodelRequestMessage) {
			return data
		}

		super.hydrate(data)

		this.remodel = new RemodelingInformation().hydrate(data.remodel)

		return this
	}
}

export interface RawStartupActionsObjetAttributionMessage {
	id: number
	actionId: number
	characterId: number
}

export class StartupActionsObjetAttributionMessage extends DofusMessage {
	public static id: number = 9830

	public actionId: number | undefined = 0
	public characterId: number | undefined = 0

	public constructor(
		actionId?: number | undefined,
		characterId?: number | undefined
	) {
		super()
		this.actionId = actionId
		this.characterId = characterId
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeInt(this.actionId!)
		writer.writeVarLong(this.characterId!)
	}

	public deserialize(reader: BinaryReader): void {
		this.actionId = reader.readInt()
		this.characterId = reader.readVarLong()
	}

	public hydrate(
		data: StartupActionsObjetAttributionMessage | Record<string, any>
	): StartupActionsObjetAttributionMessage {
		if (data instanceof StartupActionsObjetAttributionMessage) {
			return data
		}

		this.actionId = data.actionId
		this.characterId = data.characterId

		return this
	}
}

export interface RawStartupActionsExecuteMessage {
	id: number
}

export class StartupActionsExecuteMessage extends DofusMessage {
	public static id: number = 5775

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public serialize(writer: BinaryWriter): void {}

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public deserialize(reader: BinaryReader): void {}

	public hydrate(
		data: StartupActionsExecuteMessage | Record<string, any>
	): StartupActionsExecuteMessage {
		if (data instanceof StartupActionsExecuteMessage) {
			return data
		}

		return this
	}
}

export interface RawCharacterFirstSelectionMessage
	extends RawCharacterSelectionMessage {
	id: number
	doTutorial: boolean
}

export class CharacterFirstSelectionMessage extends CharacterSelectionMessage {
	public static id = 1225

	public doTutorial: boolean | undefined = false

	public constructor(
		id_?: number | undefined,
		doTutorial?: boolean | undefined
	) {
		super(id_)
		this.doTutorial = doTutorial
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeBoolean(this.doTutorial!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.doTutorial = reader.readBoolean()
	}

	public hydrate(
		data: CharacterFirstSelectionMessage | Record<string, any>
	): CharacterFirstSelectionMessage {
		if (data instanceof CharacterFirstSelectionMessage) {
			return data
		}

		super.hydrate(data)

		this.doTutorial = data.doTutorial

		return this
	}
}

export interface RawGameContextCreateRequestMessage {
	id: number
}

export class GameContextCreateRequestMessage extends DofusMessage {
	public static id: number = 6738

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public serialize(writer: BinaryWriter): void {}

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public deserialize(reader: BinaryReader): void {}

	public hydrate(
		data: GameContextCreateRequestMessage | Record<string, any>
	): GameContextCreateRequestMessage {
		if (data instanceof GameContextCreateRequestMessage) {
			return data
		}

		return this
	}
}

export interface RawCharacterDeletionRequestMessage {
	id: number
	characterId: number
	secretAnswerHash: string
}

export class CharacterDeletionRequestMessage extends DofusMessage {
	public static id: number = 7199

	public characterId: number | undefined = 0
	public secretAnswerHash: string | undefined

	public constructor(
		characterId?: number | undefined,
		secretAnswerHash?: string | undefined
	) {
		super()
		this.characterId = characterId
		this.secretAnswerHash = secretAnswerHash
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarLong(this.characterId!)
		writer.writeUTF(this.secretAnswerHash!)
	}

	public deserialize(reader: BinaryReader): void {
		this.characterId = reader.readVarLong()
		this.secretAnswerHash = reader.readUTF()
	}

	public hydrate(
		data: CharacterDeletionRequestMessage | Record<string, any>
	): CharacterDeletionRequestMessage {
		if (data instanceof CharacterDeletionRequestMessage) {
			return data
		}

		this.characterId = data.characterId
		this.secretAnswerHash = data.secretAnswerHash

		return this
	}
}

export interface RawAcquaintanceSearchMessage {
	id: number
	nickname: string
}

export class AcquaintanceSearchMessage extends DofusMessage {
	public static id: number = 4981

	public nickname: string | undefined

	public constructor(nickname?: string | undefined) {
		super()
		this.nickname = nickname
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeUTF(this.nickname!)
	}

	public deserialize(reader: BinaryReader): void {
		this.nickname = reader.readUTF()
	}

	public hydrate(
		data: AcquaintanceSearchMessage | Record<string, any>
	): AcquaintanceSearchMessage {
		if (data instanceof AcquaintanceSearchMessage) {
			return data
		}

		this.nickname = data.nickname

		return this
	}
}

export interface RawServerSelectionMessage {
	id: number
	serverId: number
}

export class ServerSelectionMessage extends DofusMessage {
	public static id: number = 6291

	public serverId: number | undefined = 0

	public constructor(serverId?: number | undefined) {
		super()
		this.serverId = serverId
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarShort(this.serverId!)
	}

	public deserialize(reader: BinaryReader): void {
		this.serverId = reader.readVarShort()
	}

	public hydrate(
		data: ServerSelectionMessage | Record<string, any>
	): ServerSelectionMessage {
		if (data instanceof ServerSelectionMessage) {
			return data
		}

		this.serverId = data.serverId

		return this
	}
}

export interface RawCheckFileMessage {
	id: number
	filenameHash: string
	type: number
	value: string
}

export class CheckFileMessage extends DofusMessage {
	public static id: number = 1

	public filenameHash: string | undefined
	public type: number | undefined = 0
	public value: string | undefined

	public constructor(
		filenameHash?: string | undefined,
		type?: number | undefined,
		value?: string | undefined
	) {
		super()
		this.filenameHash = filenameHash
		this.type = type
		this.value = value
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeUTF(this.filenameHash!)
		writer.writeByte(this.type!)
		writer.writeUTF(this.value!)
	}

	public deserialize(reader: BinaryReader): void {
		this.filenameHash = reader.readUTF()
		this.type = reader.readByte()
		this.value = reader.readUTF()
	}

	public hydrate(
		data: CheckFileMessage | Record<string, any>
	): CheckFileMessage {
		if (data instanceof CheckFileMessage) {
			return data
		}

		this.filenameHash = data.filenameHash
		this.type = data.type
		this.value = data.value

		return this
	}
}

export interface RawResetCharacterStatsRequestMessage {
	id: number
}

export class ResetCharacterStatsRequestMessage extends DofusMessage {
	public static id: number = 7828

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public serialize(writer: BinaryWriter): void {}

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public deserialize(reader: BinaryReader): void {}

	public hydrate(
		data: ResetCharacterStatsRequestMessage | Record<string, any>
	): ResetCharacterStatsRequestMessage {
		if (data instanceof ResetCharacterStatsRequestMessage) {
			return data
		}

		return this
	}
}

export interface RawStatsUpgradeRequestMessage {
	id: number
	useAdditionnal: boolean
	statId: number
	boostPoint: number
}

export class StatsUpgradeRequestMessage extends DofusMessage {
	public static id: number = 2564

	public useAdditionnal: boolean | undefined = false
	public statId: number | undefined = 11
	public boostPoint: number | undefined = 0

	public constructor(
		useAdditionnal?: boolean | undefined,
		statId?: number | undefined,
		boostPoint?: number | undefined
	) {
		super()
		this.useAdditionnal = useAdditionnal
		this.statId = statId
		this.boostPoint = boostPoint
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeBoolean(this.useAdditionnal!)
		writer.writeByte(this.statId!)
		writer.writeVarShort(this.boostPoint!)
	}

	public deserialize(reader: BinaryReader): void {
		this.useAdditionnal = reader.readBoolean()
		this.statId = reader.readByte()
		this.boostPoint = reader.readVarShort()
	}

	public hydrate(
		data: StatsUpgradeRequestMessage | Record<string, any>
	): StatsUpgradeRequestMessage {
		if (data instanceof StatsUpgradeRequestMessage) {
			return data
		}

		this.useAdditionnal = data.useAdditionnal
		this.statId = data.statId
		this.boostPoint = data.boostPoint

		return this
	}
}

export interface RawStartupActionsAllAttributionMessage {
	id: number
	characterId: number
}

export class StartupActionsAllAttributionMessage extends DofusMessage {
	public static id: number = 6836

	public characterId: number | undefined = 0

	public constructor(characterId?: number | undefined) {
		super()
		this.characterId = characterId
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarLong(this.characterId!)
	}

	public deserialize(reader: BinaryReader): void {
		this.characterId = reader.readVarLong()
	}

	public hydrate(
		data: StartupActionsAllAttributionMessage | Record<string, any>
	): StartupActionsAllAttributionMessage {
		if (data instanceof StartupActionsAllAttributionMessage) {
			return data
		}

		this.characterId = data.characterId

		return this
	}
}

export interface RawPaddockToSellListRequestMessage {
	id: number
	pageIndex: number
}

export class PaddockToSellListRequestMessage extends DofusMessage {
	public static id: number = 6059

	public pageIndex: number | undefined = 0

	public constructor(pageIndex?: number | undefined) {
		super()
		this.pageIndex = pageIndex
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarShort(this.pageIndex!)
	}

	public deserialize(reader: BinaryReader): void {
		this.pageIndex = reader.readVarShort()
	}

	public hydrate(
		data: PaddockToSellListRequestMessage | Record<string, any>
	): PaddockToSellListRequestMessage {
		if (data instanceof PaddockToSellListRequestMessage) {
			return data
		}

		this.pageIndex = data.pageIndex

		return this
	}
}

export interface RawPaddockToSellFilterMessage {
	id: number
	areaId: number
	atLeastNbMount: number
	atLeastNbMachine: number
	maxPrice: number
	orderBy: number
}

export class PaddockToSellFilterMessage extends DofusMessage {
	public static id: number = 1885

	public areaId: number | undefined = 0
	public atLeastNbMount: number | undefined = 0
	public atLeastNbMachine: number | undefined = 0
	public maxPrice: number | undefined = 0
	public orderBy: number | undefined = 0

	public constructor(
		areaId?: number | undefined,
		atLeastNbMount?: number | undefined,
		atLeastNbMachine?: number | undefined,
		maxPrice?: number | undefined,
		orderBy?: number | undefined
	) {
		super()
		this.areaId = areaId
		this.atLeastNbMount = atLeastNbMount
		this.atLeastNbMachine = atLeastNbMachine
		this.maxPrice = maxPrice
		this.orderBy = orderBy
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeInt(this.areaId!)
		writer.writeByte(this.atLeastNbMount!)
		writer.writeByte(this.atLeastNbMachine!)
		writer.writeVarLong(this.maxPrice!)
		writer.writeByte(this.orderBy!)
	}

	public deserialize(reader: BinaryReader): void {
		this.areaId = reader.readInt()
		this.atLeastNbMount = reader.readByte()
		this.atLeastNbMachine = reader.readByte()
		this.maxPrice = reader.readVarLong()
		this.orderBy = reader.readByte()
	}

	public hydrate(
		data: PaddockToSellFilterMessage | Record<string, any>
	): PaddockToSellFilterMessage {
		if (data instanceof PaddockToSellFilterMessage) {
			return data
		}

		this.areaId = data.areaId
		this.atLeastNbMount = data.atLeastNbMount
		this.atLeastNbMachine = data.atLeastNbMachine
		this.maxPrice = data.maxPrice
		this.orderBy = data.orderBy

		return this
	}
}

export interface RawHouseToSellListRequestMessage {
	id: number
	pageIndex: number
}

export class HouseToSellListRequestMessage extends DofusMessage {
	public static id: number = 5809

	public pageIndex: number | undefined = 0

	public constructor(pageIndex?: number | undefined) {
		super()
		this.pageIndex = pageIndex
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarShort(this.pageIndex!)
	}

	public deserialize(reader: BinaryReader): void {
		this.pageIndex = reader.readVarShort()
	}

	public hydrate(
		data: HouseToSellListRequestMessage | Record<string, any>
	): HouseToSellListRequestMessage {
		if (data instanceof HouseToSellListRequestMessage) {
			return data
		}

		this.pageIndex = data.pageIndex

		return this
	}
}

export interface RawHouseToSellFilterMessage {
	id: number
	areaId: number
	atLeastNbRoom: number
	atLeastNbChest: number
	skillRequested: number
	maxPrice: number
	orderBy: number
}

export class HouseToSellFilterMessage extends DofusMessage {
	public static id: number = 7868

	public areaId: number | undefined = 0
	public atLeastNbRoom: number | undefined = 0
	public atLeastNbChest: number | undefined = 0
	public skillRequested: number | undefined = 0
	public maxPrice: number | undefined = 0
	public orderBy: number | undefined = 0

	public constructor(
		areaId?: number | undefined,
		atLeastNbRoom?: number | undefined,
		atLeastNbChest?: number | undefined,
		skillRequested?: number | undefined,
		maxPrice?: number | undefined,
		orderBy?: number | undefined
	) {
		super()
		this.areaId = areaId
		this.atLeastNbRoom = atLeastNbRoom
		this.atLeastNbChest = atLeastNbChest
		this.skillRequested = skillRequested
		this.maxPrice = maxPrice
		this.orderBy = orderBy
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeInt(this.areaId!)
		writer.writeByte(this.atLeastNbRoom!)
		writer.writeByte(this.atLeastNbChest!)
		writer.writeVarShort(this.skillRequested!)
		writer.writeVarLong(this.maxPrice!)
		writer.writeByte(this.orderBy!)
	}

	public deserialize(reader: BinaryReader): void {
		this.areaId = reader.readInt()
		this.atLeastNbRoom = reader.readByte()
		this.atLeastNbChest = reader.readByte()
		this.skillRequested = reader.readVarShort()
		this.maxPrice = reader.readVarLong()
		this.orderBy = reader.readByte()
	}

	public hydrate(
		data: HouseToSellFilterMessage | Record<string, any>
	): HouseToSellFilterMessage {
		if (data instanceof HouseToSellFilterMessage) {
			return data
		}

		this.areaId = data.areaId
		this.atLeastNbRoom = data.atLeastNbRoom
		this.atLeastNbChest = data.atLeastNbChest
		this.skillRequested = data.skillRequested
		this.maxPrice = data.maxPrice
		this.orderBy = data.orderBy

		return this
	}
}

export interface RawAdminQuietCommandMessage extends RawAdminCommandMessage {
	id: number
}

export class AdminQuietCommandMessage extends AdminCommandMessage {
	public static id = 7816

	public constructor(content?: string | undefined) {
		super(content)
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
	}

	public hydrate(
		data: AdminQuietCommandMessage | Record<string, any>
	): AdminQuietCommandMessage {
		if (data instanceof AdminQuietCommandMessage) {
			return data
		}

		super.hydrate(data)

		return this
	}
}

export interface RawSetEnablePVPRequestMessage {
	id: number
	enable: boolean
}

export class SetEnablePVPRequestMessage extends DofusMessage {
	public static id: number = 8131

	public enable: boolean | undefined = false

	public constructor(enable?: boolean | undefined) {
		super()
		this.enable = enable
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeBoolean(this.enable!)
	}

	public deserialize(reader: BinaryReader): void {
		this.enable = reader.readBoolean()
	}

	public hydrate(
		data: SetEnablePVPRequestMessage | Record<string, any>
	): SetEnablePVPRequestMessage {
		if (data instanceof SetEnablePVPRequestMessage) {
			return data
		}

		this.enable = data.enable

		return this
	}
}

export interface RawCharacterAlignmentWarEffortProgressionRequestMessage {
	id: number
}

export class CharacterAlignmentWarEffortProgressionRequestMessage extends DofusMessage {
	public static id: number = 6202

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public serialize(writer: BinaryWriter): void {}

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public deserialize(reader: BinaryReader): void {}

	public hydrate(
		data:
			| CharacterAlignmentWarEffortProgressionRequestMessage
			| Record<string, any>
	): CharacterAlignmentWarEffortProgressionRequestMessage {
		if (data instanceof CharacterAlignmentWarEffortProgressionRequestMessage) {
			return data
		}

		return this
	}
}

export interface RawAlignmentWarEffortDonateRequestMessage {
	id: number
	donation: number
}

export class AlignmentWarEffortDonateRequestMessage extends DofusMessage {
	public static id: number = 8514

	public donation: number | undefined = 0

	public constructor(donation?: number | undefined) {
		super()
		this.donation = donation
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarLong(this.donation!)
	}

	public deserialize(reader: BinaryReader): void {
		this.donation = reader.readVarLong()
	}

	public hydrate(
		data: AlignmentWarEffortDonateRequestMessage | Record<string, any>
	): AlignmentWarEffortDonateRequestMessage {
		if (data instanceof AlignmentWarEffortDonateRequestMessage) {
			return data
		}

		this.donation = data.donation

		return this
	}
}

export interface RawAlignmentWarEffortProgressionRequestMessage {
	id: number
}

export class AlignmentWarEffortProgressionRequestMessage extends DofusMessage {
	public static id: number = 8769

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public serialize(writer: BinaryWriter): void {}

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public deserialize(reader: BinaryReader): void {}

	public hydrate(
		data: AlignmentWarEffortProgressionRequestMessage | Record<string, any>
	): AlignmentWarEffortProgressionRequestMessage {
		if (data instanceof AlignmentWarEffortProgressionRequestMessage) {
			return data
		}

		return this
	}
}

export interface RawObjectAveragePricesGetMessage {
	id: number
}

export class ObjectAveragePricesGetMessage extends DofusMessage {
	public static id: number = 9304

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public serialize(writer: BinaryWriter): void {}

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public deserialize(reader: BinaryReader): void {}

	public hydrate(
		data: ObjectAveragePricesGetMessage | Record<string, any>
	): ObjectAveragePricesGetMessage {
		if (data instanceof ObjectAveragePricesGetMessage) {
			return data
		}

		return this
	}
}

export interface RawReloginTokenRequestMessage {
	id: number
}

export class ReloginTokenRequestMessage extends DofusMessage {
	public static id: number = 567

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public serialize(writer: BinaryWriter): void {}

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public deserialize(reader: BinaryReader): void {}

	public hydrate(
		data: ReloginTokenRequestMessage | Record<string, any>
	): ReloginTokenRequestMessage {
		if (data instanceof ReloginTokenRequestMessage) {
			return data
		}

		return this
	}
}

export class CharacterDeletionPrepareRequestMessage extends DofusMessage {
	public static id: number = 9338

	public characterId: number | undefined = 0

	public constructor(characterId?: number | undefined) {
		super()
		this.characterId = characterId
	}

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public serialize(writer: BinaryWriter): void {
		writer.writeVarLong(this.characterId!)
	}

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public deserialize(reader: BinaryReader): void {
		this.characterId = reader.readVarUhLong()
	}

	public hydrate(
		data: CharacterDeletionPrepareRequestMessage | Record<string, any>
	): CharacterDeletionPrepareRequestMessage {
		if (data instanceof CharacterDeletionPrepareRequestMessage) {
			return data
		}

		this.characterId = data.characterId

		return this
	}
}
export class CharacterDeletionPrepareMessage extends DofusMessage {
	public static id: number = 4740

	public characterId: number | undefined = 0
	public characterName: string | undefined = ""
	public secretQuestion: string | undefined = ""
	public needSecretAnswer: boolean | undefined = false

	public constructor(
		characterId?: number | undefined,
		characterName?: string | undefined,
		secretQuestion?: string | undefined,
		needSecretAnswer?: boolean | undefined
	) {
		super()
		this.characterId = characterId
		this.characterName = characterName
		this.secretQuestion = secretQuestion
		this.needSecretAnswer = needSecretAnswer
	}

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public serialize(writer: BinaryWriter): void {
		writer.writeVarLong(this.characterId!)
		writer.writeUTF(this.characterName!)
		writer.writeUTF(this.secretQuestion!)
		writer.writeBoolean(this.needSecretAnswer!)
	}

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public deserialize(reader: BinaryReader): void {
		this.characterId = reader.readVarUhLong()
		this.characterName = reader.readUTF()
		this.secretQuestion = reader.readUTF()
		this.needSecretAnswer = reader.readBoolean()
	}

	public hydrate(
		data: CharacterDeletionPrepareMessage | Record<string, any>
	): CharacterDeletionPrepareMessage {
		if (data instanceof CharacterDeletionPrepareMessage) {
			return data
		}

		this.characterId = data.characterId
		this.characterName = data.characterName
		this.secretQuestion = data.secretQuestion
		this.needSecretAnswer = data.needSecretAnswer

		return this
	}
}

export interface RawAnomalySubareaInformationRequestMessage {
	id: number
}

export class AnomalySubareaInformationRequestMessage extends DofusMessage {
	public static id: number = 4375

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public serialize(writer: BinaryWriter): void {}

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public deserialize(reader: BinaryReader): void {}

	public hydrate(
		data: AnomalySubareaInformationRequestMessage | Record<string, any>
	): AnomalySubareaInformationRequestMessage {
		if (data instanceof AnomalySubareaInformationRequestMessage) {
			return data
		}

		return this
	}
}

export interface RawZaapRespawnSaveRequestMessage {
	id: number
}

export class ZaapRespawnSaveRequestMessage extends DofusMessage {
	public static id: number = 5772

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public serialize(writer: BinaryWriter): void {}

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public deserialize(reader: BinaryReader): void {}

	public hydrate(
		data: ZaapRespawnSaveRequestMessage | Record<string, any>
	): ZaapRespawnSaveRequestMessage {
		if (data instanceof ZaapRespawnSaveRequestMessage) {
			return data
		}

		return this
	}
}

export interface RawTeleportRequestMessage {
	id: number
	sourceType: number
	destinationType: number
	mapId: number
}

export class TeleportRequestMessage extends DofusMessage {
	public static id: number = 6400

	public sourceType: number | undefined = 0
	public destinationType: number | undefined = 0
	public mapId: number | undefined = 0

	public constructor(
		sourceType?: number | undefined,
		destinationType?: number | undefined,
		mapId?: number | undefined
	) {
		super()
		this.sourceType = sourceType
		this.destinationType = destinationType
		this.mapId = mapId
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeByte(this.sourceType!)
		writer.writeByte(this.destinationType!)
		writer.writeDouble(this.mapId!)
	}

	public deserialize(reader: BinaryReader): void {
		this.sourceType = reader.readByte()
		this.destinationType = reader.readByte()
		this.mapId = reader.readDouble()
	}

	public hydrate(
		data: TeleportRequestMessage | Record<string, any>
	): TeleportRequestMessage {
		if (data instanceof TeleportRequestMessage) {
			return data
		}

		this.sourceType = data.sourceType
		this.destinationType = data.destinationType
		this.mapId = data.mapId

		return this
	}
}

export interface RawJobCrafterDirectoryDefineSettingsMessage {
	id: number
	settings: JobCrafterDirectorySettings
}

export class JobCrafterDirectoryDefineSettingsMessage extends DofusMessage {
	public static id: number = 3149

	public settings: JobCrafterDirectorySettings | undefined

	public constructor(settings?: JobCrafterDirectorySettings | undefined) {
		super()
		this.settings = settings
	}

	public serialize(writer: BinaryWriter): void {
		this.settings!.serialize(writer)
	}

	public deserialize(reader: BinaryReader): void {
		this.settings = new JobCrafterDirectorySettings()
		this.settings!.deserialize(reader)
	}

	public hydrate(
		data: JobCrafterDirectoryDefineSettingsMessage | Record<string, any>
	): JobCrafterDirectoryDefineSettingsMessage {
		if (data instanceof JobCrafterDirectoryDefineSettingsMessage) {
			return data
		}

		this.settings = new JobCrafterDirectorySettings().hydrate(data.settings)

		return this
	}
}

export interface RawJobBookSubscribeRequestMessage {
	id: number
	jobIds: number[]
}

export class JobBookSubscribeRequestMessage extends DofusMessage {
	public static id: number = 4754

	public jobIds: number[] | undefined

	public constructor(jobIds?: number[] | undefined) {
		super()
		this.jobIds = jobIds
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeShort(this.jobIds!.length)
		this.jobIds!.forEach((current: number) => writer.writeByte(current))
	}

	public deserialize(reader: BinaryReader): void {
		this.jobIds = []
		const countJobIds = reader.readShort()
		for (let i: number = 0; i < countJobIds; i++) {
			this.jobIds.push(reader.readByte())
		}
	}

	public hydrate(
		data: JobBookSubscribeRequestMessage | Record<string, any>
	): JobBookSubscribeRequestMessage {
		if (data instanceof JobBookSubscribeRequestMessage) {
			return data
		}

		this.jobIds = data.jobIds

		return this
	}
}

export interface RawJobCrafterDirectoryListRequestMessage {
	id: number
	jobId: number
}

export class JobCrafterDirectoryListRequestMessage extends DofusMessage {
	public static id: number = 9508

	public jobId: number | undefined = 0

	public constructor(jobId?: number | undefined) {
		super()
		this.jobId = jobId
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeByte(this.jobId!)
	}

	public deserialize(reader: BinaryReader): void {
		this.jobId = reader.readByte()
	}

	public hydrate(
		data: JobCrafterDirectoryListRequestMessage | Record<string, any>
	): JobCrafterDirectoryListRequestMessage {
		if (data instanceof JobCrafterDirectoryListRequestMessage) {
			return data
		}

		this.jobId = data.jobId

		return this
	}
}

export interface RawExchangeObjectUseInWorkshopMessage {
	id: number
	objectUID: number
	quantity: number
}

export class ExchangeObjectUseInWorkshopMessage extends DofusMessage {
	public static id: number = 3123

	public objectUID: number | undefined = 0
	public quantity: number | undefined = 0

	public constructor(
		objectUID?: number | undefined,
		quantity?: number | undefined
	) {
		super()
		this.objectUID = objectUID
		this.quantity = quantity
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarInt(this.objectUID!)
		writer.writeVarInt(this.quantity!)
	}

	public deserialize(reader: BinaryReader): void {
		this.objectUID = reader.readVarInt()
		this.quantity = reader.readVarInt()
	}

	public hydrate(
		data: ExchangeObjectUseInWorkshopMessage | Record<string, any>
	): ExchangeObjectUseInWorkshopMessage {
		if (data instanceof ExchangeObjectUseInWorkshopMessage) {
			return data
		}

		this.objectUID = data.objectUID
		this.quantity = data.quantity

		return this
	}
}

export interface RawExchangeReplayStopMessage {
	id: number
}

export class ExchangeReplayStopMessage extends DofusMessage {
	public static id: number = 4712

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public serialize(writer: BinaryWriter): void {}

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public deserialize(reader: BinaryReader): void {}

	public hydrate(
		data: ExchangeReplayStopMessage | Record<string, any>
	): ExchangeReplayStopMessage {
		if (data instanceof ExchangeReplayStopMessage) {
			return data
		}

		return this
	}
}

export interface RawExchangeCraftCountRequestMessage {
	id: number
	count: number
}

export class ExchangeCraftCountRequestMessage extends DofusMessage {
	public static id: number = 3477

	public count: number | undefined = 0

	public constructor(count?: number | undefined) {
		super()
		this.count = count
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarInt(this.count!)
	}

	public deserialize(reader: BinaryReader): void {
		this.count = reader.readVarInt()
	}

	public hydrate(
		data: ExchangeCraftCountRequestMessage | Record<string, any>
	): ExchangeCraftCountRequestMessage {
		if (data instanceof ExchangeCraftCountRequestMessage) {
			return data
		}

		this.count = data.count

		return this
	}
}

export interface RawExchangeMultiCraftSetCrafterCanUseHisRessourcesMessage {
	id: number
	allow: boolean
}

export class ExchangeMultiCraftSetCrafterCanUseHisRessourcesMessage extends DofusMessage {
	public static id: number = 2252

	public allow: boolean | undefined = false

	public constructor(allow?: boolean | undefined) {
		super()
		this.allow = allow
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeBoolean(this.allow!)
	}

	public deserialize(reader: BinaryReader): void {
		this.allow = reader.readBoolean()
	}

	public hydrate(
		data:
			| ExchangeMultiCraftSetCrafterCanUseHisRessourcesMessage
			| Record<string, any>
	): ExchangeMultiCraftSetCrafterCanUseHisRessourcesMessage {
		if (
			data instanceof ExchangeMultiCraftSetCrafterCanUseHisRessourcesMessage
		) {
			return data
		}

		this.allow = data.allow

		return this
	}
}

export interface RawExchangeCraftPaymentModificationRequestMessage {
	id: number
	quantity: number
}

export class ExchangeCraftPaymentModificationRequestMessage extends DofusMessage {
	public static id: number = 9081

	public quantity: number | undefined = 0

	public constructor(quantity?: number | undefined) {
		super()
		this.quantity = quantity
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarLong(this.quantity!)
	}

	public deserialize(reader: BinaryReader): void {
		this.quantity = reader.readVarLong()
	}

	public hydrate(
		data: ExchangeCraftPaymentModificationRequestMessage | Record<string, any>
	): ExchangeCraftPaymentModificationRequestMessage {
		if (data instanceof ExchangeCraftPaymentModificationRequestMessage) {
			return data
		}

		this.quantity = data.quantity

		return this
	}
}

export interface RawExchangeSetCraftRecipeMessage {
	id: number
	objectGID: number
}

export class ExchangeSetCraftRecipeMessage extends DofusMessage {
	public static id: number = 6059

	public objectGID: number | undefined = 0

	public constructor(objectGID?: number | undefined) {
		super()
		this.objectGID = objectGID
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarShort(this.objectGID!)
	}

	public deserialize(reader: BinaryReader): void {
		this.objectGID = reader.readVarShort()
	}

	public hydrate(
		data: ExchangeSetCraftRecipeMessage | Record<string, any>
	): ExchangeSetCraftRecipeMessage {
		if (data instanceof ExchangeSetCraftRecipeMessage) {
			return data
		}

		this.objectGID = data.objectGID

		return this
	}
}

export interface RawMountSetXpRatioRequestMessage {
	id: number
	xpRatio: number
}

export class MountSetXpRatioRequestMessage extends DofusMessage {
	public static id: number = 4796

	public xpRatio: number | undefined = 0

	public constructor(xpRatio?: number | undefined) {
		super()
		this.xpRatio = xpRatio
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeByte(this.xpRatio!)
	}

	public deserialize(reader: BinaryReader): void {
		this.xpRatio = reader.readByte()
	}

	public hydrate(
		data: MountSetXpRatioRequestMessage | Record<string, any>
	): MountSetXpRatioRequestMessage {
		if (data instanceof MountSetXpRatioRequestMessage) {
			return data
		}

		this.xpRatio = data.xpRatio

		return this
	}
}

export interface RawMountHarnessDissociateRequestMessage {
	id: number
}

export class MountHarnessDissociateRequestMessage extends DofusMessage {
	public static id: number = 3596

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public serialize(writer: BinaryWriter): void {}

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public deserialize(reader: BinaryReader): void {}

	public hydrate(
		data: MountHarnessDissociateRequestMessage | Record<string, any>
	): MountHarnessDissociateRequestMessage {
		if (data instanceof MountHarnessDissociateRequestMessage) {
			return data
		}

		return this
	}
}

export interface RawMountInformationInPaddockRequestMessage {
	id: number
	mapRideId: number
}

export class MountInformationInPaddockRequestMessage extends DofusMessage {
	public static id: number = 6271

	public mapRideId: number | undefined = 0

	public constructor(mapRideId?: number | undefined) {
		super()
		this.mapRideId = mapRideId
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarInt(this.mapRideId!)
	}

	public deserialize(reader: BinaryReader): void {
		this.mapRideId = reader.readVarInt()
	}

	public hydrate(
		data: MountInformationInPaddockRequestMessage | Record<string, any>
	): MountInformationInPaddockRequestMessage {
		if (data instanceof MountInformationInPaddockRequestMessage) {
			return data
		}

		this.mapRideId = data.mapRideId

		return this
	}
}

export interface RawMountReleaseRequestMessage {
	id: number
}

export class MountReleaseRequestMessage extends DofusMessage {
	public static id: number = 460

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public serialize(writer: BinaryWriter): void {}

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public deserialize(reader: BinaryReader): void {}

	public hydrate(
		data: MountReleaseRequestMessage | Record<string, any>
	): MountReleaseRequestMessage {
		if (data instanceof MountReleaseRequestMessage) {
			return data
		}

		return this
	}
}

export interface RawMountHarnessColorsUpdateRequestMessage {
	id: number
	useHarnessColors: boolean
}

export class MountHarnessColorsUpdateRequestMessage extends DofusMessage {
	public static id: number = 1532

	public useHarnessColors: boolean | undefined = false

	public constructor(useHarnessColors?: boolean | undefined) {
		super()
		this.useHarnessColors = useHarnessColors
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeBoolean(this.useHarnessColors!)
	}

	public deserialize(reader: BinaryReader): void {
		this.useHarnessColors = reader.readBoolean()
	}

	public hydrate(
		data: MountHarnessColorsUpdateRequestMessage | Record<string, any>
	): MountHarnessColorsUpdateRequestMessage {
		if (data instanceof MountHarnessColorsUpdateRequestMessage) {
			return data
		}

		this.useHarnessColors = data.useHarnessColors

		return this
	}
}

export interface RawMountRenameRequestMessage {
	id: number
	name: string
	mountId: number
}

export class MountRenameRequestMessage extends DofusMessage {
	public static id: number = 9033

	public name: string | undefined
	public mountId: number | undefined = 0

	public constructor(name?: string | undefined, mountId?: number | undefined) {
		super()
		this.name = name
		this.mountId = mountId
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeUTF(this.name!)
		writer.writeVarInt(this.mountId!)
	}

	public deserialize(reader: BinaryReader): void {
		this.name = reader.readUTF()
		this.mountId = reader.readVarInt()
	}

	public hydrate(
		data: MountRenameRequestMessage | Record<string, any>
	): MountRenameRequestMessage {
		if (data instanceof MountRenameRequestMessage) {
			return data
		}

		this.name = data.name
		this.mountId = data.mountId

		return this
	}
}

export interface RawMountFeedRequestMessage {
	id: number
	mountUid: number
	mountLocation: number
	mountFoodUid: number
	quantity: number
}

export class MountFeedRequestMessage extends DofusMessage {
	public static id: number = 9525

	public mountUid: number | undefined = 0
	public mountLocation: number | undefined = 0
	public mountFoodUid: number | undefined = 0
	public quantity: number | undefined = 0

	public constructor(
		mountUid?: number | undefined,
		mountLocation?: number | undefined,
		mountFoodUid?: number | undefined,
		quantity?: number | undefined
	) {
		super()
		this.mountUid = mountUid
		this.mountLocation = mountLocation
		this.mountFoodUid = mountFoodUid
		this.quantity = quantity
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarInt(this.mountUid!)
		writer.writeByte(this.mountLocation!)
		writer.writeVarInt(this.mountFoodUid!)
		writer.writeVarInt(this.quantity!)
	}

	public deserialize(reader: BinaryReader): void {
		this.mountUid = reader.readVarInt()
		this.mountLocation = reader.readByte()
		this.mountFoodUid = reader.readVarInt()
		this.quantity = reader.readVarInt()
	}

	public hydrate(
		data: MountFeedRequestMessage | Record<string, any>
	): MountFeedRequestMessage {
		if (data instanceof MountFeedRequestMessage) {
			return data
		}

		this.mountUid = data.mountUid
		this.mountLocation = data.mountLocation
		this.mountFoodUid = data.mountFoodUid
		this.quantity = data.quantity

		return this
	}
}

export interface RawExchangeHandleMountsMessage {
	id: number
	actionType: number
	ridesId: number[]
}

export class ExchangeHandleMountsMessage extends DofusMessage {
	public static id: number = 173

	public actionType: number | undefined = 0
	public ridesId: number[] | undefined

	public constructor(
		actionType?: number | undefined,
		ridesId?: number[] | undefined
	) {
		super()
		this.actionType = actionType
		this.ridesId = ridesId
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeByte(this.actionType!)
		writer.writeShort(this.ridesId!.length)
		this.ridesId!.forEach((current: number) => writer.writeVarInt(current))
	}

	public deserialize(reader: BinaryReader): void {
		this.actionType = reader.readByte()
		this.ridesId = []
		const countRidesId = reader.readShort()
		for (let i: number = 0; i < countRidesId; i++) {
			this.ridesId.push(reader.readVarInt())
		}
	}

	public hydrate(
		data: ExchangeHandleMountsMessage | Record<string, any>
	): ExchangeHandleMountsMessage {
		if (data instanceof ExchangeHandleMountsMessage) {
			return data
		}

		this.actionType = data.actionType
		this.ridesId = data.ridesId

		return this
	}
}

export interface RawExchangeRequestOnMountStockMessage {
	id: number
}

export class ExchangeRequestOnMountStockMessage extends DofusMessage {
	public static id: number = 1967

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public serialize(writer: BinaryWriter): void {}

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public deserialize(reader: BinaryReader): void {}

	public hydrate(
		data: ExchangeRequestOnMountStockMessage | Record<string, any>
	): ExchangeRequestOnMountStockMessage {
		if (data instanceof ExchangeRequestOnMountStockMessage) {
			return data
		}

		return this
	}
}

export interface RawMountInformationRequestMessage {
	id: number
	id_: number
	time: number
}

export class MountInformationRequestMessage extends DofusMessage {
	public static id: number = 8339

	public id_: number | undefined = 0
	public time: number | undefined = 0

	public constructor(id_?: number | undefined, time?: number | undefined) {
		super()
		this.id_ = id_
		this.time = time
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeDouble(this.id_!)
		writer.writeDouble(this.time!)
	}

	public deserialize(reader: BinaryReader): void {
		this.id_ = reader.readDouble()
		this.time = reader.readDouble()
	}

	public hydrate(
		data: MountInformationRequestMessage | Record<string, any>
	): MountInformationRequestMessage {
		if (data instanceof MountInformationRequestMessage) {
			return data
		}

		this.id_ = data.id_
		this.time = data.time

		return this
	}
}

export interface RawMountToggleRidingRequestMessage {
	id: number
}

export class MountToggleRidingRequestMessage extends DofusMessage {
	public static id: number = 581

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public serialize(writer: BinaryWriter): void {}

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public deserialize(reader: BinaryReader): void {}

	public hydrate(
		data: MountToggleRidingRequestMessage | Record<string, any>
	): MountToggleRidingRequestMessage {
		if (data instanceof MountToggleRidingRequestMessage) {
			return data
		}

		return this
	}
}

export interface RawMountSterilizeRequestMessage {
	id: number
}

export class MountSterilizeRequestMessage extends DofusMessage {
	public static id: number = 5528

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public serialize(writer: BinaryWriter): void {}

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public deserialize(reader: BinaryReader): void {}

	public hydrate(
		data: MountSterilizeRequestMessage | Record<string, any>
	): MountSterilizeRequestMessage {
		if (data instanceof MountSterilizeRequestMessage) {
			return data
		}

		return this
	}
}

export interface RawHouseGuildShareRequestMessage {
	id: number
	houseId: number
	instanceId: number
	enable: boolean
	rights: number
}

export class HouseGuildShareRequestMessage extends DofusMessage {
	public static id: number = 5396

	public houseId: number | undefined = 0
	public instanceId: number | undefined = 0
	public enable: boolean | undefined = false
	public rights: number | undefined = 0

	public constructor(
		houseId?: number | undefined,
		instanceId?: number | undefined,
		enable?: boolean | undefined,
		rights?: number | undefined
	) {
		super()
		this.houseId = houseId
		this.instanceId = instanceId
		this.enable = enable
		this.rights = rights
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarInt(this.houseId!)
		writer.writeInt(this.instanceId!)
		writer.writeBoolean(this.enable!)
		writer.writeVarInt(this.rights!)
	}

	public deserialize(reader: BinaryReader): void {
		this.houseId = reader.readVarInt()
		this.instanceId = reader.readInt()
		this.enable = reader.readBoolean()
		this.rights = reader.readVarInt()
	}

	public hydrate(
		data: HouseGuildShareRequestMessage | Record<string, any>
	): HouseGuildShareRequestMessage {
		if (data instanceof HouseGuildShareRequestMessage) {
			return data
		}

		this.houseId = data.houseId
		this.instanceId = data.instanceId
		this.enable = data.enable
		this.rights = data.rights

		return this
	}
}

export interface RawHouseKickRequestMessage {
	id: number
	id_: number
}

export class HouseKickRequestMessage extends DofusMessage {
	public static id: number = 3694

	public id_: number | undefined = 0

	public constructor(id_?: number | undefined) {
		super()
		this.id_ = id_
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarLong(this.id_!)
	}

	public deserialize(reader: BinaryReader): void {
		this.id_ = reader.readVarLong()
	}

	public hydrate(
		data: HouseKickRequestMessage | Record<string, any>
	): HouseKickRequestMessage {
		if (data instanceof HouseKickRequestMessage) {
			return data
		}

		this.id_ = data.id_

		return this
	}
}

export interface RawHouseSellRequestMessage {
	id: number
	instanceId: number
	amount: number
	forSale: boolean
}

export class HouseSellRequestMessage extends DofusMessage {
	public static id: number = 1525

	public instanceId: number | undefined = 0
	public amount: number | undefined = 0
	public forSale: boolean | undefined = false

	public constructor(
		instanceId?: number | undefined,
		amount?: number | undefined,
		forSale?: boolean | undefined
	) {
		super()
		this.instanceId = instanceId
		this.amount = amount
		this.forSale = forSale
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeInt(this.instanceId!)
		writer.writeVarLong(this.amount!)
		writer.writeBoolean(this.forSale!)
	}

	public deserialize(reader: BinaryReader): void {
		this.instanceId = reader.readInt()
		this.amount = reader.readVarLong()
		this.forSale = reader.readBoolean()
	}

	public hydrate(
		data: HouseSellRequestMessage | Record<string, any>
	): HouseSellRequestMessage {
		if (data instanceof HouseSellRequestMessage) {
			return data
		}

		this.instanceId = data.instanceId
		this.amount = data.amount
		this.forSale = data.forSale

		return this
	}
}

export interface RawLockableChangeCodeMessage {
	id: number
	code: string
}

export class LockableChangeCodeMessage extends DofusMessage {
	public static id: number = 2066

	public code: string | undefined

	public constructor(code?: string | undefined) {
		super()
		this.code = code
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeUTF(this.code!)
	}

	public deserialize(reader: BinaryReader): void {
		this.code = reader.readUTF()
	}

	public hydrate(
		data: LockableChangeCodeMessage | Record<string, any>
	): LockableChangeCodeMessage {
		if (data instanceof LockableChangeCodeMessage) {
			return data
		}

		this.code = data.code

		return this
	}
}

export interface RawHouseLockFromInsideRequestMessage
	extends RawLockableChangeCodeMessage {
	id: number
}

export class HouseLockFromInsideRequestMessage extends LockableChangeCodeMessage {
	public static id = 780

	public constructor(code?: string | undefined) {
		super(code)
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
	}

	public hydrate(
		data: HouseLockFromInsideRequestMessage | Record<string, any>
	): HouseLockFromInsideRequestMessage {
		if (data instanceof HouseLockFromInsideRequestMessage) {
			return data
		}

		super.hydrate(data)

		return this
	}
}

export interface RawHouseBuyRequestMessage {
	id: number
	proposedPrice: number
}

export class HouseBuyRequestMessage extends DofusMessage {
	public static id: number = 3504

	public proposedPrice: number | undefined = 0

	public constructor(proposedPrice?: number | undefined) {
		super()
		this.proposedPrice = proposedPrice
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarLong(this.proposedPrice!)
	}

	public deserialize(reader: BinaryReader): void {
		this.proposedPrice = reader.readVarLong()
	}

	public hydrate(
		data: HouseBuyRequestMessage | Record<string, any>
	): HouseBuyRequestMessage {
		if (data instanceof HouseBuyRequestMessage) {
			return data
		}

		this.proposedPrice = data.proposedPrice

		return this
	}
}

export interface RawHouseSellFromInsideRequestMessage
	extends RawHouseSellRequestMessage {
	id: number
}

export class HouseSellFromInsideRequestMessage extends HouseSellRequestMessage {
	public static id = 6173

	public constructor(
		instanceId?: number | undefined,
		amount?: number | undefined,
		forSale?: boolean | undefined
	) {
		super(instanceId, amount, forSale)
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
	}

	public hydrate(
		data: HouseSellFromInsideRequestMessage | Record<string, any>
	): HouseSellFromInsideRequestMessage {
		if (data instanceof HouseSellFromInsideRequestMessage) {
			return data
		}

		super.hydrate(data)

		return this
	}
}

export interface RawHouseGuildRightsViewMessage {
	id: number
	houseId: number
	instanceId: number
}

export class HouseGuildRightsViewMessage extends DofusMessage {
	public static id: number = 1431

	public houseId: number | undefined = 0
	public instanceId: number | undefined = 0

	public constructor(
		houseId?: number | undefined,
		instanceId?: number | undefined
	) {
		super()
		this.houseId = houseId
		this.instanceId = instanceId
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarInt(this.houseId!)
		writer.writeInt(this.instanceId!)
	}

	public deserialize(reader: BinaryReader): void {
		this.houseId = reader.readVarInt()
		this.instanceId = reader.readInt()
	}

	public hydrate(
		data: HouseGuildRightsViewMessage | Record<string, any>
	): HouseGuildRightsViewMessage {
		if (data instanceof HouseGuildRightsViewMessage) {
			return data
		}

		this.houseId = data.houseId
		this.instanceId = data.instanceId

		return this
	}
}

export interface RawOrnamentSelectRequestMessage {
	id: number
	ornamentId: number
}

export class OrnamentSelectRequestMessage extends DofusMessage {
	public static id: number = 445

	public ornamentId: number | undefined = 0

	public constructor(ornamentId?: number | undefined) {
		super()
		this.ornamentId = ornamentId
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarShort(this.ornamentId!)
	}

	public deserialize(reader: BinaryReader): void {
		this.ornamentId = reader.readVarShort()
	}

	public hydrate(
		data: OrnamentSelectRequestMessage | Record<string, any>
	): OrnamentSelectRequestMessage {
		if (data instanceof OrnamentSelectRequestMessage) {
			return data
		}

		this.ornamentId = data.ornamentId

		return this
	}
}

export interface RawTitlesAndOrnamentsListRequestMessage {
	id: number
}

export class TitlesAndOrnamentsListRequestMessage extends DofusMessage {
	public static id: number = 9416

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public serialize(writer: BinaryWriter): void {}

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public deserialize(reader: BinaryReader): void {}

	public hydrate(
		data: TitlesAndOrnamentsListRequestMessage | Record<string, any>
	): TitlesAndOrnamentsListRequestMessage {
		if (data instanceof TitlesAndOrnamentsListRequestMessage) {
			return data
		}

		return this
	}
}

export interface RawTitleSelectRequestMessage {
	id: number
	titleId: number
}

export class TitleSelectRequestMessage extends DofusMessage {
	public static id: number = 9079

	public titleId: number | undefined = 0

	public constructor(titleId?: number | undefined) {
		super()
		this.titleId = titleId
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarShort(this.titleId!)
	}

	public deserialize(reader: BinaryReader): void {
		this.titleId = reader.readVarShort()
	}

	public hydrate(
		data: TitleSelectRequestMessage | Record<string, any>
	): TitleSelectRequestMessage {
		if (data instanceof TitleSelectRequestMessage) {
			return data
		}

		this.titleId = data.titleId

		return this
	}
}

export interface RawPresetDeleteRequestMessage {
	id: number
	presetId: number
}

export class PresetDeleteRequestMessage extends DofusMessage {
	public static id: number = 8718

	public presetId: number | undefined = 0

	public constructor(presetId?: number | undefined) {
		super()
		this.presetId = presetId
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeShort(this.presetId!)
	}

	public deserialize(reader: BinaryReader): void {
		this.presetId = reader.readShort()
	}

	public hydrate(
		data: PresetDeleteRequestMessage | Record<string, any>
	): PresetDeleteRequestMessage {
		if (data instanceof PresetDeleteRequestMessage) {
			return data
		}

		this.presetId = data.presetId

		return this
	}
}

export interface RawObjectUseMessage {
	id: number
	objectUID: number
}

export class ObjectUseMessage extends DofusMessage {
	public static id: number = 8030

	public objectUID: number | undefined = 0

	public constructor(objectUID?: number | undefined) {
		super()
		this.objectUID = objectUID
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarInt(this.objectUID!)
	}

	public deserialize(reader: BinaryReader): void {
		this.objectUID = reader.readVarInt()
	}

	public hydrate(
		data: ObjectUseMessage | Record<string, any>
	): ObjectUseMessage {
		if (data instanceof ObjectUseMessage) {
			return data
		}

		this.objectUID = data.objectUID

		return this
	}
}

export interface RawObjectUseMultipleMessage extends RawObjectUseMessage {
	id: number
	quantity: number
}

export class ObjectUseMultipleMessage extends ObjectUseMessage {
	public static id = 1737

	public quantity: number | undefined = 0

	public constructor(
		objectUID?: number | undefined,
		quantity?: number | undefined
	) {
		super(objectUID)
		this.quantity = quantity
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeVarInt(this.quantity!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.quantity = reader.readVarInt()
	}

	public hydrate(
		data: ObjectUseMultipleMessage | Record<string, any>
	): ObjectUseMultipleMessage {
		if (data instanceof ObjectUseMultipleMessage) {
			return data
		}

		super.hydrate(data)

		this.quantity = data.quantity

		return this
	}
}

export interface RawObjectDropMessage {
	id: number
	objectUID: number
	quantity: number
}

export class ObjectDropMessage extends DofusMessage {
	public static id: number = 5921

	public objectUID: number | undefined = 0
	public quantity: number | undefined = 0

	public constructor(
		objectUID?: number | undefined,
		quantity?: number | undefined
	) {
		super()
		this.objectUID = objectUID
		this.quantity = quantity
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarInt(this.objectUID!)
		writer.writeVarInt(this.quantity!)
	}

	public deserialize(reader: BinaryReader): void {
		this.objectUID = reader.readVarInt()
		this.quantity = reader.readVarInt()
	}

	public hydrate(
		data: ObjectDropMessage | Record<string, any>
	): ObjectDropMessage {
		if (data instanceof ObjectDropMessage) {
			return data
		}

		this.objectUID = data.objectUID
		this.quantity = data.quantity

		return this
	}
}

export interface RawIconPresetSaveRequestMessage {
	id: number
	presetId: number
	symbolId: number
	updateData: boolean
}

export class IconPresetSaveRequestMessage extends DofusMessage {
	public static id: number = 5015

	public presetId: number | undefined = 0
	public symbolId: number | undefined = 0
	public updateData: boolean | undefined = false

	public constructor(
		presetId?: number | undefined,
		symbolId?: number | undefined,
		updateData?: boolean | undefined
	) {
		super()
		this.presetId = presetId
		this.symbolId = symbolId
		this.updateData = updateData
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeShort(this.presetId!)
		writer.writeByte(this.symbolId!)
		writer.writeBoolean(this.updateData!)
	}

	public deserialize(reader: BinaryReader): void {
		this.presetId = reader.readShort()
		this.symbolId = reader.readByte()
		this.updateData = reader.readBoolean()
	}

	public hydrate(
		data: IconPresetSaveRequestMessage | Record<string, any>
	): IconPresetSaveRequestMessage {
		if (data instanceof IconPresetSaveRequestMessage) {
			return data
		}

		this.presetId = data.presetId
		this.symbolId = data.symbolId
		this.updateData = data.updateData

		return this
	}
}

export interface RawIconNamedPresetSaveRequestMessage
	extends RawIconPresetSaveRequestMessage {
	id: number
	name: string
	type: number
}

export class IconNamedPresetSaveRequestMessage extends IconPresetSaveRequestMessage {
	public static id = 9163

	public name: string | undefined
	public type: number | undefined = 0

	public constructor(
		presetId?: number | undefined,
		symbolId?: number | undefined,
		updateData?: boolean | undefined,
		name?: string | undefined,
		type?: number | undefined
	) {
		super(presetId, symbolId, updateData)
		this.name = name
		this.type = type
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeUTF(this.name!)
		writer.writeByte(this.type!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.name = reader.readUTF()
		this.type = reader.readByte()
	}

	public hydrate(
		data: IconNamedPresetSaveRequestMessage | Record<string, any>
	): IconNamedPresetSaveRequestMessage {
		if (data instanceof IconNamedPresetSaveRequestMessage) {
			return data
		}

		super.hydrate(data)

		this.name = data.name
		this.type = data.type

		return this
	}
}

export interface RawObjectDeleteMessage {
	id: number
	objectUID: number
	quantity: number
}

export class ObjectDeleteMessage extends DofusMessage {
	public static id: number = 8482

	public objectUID: number | undefined = 0
	public quantity: number | undefined = 0

	public constructor(
		objectUID?: number | undefined,
		quantity?: number | undefined
	) {
		super()
		this.objectUID = objectUID
		this.quantity = quantity
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarInt(this.objectUID!)
		writer.writeVarInt(this.quantity!)
	}

	public deserialize(reader: BinaryReader): void {
		this.objectUID = reader.readVarInt()
		this.quantity = reader.readVarInt()
	}

	public hydrate(
		data: ObjectDeleteMessage | Record<string, any>
	): ObjectDeleteMessage {
		if (data instanceof ObjectDeleteMessage) {
			return data
		}

		this.objectUID = data.objectUID
		this.quantity = data.quantity

		return this
	}
}

export interface RawAccessoryPreviewRequestMessage {
	id: number
	genericId: number[]
}

export class AccessoryPreviewRequestMessage extends DofusMessage {
	public static id: number = 4736

	public genericId: number[] | undefined

	public constructor(genericId?: number[] | undefined) {
		super()
		this.genericId = genericId
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeShort(this.genericId!.length)
		this.genericId!.forEach((current: number) => writer.writeVarShort(current))
	}

	public deserialize(reader: BinaryReader): void {
		this.genericId = []
		const countGenericId = reader.readShort()
		for (let i: number = 0; i < countGenericId; i++) {
			this.genericId.push(reader.readVarShort())
		}
	}

	public hydrate(
		data: AccessoryPreviewRequestMessage | Record<string, any>
	): AccessoryPreviewRequestMessage {
		if (data instanceof AccessoryPreviewRequestMessage) {
			return data
		}

		this.genericId = data.genericId

		return this
	}
}

export interface RawShortcutBarRemoveRequestMessage {
	id: number
	barType: number
	slot: number
}

export class ShortcutBarRemoveRequestMessage extends DofusMessage {
	public static id: number = 8528

	public barType: number | undefined = 0
	public slot: number | undefined = 0

	public constructor(barType?: number | undefined, slot?: number | undefined) {
		super()
		this.barType = barType
		this.slot = slot
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeByte(this.barType!)
		writer.writeByte(this.slot!)
	}

	public deserialize(reader: BinaryReader): void {
		this.barType = reader.readByte()
		this.slot = reader.readByte()
	}

	public hydrate(
		data: ShortcutBarRemoveRequestMessage | Record<string, any>
	): ShortcutBarRemoveRequestMessage {
		if (data instanceof ShortcutBarRemoveRequestMessage) {
			return data
		}

		this.barType = data.barType
		this.slot = data.slot

		return this
	}
}

export interface RawObjectUseOnCharacterMessage extends RawObjectUseMessage {
	id: number
	characterId: number
}

export class ObjectUseOnCharacterMessage extends ObjectUseMessage {
	public static id = 9511

	public characterId: number | undefined = 0

	public constructor(
		objectUID?: number | undefined,
		characterId?: number | undefined
	) {
		super(objectUID)
		this.characterId = characterId
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeVarLong(this.characterId!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.characterId = reader.readVarLong()
	}

	public hydrate(
		data: ObjectUseOnCharacterMessage | Record<string, any>
	): ObjectUseOnCharacterMessage {
		if (data instanceof ObjectUseOnCharacterMessage) {
			return data
		}

		super.hydrate(data)

		this.characterId = data.characterId

		return this
	}
}

export interface RawShortcutBarSwapRequestMessage {
	id: number
	barType: number
	firstSlot: number
	secondSlot: number
}

export class ShortcutBarSwapRequestMessage extends DofusMessage {
	public static id: number = 5703

	public barType: number | undefined = 0
	public firstSlot: number | undefined = 0
	public secondSlot: number | undefined = 0

	public constructor(
		barType?: number | undefined,
		firstSlot?: number | undefined,
		secondSlot?: number | undefined
	) {
		super()
		this.barType = barType
		this.firstSlot = firstSlot
		this.secondSlot = secondSlot
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeByte(this.barType!)
		writer.writeByte(this.firstSlot!)
		writer.writeByte(this.secondSlot!)
	}

	public deserialize(reader: BinaryReader): void {
		this.barType = reader.readByte()
		this.firstSlot = reader.readByte()
		this.secondSlot = reader.readByte()
	}

	public hydrate(
		data: ShortcutBarSwapRequestMessage | Record<string, any>
	): ShortcutBarSwapRequestMessage {
		if (data instanceof ShortcutBarSwapRequestMessage) {
			return data
		}

		this.barType = data.barType
		this.firstSlot = data.firstSlot
		this.secondSlot = data.secondSlot

		return this
	}
}

export interface RawObjectUseOnCellMessage extends RawObjectUseMessage {
	id: number
	cells: number
}

export class ObjectUseOnCellMessage extends ObjectUseMessage {
	public static id = 2641

	public cells: number | undefined = 0

	public constructor(
		objectUID?: number | undefined,
		cells?: number | undefined
	) {
		super(objectUID)
		this.cells = cells
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeVarShort(this.cells!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.cells = reader.readVarShort()
	}

	public hydrate(
		data: ObjectUseOnCellMessage | Record<string, any>
	): ObjectUseOnCellMessage {
		if (data instanceof ObjectUseOnCellMessage) {
			return data
		}

		super.hydrate(data)

		this.cells = data.cells

		return this
	}
}

export interface RawShortcutBarAddRequestMessage {
	id: number
	barType: number
	shortcut: Shortcut
}

export class ShortcutBarAddRequestMessage extends DofusMessage {
	public static id: number = 7306

	public barType: number | undefined = 0
	public shortcut: Shortcut | undefined

	public constructor(
		barType?: number | undefined,
		shortcut?: Shortcut | undefined
	) {
		super()
		this.barType = barType
		this.shortcut = shortcut
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeByte(this.barType!)
		writer.writeShort(this.shortcut!.id)
		this.shortcut!.serialize(writer)
	}

	public deserialize(reader: BinaryReader): void {
		this.barType = reader.readByte()
		const shortcutTypeId: number = reader.readShort()
		this.shortcut = new types[shortcutTypeId]() as Shortcut
		this.shortcut!.deserialize(reader)
	}

	public hydrate(
		data: ShortcutBarAddRequestMessage | Record<string, any>
	): ShortcutBarAddRequestMessage {
		if (data instanceof ShortcutBarAddRequestMessage) {
			return data
		}

		this.barType = data.barType
		this.shortcut = (new types[data.shortcut.id]() as Shortcut).hydrate(
			data.shortcut
		)
		return this
	}
}

export interface RawIdolsPresetSaveRequestMessage
	extends RawIconPresetSaveRequestMessage {
	id: number
}

export class IdolsPresetSaveRequestMessage extends IconPresetSaveRequestMessage {
	public static id = 5636

	public constructor(
		presetId?: number | undefined,
		symbolId?: number | undefined,
		updateData?: boolean | undefined
	) {
		super(presetId, symbolId, updateData)
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
	}

	public hydrate(
		data: IdolsPresetSaveRequestMessage | Record<string, any>
	): IdolsPresetSaveRequestMessage {
		if (data instanceof IdolsPresetSaveRequestMessage) {
			return data
		}

		super.hydrate(data)

		return this
	}
}

export interface RawPresetUseRequestMessage {
	id: number
	presetId: number
}

export class PresetUseRequestMessage extends DofusMessage {
	public static id: number = 6757

	public presetId: number | undefined = 0

	public constructor(presetId?: number | undefined) {
		super()
		this.presetId = presetId
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeShort(this.presetId!)
	}

	public deserialize(reader: BinaryReader): void {
		this.presetId = reader.readShort()
	}

	public hydrate(
		data: PresetUseRequestMessage | Record<string, any>
	): PresetUseRequestMessage {
		if (data instanceof PresetUseRequestMessage) {
			return data
		}

		this.presetId = data.presetId

		return this
	}
}

export interface RawObjectSetPositionMessage {
	id: number
	objectUID: number
	position: number
	quantity: number
}

export class ObjectSetPositionMessage extends DofusMessage {
	public static id: number = 2180

	public objectUID: number | undefined = 0
	public position: number | undefined = 63
	public quantity: number | undefined = 0

	public constructor(
		objectUID?: number | undefined,
		position?: number | undefined,
		quantity?: number | undefined
	) {
		super()
		this.objectUID = objectUID
		this.position = position
		this.quantity = quantity
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarInt(this.objectUID!)
		writer.writeShort(this.position!)
		writer.writeVarInt(this.quantity!)
	}

	public deserialize(reader: BinaryReader): void {
		this.objectUID = reader.readVarInt()
		this.position = reader.readShort()
		this.quantity = reader.readVarInt()
	}

	public hydrate(
		data: ObjectSetPositionMessage | Record<string, any>
	): ObjectSetPositionMessage {
		if (data instanceof ObjectSetPositionMessage) {
			return data
		}

		this.objectUID = data.objectUID
		this.position = data.position
		this.quantity = data.quantity

		return this
	}
}

export interface RawExchangeBidHouseBuyMessage {
	id: number
	uid: number
	qty: number
	price: number
}

export class ExchangeBidHouseBuyMessage extends DofusMessage {
	public static id: number = 6676

	public uid: number | undefined = 0
	public qty: number | undefined = 0
	public price: number | undefined = 0

	public constructor(
		uid?: number | undefined,
		qty?: number | undefined,
		price?: number | undefined
	) {
		super()
		this.uid = uid
		this.qty = qty
		this.price = price
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarInt(this.uid!)
		writer.writeVarInt(this.qty!)
		writer.writeVarLong(this.price!)
	}

	public deserialize(reader: BinaryReader): void {
		this.uid = reader.readVarInt()
		this.qty = reader.readVarInt()
		this.price = reader.readVarLong()
	}

	public hydrate(
		data: ExchangeBidHouseBuyMessage | Record<string, any>
	): ExchangeBidHouseBuyMessage {
		if (data instanceof ExchangeBidHouseBuyMessage) {
			return data
		}

		this.uid = data.uid
		this.qty = data.qty
		this.price = data.price

		return this
	}
}

export interface RawExchangeBidHousePriceMessage {
	id: number
	genId: number
}

export class ExchangeBidHousePriceMessage extends DofusMessage {
	public static id: number = 3234

	public genId: number | undefined = 0

	public constructor(genId?: number | undefined) {
		super()
		this.genId = genId
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarShort(this.genId!)
	}

	public deserialize(reader: BinaryReader): void {
		this.genId = reader.readVarShort()
	}

	public hydrate(
		data: ExchangeBidHousePriceMessage | Record<string, any>
	): ExchangeBidHousePriceMessage {
		if (data instanceof ExchangeBidHousePriceMessage) {
			return data
		}

		this.genId = data.genId

		return this
	}
}

export interface RawExchangeBidHouseSearchMessage {
	id: number
	genId: number
	follow: boolean
}

export class ExchangeBidHouseSearchMessage extends DofusMessage {
	public static id: number = 3308

	public genId: number | undefined = 0
	public follow: boolean | undefined = false

	public constructor(genId?: number | undefined, follow?: boolean | undefined) {
		super()
		this.genId = genId
		this.follow = follow
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarShort(this.genId!)
		writer.writeBoolean(this.follow!)
	}

	public deserialize(reader: BinaryReader): void {
		this.genId = reader.readVarShort()
		this.follow = reader.readBoolean()
	}

	public hydrate(
		data: ExchangeBidHouseSearchMessage | Record<string, any>
	): ExchangeBidHouseSearchMessage {
		if (data instanceof ExchangeBidHouseSearchMessage) {
			return data
		}

		this.genId = data.genId
		this.follow = data.follow

		return this
	}
}

export interface RawExchangeBidHouseListMessage {
	id: number
	id_: number
	follow: boolean
}

export class ExchangeBidHouseListMessage extends DofusMessage {
	public static id: number = 1285

	public id_: number | undefined = 0
	public follow: boolean | undefined = false

	public constructor(id_?: number | undefined, follow?: boolean | undefined) {
		super()
		this.id_ = id_
		this.follow = follow
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarShort(this.id_!)
		writer.writeBoolean(this.follow!)
	}

	public deserialize(reader: BinaryReader): void {
		this.id_ = reader.readVarShort()
		this.follow = reader.readBoolean()
	}

	public hydrate(
		data: ExchangeBidHouseListMessage | Record<string, any>
	): ExchangeBidHouseListMessage {
		if (data instanceof ExchangeBidHouseListMessage) {
			return data
		}

		this.id_ = data.id_
		this.follow = data.follow

		return this
	}
}

export interface RawExchangeBidHouseTypeMessage {
	id: number
	type: number
	follow: boolean
}

export class ExchangeBidHouseTypeMessage extends DofusMessage {
	public static id: number = 270

	public type: number | undefined = 0
	public follow: boolean | undefined = false

	public constructor(type?: number | undefined, follow?: boolean | undefined) {
		super()
		this.type = type
		this.follow = follow
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarInt(this.type!)
		writer.writeBoolean(this.follow!)
	}

	public deserialize(reader: BinaryReader): void {
		this.type = reader.readVarInt()
		this.follow = reader.readBoolean()
	}

	public hydrate(
		data: ExchangeBidHouseTypeMessage | Record<string, any>
	): ExchangeBidHouseTypeMessage {
		if (data instanceof ExchangeBidHouseTypeMessage) {
			return data
		}

		this.type = data.type
		this.follow = data.follow

		return this
	}
}

export interface RawExchangeObjectModifyPricedMessage
	extends RawExchangeObjectMovePricedMessage {
	id: number
}

export class ExchangeObjectModifyPricedMessage extends ExchangeObjectMovePricedMessage {
	public static id = 7465

	public constructor(
		objectUID?: number | undefined,
		quantity?: number | undefined,
		price?: number | undefined
	) {
		super(objectUID, quantity, price)
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
	}

	public hydrate(
		data: ExchangeObjectModifyPricedMessage | Record<string, any>
	): ExchangeObjectModifyPricedMessage {
		if (data instanceof ExchangeObjectModifyPricedMessage) {
			return data
		}

		super.hydrate(data)

		return this
	}
}

export interface RawStopToListenRunningFightRequestMessage {
	id: number
}

export class StopToListenRunningFightRequestMessage extends DofusMessage {
	public static id: number = 7557

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public serialize(writer: BinaryWriter): void {}

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public deserialize(reader: BinaryReader): void {}

	public hydrate(
		data: StopToListenRunningFightRequestMessage | Record<string, any>
	): StopToListenRunningFightRequestMessage {
		if (data instanceof StopToListenRunningFightRequestMessage) {
			return data
		}

		return this
	}
}

export interface RawGameFightSpectatePlayerRequestMessage {
	id: number
	playerId: number
}

export class GameFightSpectatePlayerRequestMessage extends DofusMessage {
	public static id: number = 5035

	public playerId: number | undefined = 0

	public constructor(playerId?: number | undefined) {
		super()
		this.playerId = playerId
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarLong(this.playerId!)
	}

	public deserialize(reader: BinaryReader): void {
		this.playerId = reader.readVarLong()
	}

	public hydrate(
		data: GameFightSpectatePlayerRequestMessage | Record<string, any>
	): GameFightSpectatePlayerRequestMessage {
		if (data instanceof GameFightSpectatePlayerRequestMessage) {
			return data
		}

		this.playerId = data.playerId

		return this
	}
}

export interface RawMapRunningFightDetailsRequestMessage {
	id: number
	fightId: number
}

export class MapRunningFightDetailsRequestMessage extends DofusMessage {
	public static id: number = 8879

	public fightId: number | undefined = 0

	public constructor(fightId?: number | undefined) {
		super()
		this.fightId = fightId
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarShort(this.fightId!)
	}

	public deserialize(reader: BinaryReader): void {
		this.fightId = reader.readVarShort()
	}

	public hydrate(
		data: MapRunningFightDetailsRequestMessage | Record<string, any>
	): MapRunningFightDetailsRequestMessage {
		if (data instanceof MapRunningFightDetailsRequestMessage) {
			return data
		}

		this.fightId = data.fightId

		return this
	}
}

export interface RawMapRunningFightListRequestMessage {
	id: number
}

export class MapRunningFightListRequestMessage extends DofusMessage {
	public static id: number = 4556

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public serialize(writer: BinaryWriter): void {}

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public deserialize(reader: BinaryReader): void {}

	public hydrate(
		data: MapRunningFightListRequestMessage | Record<string, any>
	): MapRunningFightListRequestMessage {
		if (data instanceof MapRunningFightListRequestMessage) {
			return data
		}

		return this
	}
}

export interface RawExchangeAcceptMessage {
	id: number
}

export class ExchangeAcceptMessage extends DofusMessage {
	public static id: number = 9042

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public serialize(writer: BinaryWriter): void {}

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public deserialize(reader: BinaryReader): void {}

	public hydrate(
		data: ExchangeAcceptMessage | Record<string, any>
	): ExchangeAcceptMessage {
		if (data instanceof ExchangeAcceptMessage) {
			return data
		}

		return this
	}
}

export interface RawExchangeReadyMessage {
	id: number
	ready: boolean
	step: number
}

export class ExchangeReadyMessage extends DofusMessage {
	public static id: number = 4843

	public ready: boolean | undefined = false
	public step: number | undefined = 0

	public constructor(ready?: boolean | undefined, step?: number | undefined) {
		super()
		this.ready = ready
		this.step = step
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeBoolean(this.ready!)
		writer.writeVarShort(this.step!)
	}

	public deserialize(reader: BinaryReader): void {
		this.ready = reader.readBoolean()
		this.step = reader.readVarShort()
	}

	public hydrate(
		data: ExchangeReadyMessage | Record<string, any>
	): ExchangeReadyMessage {
		if (data instanceof ExchangeReadyMessage) {
			return data
		}

		this.ready = data.ready
		this.step = data.step

		return this
	}
}

export interface RawFocusedExchangeReadyMessage
	extends RawExchangeReadyMessage {
	id: number
	focusActionId: number
}

export class FocusedExchangeReadyMessage extends ExchangeReadyMessage {
	public static id = 1260

	public focusActionId: number | undefined = 0

	public constructor(
		ready?: boolean | undefined,
		step?: number | undefined,
		focusActionId?: number | undefined
	) {
		super(ready, step)
		this.focusActionId = focusActionId
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeVarInt(this.focusActionId!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.focusActionId = reader.readVarInt()
	}

	public hydrate(
		data: FocusedExchangeReadyMessage | Record<string, any>
	): FocusedExchangeReadyMessage {
		if (data instanceof FocusedExchangeReadyMessage) {
			return data
		}

		super.hydrate(data)

		this.focusActionId = data.focusActionId

		return this
	}
}

export interface RawGameMapMovementCancelMessage {
	id: number
	cellId: number
}

export class GameMapMovementCancelMessage extends DofusMessage {
	public static id: number = 2541

	public cellId: number | undefined = 0

	public constructor(cellId?: number | undefined) {
		super()
		this.cellId = cellId
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarShort(this.cellId!)
	}

	public deserialize(reader: BinaryReader): void {
		this.cellId = reader.readVarShort()
	}

	public hydrate(
		data: GameMapMovementCancelMessage | Record<string, any>
	): GameMapMovementCancelMessage {
		if (data instanceof GameMapMovementCancelMessage) {
			return data
		}

		this.cellId = data.cellId

		return this
	}
}

export interface RawChangeMapMessage {
	id: number
	mapId: number
	autopilot: boolean
}

export class ChangeMapMessage extends DofusMessage {
	public static id: number = 9045

	public mapId: number | undefined = 0
	public autopilot: boolean | undefined = false

	public constructor(
		mapId?: number | undefined,
		autopilot?: boolean | undefined
	) {
		super()
		this.mapId = mapId
		this.autopilot = autopilot
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeDouble(this.mapId!)
		writer.writeBoolean(this.autopilot!)
	}

	public deserialize(reader: BinaryReader): void {
		this.mapId = reader.readDouble()
		this.autopilot = reader.readBoolean()
	}

	public hydrate(
		data: ChangeMapMessage | Record<string, any>
	): ChangeMapMessage {
		if (data instanceof ChangeMapMessage) {
			return data
		}

		this.mapId = data.mapId
		this.autopilot = data.autopilot

		return this
	}
}

export interface RawGameCautiousMapMovementRequestMessage
	extends RawGameMapMovementRequestMessage {
	id: number
}

export class GameCautiousMapMovementRequestMessage extends GameMapMovementRequestMessage {
	public static id = 5883

	public constructor(
		keyMovements?: number[] | undefined,
		mapId?: number | undefined
	) {
		super(keyMovements, mapId)
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
	}

	public hydrate(
		data: GameCautiousMapMovementRequestMessage | Record<string, any>
	): GameCautiousMapMovementRequestMessage {
		if (data instanceof GameCautiousMapMovementRequestMessage) {
			return data
		}

		super.hydrate(data)

		return this
	}
}

export interface RawInteractiveUseRequestMessage {
	id: number
	elemId: number
	skillInstanceUid: number
}

export class InteractiveUseRequestMessage extends DofusMessage {
	public static id: number = 9394

	public elemId: number | undefined = 0
	public skillInstanceUid: number | undefined = 0

	public constructor(
		elemId?: number | undefined,
		skillInstanceUid?: number | undefined
	) {
		super()
		this.elemId = elemId
		this.skillInstanceUid = skillInstanceUid
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarInt(this.elemId!)
		writer.writeVarInt(this.skillInstanceUid!)
	}

	public deserialize(reader: BinaryReader): void {
		this.elemId = reader.readVarInt()
		this.skillInstanceUid = reader.readVarInt()
	}

	public hydrate(
		data: InteractiveUseRequestMessage | Record<string, any>
	): InteractiveUseRequestMessage {
		if (data instanceof InteractiveUseRequestMessage) {
			return data
		}

		this.elemId = data.elemId
		this.skillInstanceUid = data.skillInstanceUid

		return this
	}
}

export interface RawInteractiveUseWithParamRequestMessage
	extends RawInteractiveUseRequestMessage {
	id: number
	id_: number
}

export class InteractiveUseWithParamRequestMessage extends InteractiveUseRequestMessage {
	public static id = 2661

	public id_: number | undefined = 0

	public constructor(
		elemId?: number | undefined,
		skillInstanceUid?: number | undefined,
		id_?: number | undefined
	) {
		super(elemId, skillInstanceUid)
		this.id_ = id_
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeInt(this.id_!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.id_ = reader.readInt()
	}

	public hydrate(
		data: InteractiveUseWithParamRequestMessage | Record<string, any>
	): InteractiveUseWithParamRequestMessage {
		if (data instanceof InteractiveUseWithParamRequestMessage) {
			return data
		}

		super.hydrate(data)

		this.id_ = data.id_

		return this
	}
}

export interface RawGameRolePlayAttackMonsterRequestMessage {
	id: number
	monsterGroupId: number
}

export class GameRolePlayAttackMonsterRequestMessage extends DofusMessage {
	public static id: number = 9947

	public monsterGroupId: number | undefined = 0

	public constructor(monsterGroupId?: number | undefined) {
		super()
		this.monsterGroupId = monsterGroupId
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeDouble(this.monsterGroupId!)
	}

	public deserialize(reader: BinaryReader): void {
		this.monsterGroupId = reader.readDouble()
	}

	public hydrate(
		data: GameRolePlayAttackMonsterRequestMessage | Record<string, any>
	): GameRolePlayAttackMonsterRequestMessage {
		if (data instanceof GameRolePlayAttackMonsterRequestMessage) {
			return data
		}

		this.monsterGroupId = data.monsterGroupId

		return this
	}
}

export interface RawGameMapMovementConfirmMessage {
	id: number
}

export class GameMapMovementConfirmMessage extends DofusMessage {
	public static id: number = 4717

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public serialize(writer: BinaryWriter): void {}

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public deserialize(reader: BinaryReader): void {}

	public hydrate(
		data: GameMapMovementConfirmMessage | Record<string, any>
	): GameMapMovementConfirmMessage {
		if (data instanceof GameMapMovementConfirmMessage) {
			return data
		}

		return this
	}
}

export interface RawExchangeObjectMoveKamaMessage {
	id: number
	quantity: number
}

export class ExchangeObjectMoveKamaMessage extends DofusMessage {
	public static id: number = 1621

	public quantity: number | undefined = 0

	public constructor(quantity?: number | undefined) {
		super()
		this.quantity = quantity
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarLong(this.quantity!)
	}

	public deserialize(reader: BinaryReader): void {
		this.quantity = reader.readVarLong()
	}

	public hydrate(
		data: ExchangeObjectMoveKamaMessage | Record<string, any>
	): ExchangeObjectMoveKamaMessage {
		if (data instanceof ExchangeObjectMoveKamaMessage) {
			return data
		}

		this.quantity = data.quantity

		return this
	}
}

export interface RawExchangeObjectTransfertExistingToInvMessage {
	id: number
}

export class ExchangeObjectTransfertExistingToInvMessage extends DofusMessage {
	public static id: number = 6444

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public serialize(writer: BinaryWriter): void {}

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public deserialize(reader: BinaryReader): void {}

	public hydrate(
		data: ExchangeObjectTransfertExistingToInvMessage | Record<string, any>
	): ExchangeObjectTransfertExistingToInvMessage {
		if (data instanceof ExchangeObjectTransfertExistingToInvMessage) {
			return data
		}

		return this
	}
}

export interface RawExchangeObjectTransfertListFromInvMessage {
	id: number
	ids: number[]
}

export class ExchangeObjectTransfertListFromInvMessage extends DofusMessage {
	public static id: number = 9384

	public ids: number[] | undefined

	public constructor(ids?: number[] | undefined) {
		super()
		this.ids = ids
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeShort(this.ids!.length)
		this.ids!.forEach((current: number) => writer.writeVarInt(current))
	}

	public deserialize(reader: BinaryReader): void {
		this.ids = []
		const countIds = reader.readShort()
		for (let i: number = 0; i < countIds; i++) {
			this.ids.push(reader.readVarInt())
		}
	}

	public hydrate(
		data: ExchangeObjectTransfertListFromInvMessage | Record<string, any>
	): ExchangeObjectTransfertListFromInvMessage {
		if (data instanceof ExchangeObjectTransfertListFromInvMessage) {
			return data
		}

		this.ids = data.ids

		return this
	}
}

export interface RawExchangeObjectTransfertAllToInvMessage {
	id: number
}

export class ExchangeObjectTransfertAllToInvMessage extends DofusMessage {
	public static id: number = 6225

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public serialize(writer: BinaryWriter): void {}

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public deserialize(reader: BinaryReader): void {}

	public hydrate(
		data: ExchangeObjectTransfertAllToInvMessage | Record<string, any>
	): ExchangeObjectTransfertAllToInvMessage {
		if (data instanceof ExchangeObjectTransfertAllToInvMessage) {
			return data
		}

		return this
	}
}

export interface RawExchangeObjectTransfertListToInvMessage {
	id: number
	ids: number[]
}

export class ExchangeObjectTransfertListToInvMessage extends DofusMessage {
	public static id: number = 8258

	public ids: number[] | undefined

	public constructor(ids?: number[] | undefined) {
		super()
		this.ids = ids
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeShort(this.ids!.length)
		this.ids!.forEach((current: number) => writer.writeVarInt(current))
	}

	public deserialize(reader: BinaryReader): void {
		this.ids = []
		const countIds = reader.readShort()
		for (let i: number = 0; i < countIds; i++) {
			this.ids.push(reader.readVarInt())
		}
	}

	public hydrate(
		data: ExchangeObjectTransfertListToInvMessage | Record<string, any>
	): ExchangeObjectTransfertListToInvMessage {
		if (data instanceof ExchangeObjectTransfertListToInvMessage) {
			return data
		}

		this.ids = data.ids

		return this
	}
}

export interface RawExchangeObjectTransfertListWithQuantityToInvMessage {
	id: number
	ids: number[]
	qtys: number[]
}

export class ExchangeObjectTransfertListWithQuantityToInvMessage extends DofusMessage {
	public static id: number = 8847

	public ids: number[] | undefined
	public qtys: number[] | undefined

	public constructor(ids?: number[] | undefined, qtys?: number[] | undefined) {
		super()
		this.ids = ids
		this.qtys = qtys
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeShort(this.ids!.length)
		this.ids!.forEach((current: number) => writer.writeVarInt(current))
		writer.writeShort(this.qtys!.length)
		this.qtys!.forEach((current: number) => writer.writeVarInt(current))
	}

	public deserialize(reader: BinaryReader): void {
		this.ids = []
		const countIds = reader.readShort()
		for (let i: number = 0; i < countIds; i++) {
			this.ids.push(reader.readVarInt())
		}
		this.qtys = []
		const countQtys = reader.readShort()
		for (let i: number = 0; i < countQtys; i++) {
			this.qtys.push(reader.readVarInt())
		}
	}

	public hydrate(
		data:
			| ExchangeObjectTransfertListWithQuantityToInvMessage
			| Record<string, any>
	): ExchangeObjectTransfertListWithQuantityToInvMessage {
		if (data instanceof ExchangeObjectTransfertListWithQuantityToInvMessage) {
			return data
		}

		this.ids = data.ids
		this.qtys = data.qtys

		return this
	}
}

export interface RawExchangeObjectTransfertAllFromInvMessage {
	id: number
}

export class ExchangeObjectTransfertAllFromInvMessage extends DofusMessage {
	public static id: number = 1221

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public serialize(writer: BinaryWriter): void {}

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public deserialize(reader: BinaryReader): void {}

	public hydrate(
		data: ExchangeObjectTransfertAllFromInvMessage | Record<string, any>
	): ExchangeObjectTransfertAllFromInvMessage {
		if (data instanceof ExchangeObjectTransfertAllFromInvMessage) {
			return data
		}

		return this
	}
}

export interface RawExchangeObjectTransfertExistingFromInvMessage {
	id: number
}

export class ExchangeObjectTransfertExistingFromInvMessage extends DofusMessage {
	public static id: number = 5796

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public serialize(writer: BinaryWriter): void {}

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public deserialize(reader: BinaryReader): void {}

	public hydrate(
		data: ExchangeObjectTransfertExistingFromInvMessage | Record<string, any>
	): ExchangeObjectTransfertExistingFromInvMessage {
		if (data instanceof ExchangeObjectTransfertExistingFromInvMessage) {
			return data
		}

		return this
	}
}

export interface RawNpcDialogReplyMessage {
	id: number
	replyId: number
}

export class NpcDialogReplyMessage extends DofusMessage {
	public static id: number = 6305

	public replyId: number | undefined = 0

	public constructor(replyId?: number | undefined) {
		super()
		this.replyId = replyId
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarInt(this.replyId!)
	}

	public deserialize(reader: BinaryReader): void {
		this.replyId = reader.readVarInt()
	}

	public hydrate(
		data: NpcDialogReplyMessage | Record<string, any>
	): NpcDialogReplyMessage {
		if (data instanceof NpcDialogReplyMessage) {
			return data
		}

		this.replyId = data.replyId

		return this
	}
}

export interface RawPaddockBuyRequestMessage {
	id: number
	proposedPrice: number
}

export class PaddockBuyRequestMessage extends DofusMessage {
	public static id: number = 9656

	public proposedPrice: number | undefined = 0

	public constructor(proposedPrice?: number | undefined) {
		super()
		this.proposedPrice = proposedPrice
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarLong(this.proposedPrice!)
	}

	public deserialize(reader: BinaryReader): void {
		this.proposedPrice = reader.readVarLong()
	}

	public hydrate(
		data: PaddockBuyRequestMessage | Record<string, any>
	): PaddockBuyRequestMessage {
		if (data instanceof PaddockBuyRequestMessage) {
			return data
		}

		this.proposedPrice = data.proposedPrice

		return this
	}
}

export interface RawPaddockSellRequestMessage {
	id: number
	price: number
	forSale: boolean
}

export class PaddockSellRequestMessage extends DofusMessage {
	public static id: number = 663

	public price: number | undefined = 0
	public forSale: boolean | undefined = false

	public constructor(
		price?: number | undefined,
		forSale?: boolean | undefined
	) {
		super()
		this.price = price
		this.forSale = forSale
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarLong(this.price!)
		writer.writeBoolean(this.forSale!)
	}

	public deserialize(reader: BinaryReader): void {
		this.price = reader.readVarLong()
		this.forSale = reader.readBoolean()
	}

	public hydrate(
		data: PaddockSellRequestMessage | Record<string, any>
	): PaddockSellRequestMessage {
		if (data instanceof PaddockSellRequestMessage) {
			return data
		}

		this.price = data.price
		this.forSale = data.forSale

		return this
	}
}

export interface RawGuildInvitationAnswerMessage {
	id: number
	accept: boolean
}

export class GuildInvitationAnswerMessage extends DofusMessage {
	public static id: number = 2671

	public accept: boolean | undefined = false

	public constructor(accept?: boolean | undefined) {
		super()
		this.accept = accept
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeBoolean(this.accept!)
	}

	public deserialize(reader: BinaryReader): void {
		this.accept = reader.readBoolean()
	}

	public hydrate(
		data: GuildInvitationAnswerMessage | Record<string, any>
	): GuildInvitationAnswerMessage {
		if (data instanceof GuildInvitationAnswerMessage) {
			return data
		}

		this.accept = data.accept

		return this
	}
}

export interface RawGuildModificationEmblemValidMessage {
	id: number
	guildEmblem: GuildEmblem
}

export class GuildModificationEmblemValidMessage extends DofusMessage {
	public static id: number = 8864

	public guildEmblem: GuildEmblem | undefined

	public constructor(guildEmblem?: GuildEmblem | undefined) {
		super()
		this.guildEmblem = guildEmblem
	}

	public serialize(writer: BinaryWriter): void {
		this.guildEmblem!.serialize(writer)
	}

	public deserialize(reader: BinaryReader): void {
		this.guildEmblem = new GuildEmblem()
		this.guildEmblem!.deserialize(reader)
	}

	public hydrate(
		data: GuildModificationEmblemValidMessage | Record<string, any>
	): GuildModificationEmblemValidMessage {
		if (data instanceof GuildModificationEmblemValidMessage) {
			return data
		}

		this.guildEmblem = new GuildEmblem().hydrate(data.guildEmblem)

		return this
	}
}

export interface RawGuildModificationValidMessage {
	id: number
	guildName: string
	guildEmblem: GuildEmblem
}

export class GuildModificationValidMessage extends DofusMessage {
	public static id: number = 9265

	public guildName: string | undefined
	public guildEmblem: GuildEmblem | undefined

	public constructor(
		guildName?: string | undefined,
		guildEmblem?: GuildEmblem | undefined
	) {
		super()
		this.guildName = guildName
		this.guildEmblem = guildEmblem
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeUTF(this.guildName!)
		this.guildEmblem!.serialize(writer)
	}

	public deserialize(reader: BinaryReader): void {
		this.guildName = reader.readUTF()
		this.guildEmblem = new GuildEmblem()
		this.guildEmblem!.deserialize(reader)
	}

	public hydrate(
		data: GuildModificationValidMessage | Record<string, any>
	): GuildModificationValidMessage {
		if (data instanceof GuildModificationValidMessage) {
			return data
		}

		this.guildName = data.guildName
		this.guildEmblem = new GuildEmblem().hydrate(data.guildEmblem)

		return this
	}
}

export interface RawGuildModificationNameValidMessage {
	id: number
	guildName: string
}

export class GuildModificationNameValidMessage extends DofusMessage {
	public static id: number = 4598

	public guildName: string | undefined

	public constructor(guildName?: string | undefined) {
		super()
		this.guildName = guildName
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeUTF(this.guildName!)
	}

	public deserialize(reader: BinaryReader): void {
		this.guildName = reader.readUTF()
	}

	public hydrate(
		data: GuildModificationNameValidMessage | Record<string, any>
	): GuildModificationNameValidMessage {
		if (data instanceof GuildModificationNameValidMessage) {
			return data
		}

		this.guildName = data.guildName

		return this
	}
}

export interface RawGuildCreationValidMessage {
	id: number
	guildName: string
	guildEmblem: GuildEmblem
}

export class GuildCreationValidMessage extends DofusMessage {
	public static id: number = 1275

	public guildName: string | undefined
	public guildEmblem: GuildEmblem | undefined

	public constructor(
		guildName?: string | undefined,
		guildEmblem?: GuildEmblem | undefined
	) {
		super()
		this.guildName = guildName
		this.guildEmblem = guildEmblem
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeUTF(this.guildName!)
		this.guildEmblem!.serialize(writer)
	}

	public deserialize(reader: BinaryReader): void {
		this.guildName = reader.readUTF()
		this.guildEmblem = new GuildEmblem()
		this.guildEmblem!.deserialize(reader)
	}

	public hydrate(
		data: GuildCreationValidMessage | Record<string, any>
	): GuildCreationValidMessage {
		if (data instanceof GuildCreationValidMessage) {
			return data
		}

		this.guildName = data.guildName
		this.guildEmblem = new GuildEmblem().hydrate(data.guildEmblem)

		return this
	}
}

export interface RawTeleportBuddiesAnswerMessage {
	id: number
	accept: boolean
}

export class TeleportBuddiesAnswerMessage extends DofusMessage {
	public static id: number = 396

	public accept: boolean | undefined = false

	public constructor(accept?: boolean | undefined) {
		super()
		this.accept = accept
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeBoolean(this.accept!)
	}

	public deserialize(reader: BinaryReader): void {
		this.accept = reader.readBoolean()
	}

	public hydrate(
		data: TeleportBuddiesAnswerMessage | Record<string, any>
	): TeleportBuddiesAnswerMessage {
		if (data instanceof TeleportBuddiesAnswerMessage) {
			return data
		}

		this.accept = data.accept

		return this
	}
}

export interface RawAllianceInvitationAnswerMessage {
	id: number
	accept: boolean
}

export class AllianceInvitationAnswerMessage extends DofusMessage {
	public static id: number = 4464

	public accept: boolean | undefined = false

	public constructor(accept?: boolean | undefined) {
		super()
		this.accept = accept
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeBoolean(this.accept!)
	}

	public deserialize(reader: BinaryReader): void {
		this.accept = reader.readBoolean()
	}

	public hydrate(
		data: AllianceInvitationAnswerMessage | Record<string, any>
	): AllianceInvitationAnswerMessage {
		if (data instanceof AllianceInvitationAnswerMessage) {
			return data
		}

		this.accept = data.accept

		return this
	}
}

export interface RawAllianceModificationNameAndTagValidMessage {
	id: number
	allianceName: string
	allianceTag: string
}

export class AllianceModificationNameAndTagValidMessage extends DofusMessage {
	public static id: number = 5789

	public allianceName: string | undefined
	public allianceTag: string | undefined

	public constructor(
		allianceName?: string | undefined,
		allianceTag?: string | undefined
	) {
		super()
		this.allianceName = allianceName
		this.allianceTag = allianceTag
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeUTF(this.allianceName!)
		writer.writeUTF(this.allianceTag!)
	}

	public deserialize(reader: BinaryReader): void {
		this.allianceName = reader.readUTF()
		this.allianceTag = reader.readUTF()
	}

	public hydrate(
		data: AllianceModificationNameAndTagValidMessage | Record<string, any>
	): AllianceModificationNameAndTagValidMessage {
		if (data instanceof AllianceModificationNameAndTagValidMessage) {
			return data
		}

		this.allianceName = data.allianceName
		this.allianceTag = data.allianceTag

		return this
	}
}

export interface RawAllianceCreationValidMessage {
	id: number
	allianceName: string
	allianceTag: string
	allianceEmblem: GuildEmblem
}

export class AllianceCreationValidMessage extends DofusMessage {
	public static id: number = 813

	public allianceName: string | undefined
	public allianceTag: string | undefined
	public allianceEmblem: GuildEmblem | undefined

	public constructor(
		allianceName?: string | undefined,
		allianceTag?: string | undefined,
		allianceEmblem?: GuildEmblem | undefined
	) {
		super()
		this.allianceName = allianceName
		this.allianceTag = allianceTag
		this.allianceEmblem = allianceEmblem
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeUTF(this.allianceName!)
		writer.writeUTF(this.allianceTag!)
		this.allianceEmblem!.serialize(writer)
	}

	public deserialize(reader: BinaryReader): void {
		this.allianceName = reader.readUTF()
		this.allianceTag = reader.readUTF()
		this.allianceEmblem = new GuildEmblem()
		this.allianceEmblem!.deserialize(reader)
	}

	public hydrate(
		data: AllianceCreationValidMessage | Record<string, any>
	): AllianceCreationValidMessage {
		if (data instanceof AllianceCreationValidMessage) {
			return data
		}

		this.allianceName = data.allianceName
		this.allianceTag = data.allianceTag
		this.allianceEmblem = new GuildEmblem().hydrate(data.allianceEmblem)

		return this
	}
}

export interface RawAllianceModificationValidMessage {
	id: number
	allianceName: string
	allianceTag: string
	Alliancemblem: GuildEmblem
}

export class AllianceModificationValidMessage extends DofusMessage {
	public static id: number = 8124

	public allianceName: string | undefined
	public allianceTag: string | undefined
	public Alliancemblem: GuildEmblem | undefined

	public constructor(
		allianceName?: string | undefined,
		allianceTag?: string | undefined,
		Alliancemblem?: GuildEmblem | undefined
	) {
		super()
		this.allianceName = allianceName
		this.allianceTag = allianceTag
		this.Alliancemblem = Alliancemblem
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeUTF(this.allianceName!)
		writer.writeUTF(this.allianceTag!)
		this.Alliancemblem!.serialize(writer)
	}

	public deserialize(reader: BinaryReader): void {
		this.allianceName = reader.readUTF()
		this.allianceTag = reader.readUTF()
		this.Alliancemblem = new GuildEmblem()
		this.Alliancemblem!.deserialize(reader)
	}

	public hydrate(
		data: AllianceModificationValidMessage | Record<string, any>
	): AllianceModificationValidMessage {
		if (data instanceof AllianceModificationValidMessage) {
			return data
		}

		this.allianceName = data.allianceName
		this.allianceTag = data.allianceTag
		this.Alliancemblem = new GuildEmblem().hydrate(data.Alliancemblem)

		return this
	}
}

export interface RawAllianceModificationEmblemValidMessage {
	id: number
	Alliancemblem: GuildEmblem
}

export class AllianceModificationEmblemValidMessage extends DofusMessage {
	public static id: number = 1433

	public Alliancemblem: GuildEmblem | undefined

	public constructor(Alliancemblem?: GuildEmblem | undefined) {
		super()
		this.Alliancemblem = Alliancemblem
	}

	public serialize(writer: BinaryWriter): void {
		this.Alliancemblem!.serialize(writer)
	}

	public deserialize(reader: BinaryReader): void {
		this.Alliancemblem = new GuildEmblem()
		this.Alliancemblem!.deserialize(reader)
	}

	public hydrate(
		data: AllianceModificationEmblemValidMessage | Record<string, any>
	): AllianceModificationEmblemValidMessage {
		if (data instanceof AllianceModificationEmblemValidMessage) {
			return data
		}

		this.Alliancemblem = new GuildEmblem().hydrate(data.Alliancemblem)

		return this
	}
}

export interface RawIdolSelectRequestMessage {
	id: number
	activate: boolean
	party: boolean
	idolId: number
}

export class IdolSelectRequestMessage extends DofusMessage {
	public static id: number = 9165

	public activate: boolean | undefined = false
	public party: boolean | undefined = false
	public idolId: number | undefined = 0

	public constructor(
		activate?: boolean | undefined,
		party?: boolean | undefined,
		idolId?: number | undefined
	) {
		super()
		this.activate = activate
		this.party = party
		this.idolId = idolId
	}

	public serialize(writer: BinaryWriter): void {
		let box0: number = 0
		box0 = setFlag(box0, 0, this.activate!)
		box0 = setFlag(box0, 1, this.party!)
		writer.writeByte(box0)
		writer.writeVarShort(this.idolId!)
	}

	public deserialize(reader: BinaryReader): void {
		const box0 = reader.readByte()
		this.activate = getFlag(box0, 0)
		this.party = getFlag(box0, 1)
		this.idolId = reader.readVarShort()
	}

	public hydrate(
		data: IdolSelectRequestMessage | Record<string, any>
	): IdolSelectRequestMessage {
		if (data instanceof IdolSelectRequestMessage) {
			return data
		}

		this.activate = data.activate
		this.party = data.party
		this.idolId = data.idolId

		return this
	}
}

export interface RawIdolPartyRegisterRequestMessage {
	id: number
	register: boolean
}

export class IdolPartyRegisterRequestMessage extends DofusMessage {
	public static id: number = 7898

	public register: boolean | undefined = false

	public constructor(register?: boolean | undefined) {
		super()
		this.register = register
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeBoolean(this.register!)
	}

	public deserialize(reader: BinaryReader): void {
		this.register = reader.readBoolean()
	}

	public hydrate(
		data: IdolPartyRegisterRequestMessage | Record<string, any>
	): IdolPartyRegisterRequestMessage {
		if (data instanceof IdolPartyRegisterRequestMessage) {
			return data
		}

		this.register = data.register

		return this
	}
}

export interface RawHaapiBufferListRequestMessage {
	id: number
}

export class HaapiBufferListRequestMessage extends DofusMessage {
	public static id: number = 8126

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public serialize(writer: BinaryWriter): void {}

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public deserialize(reader: BinaryReader): void {}

	public hydrate(
		data: HaapiBufferListRequestMessage | Record<string, any>
	): HaapiBufferListRequestMessage {
		if (data instanceof HaapiBufferListRequestMessage) {
			return data
		}

		return this
	}
}

export interface RawHaapiConfirmationRequestMessage {
	id: number
	kamas: number
	ogrines: number
	rate: number
	action: number
}

export class HaapiConfirmationRequestMessage extends DofusMessage {
	public static id: number = 7918

	public kamas: number | undefined = 0
	public ogrines: number | undefined = 0
	public rate: number | undefined = 0
	public action: number | undefined = 0

	public constructor(
		kamas?: number | undefined,
		ogrines?: number | undefined,
		rate?: number | undefined,
		action?: number | undefined
	) {
		super()
		this.kamas = kamas
		this.ogrines = ogrines
		this.rate = rate
		this.action = action
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarLong(this.kamas!)
		writer.writeVarLong(this.ogrines!)
		writer.writeVarShort(this.rate!)
		writer.writeByte(this.action!)
	}

	public deserialize(reader: BinaryReader): void {
		this.kamas = reader.readVarLong()
		this.ogrines = reader.readVarLong()
		this.rate = reader.readVarShort()
		this.action = reader.readByte()
	}

	public hydrate(
		data: HaapiConfirmationRequestMessage | Record<string, any>
	): HaapiConfirmationRequestMessage {
		if (data instanceof HaapiConfirmationRequestMessage) {
			return data
		}

		this.kamas = data.kamas
		this.ogrines = data.ogrines
		this.rate = data.rate
		this.action = data.action

		return this
	}
}

export interface RawHaapiCancelBidRequestMessage {
	id: number
	id_: number
	type: number
}

export class HaapiCancelBidRequestMessage extends DofusMessage {
	public static id: number = 512

	public id_: number | undefined = 0
	public type: number | undefined = 0

	public constructor(id_?: number | undefined, type?: number | undefined) {
		super()
		this.id_ = id_
		this.type = type
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarLong(this.id_!)
		writer.writeByte(this.type!)
	}

	public deserialize(reader: BinaryReader): void {
		this.id_ = reader.readVarLong()
		this.type = reader.readByte()
	}

	public hydrate(
		data: HaapiCancelBidRequestMessage | Record<string, any>
	): HaapiCancelBidRequestMessage {
		if (data instanceof HaapiCancelBidRequestMessage) {
			return data
		}

		this.id_ = data.id_
		this.type = data.type

		return this
	}
}

export interface RawHaapiShopApiKeyRequestMessage {
	id: number
}

export class HaapiShopApiKeyRequestMessage extends DofusMessage {
	public static id: number = 9098

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public serialize(writer: BinaryWriter): void {}

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public deserialize(reader: BinaryReader): void {}

	public hydrate(
		data: HaapiShopApiKeyRequestMessage | Record<string, any>
	): HaapiShopApiKeyRequestMessage {
		if (data instanceof HaapiShopApiKeyRequestMessage) {
			return data
		}

		return this
	}
}

export interface RawHaapiValidationRequestMessage {
	id: number
	transaction: string
}

export class HaapiValidationRequestMessage extends DofusMessage {
	public static id: number = 3277

	public transaction: string | undefined

	public constructor(transaction?: string | undefined) {
		super()
		this.transaction = transaction
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeUTF(this.transaction!)
	}

	public deserialize(reader: BinaryReader): void {
		this.transaction = reader.readUTF()
	}

	public hydrate(
		data: HaapiValidationRequestMessage | Record<string, any>
	): HaapiValidationRequestMessage {
		if (data instanceof HaapiValidationRequestMessage) {
			return data
		}

		this.transaction = data.transaction

		return this
	}
}

export interface RawHaapiTokenRequestMessage {
	id: number
}

export class HaapiTokenRequestMessage extends DofusMessage {
	public static id: number = 3174

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public serialize(writer: BinaryWriter): void {}

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public deserialize(reader: BinaryReader): void {}

	public hydrate(
		data: HaapiTokenRequestMessage | Record<string, any>
	): HaapiTokenRequestMessage {
		if (data instanceof HaapiTokenRequestMessage) {
			return data
		}

		return this
	}
}

export interface RawHaapiConsumeBufferRequestMessage {
	id: number
}

export class HaapiConsumeBufferRequestMessage extends DofusMessage {
	public static id: number = 7398

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public serialize(writer: BinaryWriter): void {}

	// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
	public deserialize(reader: BinaryReader): void {}

	public hydrate(
		data: HaapiConsumeBufferRequestMessage | Record<string, any>
	): HaapiConsumeBufferRequestMessage {
		if (data instanceof HaapiConsumeBufferRequestMessage) {
			return data
		}

		return this
	}
}

export interface RawSequenceNumberMessage {
	id: number
	number: number
}

export class SequenceNumberMessage extends DofusMessage {
	public static id: number = 278

	public number: number | undefined = 0

	public constructor(number?: number | undefined) {
		super()
		this.number = number
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeShort(this.number!)
	}

	public deserialize(reader: BinaryReader): void {
		this.number = reader.readShort()
	}

	public hydrate(
		data: SequenceNumberMessage | Record<string, any>
	): SequenceNumberMessage {
		if (data instanceof SequenceNumberMessage) {
			return data
		}

		this.number = data.number

		return this
	}
}

export class GuildGetPlayerApplicationMessage extends DofusMessage {
	public static id: number = 2495

	public constructor() {
		super()
	}

	public serialize(writer: BinaryWriter): void {}

	public deserialize(reader: BinaryReader): void {}
}

export interface RawForgettableSpellClientActionMessage {
	id: number
	spellId: number
	action: number
}

export class ForgettableSpellClientActionMessage extends DofusMessage {
	public static id: number = 8669

	public spellId: number | undefined = 0
	public action: number | undefined = 0

	public constructor(
		spellId?: number | undefined,
		action?: number | undefined
	) {
		super()
		this.spellId = spellId
		this.action = action
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeInt(this.spellId!)
		writer.writeByte(this.action!)
	}

	public deserialize(reader: BinaryReader): void {
		this.spellId = reader.readInt()
		this.action = reader.readByte()
	}

	public hydrate(
		data: ForgettableSpellClientActionMessage | Record<string, any>
	): ForgettableSpellClientActionMessage {
		if (data instanceof ForgettableSpellClientActionMessage) {
			return data
		}

		this.spellId = data.spellId
		this.action = data.action

		return this
	}
}

export interface RawLivingObjectChangeSkinRequestMessage {
	id: number
	livingUID: number
	livingPosition: number
	skinId: number
}

export class LivingObjectChangeSkinRequestMessage extends DofusMessage {
	public static id: number = 5753

	public livingUID: number | undefined = 0
	public livingPosition: number | undefined = 0
	public skinId: number | undefined = 0

	public constructor(
		livingUID?: number | undefined,
		livingPosition?: number | undefined,
		skinId?: number | undefined
	) {
		super()
		this.livingUID = livingUID
		this.livingPosition = livingPosition
		this.skinId = skinId
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarInt(this.livingUID!)
		writer.writeByte(this.livingPosition!)
		writer.writeVarInt(this.skinId!)
	}

	public deserialize(reader: BinaryReader): void {
		this.livingUID = reader.readVarInt()
		this.livingPosition = reader.readByte()
		this.skinId = reader.readVarInt()
	}

	public hydrate(
		data: LivingObjectChangeSkinRequestMessage | Record<string, any>
	): LivingObjectChangeSkinRequestMessage {
		if (data instanceof LivingObjectChangeSkinRequestMessage) {
			return data
		}

		this.livingUID = data.livingUID
		this.livingPosition = data.livingPosition
		this.skinId = data.skinId

		return this
	}
}

export interface RawSymbioticObjectAssociateRequestMessage {
	id: number
	symbioteUID: number
	symbiotePos: number
	hostUID: number
	hostPos: number
}

export class SymbioticObjectAssociateRequestMessage extends DofusMessage {
	public static id: number = 5881

	public symbioteUID: number | undefined = 0
	public symbiotePos: number | undefined = 0
	public hostUID: number | undefined = 0
	public hostPos: number | undefined = 0

	public constructor(
		symbioteUID?: number | undefined,
		symbiotePos?: number | undefined,
		hostUID?: number | undefined,
		hostPos?: number | undefined
	) {
		super()
		this.symbioteUID = symbioteUID
		this.symbiotePos = symbiotePos
		this.hostUID = hostUID
		this.hostPos = hostPos
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarInt(this.symbioteUID!)
		writer.writeByte(this.symbiotePos!)
		writer.writeVarInt(this.hostUID!)
		writer.writeByte(this.hostPos!)
	}

	public deserialize(reader: BinaryReader): void {
		this.symbioteUID = reader.readVarInt()
		this.symbiotePos = reader.readByte()
		this.hostUID = reader.readVarInt()
		this.hostPos = reader.readByte()
	}

	public hydrate(
		data: SymbioticObjectAssociateRequestMessage | Record<string, any>
	): SymbioticObjectAssociateRequestMessage {
		if (data instanceof SymbioticObjectAssociateRequestMessage) {
			return data
		}

		this.symbioteUID = data.symbioteUID
		this.symbiotePos = data.symbiotePos
		this.hostUID = data.hostUID
		this.hostPos = data.hostPos

		return this
	}
}

export interface RawMimicryObjectFeedAndAssociateRequestMessage
	extends RawSymbioticObjectAssociateRequestMessage {
	id: number
	foodUID: number
	foodPos: number
	preview: boolean
}

export class MimicryObjectFeedAndAssociateRequestMessage extends SymbioticObjectAssociateRequestMessage {
	public static id = 1925

	public foodUID: number | undefined = 0
	public foodPos: number | undefined = 0
	public preview: boolean | undefined = false

	public constructor(
		symbioteUID?: number | undefined,
		symbiotePos?: number | undefined,
		hostUID?: number | undefined,
		hostPos?: number | undefined,
		foodUID?: number | undefined,
		foodPos?: number | undefined,
		preview?: boolean | undefined
	) {
		super(symbioteUID, symbiotePos, hostUID, hostPos)
		this.foodUID = foodUID
		this.foodPos = foodPos
		this.preview = preview
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeVarInt(this.foodUID!)
		writer.writeByte(this.foodPos!)
		writer.writeBoolean(this.preview!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.foodUID = reader.readVarInt()
		this.foodPos = reader.readByte()
		this.preview = reader.readBoolean()
	}

	public hydrate(
		data: MimicryObjectFeedAndAssociateRequestMessage | Record<string, any>
	): MimicryObjectFeedAndAssociateRequestMessage {
		if (data instanceof MimicryObjectFeedAndAssociateRequestMessage) {
			return data
		}

		super.hydrate(data)

		this.foodUID = data.foodUID
		this.foodPos = data.foodPos
		this.preview = data.preview

		return this
	}
}

export interface RawWrapperObjectDissociateRequestMessage {
	id: number
	hostUID: number
	hostPos: number
}

export class WrapperObjectDissociateRequestMessage extends DofusMessage {
	public static id: number = 8316

	public hostUID: number | undefined = 0
	public hostPos: number | undefined = 0

	public constructor(
		hostUID?: number | undefined,
		hostPos?: number | undefined
	) {
		super()
		this.hostUID = hostUID
		this.hostPos = hostPos
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarInt(this.hostUID!)
		writer.writeByte(this.hostPos!)
	}

	public deserialize(reader: BinaryReader): void {
		this.hostUID = reader.readVarInt()
		this.hostPos = reader.readByte()
	}

	public hydrate(
		data: WrapperObjectDissociateRequestMessage | Record<string, any>
	): WrapperObjectDissociateRequestMessage {
		if (data instanceof WrapperObjectDissociateRequestMessage) {
			return data
		}

		this.hostUID = data.hostUID
		this.hostPos = data.hostPos

		return this
	}
}

export interface RawMimicryObjectEraseRequestMessage {
	id: number
	hostUID: number
	hostPos: number
}

export class MimicryObjectEraseRequestMessage extends DofusMessage {
	public static id: number = 195

	public hostUID: number | undefined = 0
	public hostPos: number | undefined = 0

	public constructor(
		hostUID?: number | undefined,
		hostPos?: number | undefined
	) {
		super()
		this.hostUID = hostUID
		this.hostPos = hostPos
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarInt(this.hostUID!)
		writer.writeByte(this.hostPos!)
	}

	public deserialize(reader: BinaryReader): void {
		this.hostUID = reader.readVarInt()
		this.hostPos = reader.readByte()
	}

	public hydrate(
		data: MimicryObjectEraseRequestMessage | Record<string, any>
	): MimicryObjectEraseRequestMessage {
		if (data instanceof MimicryObjectEraseRequestMessage) {
			return data
		}

		this.hostUID = data.hostUID
		this.hostPos = data.hostPos

		return this
	}
}

export interface RawLivingObjectDissociateMessage {
	id: number
	livingUID: number
	livingPosition: number
}

export class LivingObjectDissociateMessage extends DofusMessage {
	public static id: number = 9684

	public livingUID: number | undefined = 0
	public livingPosition: number | undefined = 0

	public constructor(
		livingUID?: number | undefined,
		livingPosition?: number | undefined
	) {
		super()
		this.livingUID = livingUID
		this.livingPosition = livingPosition
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarInt(this.livingUID!)
		writer.writeByte(this.livingPosition!)
	}

	public deserialize(reader: BinaryReader): void {
		this.livingUID = reader.readVarInt()
		this.livingPosition = reader.readByte()
	}

	public hydrate(
		data: LivingObjectDissociateMessage | Record<string, any>
	): LivingObjectDissociateMessage {
		if (data instanceof LivingObjectDissociateMessage) {
			return data
		}

		this.livingUID = data.livingUID
		this.livingPosition = data.livingPosition

		return this
	}
}

export interface RawObjectFeedMessage {
	id: number
	objectUID: number
	meal: ObjectItemQuantity[]
}

export class ObjectFeedMessage extends DofusMessage {
	public static id: number = 8089

	public objectUID: number | undefined = 0
	public meal: ObjectItemQuantity[] | undefined

	public constructor(
		objectUID?: number | undefined,
		meal?: ObjectItemQuantity[] | undefined
	) {
		super()
		this.objectUID = objectUID
		this.meal = meal
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarInt(this.objectUID!)
		writer.writeShort(this.meal!.length)
		this.meal!.forEach((current) => {
			current.serialize(writer)
		})
	}

	public deserialize(reader: BinaryReader): void {
		this.objectUID = reader.readVarInt()
		this.meal = []
		const countMeal = reader.readShort()
		for (let i: number = 0; i < countMeal; i++) {
			const type: ObjectItemQuantity = new ObjectItemQuantity()
			type.deserialize(reader)
			this.meal.push(type)
		}
	}

	public hydrate(
		data: ObjectFeedMessage | Record<string, any>
	): ObjectFeedMessage {
		if (data instanceof ObjectFeedMessage) {
			return data
		}

		this.objectUID = data.objectUID
		this.meal = data.meal.map(
			(
				dataElement: ObjectItemQuantity | Record<string, any>
			): ObjectItemQuantity => {
				if (dataElement instanceof ObjectItemQuantity) {
					return dataElement
				} else {
					return new ObjectItemQuantity().hydrate(dataElement)
				}
			}
		)

		return this
	}
}

export interface RawGameFightOptionToggleMessage {
	id: number
	option: number
}

export class GameFightOptionToggleMessage extends DofusMessage {
	public static id: number = 5444

	public option: number | undefined = 3

	public constructor(option?: number | undefined) {
		super()
		this.option = option
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeByte(this.option!)
	}

	public deserialize(reader: BinaryReader): void {
		this.option = reader.readByte()
	}

	public hydrate(
		data: GameFightOptionToggleMessage | Record<string, any>
	): GameFightOptionToggleMessage {
		if (data instanceof GameFightOptionToggleMessage) {
			return data
		}

		this.option = data.option

		return this
	}
}

export interface RawLockableUseCodeMessage {
	id: number
	code: string
}

export class LockableUseCodeMessage extends DofusMessage {
	public static id: number = 3545

	public code: string | undefined

	public constructor(code?: string | undefined) {
		super()
		this.code = code
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeUTF(this.code!)
	}

	public deserialize(reader: BinaryReader): void {
		this.code = reader.readUTF()
	}

	public hydrate(
		data: LockableUseCodeMessage | Record<string, any>
	): LockableUseCodeMessage {
		if (data instanceof LockableUseCodeMessage) {
			return data
		}

		this.code = data.code

		return this
	}
}

export interface RawBasicWhoAmIRequestMessage {
	id: number
	verbose: boolean
}

export class BasicWhoAmIRequestMessage extends DofusMessage {
	public static id: number = 4792

	public verbose: boolean | undefined = false

	public constructor(verbose?: boolean | undefined) {
		super()
		this.verbose = verbose
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeBoolean(this.verbose!)
	}

	public deserialize(reader: BinaryReader): void {
		this.verbose = reader.readBoolean()
	}

	public hydrate(
		data: BasicWhoAmIRequestMessage | Record<string, any>
	): BasicWhoAmIRequestMessage {
		if (data instanceof BasicWhoAmIRequestMessage) {
			return data
		}

		this.verbose = data.verbose

		return this
	}
}

export class WorldRegistrationRequestMessage extends DofusMessage {
	public static id: number = 2590

	public serverId: number | undefined
	public address: string | undefined
	public port: number | undefined
	public name: string | undefined
	public capacity: number | undefined
	public requiredRole: number | undefined
	public isMonoAccount: boolean | undefined
	public isSelectable: boolean | undefined
	public requireSubscription: boolean | undefined

	constructor(
		id?: number | undefined,
		address?: string | undefined,
		port?: number | undefined,
		name?: string | undefined,
		capacity?: number | undefined,
		requiredRole?: number | undefined,
		isMonoAccount?: boolean | undefined,
		isSelectable?: boolean | undefined,
		requireSubscription?: boolean | undefined
	) {
		super()
		this.serverId = id
		this.address = address
		this.port = port
		this.name = name
		this.capacity = capacity
		this.requiredRole = requiredRole
		this.isMonoAccount = isMonoAccount
		this.isSelectable = isSelectable
		this.requireSubscription = requireSubscription
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarInt(this.serverId!)
		writer.writeUTF(this.address!)
		writer.writeVarShort(this.port!)
		writer.writeUTF(this.name!)
		writer.writeVarShort(this.capacity!)
		writer.writeByte(this.requiredRole!)
		writer.writeBoolean(this.isMonoAccount!)
		writer.writeBoolean(this.isSelectable!)
		writer.writeBoolean(this.requireSubscription!)
	}

	public deserialize(reader: BinaryReader): void {
		this.serverId = reader.readVarInt()
		this.address = reader.readUTF()
		this.port = reader.readVarShort()
		this.name = reader.readUTF()
		this.capacity = reader.readByte()
		this.requiredRole = reader.readByte()
		this.isMonoAccount = reader.readBoolean()
		this.isSelectable = reader.readBoolean()
		this.requireSubscription = reader.readBoolean()
	}
}

export interface RawBasicStatMessage {
	id: number
	timeSpent: number
	statId: number
}

export class BasicStatMessage extends DofusMessage {
	public static id: number = 7506

	public timeSpent: number | undefined = 0
	public statId: number | undefined = 0

	public constructor(
		timeSpent?: number | undefined,
		statId?: number | undefined
	) {
		super()
		this.timeSpent = timeSpent
		this.statId = statId
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeDouble(this.timeSpent!)
		writer.writeVarShort(this.statId!)
	}

	public deserialize(reader: BinaryReader): void {
		this.timeSpent = reader.readDouble()
		this.statId = reader.readVarShort()
	}

	public hydrate(
		data: BasicStatMessage | Record<string, any>
	): BasicStatMessage {
		if (data instanceof BasicStatMessage) {
			return data
		}

		this.timeSpent = data.timeSpent
		this.statId = data.statId

		return this
	}
}

export interface RawBasicStatWithDataMessage extends RawBasicStatMessage {
	id: number
	datas: StatisticData[]
}

export class BasicStatWithDataMessage extends BasicStatMessage {
	public static id = 6736

	public datas: StatisticData[] | undefined

	public constructor(
		timeSpent?: number | undefined,
		statId?: number | undefined,
		datas?: StatisticData[] | undefined
	) {
		super(timeSpent, statId)
		this.datas = datas
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeShort(this.datas!.length)
		this.datas!.forEach((current) => {
			writer.writeShort(current.id)
			current.serialize(writer)
		})
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.datas = []
		const countDatas = reader.readShort()
		for (let i: number = 0; i < countDatas; i++) {
			const datasTypeId: number = reader.readShort()
			const type: StatisticData = new types[datasTypeId]() as StatisticData
			type.deserialize(reader)
			this.datas.push(type)
		}
	}

	public hydrate(
		data: BasicStatWithDataMessage | Record<string, any>
	): BasicStatWithDataMessage {
		if (data instanceof BasicStatWithDataMessage) {
			return data
		}

		super.hydrate(data)

		this.datas = data.datas.map(
			(dataElement: StatisticData | Record<string, any>): StatisticData => {
				if (dataElement instanceof StatisticData) {
					return dataElement
				} else {
					return (new types[dataElement.id]() as StatisticData).hydrate(
						dataElement
					)
				}
			}
		)

		return this
	}
}

export interface RawPartyLocateMembersRequestMessage
	extends RawAbstractPartyMessage {
	id: number
}

export class PartyLocateMembersRequestMessage extends AbstractPartyMessage {
	public static id = 7609

	public constructor(partyId?: number | undefined) {
		super(partyId)
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
	}

	public hydrate(
		data: PartyLocateMembersRequestMessage | Record<string, any>
	): PartyLocateMembersRequestMessage {
		if (data instanceof PartyLocateMembersRequestMessage) {
			return data
		}

		super.hydrate(data)

		return this
	}
}

export interface RawContactLookRequestByNameMessage
	extends RawContactLookRequestMessage {
	id: number
	playerName: string
}

export class ContactLookRequestByNameMessage extends ContactLookRequestMessage {
	public static id = 4430

	public playerName: string | undefined

	public constructor(
		requestId?: number | undefined,
		contactType?: number | undefined,
		playerName?: string | undefined
	) {
		super(requestId, contactType)
		this.playerName = playerName
	}

	public serialize(writer: BinaryWriter): void {
		super.serialize(writer)
		writer.writeUTF(this.playerName!)
	}

	public deserialize(reader: BinaryReader): void {
		super.deserialize(reader)
		this.playerName = reader.readUTF()
	}

	public hydrate(
		data: ContactLookRequestByNameMessage | Record<string, any>
	): ContactLookRequestByNameMessage {
		if (data instanceof ContactLookRequestByNameMessage) {
			return data
		}

		super.hydrate(data)

		this.playerName = data.playerName

		return this
	}
}

export interface RawJobCrafterDirectoryEntryRequestMessage {
	id: number
	playerId: number
}

export class JobCrafterDirectoryEntryRequestMessage extends DofusMessage {
	public static id: number = 9607

	public playerId: number | undefined = 0

	public constructor(playerId?: number | undefined) {
		super()
		this.playerId = playerId
	}

	public serialize(writer: BinaryWriter): void {
		writer.writeVarLong(this.playerId!)
	}

	public deserialize(reader: BinaryReader): void {
		this.playerId = reader.readVarLong()
	}

	public hydrate(
		data: JobCrafterDirectoryEntryRequestMessage | Record<string, any>
	): JobCrafterDirectoryEntryRequestMessage {
		if (data instanceof JobCrafterDirectoryEntryRequestMessage) {
			return data
		}

		this.playerId = data.playerId

		return this
	}
}

export class PopupWarningCloseRequestMessage extends DofusMessage {
	public static id: number = 6765

	public constructor() {
		super()
	}

	public serialize(writer: BinaryWriter): void {}

	public deserialize(reader: BinaryReader): void {}
}

export class PopupWarningClosedMessage extends DofusMessage {
	public static id: number = 3684

	public constructor() {
		super()
	}

	public serialize(writer: BinaryWriter): void {}

	public deserialize(reader: BinaryReader): void {}
}

export const types: { [key: number]: typeof DofusType } = {
	7500: GameContextActorPositionInformations,
	1094: SpellModifierMessage,
  2009: Uuid,
	9225: CharacterCharacteristic,
	6639: GameContextActorInformations,
	9377: GameRolePlayActorInformations,
	4648: GameRolePlayGroupMonsterInformations,
	3168: HavenBagRoomPreviewInformation,
	6205: AccountTagInformation,
	6168: InteractiveElement,
	8400: GameFightFighterInformations,
	9631: GameFightEntityInformation,
	7: GameRolePlayPrismInformations,
	950: GameFightAIInformations,
	6096: GameFightMonsterInformations,
	9830: CharacterCharacteristicValue,
	7041: GameRolePlayGroupMonsterWaveInformations,
	3424: GameRolePlayTaxCollectorInformations,
	9155: GameRolePlayNamedActorInformations,
	4944: GameRolePlayMountInformations,
	8307: GameRolePlayNpcInformations,
	5968: GameRolePlayNpcWithQuestInformations,
	1204: GameRolePlayMerchantInformations,
	5061: GameRolePlayHumanoidInformations,
	1982: GameRolePlayCharacterInformations,
	6138: GameRolePlayPortalInformations,
	8271: GameRolePlayMutantInformations,
	6665: GameFightFighterNamedInformations,
	7807: GameFightCharacterInformations,
	6975: GameFightTaxCollectorInformations,
	3340: EntityLook,
	7682: SubEntity,
	9836: AbstractFightDispellableEffect,
	2131: SpawnInformation,
	7811: SpawnCompanionInformation,
	1071: BaseSpawnMonsterInformation,
	8617: SpawnScaledMonsterInformation,
	7069: GameContextBasicSpawnInformation,
	904: GameContextSummonsInformation,
	9167: GameFightSpellCooldown,
	2668: FightTemporaryBoostEffect,
	1888: SpawnCharacterInformation,
	3264: SpawnMonsterInformation,
	9940: EntityDispositionInformations,
	2821: HumanOption,
	374: HumanOptionAlliance,
	8461: HumanOptionFollowers,
	366: ActorOrientation,
	4311: GroupMonsterStaticInformations,
	9307: HumanInformations,
	6629: FightTeamMemberInformations,
	5066: HouseInformations,
	8830: HouseOnMapInformations,
	2440: HumanOptionObjectUse,
	9271: HouseInstanceInformations,
	7370: HumanOptionEmote,
	9311: ObjectItemInRolePlay,
	5602: PaddockItem,
	5839: AbstractFightTeamInformations,
	563: FightTeamInformations,
	9720: IndexedEntityLook,
	4888: HumanOptionSkillUse,
	1267: AlternativeMonstersInGroupLightInformations,
	2177: FightCommonInformations,
	7146: MonsterInGroupLightInformations,
	3232: MonsterInGroupInformations,
	7674: MapObstacle,
	8629: GroupMonsterStaticInformationsWithAlternatives,
	4954: FightEntityDispositionInformations,
	4379: BreachBranch,
	8253: GameFightMinimalStats,
	9464: GameFightMinimalStatsPreparation,
	4029: IdentifiedEntityDispositionInformations,
	335: StatedElement,
	2284: ActorRestrictionsInformations,
	4995: CharacterCharacteristicsInformations,
	2111: AbstractCharacterInformation,
	4297: CharacterBasicMinimalInformations,
	1869: CharacterMinimalInformations,
	9181: CharacterMinimalPlusLookInformations,
	7798: CharacterBaseInformations,
	2740: FightDispellableEffectExtendedInformations,
	7802: GameActionMarkedCell,
	5766: FightResultListEntry,
	7733: FightResultFighterListEntry,
	8499: GameFightResumeSlaveInfo,
	8513: NamedPartyTeamWithOutcome,
	8797: GameActionMark,
	644: NamedPartyTeam,
	5752: Idol,
	4633: GameFightMutantInformations,
	6765: FightResultPlayerListEntry,
	6240: FightResultTaxCollectorListEntry,
	327: TrustCertificate,
	7452: GameFightEffectTriggerCount,
	5822: AchievementAchieved,
	5596: Item,
	9326: ObjectItem,
	4941: ObjectEffect,
	7541: ObjectEffectInteger,
	9332: CharacterSpellModification,
	1767: CharacterBaseCharacteristic,
	6762: InteractiveElementSkill,
	6433: QuestActiveInformations,
	5963: PrismInformation,
	2842: TaxCollectorStaticInformations,
	7615: SkillActionDescription,
	8967: SkillActionDescriptionCraft,
	4248: JobDescription,
	263: SkillActionDescriptionTimed,
	6581: SkillActionDescriptionCollect,
	8807: GameServerInformations,
	1824: PaddockInformations,
	4322: PaddockInstancesInformations,
	4662: PaddockBuyableInformations,
	9023: GameRolePlayNpcQuestFlag,
	5623: ItemDurability,
	7985: AchievementAchievedRewardable,
	1102: HumanOptionOrnament,
	8924: HumanOptionTitle,
	8916: AccountHouseInformations,
	2751: HouseInformationsInside,
	6198: ActorAlignmentInformations,
	1367: PortalInformation,
	5996: AlliancePrismInformation,
	6982: AllianceInsiderPrismInformation,
	8512: GuildMember,
	7403: SpellItem,
	6454: ForgettableSpellItem,
	1443: PlayerStatus,
	7229: HumanOptionGuild,
	9466: TaxCollectorMovement,
	6667: HouseInformationsForGuild,
	5170: AbstractContactInformations,
	9286: FriendInformations,
	450: FriendOnlineInformations,
	2943: PlayerStatusExtended,
	4492: AcquaintanceInformation,
	5184: AcquaintanceOnlineInformation,
	9440: ObjectItemGenericQuantity,
	4735: PaddockContentInformations,
	4160: IgnoredInformations,
	5101: IgnoredOnlineInformations,
	5151: TaxCollectorInformations,
	781: AbstractSocialGroupInfos,
	492: BasicGuildInformations,
	3988: BasicAllianceInformations,
	6659: ObjectItemQuantityPriceDateEffects,
	8707: DungeonPartyFinderPlayer,
	8246: PartyMemberInformations,
	1101: PartyMemberArenaInformations,
	4252: PartyEntityBaseInformation,
	7145: PartyInvitationMemberInformations,
	9468: PartyGuestInformations,
	4347: PartyEntityMemberInformation,
	6928: GuildInformations,
	8268: GuildInAllianceInformations,
	9305: PrismSubareaEmptyInfo,
	8192: PrismGeolocalizedInformation,
	5100: GuildFactSheetInformations,
	6301: GuildInsiderFactSheetInformations,
	8515: ActorExtendedAlignmentInformations,
	3040: FightTriggeredEffect,
	8464: FightTemporarySpellImmunityEffect,
	4451: FightTemporaryBoostWeaponDamagesEffect,
	7115: FightTemporaryBoostStateEffect,
	5674: FightTemporarySpellBoostEffect,
	8642: FinishMoveInformations,
	956: FightStartingPositions,
	5935: BasicNamedAllianceInformations,
	2484: AllianceInformations,
	9851: FightTeamMemberCharacterInformations,
	8004: FightTeamMemberWithAllianceCharacterInformations,
	4962: ExtendedBreachBranch,
	5533: BreachReward,
	2823: HouseGuildedInformations,
	1420: FightOptionsInformations,
	431: FightTeamMemberTaxCollectorInformations,
	6436: TaxCollectorStaticExtendedInformations,
	5073: GameRolePlayTreasureHintInformations,
	6988: FightResultMutantListEntry,
	5041: TreasureHuntStep,
	6367: TreasureHuntStepFight,
	2571: MapCoordinates,
	4533: FriendSpouseInformations,
	7417: FriendSpouseOnlineInformations,
	651: CharacterMinimalPlusLookAndGradeInformations,
	7795: StatisticData,
	4749: StatisticDataShort,
	5618: FightResultAdditionalData,
	2135: FightResultExperienceData,
	2216: ObjectEffectString,
	2126: Preset,
	1498: IdolsPreset,
	920: AlliancedGuildFactSheetInformations,
	7096: ForgettableSpellsPreset,
	8239: Shortcut,
	3691: ShortcutSpell,
	3536: StatisticDataByte,
	3298: TreasureHuntStepDig,
	7986: FullStatsPreset,
	3347: InteractiveElementNamedSkill,
	3462: FightResultPvpData,
	5721: TreasureHuntStepFollowDirectionToHint,
	7908: GuildVersatileInformations,
	5949: GuildInAllianceVersatileInformations,
	5832: ShortcutObject,
	2568: ObjectEffectDice,
	2036: ObjectEffectDate,
	3205: UpdateMountCharacteristic,
	4162: UpdateMountIntegerCharacteristic,
	8932: ShortcutObjectItem,
	8695: QuestObjectiveInformations,
	5778: QuestObjectiveInformationsWithCompletion,
	6288: FightTeamMemberEntityInformation,
	4340: UpdateMountBooleanCharacteristic,
	6416: CharacterMinimalGuildInformations,
	9412: CharacterMinimalAllianceInformations,
	870: ItemsPreset,
	8054: ServerSessionConstant,
	8199: ServerSessionConstantInteger,
	9088: ShortcutEmote,
	1561: TaxCollectorComplementaryInformations,
	4070: TaxCollectorLootInformations,
	5358: MapCoordinatesAndId,
	4714: EntitiesPreset,
	9957: DebtInformation,
	5112: PaddockGuildedInformations,
	9275: KamaDebtInformation,
	9818: StatisticDataString,
	2645: PresetsContainerPreset,
	3146: IconNamedPreset,
	133: ServerSessionConstantString,
	3438: QuestActiveDetailedInformations,
	6700: ShortcutEntitiesPreset,
	9295: ObjectEffectCreature,
	6916: ObjectEffectLadder,
	8081: FightTeamMemberMonsterInformations,
	9809: ShortcutObjectIdolsPreset,
	1783: ShortcutObjectPreset,
	343: TaxCollectorGuildInformations,
	3744: TaxCollectorWaitingForHelpInformations,
	440: StatsPreset,
	7748: ObjectEffectDuration,
	6683: GameFightFighterLightInformations,
	6947: GameFightFighterMonsterLightInformations,
	8613: GameFightFighterTaxCollectorLightInformations,
	5175: FightAllianceTeamInformations,
	3059: CharacterHardcoreOrEpicInformations,
	6182: GameFightFighterEntityLightInformation,
	2488: ServerSessionConstantLong,
	3396: InteractiveElementWithAgeBonus,
	4640: StatisticDataInt,
	6853: AllianceFactSheetInformations,
	8143: GameFightFighterNamedLightInformations,
	7951: TreasureHuntStepFollowDirectionToPOI,
	3779: StatisticDataBoolean,
	3547: ExtendedLockedBreachBranch,
	5714: PartyIdol,
	1318: GameFightMonsterWithAlignmentInformations,
	1591: MapCoordinatesExtended,
	1881: TreasureHuntStepFollowDirection,
	2344: ShortcutSmiley,
	9076: ObjectEffectMinMax,
	3404: SpellsPreset,
	8688: ObjectEffectMount,
	6103: ItemForPreset,
	3510: MountClientData,
	7757: FightLoot,
	2701: TreasureHuntFlag,
	4416: ObjectItemMinimalInformation,
	6404: ObjectItemInformationWithQuantity,
	5320: StartupActionAddObject,
	2924: CharacterRemodelingInformation,
	1292: CharacterToRemodelInformations,
	7815: RemodelingInformation,
	6752: Version,
	1231: SimpleCharacterCharacteristicForPreset,
	7508: CharacterCharacteristicForPreset,
	6884: SpellForPreset,
	3448: Achievement,
	4752: ObjectItemNotInContainer,
	446: ObjectItemToSell,
	2594: TaxCollectorFightersInformation,
	6506: TeleportDestination,
	4497: MonsterBoosts,
	3237: DecraftedItemStackInfo,
	7137: TaxCollectorBasicInformations,
	6428: PartyMemberGeoPosition,
	2852: ObjectItemToSellInNpcShop,
	4082: ObjectItemToSellInBid,
	7048: SellerBuyerDescriptor,
	8534: JobCrafterDirectoryEntryPlayerInfo,
	3458: JobCrafterDirectoryEntryJobInfo,
	1757: JobCrafterDirectoryListEntry,
	1397: FightExternalInformations,
	4792: JobCrafterDirectorySettings,
	7040: ArenaRankInfos,
	6401: JobExperience,
	3013: AllianceVersatileInformations,
	4016: PrismFightersInformation,
	6102: HavenBagFurnitureInformation,
	7482: BufferInformation,
	9877: AnomalySubareaInformation,
	4946: PaddockInformationsForSell,
	2887: CharacterMinimalGuildPublicInformations,
	6556: EntityInformation,
	2771: AlignmentWarEffortInformation,
	3630: RecycledItem,
	8489: HouseInformationsForSell,
	8818: JobBookSubscription,
	4296: GoldItem,
	8040: ObjectItemToSellInHumanVendorShop,
	3184: ObjectItemQuantity,
	8915: EntityMovementInformations,
	9234: BidExchangerObjectInfo,
	1189: LeagueFriendInformations,
	6171: AtlasPointsInformations,
	6377: GuildEmblem,
	9191: AdditionalTaxCollectorInformations,
	6130: ProtectedEntityWaitingForHelpInfo,
	4454: MountInformationsForPaddock,
	4843: ObjectEffects,
	1608: AchievementObjective,
	262: AchievementStartedObjective,
	6266: FightTeamLightInformations,
	7102: ArenaRanking,
	125: ArenaLeagueRanking,
}

export const messages: { [key: number]: typeof DofusMessage } = {
	6075: BasicPingMessage,
	6765: PopupWarningCloseRequestMessage,
	3684: PopupWarningClosedMessage,
	2590: WorldRegistrationRequestMessage,
	4824: GameFightSynchronizeMessage,
	8791: AbstractGameActionMessage,
	7655: AbstractGameActionFightTargetedAbilityMessage,
  211: AchievementAlmostFinishedDetailedListMessage,
	5026: GameActionFightSpellCastMessage,
	1408: GameActionFightDispellMessage,
	7947: GameActionFightDispellEffectMessage,
	9562: GameActionFightTriggerEffectMessage,
	3775: GameActionFightTackledMessage,
	1575: GameActionFightInvisibilityMessage,
	2232: GameActionFightCloseCombatMessage,
	3884: GameFightShowFighterMessage,
	6588: GameFightShowFighterRandomStaticPoseMessage,
	6074: GameActionFightReduceDamagesMessage,
	1531: GameActionFightLifePointsGainMessage,
	9967: AllianceRanksMessage,
	6413: GameActionFightModifyEffectsDurationMessage,
	9063: GameActionFightTeleportOnSameMapMessage,
	4730: GameActionFightInvisibleDetectedMessage,
	9184: GameActionFightDispellSpellMessage,
	9365: GameFightTurnListMessage,
	5574: GameActionFightChangeLookMessage,
	7952: GameActionFightDodgePointLossMessage,
	5293: SequenceStartMessage,
	1076: GameActionFightSpellImmunityMessage,
	5910: GameActionFightDispellableEffectMessage,
	622: GameActionFightVanishMessage,
	9016: GameActionFightThrowCharacterMessage,
	5036: GameActionFightMultipleSummonMessage,
	986: GameFightRefreshFighterMessage,
	1549: GameActionFightSlideMessage,
	8275: GameActionFightKillMessage,
	1538: GameActionFightMarkCellsMessage,
	772: GameActionFightSpellCooldownVariationMessage,
	7728: FighterStatsListMessage,
	5371: GameMapMovementMessage,
	8796: GameActionFightSummonMessage,
	8910: GameActionFightDropCharacterMessage,
	8084: GameActionFightTriggerGlyphTrapMessage,
	3225: GameActionFightDeathMessage,
	6663: GameActionFightStealKamaMessage,
	5415: GameActionFightPointsVariationMessage,
	7632: SequenceEndMessage,
	8747: GameActionFightLifePointsLostMessage,
	423: GameActionFightLifeAndShieldPointsLostMessage,
	1453: GameActionFightReflectSpellMessage,
	3652: GameActionFightCarryCharacterMessage,
	449: GameActionFightActivateGlyphTrapMessage,
	4963: GameActionFightUnmarkCellsMessage,
	7605: GameActionFightReflectDamagesMessage,
	640: GameActionFightExchangePositionsMessage,
	7827: MapComplementaryInformationsDataMessage,
	8604: MapComplementaryInformationsAnomalyMessage,
	8038: MapNpcsQuestStatusUpdateMessage,
	9746: GameFightUpdateTeamMessage,
	5650: GameDataPaddockObjectRemoveMessage,
	420: ObjectGroundRemovedMultipleMessage,
	8993: GameFightRemoveTeamMemberMessage,
	4945: EmotePlayRequestMessage,
	2008: UpdateMapPlayersAgressableStatusMessage,
	5652: PaddockMoveItemRequestMessage,
	2797: ObjectGroundListAddedMessage,
	7042: UpdateSelfAgressableStatusMessage,
	5308: MapComplementaryInformationsWithCoordsMessage,
	2017: GameContextRefreshEntityLookMessage,
	4332: MapComplementaryInformationsDataInHavenBagMessage,
	3311: BreachExitResponseMessage,
	7954: PaddockRemoveItemRequestMessage,
	5147: GameMapChangeOrientationMessage,
	3539: ObjectGroundAddedMessage,
	9979: BreachEnterMessage,
	6727: GameRolePlayShowActorMessage,
	8442: GameDataPlayFarmObjectAnimationMessage,
	6006: GameRolePlayShowChallengeMessage,
	9279: GameRolePlayRemoveChallengeMessage,
	2130: MapRewardRateMessage,
	4325: GameRolePlayMonsterAngryAtPlayerMessage,
	5993: GameDataPaddockObjectAddMessage,
	9214: MapComplementaryInformationsDataInHouseMessage,
	9971: StatedMapUpdateMessage,
	9422: GameMapChangeOrientationsMessage,
	6430: ShowCellMessage,
	3052: HousePropertiesMessage,
	4276: GameRolePlayMonsterNotAngryAtPlayerMessage,
	1936: BreachTeleportResponseMessage,
	849: GameContextRemoveMultipleElementsMessage,
	224: GameRolePlayShowMultipleActorsMessage,
	5737: ObjectGroundRemovedMessage,
	8033: GameDataPaddockObjectListAddMessage,
	5822: AnomalyStateMessage,
	231: MapInformationsRequestMessage,
	8434: InteractiveUsedMessage,
	1874: MapFightCountMessage,
	2058: InteractiveMapUpdateMessage,
	4327: GameContextRemoveElementMessage,
	3750: GameFightOptionStateUpdateMessage,
	6772: BreachTeleportRequestMessage,
	3106: MapComplementaryInformationsBreachMessage,
	5646: GameEntitiesDispositionMessage,
	9734: ShowCellSpectatorMessage,
	866: GameFightPlacementSwapPositionsMessage,
	3636: GameEntityDispositionMessage,
	5755: GameFightHumanReadyStateMessage,
	4865: PlayerStatusUpdateMessage,
	6612: GameFightEndMessage,
	6696: BreachGameFightEndMessage,
	4069: ChallengeTargetUpdateMessage,
	4491: GameFightLeaveMessage,
	9624: GameFightSpectateMessage,
	8007: GameFightResumeMessage,
	3940: GameFightResumeWithSlavesMessage,
	6179: CurrentMapMessage,
	3125: CurrentMapInstanceMessage,
	3960: GameFightStartingMessage,
	685: GameFightJoinMessage,
	2250: ChallengeTargetsListRequestMessage,
	5363: GameFightStartMessage,
	2159: GameActionFightNoSpellCastMessage,
	7633: GameContextDestroyMessage,
	6930: GameFightSpectatorJoinMessage,
	9675: ChallengeInfoMessage,
	2009: ChallengeTargetsListMessage,
	6903: MapObstacleUpdateMessage,
	2158: ArenaFighterLeaveMessage,
	5960: GameContextReadyMessage,
	2089: ChallengeResultMessage,
	5330: GameFightTurnStartPlayingMessage,
	6575: GameFightNewWaveMessage,
	6427: GameFightPauseMessage,
	6112: SlaveNoLongerControledMessage,
	5364: CharacterStatsListMessage,
	7110: GameFightTurnStartMessage,
	3790: GameActionAcknowledgementMessage,
	2330: GameFightTurnResumeMessage,
	765: GameFightTurnReadyMessage,
	6293: GameFightTurnReadyRequestMessage,
	2534: GameActionUpdateEffectTriggerCountMessage,
	8856: GameFightTurnEndMessage,
	4660: GameFightNewRoundMessage,
	1497: RefreshCharacterStatsMessage,
	5295: SlaveSwitchContextMessage,
	2027: HaapiApiKeyRequestMessage,
	2503: DebugClearHighlightCellsMessage,
	7861: DebugHighlightCellsMessage,
	2283: DebugInClientMessage,
	8158: AchievementListMessage,
	4805: IdentificationMessage,
	4574: IdentificationAccountForceMessage,
	9898: BasicAckMessage,
	7318: BasicNoOperationMessage,
	4271: CredentialsAcknowledgementMessage,
	4557: OnConnectionEventMessage,
	5863: ObjectJobAddedMessage,
	6521: LivingObjectMessageRequestMessage,
	1693: IdentificationSuccessMessage,
	6945: URLOpenMessage,
	6253: RawDataMessage,
	2545: TrustStatusMessage,
	8557: ServersListMessage,
	8522: BasicPongMessage,
	2340: BasicLatencyStatsRequestMessage,
	9646: BasicLatencyStatsMessage,
	8389: CheckIntegrityMessage,
	7272: AdminCommandMessage,
	2223: ConsoleMessage,
	3230: QuestListMessage,
	7778: QuestValidatedMessage,
	1293: CharacterCreationResultMessage,
	1947: NicknameRefusedMessage,
	1279: NicknameAcceptedMessage,
	6694: HelloGameMessage,
	4710: GuildFactsErrorMessage,
	4505: AchievementDetailedListMessage,
	9044: AuthenticationTicketAcceptedMessage,
	6703: GuildInvitationStateRecrutedMessage,
	7533: KamasUpdateMessage,
	7292: StorageObjectsUpdateMessage,
	3343: GuildInvitedMessage,
	4852: ShortcutBarContentMessage,
	1391: ObjectsAddedMessage,
	9868: CharacterSelectedSuccessMessage,
	7242: ExchangeCraftResultMessage,
	4589: ExchangeCraftResultWithObjectDescMessage,
	995: AbstractPartyMessage,
	2338: AbstractPartyEventMessage,
	5580: PartyMemberRemoveMessage,
	2891: GameRolePlayPlayerFightFriendlyAnsweredMessage,
	9329: BasicWhoIsNoMatchMessage,
	3657: InteractiveUseErrorMessage,
	7625: GameRolePlayGameOverMessage,
	1287: NotificationByServerMessage,
	2910: GuildMemberOnlineStatusMessage,
	4871: ExchangeMountsPaddockRemoveMessage,
	1883: SocialNoticeMessage,
	3713: GameRolePlaySpellAnimMessage,
	918: EmotePlayAbstractMessage,
	3437: OrnamentGainedMessage,
	4688: ExchangeBidHouseUnsoldItemsMessage,
	418: ExchangeShopStockMovementRemovedMessage,
	1593: IdolSelectErrorMessage,
	377: SymbioticObjectAssociatedMessage,
	288: MimicryObjectAssociatedMessage,
	7584: BasicCharactersListMessage,
	1216: TreasureHuntAvailableRetryCountUpdateMessage,
	6831: LoginQueueStatusMessage,
	1837: PartyCancelInvitationNotificationMessage,
	8025: DungeonPartyFinderListenErrorMessage,
	3929: ExchangeObjectMessage,
	5784: ExchangeObjectsRemovedMessage,
	8680: TextInformationMessage,
	9296: WarnOnPermaDeathStateMessage,
	9786: ExchangeOfflineSoldItemsMessage,
	8726: PartyLeaveMessage,
	3069: QueueStatusMessage,
	5600: ExchangeObjectAddedMessage,
	5713: ExchangeShopStockMovementUpdatedMessage,
	1653: AbstractTaxCollectorListMessage,
	6709: TaxCollectorListMessage,
	1671: GameRolePlayDelayedActionMessage,
	6445: PauseDialogMessage,
	5005: TeleportDestinationsMessage,
	7338: LifePointsRegenBeginMessage,
	913: BreachBranchesMessage,
	3787: CheckFileRequestMessage,
	3233: ForgettableSpellListUpdateMessage,
	6850: ChatAbstractServerMessage,
	1165: CharactersListMessage,
	1171: CharactersListWithRemodelingMessage,
	6876: InteractiveElementUpdatedMessage,
	5454: GameRolePlayFightRequestCanceledMessage,
	8176: BreachSavedMessage,
	6675: GuildFightPlayersHelpersLeaveMessage,
	6974: HaapiApiKeyMessage,
	1779: TopTaxCollectorListMessage,
	4175: GameRolePlayArenaFighterStatusMessage,
	9502: ChatServerCopyMessage,
	2736: ChatSmileyMessage,
	7234: LocalizedChatSmileyMessage,
	9126: GameRolePlayArenaSwitchToFightServerMessage,
	6212: ProtocolRequired,
	476: CompassUpdateMessage,
	979: GameRefreshMonsterBoostsMessage,
	971: DungeonPartyFinderRegisterSuccessMessage,
	2623: SpellVariantActivationMessage,
	3869: StorageObjectsRemoveMessage,
	6105: MountReleasedMessage,
	9469: DecraftResultMessage,
	7089: MapFightStartPositionsUpdateMessage,
	8465: OrnamentLostMessage,
	2: NetworkDataContainerMessage,
	9221: GuildPaddockBoughtMessage,
	5489: AbstractPartyMemberInFightMessage,
	3432: PartyMemberInStandardFightMessage,
	3035: ExchangeStartedMessage,
	8129: SpouseStatusMessage,
	3344: SubscriptionLimitationMessage,
	3774: ExchangeBidPriceMessage,
	4716: ExchangeBidPriceForSellerMessage,
	2846: LockableShowCodeDialogMessage,
	5722: GuildFightPlayersHelpersJoinMessage,
	3995: TaxCollectorMovementsOfflineMessage,
	2752: UpdateLifePointsMessage,
	3729: ReloginTokenStatusMessage,
	3189: TitleGainedMessage,
	6852: InventoryContentMessage,
	714: StorageInventoryContentMessage,
	1200: ExchangeShopStockMultiMovementRemovedMessage,
	1261: TaxCollectorAttackedResultMessage,
	5047: ExchangeObjectRemovedMessage,
	1719: PrismFightAttackerAddMessage,
	7628: LivingObjectMessageMessage,
	1605: PartyInvitationMessage,
	5673: TreasureHuntRequestAnswerMessage,
	7308: CharacterLoadingCompleteMessage,
	4075: TreasureHuntFlagRequestAnswerMessage,
	8789: ExchangeIsReadyMessage,
	9299: AllianceFactsErrorMessage,
	5647: InteractiveUseEndedMessage,
	3392: AllianceInvitedMessage,
	7527: ExchangeStartOkCraftMessage,
	7607: PartyLocateMembersMessage,
	2210: ObjectsDeletedMessage,
	2495: GuildGetPlayerApplicationMessage,
	2259: PaddockPropertiesMessage,
	9998: GameContextRemoveMultipleElementsWithEventsMessage,
	5660: ExchangeStartOkMulticraftCustomerMessage,
	9965: SocialNoticeSetErrorMessage,
	7608: GuildBulletinSetErrorMessage,
	1972: AccessoryPreviewMessage,
	6110: ExchangeStartOkNpcShopMessage,
	5568: PartyUpdateMessage,
	2422: PartyNewMemberMessage,
	5627: InviteInHavenBagMessage,
	3584: AllianceInvitationStateRecruterMessage,
	6788: ExchangeCrafterJobLevelupMessage,
	3617: IgnoredAddFailureMessage,
	1385: ExchangeStartedBidSellerMessage,
	2881: EmotePlayMassiveMessage,
	8381: HaapiValidationMessage,
	4091: IgnoredDeleteResultMessage,
	5594: CompassUpdatePartyMemberMessage,
	8650: ExchangeObjectPutInBagMessage,
	2079: GuildFightPlayersEnemiesListMessage,
	3954: GameCautiousMapMovementMessage,
	9364: AchievementFinishedMessage,
	1659: AchievementFinishedInformationMessage,
	6863: EntityTalkMessage,
	4109: LockableStateUpdateAbstractMessage,
	6717: LockableStateUpdateStorageMessage,
	6940: ExchangeStartedBidBuyerMessage,
	5865: AllianceListMessage,
	3830: JobCrafterDirectoryEntryMessage,
	7458: ObtainedItemMessage,
	5610: ObtainedItemWithBonusMessage,
	7309: SpellListMessage,
	369: GuildPaddockRemovedMessage,
	6740: BreachInvitationResponseMessage,
	105: GuildLeftMessage,
	6189: EditHavenBagStartMessage,
	4578: PartyRefuseInvitationNotificationMessage,
	5079: CharacterNameSuggestionFailureMessage,
	95: SelectedServerRefusedMessage,
	2678: PrismInfoInValidMessage,
	9696: ExchangeBidHouseBuyResultMessage,
	5438: ChatCommunityChannelCommunityMessage,
	9953: IdolPartyLostMessage,
	8494: ExchangePodsModifiedMessage,
	6664: TaxCollectorDialogQuestionBasicMessage,
	9199: TaxCollectorDialogQuestionExtendedMessage,
	1736: AllianceTaxCollectorDialogQuestionExtendedMessage,
	8589: TaxCollectorStateUpdateMessage,
	636: ExchangeBidHouseGenericItemRemovedMessage,
	2660: QuestStepInfoMessage,
	5407: ServerOptionalFeaturesMessage,
	884: BreachRoomUnlockResultMessage,
	9690: DungeonPartyFinderRoomContentUpdateMessage,
	5890: QuestStepValidatedMessage,
	4417: CompassUpdatePvpSeekMessage,
	6638: AllianceFactsMessage,
	873: PrismFightDefenderAddMessage,
	1484: JobCrafterDirectoryAddMessage,
	4478: ShortcutBarSwapErrorMessage,
	744: PartyInvitationDungeonMessage,
	2375: BreachBudgetMessage,
	6296: JobAllowMultiCraftRequestMessage,
	5801: JobMultiCraftAvailableSkillsMessage,
	1752: ExchangeMountsStableAddMessage,
	2999: FriendAddedMessage,
	3594: CharacterCanBeCreatedResultMessage,
	1685: NpcGenericActionFailureMessage,
	6480: AccountHouseMessage,
	2175: AcquaintanceSearchErrorMessage,
	255: ExchangeStartOkRecycleTradeMessage,
	5392: StatsUpgradeResultMessage,
	2666: MapRunningFightListMessage,
	1620: SequenceNumberRequestMessage,
	3818: PartyInvitationDetailsMessage,
	1024: PartyInvitationDungeonDetailsMessage,
	2868: ExchangeTypesExchangerDescriptionForUserMessage,
	809: JobCrafterDirectorySettingsMessage,
	4794: MoodSmileyUpdateMessage,
	6496: EmotePlayMessage,
	2882: SelectedServerDataMessage,
	7321: SelectedServerDataExtendedMessage,
	6364: FriendWarnOnConnectionStateMessage,
	3771: DungeonPartyFinderRoomContentMessage,
	7123: BasicDateMessage,
	839: ExchangeMountsStableBornAddMessage,
	3482: JobDescriptionMessage,
	2150: AccountLoggingKickedMessage,
	1372: ExchangeObjectModifiedInBagMessage,
	9975: DebtsUpdateMessage,
	2247: GameRolePlayArenaUpdatePlayerInfosMessage,
	451: GameRolePlayArenaUpdatePlayerInfosAllQueuesMessage,
	6753: GuildCreationResultMessage,
	5468: ExchangeStoppedMessage,
	230: ExchangeShopStockMultiMovementUpdatedMessage,
	3493: AccountInformationsUpdateMessage,
	7106: TitleSelectErrorMessage,
	7413: AccountCapabilitiesMessage,
	1475: TreasureHuntDigRequestAnswerMessage,
	9892: TreasureHuntDigRequestAnswerFailedMessage,
	7003: GameEntityDispositionErrorMessage,
	5327: EmoteAddMessage,
	3362: GuildMotdMessage,
	3269: PartyLeaderUpdateMessage,
	5509: ChatServerMessage,
	5240: ChatAdminServerMessage,
	1248: MountSterilizedMessage,
	4158: BasicWhoIsMessage,
	1715: ObjectAddedMessage,
	3464: GameActionNoopMessage,
	4006: PopupWarningMessage,
	4823: JobExperienceUpdateMessage,
	8683: GuildInformationsPaddocksMessage,
	7241: GuildVersatileInfoListMessage,
	4905: IdentificationFailedMessage,
	8907: IdentificationFailedForBadVersionMessage,
	2061: JobLevelUpMessage,
	1407: ExchangeBidHouseInListAddedMessage,
	8074: ExchangeStartedMountStockMessage,
	6961: BreachCharactersMessage,
	815: AllianceVersatileInfoListMessage,
	2762: HaapiShopApiKeyMessage,
	9812: ObjectErrorMessage,
	5316: SymbioticObjectErrorMessage,
	6833: MimicryObjectErrorMessage,
	5197: KohUpdateMessage,
	4819: ClientUIOpenedMessage,
	4274: ClientUIOpenedByObjectMessage,
	2270: TeleportBuddiesRequestedMessage,
	9997: ExchangeStartOkEvolutiveObjectRecycleTradeMessage,
	8994: ExchangeCraftPaymentModifiedMessage,
	2111: AllianceMotdSetErrorMessage,
	2479: LeaveDialogMessage,
	4632: ExchangeLeaveMessage,
	8117: TaxCollectorErrorMessage,
	6303: BreachRoomLockedMessage,
	6079: IdolListMessage,
	3309: EmoteRemoveMessage,
	2268: ExchangeGuildTaxCollectorGetMessage,
	338: GuildMotdSetErrorMessage,
	6943: GameRolePlayArenaSwitchToGameServerMessage,
	4440: ContactLookMessage,
	4368: AlliancePartialListMessage,
	8222: MapRunningFightDetailsMessage,
	3172: MapRunningFightDetailsExtendedMessage,
	1800: AcquaintanceServerListMessage,
	8304: DungeonPartyFinderRegisterErrorMessage,
	8072: EmoteListMessage,
	4737: TitlesAndOrnamentsListMessage,
	2667: HaapiConfirmationMessage,
	4624: PrismsInfoValidMessage,
	2889: InviteInHavenBagOfferMessage,
	7074: HavenBagPackListMessage,
	9555: CharacterDeletionErrorMessage,
	162: HavenBagFurnituresMessage,
	1493: AcquaintancesListMessage,
	2431: ExchangeStartedTaxCollectorShopMessage,
	8731: GuildHouseRemoveMessage,
	2759: TreasureHuntFinishedMessage,
	875: HaapiBufferListMessage,
	134: WrapperObjectAssociatedMessage,
	8730: ObjectDeletedMessage,
	7887: PartyMemberEjectedMessage,
	2552: ExchangeMountsStableRemoveMessage,
	4020: AllianceCreationStartedMessage,
	1264: InventoryWeightMessage,
	5783: MountDataErrorMessage,
	4402: ExchangeMoneyMovementInformationMessage,
	6953: ZaapRespawnUpdatedMessage,
	7247: ExchangeMultiCraftCrafterCanUseHisRessourcesMessage,
	4221: InvalidPresetsMessage,
	810: PresetSaveErrorMessage,
	7131: GuildInformationsMemberUpdateMessage,
	4833: AllianceGetPlayerApplicationMessage,
	5381: ExchangeStartedWithStorageMessage,
	5505: TeleportToBuddyOfferMessage,
	1951: ExchangeCraftResultWithObjectIdMessage,
	819: ExchangeCraftInformationObjectMessage,
	7075: PartyLoyaltyStatusMessage,
	7514: JobCrafterDirectoryRemoveMessage,
	1595: ExchangeObjectModifiedMessage,
	9391: AnomalySubareaInformationResponseMessage,
	9558: FriendAddFailureMessage,
	2501: HavenBagRoomUpdateMessage,
	6070: BulletinMessage,
	7441: GuildBulletinMessage,
	3044: PartyUpdateLightMessage,
	3906: BreachInvitationOfferMessage,
	8729: GuildJoinedMessage,
	2509: GuildMembershipMessage,
	5540: SubscriptionZoneMessage,
	139: GameFightPlacementSwapPositionsErrorMessage,
	5902: ExchangeReplyTaxVendorMessage,
	2621: PresetUseResultMessage,
	5027: IdentificationFailedBannedMessage,
	5563: BreachRewardsMessage,
	5500: ObjectAveragePricesMessage,
	1180: GuildHousesInformationMessage,
	5004: DisplayNumericalValuePaddockMessage,
	9985: MailStatusMessage,
	2732: NewMailMessage,
	9127: MountEquipedErrorMessage,
	8876: AchievementRewardErrorMessage,
	3637: ChallengeFightJoinRefusedMessage,
	7590: GuildMemberLeavingMessage,
	1271: ForgettableSpellEquipmentSlotsMessage,
	5912: GameActionSpamMessage,
	963: GuildLevelUpMessage,
	1115: AllianceJoinedMessage,
	5521: NumericWhoIsMessage,
	8600: ExchangeBidSearchOkMessage,
	2971: PaddockToSellListMessage,
	7129: HavenBagDailyLoteryMessage,
	3240: PurchasableDialogMessage,
	3258: AlignmentWarEffortDonationResultMessage,
	6551: AllianceMotdMessage,
	8309: GameRolePlayArenaLeagueRewardsMessage,
	6726: GameRolePlayShowActorWithEventMessage,
	4210: HaapiAuthErrorMessage,
	360: PartyDeletedMessage,
	6491: GuildFactsMessage,
	6411: GuildInAllianceFactsMessage,
	7313: HouseBuyResultMessage,
	6724: SystemMessageDisplayMessage,
	2741: ExchangeBidHouseInListUpdatedMessage,
	6628: AllianceModificationStartedMessage,
	2583: ExchangeMountsTakenFromPaddockMessage,
	2403: RecycleResultMessage,
	3058: HaapiTokenMessage,
	1218: CurrentServerStatusUpdateMessage,
	842: PartyCannotJoinErrorMessage,
	2353: AllianceGuildLeavingMessage,
	7258: GuildInvitationStateRecruterMessage,
	4244: IgnoredListMessage,
	1152: IgnoredAddedMessage,
	325: EntityInformationMessage,
	1424: AlignmentWarEffortProgressionMessage,
	7382: GuildHouseUpdateInformationMessage,
	7426: MountDataMessage,
	5741: NpcDialogCreationMessage,
	9795: PortalDialogCreationMessage,
	2267: PrismSetSabotagedRefusedMessage,
	7836: MountSetMessage,
	2521: PartyInvitationCancelledForGuestMessage,
	5488: ExchangeCraftCountModifiedMessage,
	678: ExchangeSellOkMessage,
	1527: GuildCreationStartedMessage,
	907: MimicryObjectPreviewMessage,
	7372: NotificationListMessage,
	7486: StorageObjectUpdateMessage,
	6801: CharactersListErrorMessage,
	9887: JobCrafterDirectoryListMessage,
	9636: EditHavenBagFinishedMessage,
	5876: StatedElementUpdatedMessage,
	5851: IdolPartyRefreshMessage,
	1921: ClientYouAreDrunkMessage,
	6223: GameContextCreateErrorMessage,
	5076: ObjectQuantityMessage,
	246: CharacterLevelUpMessage,
	2236: CharacterLevelUpInformationMessage,
	4763: GuildMemberWarnOnConnectionStateMessage,
	3021: FriendUpdateMessage,
	1466: HavenBagPermissionsUpdateMessage,
	9238: AuthenticationTicketRefusedMessage,
	2146: AchievementDetailsMessage,
	5525: TaxCollectorMovementMessage,
	7636: AlliancePrismDialogQuestionMessage,
	2914: ExchangeStartOkMountWithOutPaddockMessage,
	7742: TreasureHuntMessage,
	1554: ExchangeStartedWithPodsMessage,
	3669: GameRolePlayArenaFightPropositionMessage,
	1188: StartupActionAddMessage,
	6447: PrismFightRemovedMessage,
	8962: ItemNoMoreAvailableMessage,
	1344: ChatServerWithObjectMessage,
	3252: TaxCollectorMovementAddMessage,
	8622: EvolutiveObjectRecycleResultMessage,
	2233: MoodSmileyResultMessage,
	3180: HaapiSessionMessage,
	1843: ExchangeStartOkMountMessage,
	6648: DocumentReadingBeginMessage,
	1898: ServerExperienceModificatorMessage,
	4917: ExchangeKamaModifiedMessage,
	6160: IdentificationSuccessWithLoginTokenMessage,
	748: GameRolePlayDelayedObjectUseMessage,
	7400: CharacterCapabilitiesMessage,
	6312: PaddockBuyResultMessage,
	1594: AllianceCreationResultMessage,
	3413: PartyMemberInBreachFightMessage,
	9548: PartyNameUpdateMessage,
	7923: StartupActionFinishedMessage,
	6872: ExchangeStartOkNpcTradeMessage,
	1161: ChatErrorMessage,
	8301: HouseGuildRightsMessage,
	4979: DungeonKeyRingUpdateMessage,
	1307: PrismFightAttackerRemoveMessage,
	9560: AllianceLeftMessage,
	7315: AllianceInvitationStateRecrutedMessage,
	187: ExchangeStartOkCraftWithInformationMessage,
	1968: MountUnSetMessage,
	5404: MountXpRatioMessage,
	1449: JobExperienceMultiUpdateMessage,
	1985: AlmanachCalendarDateMessage,
	7031: ContactLookErrorMessage,
	9694: ObjectModifiedMessage,
	989: ExchangeWeightMessage,
	1186: PartyNewGuestMessage,
	7439: HelloConnectMessage,
	9162: FriendStatusShareStateMessage,
	9517: HouseGuildNoneMessage,
	7669: ChatServerCopyWithObjectMessage,
	7744: MountRidingMessage,
	2776: ShortcutBarRemoveErrorMessage,
	1455: ChannelEnablingChangeMessage,
	4806: PartyNameSetErrorMessage,
	725: GameFightPlacementSwapPositionsOfferMessage,
	7582: AllianceInsiderInfoMessage,
	7851: HouseToSellListMessage,
	1374: BreachRewardBoughtMessage,
	8720: ExchangeMountFreeFromPaddockMessage,
	1211: EnabledChannelsMessage,
	9796: CinematicMessage,
	9846: ExchangeStartOkJobIndexMessage,
	4098: GameFightPlacementPossiblePositionsMessage,
	7442: CharacterSelectedErrorMessage,
	7982: AccountLinkRequiredMessage,
	3454: AchievementRewardSuccessMessage,
	9270: MigratedServerListMessage,
	5095: CompassResetMessage,
	5956: ExchangeObjectRemovedFromBagMessage,
	5273: PartyJoinMessage,
	1656: WatchInventoryContentMessage,
	9471: StorageKamasUpdateMessage,
	8778: HouseSellingUpdateMessage,
	5098: ShortcutBarReplacedMessage,
	7522: JobBookSubscriptionMessage,
	6258: PrismSettingsErrorMessage,
	5951: BreachKickResponseMessage,
	940: SpouseInformationsMessage,
	8752: HaapiBuyValidationMessage,
	7521: TitleLostMessage,
	2420: PresetSavedMessage,
	4206: ExchangeStartOkRunesTradeMessage,
	5855: ShortcutBarRefreshMessage,
	4148: DungeonKeyRingMessage,
	8234: TeleportOnSameMapMessage,
	9952: TreasureHuntShowLegendaryUIMessage,
	6: ChatSmileyExtraPackListMessage,
	3516: ServerStatusUpdateMessage,
	8443: TeleportBuddiesMessage,
	8421: AlignmentWarEffortDonatePreviewMessage,
	1255: GoldAddedMessage,
	7752: FriendWarnOnLevelGainStateMessage,
	7453: GuildListMessage,
	2952: PresetDeleteResultMessage,
	526: ExchangeItemAutoCraftStopedMessage,
	9003: ExchangeErrorMessage,
	2395: PrismFightStateUpdateMessage,
	4993: ExchangeMountSterilizeFromPaddockMessage,
	5749: TaxCollectorAttackedMessage,
	666: ServerSettingsMessage,
	1543: AcquaintanceAddedMessage,
	7419: StorageObjectRemoveMessage,
	3134: FollowedQuestsMessage,
	3329: ServerSessionConstantsMessage,
	5177: DungeonPartyFinderAvailableDungeonsMessage,
	5866: CharacterNameSuggestionSuccessMessage,
	8603: GameMapNoMovementMessage,
	2786: MountEmoteIconUsedOkMessage,
	5795: QuestStartedMessage,
	2798: MountRenamedMessage,
	697: ExchangeObjectsAddedMessage,
	5232: GuestLimitationMessage,
	1269: ExchangeObjectsModifiedMessage,
	6972: WrapperObjectErrorMessage,
	2157: ExchangeRequestedMessage,
	4929: ExchangeRequestedTradeMessage,
	4921: IdolFightPreparationUpdateMessage,
	6840: ShortcutBarAddErrorMessage,
	2458: IdolSelectedMessage,
	5814: ExchangeStartOkHumanVendorMessage,
	5776: FriendDeleteResultMessage,
	3014: PresetsMessage,
	8051: ObjectsQuantityMessage,
	8139: QuestObjectiveValidatedMessage,
	5626: GameRolePlayAggressionMessage,
	7251: GuildInformationsMembersMessage,
	2262: SetUpdateMessage,
	7611: ExchangeMountsPaddockAddMessage,
	9486: CharacterExperienceGainMessage,
	4815: PrismsListMessage,
	9870: PrismsListUpdateMessage,
	9744: EntitiesInformationMessage,
	4627: FinishMoveListMessage,
	6887: PartyModifiableStatusMessage,
	6469: JobExperienceOtherPlayerUpdateMessage,
	8188: GuildModificationStartedMessage,
	5979: PartyRestrictedMessage,
	2411: NicknameRegistrationMessage,
	6005: GameContextRemoveElementWithEventMessage,
	8153: GameRolePlayPlayerFightFriendlyRequestedMessage,
	7079: UpdateMountCharacteristicsMessage,
	2604: ShortcutBarRemovedMessage,
	35: ExchangeBuyOkMessage,
	1338: LifePointsRegenEndMessage,
	1030: GameContextCreateMessage,
	9276: PlayerStatusUpdateErrorMessage,
	5555: GameFightPlacementSwapPositionsCancelledMessage,
	7414: ConsoleCommandsListMessage,
	9417: StartupActionsListMessage,
	9648: TaxCollectorMovementRemoveMessage,
	4867: AreaFightModificatorUpdateMessage,
	1444: ExchangeBidHouseInListRemovedMessage,
	3716: AllianceBulletinSetErrorMessage,
	1920: ForgettableSpellDeleteMessage,
	5410: DebtsDeleteMessage,
	4882: ExchangeCraftResultMagicWithObjectDescMessage,
	2229: TitleSelectedMessage,
	7030: AbstractGameActionWithAckMessage,
	8459: ExchangeBidHouseItemRemoveOkMessage,
	50: OrnamentSelectedMessage,
	5460: AllianceBulletinMessage,
	4399: ObjectAveragePricesErrorMessage,
	2959: PresetUseResultWithMissingIdsMessage,
	6085: OrnamentSelectErrorMessage,
	7867: GameContextMoveElementMessage,
	7377: ExchangeTypesItemsExchangerDescriptionForUserMessage,
	8697: FriendsListMessage,
	6760: PrismInfoCloseMessage,
	3077: PrismFightDefenderLeaveMessage,
	528: GameRolePlayPlayerLifeStatusMessage,
	2035: FriendGuildWarnOnAchievementCompleteStateMessage,
	6871: GameRolePlayArenaInvitationCandidatesAnswer,
	8376: BreachInvitationCloseMessage,
	2112: LockableStateUpdateHouseDoorMessage,
	8137: PaddockSellBuyDialogMessage,
	5183: ExchangeOkMultiCraftMessage,
	5909: ExchangeWaitingResultMessage,
	13: AlreadyConnectedMessage,
	7921: NpcDialogQuestionMessage,
	790: EmotePlayErrorMessage,
	2289: GameRolePlayDelayedActionFinishedMessage,
	3991: ContactAddFailureMessage,
	4989: CharacterAlignmentWarEffortProgressionMessage,
	2529: AtlasPointInformationsMessage,
	6071: GuestModeMessage,
	8402: ObjectMovementMessage,
	7160: LockableCodeResultMessage,
	2208: ExchangeMountStableErrorMessage,
	9096: GuildFightPlayersEnemyRemoveMessage,
	1220: BreachStateMessage,
	4532: GuildInformationsGeneralMessage,
	2919: TeleportToBuddyCloseMessage,
	3478: BreachBonusMessage,
	6701: ExchangeStartOkMulticraftCrafterMessage,
	9089: ExchangeShopStockStartedMessage,
	6808: BasicTimeMessage,
	5427: ZaapDestinationsMessage,
	2425: GuildInfosUpgradeMessage,
	806: ExchangeBidHouseItemAddOkMessage,
	9995: GameRolePlayArenaRegistrationStatusMessage,
	3389: PartyEntityUpdateLightMessage,
	721: GameContextMoveMultipleElementsMessage,
	8395: PartyFollowStatusUpdateMessage,
	5640: PrismFightAddedMessage,
	6150: ItemForPresetUpdateMessage,
	8111: SetCharacterRestrictionsMessage,
	9472: PartyKickedByMessage,
	2692: QuestStepStartedMessage,
	1682: AllianceMembershipMessage,
	5649: InviteInHavenBagClosedMessage,
	9722: ExchangeBidHouseGenericItemAddedMessage,
	2029: AlignmentRankUpdateMessage,
	8715: AccessoryPreviewErrorMessage,
	2068: CharacterSelectedForceMessage,
	3153: GuildFactsRequestMessage,
	5072: ClientKeyMessage,
	4355: NicknameChoiceRequestMessage,
	4229: AllianceFactsRequestMessage,
	5508: TeleportHavenBagRequestMessage,
	5569: GameMapChangeOrientationRequestMessage,
	69: ExchangeRequestOnTaxCollectorMessage,
	5687: ExchangeOnHumanVendorRequestMessage,
	8531: ExchangeBuyMessage,
	6025: EnterHavenBagRequestMessage,
	6086: ErrorMapNotFoundMessage,
	2334: ExchangeRequestMessage,
	4040: ExchangePlayerRequestMessage,
	8087: GameRolePlayPlayerFightRequestMessage,
	8527: ExchangePlayerMultiCraftRequestMessage,
	1070: ExchangeObjectMoveMessage,
	3567: ExchangeObjectMovePricedMessage,
	3439: ExchangeStartAsVendorMessage,
	6789: PortalUseRequestMessage,
	6306: ExchangeSellMessage,
	6865: GameRolePlayFreeSoulRequestMessage,
	9751: LeaveDialogRequestMessage,
	205: TeleportHavenBagAnswerMessage,
	9331: KickHavenBagRequestMessage,
	6002: NpcGenericActionRequestMessage,
	7175: GameRolePlayTaxCollectorFightRequestMessage,
	3588: GameRolePlayPlayerFightFriendlyAnswerMessage,
	2113: ExchangeShowVendorTaxMessage,
	1872: ExchangeRequestOnShopStockMessage,
	2580: HouseTeleportRequestMessage,
	800: FriendJoinRequestMessage,
	9603: FriendSpouseFollowWithCompassRequestMessage,
	7244: SocialNoticeSetRequestMessage,
	9793: GuildBulletinSetRequestMessage,
	7668: GuildSpellUpgradeRequestMessage,
	1666: GuildCharacsUpgradeRequestMessage,
	3095: SpouseGetInformationsMessage,
	8483: WarnOnPermaDeathMessage,
	5452: GuildGetInformationsMessage,
	2659: FriendSetWarnOnConnectionMessage,
	8701: IgnoredGetListMessage,
	9563: GuildMotdSetRequestMessage,
	3898: GuildMemberSetWarnOnConnectionMessage,
	9881: IgnoredDeleteRequestMessage,
	2729: GuildChangeMemberParametersMessage,
	7195: GuildFightJoinRequestMessage,
	5614: FriendDeleteRequestMessage,
	6653: ContactLookRequestMessage,
	3633: ContactLookRequestByIdMessage,
	1663: FriendAddRequestMessage,
	9450: PlayerStatusUpdateRequestMessage,
	6284: GuildPaddockTeleportRequestMessage,
	5690: IgnoredAddRequestMessage,
	6299: FriendSetStatusShareMessage,
	5473: GuildKickRequestMessage,
	5495: FriendGuildSetWarnOnAchievementCompleteMessage,
	8404: GuildInvitationMessage,
	1328: GuildFightLeaveRequestMessage,
	9107: AcquaintancesGetListMessage,
	3828: FriendSpouseJoinRequestMessage,
	429: FriendSetWarnOnLevelGainMessage,
	3897: FriendsGetListMessage,
	5265: GuildInvitationByNameMessage,
	1111: GuildFightTakePlaceRequestMessage,
	832: ChatAbstractClientMessage,
	6307: ChatClientPrivateMessage,
	5903: ChatClientPrivateWithObjectMessage,
	670: MoodSmileyRequestMessage,
	5172: ChatSmileyRequestMessage,
	43: ChatCommunityChannelSetCommunityRequestMessage,
	6558: BasicWhoIsRequestMessage,
	4617: ChatClientMultiMessage,
	5275: ChatClientMultiWithObjectMessage,
	1902: ChannelEnablingMessage,
	1244: NumericWhoIsRequestMessage,
	8938: PartyPledgeLoyaltyRequestMessage,
	7104: PartyFollowMemberRequestMessage,
	8893: PartyFollowThisMemberRequestMessage,
	8721: DungeonPartyFinderAvailableDungeonsRequestMessage,
	8642: PartyRefuseInvitationMessage,
	5482: PartyNameSetRequestMessage,
	6141: PartyLeaveRequestMessage,
	4262: TeleportToBuddyAnswerMessage,
	2536: GameRolePlayArenaFightAnswerMessage,
	2850: PartyAbdicateThroneMessage,
	7999: BreachInvitationAnswerMessage,
	4371: GameRolePlayArenaRegisterMessage,
	1084: PartyInvitationRequestMessage,
	4310: PartyInvitationArenaRequestMessage,
	5213: DungeonPartyFinderListenRequestMessage,
	2173: PartyInvitationDetailsRequestMessage,
	1048: PartyCancelInvitationMessage,
	931: PartyInvitationDungeonRequestMessage,
	5219: DungeonPartyFinderRegisterRequestMessage,
	6661: GameRolePlayArenaUnregisterMessage,
	6538: PartyAcceptInvitationMessage,
	4679: PartyStopFollowRequestMessage,
	7424: PartyKickRequestMessage,
	6578: PrismFightJoinLeaveRequestMessage,
	5624: PrismSettingsRequestMessage,
	4475: AllianceKickRequestMessage,
	9455: PrismInfoJoinLeaveRequestMessage,
	7833: PrismFightSwapRequestMessage,
	1806: PrismSetSabotagedRequestMessage,
	9551: PrismUseRequestMessage,
	4413: PrismModuleExchangeRequestMessage,
	7829: SetEnableAVARequestMessage,
	5140: PrismsListRegisterMessage,
	9138: AllianceMotdSetRequestMessage,
	972: PrismAttackRequestMessage,
	8973: AllianceChangeGuildRightsMessage,
	7301: AllianceBulletinSetRequestMessage,
	1729: AllianceInsiderInfoRequestMessage,
	9978: AllianceInvitationMessage,
	8255: AchievementAlmostFinishedDetailedListRequestMessage,
	3535: ShowCellRequestMessage,
	1536: GameFightTurnFinishMessage,
	1119: GameMapMovementRequestMessage,
	5055: GameActionFightCastOnTargetRequestMessage,
	1470: GameActionFightCastRequestMessage,
	1852: FinishMoveSetRequestMessage,
	3924: FinishMoveListRequestMessage,
	7240: SpellVariantActivationRequestMessage,
	927: GameContextQuitMessage,
	6725: BreachRoomUnlockRequestMessage,
	836: BreachRewardBuyMessage,
	9437: BreachExitRequestMessage,
	1305: BreachKickRequestMessage,
	4246: BreachInvitationRequestMessage,
	2826: EditHavenBagRequestMessage,
	5326: ChangeHavenBagRoomRequestMessage,
	9787: EditHavenBagCancelRequestMessage,
	5848: HavenBagFurnituresRequestMessage,
	4397: HavenBagPermissionsUpdateRequestMessage,
	2398: OpenHavenBagFurnitureSequenceRequestMessage,
	6985: CloseHavenBagFurnitureSequenceRequestMessage,
	4026: ChangeThemeRequestMessage,
	9801: ExitHavenBagRequestMessage,
	3696: HouseKickIndoorMerchantRequestMessage,
	6133: GameFightJoinRequestMessage,
	8878: GameFightPlacementPositionRequestMessage,
	1380: GameFightPlacementSwapPositionsRequestMessage,
	4471: GameContextKickMessage,
	9929: GameFightPlacementSwapPositionsCancelMessage,
	266: GameFightReadyMessage,
	3893: GameFightPlacementSwapPositionsAcceptMessage,
	9352: NotificationResetMessage,
	2332: UnfollowQuestObjectiveRequestMessage,
	7565: TreasureHuntFlagRemoveRequestMessage,
	692: TreasureHuntFlagRequestMessage,
	1205: GuidedModeReturnRequestMessage,
	7662: TreasureHuntLegendaryRequestMessage,
	5740: GuidedModeQuitRequestMessage,
	1622: TreasureHuntGiveUpRequestMessage,
	7112: QuestListRequestMessage,
	2214: QuestStepInfoRequestMessage,
	2378: FollowQuestObjectiveRequestMessage,
	795: AchievementRewardRequestMessage,
	534: NotificationUpdateFlagMessage,
	6610: QuestObjectiveValidationMessage,
	5403: AchievementDetailsRequestMessage,
	1822: RefreshFollowedQuestsOrderRequestMessage,
	6177: QuestStartRequestMessage,
	8751: AchievementDetailedListRequestMessage,
	2632: TreasureHuntDigRequestMessage,
	3503: AuthenticationTicketMessage,
	4543: GuildRanksRequestMessage,
	4312: CharacterSelectionMessage,
	3592: CharacterSelectionWithRemodelMessage,
	1741: CharacterNameSuggestionRequestMessage,
	5754: CharacterSelectedForceReadyMessage,
	5450: CharactersListRequestMessage,
	974: KnownZaapListMessage,
	774: CharacterCreationRequestMessage,
	2372: CharacterCanBeCreatedRequestMessage,
	9005: CharacterReplayRequestMessage,
	8678: CharacterReplayWithRemodelRequestMessage,
	9830: StartupActionsObjetAttributionMessage,
	5775: StartupActionsExecuteMessage,
	1225: CharacterFirstSelectionMessage,
	6738: GameContextCreateRequestMessage,
	7199: CharacterDeletionRequestMessage,
	4981: AcquaintanceSearchMessage,
	6291: ServerSelectionMessage,
	1: CheckFileMessage,
	7828: ResetCharacterStatsRequestMessage,
	2564: StatsUpgradeRequestMessage,
	6836: StartupActionsAllAttributionMessage,
	6051: PaddockToSellListRequestMessage,
	1885: PaddockToSellFilterMessage,
	5809: HouseToSellListRequestMessage,
	7868: HouseToSellFilterMessage,
	7816: AdminQuietCommandMessage,
	8131: SetEnablePVPRequestMessage,
	6202: CharacterAlignmentWarEffortProgressionRequestMessage,
	8514: AlignmentWarEffortDonateRequestMessage,
	8769: AlignmentWarEffortProgressionRequestMessage,
	9304: ObjectAveragePricesGetMessage,
	567: ReloginTokenRequestMessage,
	4375: AnomalySubareaInformationRequestMessage,
	5772: ZaapRespawnSaveRequestMessage,
	6400: TeleportRequestMessage,
	3149: JobCrafterDirectoryDefineSettingsMessage,
	4754: JobBookSubscribeRequestMessage,
	9508: JobCrafterDirectoryListRequestMessage,
	3123: ExchangeObjectUseInWorkshopMessage,
	4712: ExchangeReplayStopMessage,
	3477: ExchangeCraftCountRequestMessage,
	4740: CharacterDeletionPrepareMessage,
	9338: CharacterDeletionPrepareRequestMessage,
	2252: ExchangeMultiCraftSetCrafterCanUseHisRessourcesMessage,
	9081: ExchangeCraftPaymentModificationRequestMessage,
	6059: ExchangeSetCraftRecipeMessage,
	4796: MountSetXpRatioRequestMessage,
	3596: MountHarnessDissociateRequestMessage,
	6271: MountInformationInPaddockRequestMessage,
	460: MountReleaseRequestMessage,
	1532: MountHarnessColorsUpdateRequestMessage,
	9033: MountRenameRequestMessage,
	9525: MountFeedRequestMessage,
	173: ExchangeHandleMountsMessage,
	1967: ExchangeRequestOnMountStockMessage,
	8339: MountInformationRequestMessage,
	581: MountToggleRidingRequestMessage,
	5528: MountSterilizeRequestMessage,
	5396: HouseGuildShareRequestMessage,
	8627: AllianceRanksRequestMessage,
	3694: HouseKickRequestMessage,
	1525: HouseSellRequestMessage,
	2066: LockableChangeCodeMessage,
	780: HouseLockFromInsideRequestMessage,
	3504: HouseBuyRequestMessage,
	6173: HouseSellFromInsideRequestMessage,
	1431: HouseGuildRightsViewMessage,
	445: OrnamentSelectRequestMessage,
	9416: TitlesAndOrnamentsListRequestMessage,
	9079: TitleSelectRequestMessage,
	8718: PresetDeleteRequestMessage,
	8030: ObjectUseMessage,
	1737: ObjectUseMultipleMessage,
	5921: ObjectDropMessage,
	5015: IconPresetSaveRequestMessage,
	9163: IconNamedPresetSaveRequestMessage,
	8482: ObjectDeleteMessage,
	4736: AccessoryPreviewRequestMessage,
	8528: ShortcutBarRemoveRequestMessage,
	9511: ObjectUseOnCharacterMessage,
	5703: ShortcutBarSwapRequestMessage,
	2641: ObjectUseOnCellMessage,
	7306: ShortcutBarAddRequestMessage,
	5636: IdolsPresetSaveRequestMessage,
	6757: PresetUseRequestMessage,
	2180: ObjectSetPositionMessage,
	6676: ExchangeBidHouseBuyMessage,
	3234: ExchangeBidHousePriceMessage,
	3308: ExchangeBidHouseSearchMessage,
	1285: ExchangeBidHouseListMessage,
	270: ExchangeBidHouseTypeMessage,
	7465: ExchangeObjectModifyPricedMessage,
	7557: StopToListenRunningFightRequestMessage,
	5035: GameFightSpectatePlayerRequestMessage,
	8879: MapRunningFightDetailsRequestMessage,
	4556: MapRunningFightListRequestMessage,
	9042: ExchangeAcceptMessage,
	4843: ExchangeReadyMessage,
	1260: FocusedExchangeReadyMessage,
	2541: GameMapMovementCancelMessage,
	9045: ChangeMapMessage,
	5883: GameCautiousMapMovementRequestMessage,
	9394: InteractiveUseRequestMessage,
	2661: InteractiveUseWithParamRequestMessage,
	9947: GameRolePlayAttackMonsterRequestMessage,
	4717: GameMapMovementConfirmMessage,
	1621: ExchangeObjectMoveKamaMessage,
	6444: ExchangeObjectTransfertExistingToInvMessage,
	9384: ExchangeObjectTransfertListFromInvMessage,
	6225: ExchangeObjectTransfertAllToInvMessage,
	8258: ExchangeObjectTransfertListToInvMessage,
	8847: ExchangeObjectTransfertListWithQuantityToInvMessage,
	1221: ExchangeObjectTransfertAllFromInvMessage,
	5796: ExchangeObjectTransfertExistingFromInvMessage,
	6305: NpcDialogReplyMessage,
	9656: PaddockBuyRequestMessage,
	663: PaddockSellRequestMessage,
	2671: GuildInvitationAnswerMessage,
	8864: GuildModificationEmblemValidMessage,
	9265: GuildModificationValidMessage,
	4598: GuildModificationNameValidMessage,
	1275: GuildCreationValidMessage,
	396: TeleportBuddiesAnswerMessage,
	4464: AllianceInvitationAnswerMessage,
	5789: AllianceModificationNameAndTagValidMessage,
	813: AllianceCreationValidMessage,
	8124: AllianceModificationValidMessage,
	1433: AllianceModificationEmblemValidMessage,
	9165: IdolSelectRequestMessage,
	7898: IdolPartyRegisterRequestMessage,
	8126: HaapiBufferListRequestMessage,
	7918: HaapiConfirmationRequestMessage,
	512: HaapiCancelBidRequestMessage,
	9098: HaapiShopApiKeyRequestMessage,
	3277: HaapiValidationRequestMessage,
	3174: HaapiTokenRequestMessage,
	7398: HaapiConsumeBufferRequestMessage,
	278: SequenceNumberMessage,
	8669: ForgettableSpellClientActionMessage,
	5753: LivingObjectChangeSkinRequestMessage,
	5881: SymbioticObjectAssociateRequestMessage,
	1925: MimicryObjectFeedAndAssociateRequestMessage,
	8316: WrapperObjectDissociateRequestMessage,
	195: MimicryObjectEraseRequestMessage,
	9684: LivingObjectDissociateMessage,
	8089: ObjectFeedMessage,
	5444: GameFightOptionToggleMessage,
	3545: LockableUseCodeMessage,
	4792: BasicWhoAmIRequestMessage,
	7506: BasicStatMessage,
	6736: BasicStatWithDataMessage,
	7609: PartyLocateMembersRequestMessage,
	4430: ContactLookRequestByNameMessage,
	9607: JobCrafterDirectoryEntryRequestMessage,
}
